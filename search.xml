<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/03/21/hello-world/"/>
      <url>/2024/03/21/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>小兔鲜</title>
      <link href="/2024/01/21/xiao-tu-xian/"/>
      <url>/2024/01/21/xiao-tu-xian/</url>
      
        <content type="html"><![CDATA[<h1 id="一-项目起步"><a href="#一-项目起步" class="headerlink" title="一.项目起步"></a>一.项目起步</h1><h2 id="1-1-定制主题"><a href="#1-1-定制主题" class="headerlink" title="1.1 定制主题"></a>1.1 定制主题</h2><ul><li>安装 scss:</li></ul><pre><code>npm i sass -D</code></pre><ul><li>准备定制样式文件</li></ul><p>​styles&#x2F;element&#x2F;index.scss</p><ul><li>对elementPlus进行样式覆盖</li></ul><h3 id="1-1-1-定制化样式文件"><a href="#1-1-1-定制化样式文件" class="headerlink" title="1.1.1 定制化样式文件"></a>1.1.1 定制化样式文件</h3><pre><code class="scss">/* 只需要重写你需要的即可 */@forward &#39;element-plus/theme-chalk/src/common/var.scss&#39; with (  $colors: (    &#39;primary&#39;: (      // 主色      &#39;base&#39;: #27ba9b,    ),    &#39;success&#39;: (      // 成功色      &#39;base&#39;: #1dc779,    ),    &#39;warning&#39;: (      // 警告色      &#39;base&#39;: #ffb302,    ),    &#39;danger&#39;: (      // 危险色      &#39;base&#39;: #e26237,    ),    &#39;error&#39;: (      // 错误色      &#39;base&#39;: #cf4444,    ),  ))</code></pre><h3 id="1-1-2-自动导入配置"><a href="#1-1-2-自动导入配置" class="headerlink" title="1.1.2 自动导入配置"></a>1.1.2 自动导入配置</h3><p>这里自动导入需要深入到elementPlus的组件中，按照官方的配置文档来</p><ol><li>自动导入定制化样式文件进行样式覆盖</li><li>按需定制主题配置 （需要安装 unplugin-element-plus）</li></ol><pre><code class="js">import &#123; fileURLToPath, URL &#125; from &#39;node:url&#39;import &#123; defineConfig &#125; from &#39;vite&#39;//elementPlus按需导入import AutoImport from &#39;unplugin-auto-import/vite&#39;import Components from &#39;unplugin-vue-components/vite&#39;import &#123; ElementPlusResolver &#125; from &#39;unplugin-vue-components/resolvers&#39;import vue from &#39;@vitejs/plugin-vue&#39;// https://vitejs.dev/config/export default defineConfig(&#123;  plugins: [    vue(),      // ...      AutoImport(&#123;        resolvers: [ElementPlusResolver()],      &#125;),      Components(&#123;        resolvers: [          //1. 配置elementPlus采用sass          ElementPlusResolver(&#123;importStyle: &quot;sass&quot;&#125;)        ],      &#125;),  ],  resolve: &#123;    alias: &#123;      &#39;@&#39;: fileURLToPath(new URL(&#39;./src&#39;, import.meta.url))    &#125;  &#125;,  css: &#123;    preprocessorOptions: &#123;      scss: &#123;        // 自动导入定制化样式文件进行样式覆盖        additionalData: `          @use &quot;@/styles/element/index.scss&quot; as *;        `,      &#125;    &#125;  &#125;&#125;)</code></pre><h2 id="1-2-axios-配置"><a href="#1-2-axios-配置" class="headerlink" title="1.2 axios 配置"></a>1.2 axios 配置</h2><h3 id="1-2-1-安装axios"><a href="#1-2-1-安装axios" class="headerlink" title="1.2.1 安装axios"></a>1.2.1 安装axios</h3><pre><code>npm i axios</code></pre><h3 id="1-2-2-配置基础实例"><a href="#1-2-2-配置基础实例" class="headerlink" title="1.2.2 配置基础实例"></a>1.2.2 配置基础实例</h3><ul><li>接口基础地址</li><li>接口超时时间</li><li>请求拦截器</li><li>相应拦截器</li></ul><pre><code class="ts">import axios from &#39;axios&#39;const httpInstance=axios.create(&#123;    baseURL: &#39;http://pcapi-xiaotuxian-front-devtest.itheima.net&#39;,    timeout: 5000  //五秒钟&#125;)//拦截器// axios请求拦截器httpInstance.interceptors.request.use(config =&gt; &#123;    return config  &#125;, e =&gt; Promise.reject(e))    // axios响应式拦截器  httpInstance.interceptors.response.use(res =&gt; res.data, e =&gt; &#123;    return Promise.reject(e)  &#125;)export default httpInstance</code></pre><h3 id="1-2-3-项目路由设计"><a href="#1-2-3-项目路由设计" class="headerlink" title="1.2.3 项目路由设计"></a>1.2.3 项目路由设计</h3><p><strong>路由设计原则：找页面的切换方式，如果是整体切换，则为一级路由，如果是在一级路由的内部进行的内容切换，则为二级路由</strong></p><h2 id="1-3-scss文件自动导入"><a href="#1-3-scss文件自动导入" class="headerlink" title="1.3 scss文件自动导入"></a>1.3 scss文件自动导入</h2><p>为什么需要自动导入?</p><p>在项目中一些组件共享的色值会以scss变量的方式统一放到名为var.scss的文件中,正常的组件使用需要先导入scss文件,再使用其内部的变量. 自动导入可以免去导入文件的步骤,比较简单</p><p>文件内容</p><pre><code class="scss">$xtxColor: #27ba9b;$helpColor: #e26237;$sucColor: #1dc779;$warnColor: #ffb302;$priceColor: #cf4444;</code></pre><p>在vite.config.ts中:</p><pre><code class="ts">css: &#123;    preprocessorOptions: &#123;      scss: &#123;        // 自动导入scss文件        additionalData: `          @use &quot;@/styles/element/index.scss&quot; as *;          @use &quot;@/styles/var.scss&quot; as *;        `,      &#125;    &#125;&#125;</code></pre><h1 id="二-Layout开发"><a href="#二-Layout开发" class="headerlink" title="二. Layout开发"></a>二. Layout开发</h1><p><img src="https://gitee.com/DylanToT99/images/raw/master/images2/image-20240321201545019.png" alt="image-20240321201545019"></p><h2 id="2-1引入字体图标"><a href="#2-1引入字体图标" class="headerlink" title="2.1引入字体图标:"></a>2.1引入字体图标:</h2><p><img src="https://gitee.com/DylanToT99/images/raw/master/images2/image-20240321201518826.png" alt="image-20240321201518826"></p><p>字体图标采用的是阿里的字体图标库，样式文件已经准备好，在 index.html文件中引入即可(不稳定,仅供开发环境使用)</p>  <link rel="stylesheet" href="//at.alicdn.com/t/font_2143783_iq6z4ey5vu.css"><h2 id="2-2-吸顶导航"><a href="#2-2-吸顶导航" class="headerlink" title="2.2 吸顶导航"></a>2.2 吸顶导航</h2><p><img src="https://gitee.com/DylanToT99/images/raw/master/images2/image-20240321201459064.png" alt="image-20240321201459064"></p><ul><li>使用vueUse帮助获取滚动数据:</li></ul><pre><code class="js">&lt;script setup lang=&quot;ts&quot;&gt;import &#123; useScroll &#125; from &#39;@vueuse/core&#39;const el = ref&lt;HTMLElement | null&gt;(null)const &#123; x, y, isScrolling, arrivedState, directions &#125; = useScroll(el)&lt;/script&gt;&lt;template&gt;  &lt;div ref=&quot;el&quot; /&gt;&lt;/template&gt;</code></pre><pre><code class="ts">&lt;script setup&gt;import &#123; useScroll &#125; from &#39;@vueuse/core&#39;import &#123;useCategoryStore&#125; from &quot;@/stores/category.ts&quot;;//拿到纵向滚动距离const &#123;y&#125;=useScroll(window)</code></pre><ul><li>添加新的导航组件样式类名</li></ul><pre><code class="scss">.app-header-sticky &#123;  width: 100%;  height: 80px;  position: fixed;  left: 0;  top: 0;  z-index: 999;  background-color: #fff;  border-bottom: 1px solid #e4e4e4;    // 此处为关键样式!!!    // 默认状态将其向上平移100%,使其不显示    // 状态一：往上平移自身高度 + 完全透明  transform: translateY(-100%);  opacity: 0;  // 状态二：移除平移 + 完全不透明  &amp;.show &#123;      //这段CSS代码片段定义了一个元素属性的过渡效果。      // 当元素的样式发生任何变化时，例如颜色、尺寸或位置等属性发生变化时，这个过渡效果将在0.3秒内以线性方式完成动画过渡。      //transition: all 表示所有可过渡的CSS属性都将应用此过渡效果。      //0.3s 指定了过渡动画的持续时间是0.3秒。      //linear 是过渡 timing function（计时函数），表示在动画进行过程中，速度是均匀的，不会出现加速或减速的情况。    transition: all 0.3s linear;    transform: none;    opacity: 1;  &#125;</code></pre><h2 id="2-3-pinia优化重复请求的数据"><a href="#2-3-pinia优化重复请求的数据" class="headerlink" title="2.3 pinia优化重复请求的数据"></a>2.3 pinia优化重复请求的数据</h2><p><img src="https://gitee.com/DylanToT99/images/raw/master/images3/image-20240318164527320.png" alt="image-20240318164527320"></p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images3/image-20240318164535343.png" alt="image-20240318164535343"></p><p>思路: 父组件中发送pinia封装好的请求,拿到数据存到pinia中, 子组件再从pinia中取,实现一次请求,多个组件共用数据的效果</p><pre><code class="ts">category.tsimport &#123; ref &#125; from &#39;vue&#39;import &#123; defineStore &#125; from &#39;pinia&#39;import &#123;getCategoryApi&#125; from &quot;@/apis/layout&quot;;export const useCategoryStore    = defineStore(&#39;category&#39;, () =&gt; &#123;    // 当前导航列表的逻辑    const categoryList=ref([])    const getCategory=async ()=&gt;&#123;        const res=await getCategoryApi()        console.log(res)        categoryList.value=res.result    &#125;    //返回数据和方法    return &#123;        categoryList,        getCategory    &#125;&#125;)</code></pre><p>父组件使用:</p><pre><code class="ts">import &#123;useCategoryStore&#125; from &quot;@/stores/category&quot;;import &#123;onMounted&#125; from &quot;vue&quot;;//触发获取导航列表的actionconst categoryStore=useCategoryStore()onMounted(()=&gt;&#123;    categoryStore.getCategory()&#125;)</code></pre><p>子组件获取数据</p><pre><code class="ts">import &#123;useCategoryStore&#125; from &quot;@/stores/category.ts&quot;;//使用pinia的值const categoryStore=useCategoryStore()</code></pre><h1 id="三-Home页开发"><a href="#三-Home页开发" class="headerlink" title="三. Home页开发"></a>三. Home页开发</h1><h2 id="3-1-整体结构的创建"><a href="#3-1-整体结构的创建" class="headerlink" title="3.1 整体结构的创建"></a>3.1 整体结构的创建</h2><p><img src="https://gitee.com/DylanToT99/images/raw/master/images3/image-20240319153624016.png" alt="image-20240319153624016"></p><p>1- 按照结构新增五个组件，准备最简单的模版，分别在Home模块的入口组件中引入</p><ul><li>HomeCategory</li><li>HomeBanner</li><li>HomeNew</li><li>HomeHot</li><li>HomeProduct</li></ul><pre><code class="vue">&lt;script setup&gt;import HomeCategory from &#39;./components/HomeCategory.vue&#39;import HomeBanner from &#39;./components/HomeBanner.vue&#39;import HomeNew from &#39;./components/HomeNew.vue&#39;import HomeHot from &#39;./components/HomeHot.vue&#39;import homeProduct from &#39;./components/HomeProduct.vue&#39;&lt;/script&gt;&lt;template&gt;  &lt;div class=&quot;container&quot;&gt;    &lt;HomeCategory /&gt;    &lt;HomeBanner /&gt;  &lt;/div&gt;  &lt;HomeNew /&gt;  &lt;HomeHot /&gt;  &lt;homeProduct /&gt;&lt;/template&gt;</code></pre><h2 id="3-2-banner轮播图的实现"><a href="#3-2-banner轮播图的实现" class="headerlink" title="3.2 banner轮播图的实现"></a>3.2 banner轮播图的实现</h2><p>使用elementUI的组件:</p><p><strong>Carousel 走马灯</strong></p><p>在有限空间内，循环播放同一类型的图片、文字等内容</p><pre><code class="vue">  &lt;div class=&quot;home-banner&quot;&gt;        &lt;el-carousel height=&quot;500px&quot; motion-blur interval=&quot;1800&quot;&gt;            &lt;el-carousel-item v-for=&quot;item in bannerList&quot; :key=&quot;item.id&quot;&gt;                &lt;img :src=&quot;item.imgUrl&quot;  alt=&quot;&quot;&gt;            &lt;/el-carousel-item&gt;        &lt;/el-carousel&gt;    &lt;/div&gt;</code></pre><h2 id="3-3-面板组件的封装"><a href="#3-3-面板组件的封装" class="headerlink" title="3.3 面板组件的封装"></a>3.3 面板组件的封装</h2><p>抽象了一个公用的展示组件, 用props和插槽传值</p><pre><code class="vue">&lt;script setup&gt; //定义propsdefineProps(&#123;  title: &#123;    type: String,    default: &#39;&#39;  &#125;,  subTitle: &#123;    type: String,    default: &#39;&#39;  &#125;&#125;)&lt;/script&gt;&lt;template&gt;  &lt;div class=&quot;home-panel&quot;&gt;    &lt;div class=&quot;container&quot;&gt;      &lt;div class=&quot;head&quot;&gt;        &lt;!-- 主标题和副标题 --&gt;        &lt;h3&gt;          &#123;&#123; title &#125;&#125;&lt;small&gt;&#123;&#123; subTitle &#125;&#125;&lt;/small&gt;        &lt;/h3&gt;      &lt;/div&gt;      &lt;!-- 主体内容区域 ,使用插槽--&gt;      &lt;slot/&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><p><strong>实现方式</strong></p><pre><code class="vue">&lt;template&gt;    &lt;HomePanel title=&quot;人气推荐&quot; sub-title=&quot;人气爆款 不容错过&quot;&gt;        &lt;!--插槽区域--&gt;        &lt;ul class=&quot;goods-list&quot;&gt;            &lt;li v-for=&quot;item in hotList&quot; :key=&quot;item.id&quot;&gt;                &lt;RouterLink to=&quot;/&quot;&gt;                    &lt;img v-img-lazy=&quot;item.picture&quot; alt=&quot;&quot;/&gt;                    &lt;p class=&quot;name&quot;&gt;&#123;&#123; item.title &#125;&#125;&lt;/p&gt;                    &lt;p class=&quot;desc&quot;&gt;&#123;&#123; item.alt &#125;&#125;&lt;/p&gt;                &lt;/RouterLink&gt;            &lt;/li&gt;        &lt;/ul&gt;    &lt;/HomePanel&gt;&lt;/template&gt;</code></pre><h2 id="3-4-懒加载指令的实现"><a href="#3-4-懒加载指令的实现" class="headerlink" title="3.4 懒加载指令的实现"></a>3.4 懒加载指令的实现</h2><ol><li>为了抽象出公共逻辑, 我决定使用插件的方式来完成指令的注册</li><li>指令的逻辑实现:<ul><li>当图片未出现在视口区域内, 不去赋值img的src属性让其去加载图片</li><li>当图片出现到了视口区域内, 复制src属性, 并将监视该图片的代码片段停止</li></ul></li></ol><p>使用vueUse的<strong>useIntersectionObserver</strong>函数来帮助监视是否有对应内容出现在视口区域内:</p><p>小demo:</p><p>当内容未出现时:</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images3/image-20240319160253444.png" alt="image-20240319160253444"></p><p>当内容出现时:</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images3/image-20240319160320298.png" alt="image-20240319160320298"></p><p>源码分析</p><pre><code class="vue">&lt;script setup&gt;import &#123; ref &#125; from &#39;vue&#39;import &#123; useIntersectionObserver &#125; from &#39;@vueuse/core&#39;//target是监视目标const target = ref(null)//是否出现在视口区域内const targetIsVisible = ref(false)//stop是该方法返回对象的一个属性, 能够让监视程序停止const &#123; stop &#125; = useIntersectionObserver(  target,    //isIntersecting: 是否出现(x和y方向都可检测)    //observerElement 监视的元素  ([&#123; isIntersecting &#125;], observerElement) =&gt; &#123;    targetIsVisible.value = isIntersecting  &#125;,)&lt;/script&gt;&lt;template&gt;  &lt;div ref=&quot;target&quot;&gt;    &lt;h1&gt;Hello world&lt;/h1&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><p> vue3的自定义指令api可以配合该方法一起使用</p><p>将一个自定义指令全局注册到应用层级是一种常见的做法：</p><pre><code class="js">const app = createApp(&#123;&#125;)// 使 v-focus 在所有组件中都可用app.directive(&#39;focus&#39;, &#123;  /* ... */&#125;)</code></pre><p>指令钩子</p><p>一个指令的定义对象可以提供几种钩子函数 (都是可选的)：</p><pre><code class="js">const myDirective = &#123;  // 在绑定元素的 attribute 前  // 或事件监听器应用前调用  created(el, binding, vnode, prevVnode) &#123;    // 下面会介绍各个参数的细节  &#125;,  // 在元素被插入到 DOM 前调用  beforeMount(el, binding, vnode, prevVnode) &#123;&#125;,  // 在绑定元素的父组件  // 及他自己的所有子节点都挂载完成后调用  mounted(el, binding, vnode, prevVnode) &#123;&#125;,  // 绑定元素的父组件更新前调用  beforeUpdate(el, binding, vnode, prevVnode) &#123;&#125;,  // 在绑定元素的父组件  // 及他自己的所有子节点都更新后调用  updated(el, binding, vnode, prevVnode) &#123;&#125;,  // 绑定元素的父组件卸载前调用  beforeUnmount(el, binding, vnode, prevVnode) &#123;&#125;,  // 绑定元素的父组件卸载后调用  unmounted(el, binding, vnode, prevVnode) &#123;&#125;&#125;</code></pre><p>钩子参数</p><p>指令的钩子会传递以下几种参数：</p><ul><li><strong><code>el</code>：指令绑定到的元素。这可以用于直接操作 DOM。</strong></li><li><code>binding</code>：一个对象，包含以下属性。<ul><li><strong><code>value</code>：传递给指令的值。例如在 <code>v-my-directive=&quot;1 + 1&quot;</code> 中，值是 <code>2</code>。</strong></li><li><code>oldValue</code>：之前的值，仅在 <code>beforeUpdate</code> 和 <code>updated</code> 中可用。无论值是否更改，它都可用。</li><li><code>arg</code>：传递给指令的参数 (如果有的话)。例如在 <code>v-my-directive:foo</code> 中，参数是 <code>&quot;foo&quot;</code>。</li><li><code>modifiers</code>：一个包含修饰符的对象 (如果有的话)。例如在 <code>v-my-directive.foo.bar</code> 中，修饰符对象是 <code>&#123; foo: true, bar: true &#125;</code>。</li><li><code>instance</code>：使用该指令的组件实例。</li><li><code>dir</code>：指令的定义对象。</li></ul></li><li><code>vnode</code>：代表绑定元素的底层 VNode。</li><li><code>prevNode</code>：代表之前的渲染中指令所绑定元素的 VNode。仅在 <code>beforeUpdate</code> 和 <code>updated</code> 钩子中可用。</li></ul><p><strong>实现方式</strong></p><pre><code class="ts">import &#123; useIntersectionObserver &#125; from &#39;@vueuse/core&#39;export const lazyPlugin=&#123;    install(app:any)&#123;        // 定义全局指令        app.directive(&quot;img-lazy&quot;,&#123;            //钩子函数            mounted(el:any,binding:any)&#123;                //el :代表指令绑定的元素, 该场景下指的是img元素                //binding: binding.value 是指令等于号后面绑定的表达式的值                console.log(el,binding)               const &#123;stop&#125;= useIntersectionObserver(                    el,                    ([&#123; isIntersecting &#125;]) =&gt; &#123;                        console.log(isIntersecting)                        if (isIntersecting)&#123;                            //进入视口区域,将指令绑定的值赋值给img的src                            el.src=binding.value                            //第一次赋值完毕后,停止监听避免资源浪费                            stop()                        &#125;                    &#125;,                )            &#125;        &#125;)    &#125;&#125;</code></pre><p>在入口文件中注册插件</p><pre><code class="js">//引入懒加载插件,并注册import &#123;*lazyPlugin*&#125; from &quot;@/directives&quot;;app.use(*lazyPlugin*)</code></pre><h2 id="3-5-goodItem的封装"><a href="#3-5-goodItem的封装" class="headerlink" title="3.5 goodItem的封装"></a>3.5 goodItem的封装</h2><p>展示组件的封装思路: 样式为静态结构, 数据需要展示什么就将其封装为props, 若样式在某些地方不同,则使用插槽来完成样式的多样化</p><pre><code class="vue">&lt;template&gt;    &lt;RouterLink to=&quot;/&quot; class=&quot;goods-item&quot;&gt;        &lt;img v-img-lazy=&quot;goods.picture&quot; alt=&quot;&quot; /&gt;        &lt;p class=&quot;name ellipsis&quot;&gt;&#123;&#123; goods.name &#125;&#125;&lt;/p&gt;        &lt;p class=&quot;desc ellipsis&quot;&gt;&#123;&#123; goods.desc &#125;&#125;&lt;/p&gt;        &lt;p class=&quot;price&quot;&gt;&amp;yen;&#123;&#123; goods.price &#125;&#125;&lt;/p&gt;    &lt;/RouterLink&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;defineProps(&#123;    goods:&#123;        type:Object,        default:()=&gt;&#123;&#125;    &#125;&#125;)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> vue </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="/2024/01/21/she-ji-mo-shi-xue-xi/"/>
      <url>/2024/01/21/she-ji-mo-shi-xue-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="1-创建型模式"><a href="#1-创建型模式" class="headerlink" title="1.创建型模式"></a>1.创建型模式</h1><h2 id="1-1-工厂模式"><a href="#1-1-工厂模式" class="headerlink" title="1.1 工厂模式"></a>1.1 工厂模式</h2><p>工厂模式又称工厂方法模式，是一种创建型设计模式，<strong>其在父类中提供一个创建对象的方法， 允许子类决定实例化对象的类型。</strong></p><p>这种设计模式也是 Java 开发中最常见的一种模式，它的主要意图是定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。</p><p><strong>简单说就是为了提供代码结构的扩展性，屏蔽每一个功能类中的具体实现逻辑。让外部可以更加简单的只是知道调用即可</strong>，同时，这也是去掉众多<code>ifelse</code>的方式。当然这可能也有一些缺点，比如需要实现的类非常多，如何去维护，怎样减低开发成本。但这些问题都可以在后续的设计模式结合使用中，逐步降低。</p><h3 id="1-1-1-实战"><a href="#1-1-1-实战" class="headerlink" title="1.1.1 实战"></a>1.1.1 实战</h3><p>在营销场景中经常会有某个用户做了一些操作；打卡、分享、留言、邀请注册等等，进行返利积分，最后通过积分在兑换商品，从而促活和拉新。</p><p>那么在这里我们模拟积分兑换中的发放多种类型商品，假如现在我们有如下三种类型的商品接口；</p><table><thead><tr><th>序号</th><th>类型</th><th>接口</th></tr></thead><tbody><tr><td>1</td><td>优惠券</td><td><code>CouponResult sendCoupon(String uId, String couponNumber, String uuid)</code></td></tr><tr><td>2</td><td>实物商品</td><td><code>Boolean deliverGoods(DeliverReq req)</code></td></tr><tr><td>3</td><td>第三方爱奇艺兑换卡</td><td><code>void grantToken(String bindMobileNumber, String cardId)</code></td></tr></tbody></table><p><strong>从以上接口来看有如下信息：</strong></p><ul><li>三个接口返回类型不同，有对象类型、布尔类型、还有一个空类型。</li><li>入参不同，发放优惠券需要仿重、兑换卡需要卡ID、实物商品需要发货位置(对象中含有)。</li><li>另外可能会随着后续的业务的发展，会新增其他种商品类型。因为你所有的开发需求都是随着业务对市场的拓展而带来的</li></ul><h3 id="普通实现"><a href="#普通实现" class="headerlink" title="普通实现"></a><strong>普通实现</strong></h3><pre><code class="java">public class PrizeController &#123;    private Logger logger= LoggerFactory.getLogger(PrizeController.class);    public AwardRes awardToUser(AwardReq req)&#123;        String reqJson = JSON.toJSONString(req);        AwardRes awardRes = null;        try &#123;            logger.info(&quot;奖品发放开始&#123;&#125;。req:&#123;&#125;&quot;, req.getUId(), reqJson);            // 按照不同类型方法商品[1优惠券、2实物商品、3第三方兑换卡(爱奇艺)]            if (req.getAwardType() == 1) &#123;                CouponService couponService = new CouponService();                CouponResult couponResult = couponService.sendCoupon(req.getUId(), req.getAwardNumber(), req.getBizId());                if (&quot;0000&quot;.equals(couponResult.getCode())) &#123;                    awardRes = new AwardRes(&quot;0000&quot;, &quot;发放成功&quot;);                &#125; else &#123;                    awardRes = new AwardRes(&quot;0001&quot;, couponResult.getInfo());                &#125;            &#125; else if (req.getAwardType() == 2) &#123;                GoodsService goodsService = new GoodsService();                DeliverReq deliverReq = new DeliverReq();                deliverReq.setUserName(queryUserName(req.getUId()));                deliverReq.setUserPhone(queryUserPhoneNumber(req.getUId()));                deliverReq.setSku(req.getAwardNumber());                deliverReq.setOrderId(req.getBizId());                deliverReq.setConsigneeUserName(req.getExtMap().get(&quot;consigneeUserName&quot;));                deliverReq.setConsigneeUserPhone(req.getExtMap().get(&quot;consigneeUserPhone&quot;));                deliverReq.setConsigneeUserAddress(req.getExtMap().get(&quot;consigneeUserAddress&quot;));                Boolean isSuccess = goodsService.deliverGoods(deliverReq);                if (isSuccess) &#123;                    awardRes = new AwardRes(&quot;0000&quot;, &quot;发放成功&quot;);                &#125; else &#123;                    awardRes = new AwardRes(&quot;0001&quot;, &quot;发放失败&quot;);                &#125;            &#125; else if (req.getAwardType() == 3) &#123;                String bindMobileNumber = queryUserPhoneNumber(req.getUId());                IQiYiCardService iQiYiCardService = new IQiYiCardService();                iQiYiCardService.grantToken(bindMobileNumber, req.getAwardNumber());                awardRes = new AwardRes(&quot;0000&quot;, &quot;发放成功&quot;);            &#125;            logger.info(&quot;奖品发放完成&#123;&#125;。&quot;, req.getUId());        &#125; catch (Exception e) &#123;            logger.error(&quot;奖品发放失败&#123;&#125;。req:&#123;&#125;&quot;, req.getUId(), reqJson, e);            awardRes = new AwardRes(&quot;0001&quot;, e.getMessage());        &#125;        return awardRes;    &#125;    private String queryUserName(String uId) &#123;        return &quot;花花&quot;;    &#125;    private String queryUserPhoneNumber(String uId) &#123;        return &quot;15200101&quot;;    &#125;&#125;</code></pre><p>核心逻辑: 通过if else 判断返回的奖品是什么类型再根据类型执行相应的逻辑,此种方法虽然简单但不易于维护, 若系统需要拓展则只能通过添加该类中的方法代码实现拓展效果</p><h3 id="工厂模式实现"><a href="#工厂模式实现" class="headerlink" title="工厂模式实现"></a>工厂模式实现</h3><p>发放商品接口</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images2/image-20240317141720563.png" alt="image-20240317141720563"></p><p>商品工厂</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images2/image-20240317141812548.png" alt="image-20240317141812548"></p><p>根据需求从工厂拿到需要的发放类, 传入参数即可完成需求</p><pre><code class="java">@Testpublic void test_commodity() throws Exception &#123;    StoreFactory storeFactory = new StoreFactory();    // 1. 优惠券    ICommodity commodityService_1 = storeFactory.getCommodityService(1);    commodityService_1.sendCommodity(&quot;10001&quot;, &quot;EGM1023938910232121323432&quot;, &quot;791098764902132&quot;, null);    // 2. 实物商品    ICommodity commodityService_2 = storeFactory.getCommodityService(2);    Map&lt;String,String&gt; extMap = new HashMap&lt;String,String&gt;();    extMap.put(&quot;consigneeUserName&quot;, &quot;谢飞机&quot;);    extMap.put(&quot;consigneeUserPhone&quot;, &quot;15200292123&quot;);    extMap.put(&quot;consigneeUserAddress&quot;, &quot;吉林省.长春市.双阳区.XX街道.檀溪苑小区.#18-2109&quot;);    commodityService_2.sendCommodity(&quot;10001&quot;,&quot;9820198721311&quot;,&quot;1023000020112221113&quot;,new HashMap&lt;String, String&gt;() &#123;&#123;        put("consigneeUserName", "谢飞机");        put("consigneeUserPhone", "15200292123");        put("consigneeUserAddress", "吉林省.长春市.双阳区.XX街道.檀溪苑小区.#18-2109");    &#125;&#125;);    // 3. 第三方兑换卡(爱奇艺)    ICommodity commodityService_3 = storeFactory.getCommodityService(3);    commodityService_3.sendCommodity(&quot;10001&quot;,&quot;AQY1xjkUodl8LO975GdfrYUio&quot;,null,null);&#125;</code></pre><h2 id="1-2-抽象工厂模式"><a href="#1-2-抽象工厂模式" class="headerlink" title="1.2 抽象工厂模式"></a>1.2 抽象工厂模式</h2><p><img src="https://gitee.com/DylanToT99/images/raw/master/images2/image-20240318125434700.png" alt="image-20240318125434700"></p><p>抽象工厂模式与工厂方法模式虽然主要意图都是为了解决，<strong>接口选择</strong>问题。但在实现上，抽象工厂是一个中心工厂，创建其他工厂的模式。</p><h3 id="1-2-1-场景模拟"><a href="#1-2-1-场景模拟" class="headerlink" title="1.2.1 场景模拟"></a>1.2.1 场景模拟</h3><p><img src="https://gitee.com/DylanToT99/images/raw/master/images2/image-20240318125546836.png" alt="image-20240318125546836"></p><p>预估<code>QPS较低</code>、<code>系统压力较小</code>、<code>并发访问不大</code>、<code>近一年没有大动作</code>等等，在考虑时间投入成本的前提前，并不会投入特别多的人力去构建非常完善的系统。就像对 <code>Redis</code> 的使用，往往可能只要是单机的就可以满足现状。</p><p>但随着业务超过预期的快速发展，系统的负载能力也要随着跟上。原有的单机 <code>Redis</code> 已经满足不了系统需求。这时候就需要更换为更为健壮的Redis集群服务，虽然需要修改但是不能影响目前系统的运行，还要平滑过渡过去。</p><p>随着这次的升级，可以预见的问题会有；</p><ol><li>很多服务用到了Redis需要一起升级到集群。</li><li>需要兼容集群A和集群B，便于后续的灾备。</li><li>两套集群提供的接口和方法各有差异，需要做适配。</li><li>不能影响到目前正常运行的系统。</li></ol><ul><li>模拟单机redisUtils:</li></ul><pre><code class="java">public class RedisUtils &#123;    private Logger logger= LoggerFactory.getLogger(RedisUtils.class);    private Map&lt;String, String&gt; dataMap = new ConcurrentHashMap&lt;String, String&gt;();    public String get(String key) &#123;        logger.info(&quot;redis获取数据 key: &#123;&#125;&quot;,key);        return dataMap.get(key);    &#125;    public void set(String key, String value) &#123;        logger.info(&quot;Redis写入数据 key：&#123;&#125; val：&#123;&#125;&quot;, key, value);        dataMap.put(key, value);    &#125;    public void set(String key, String value, long timeout, TimeUnit timeUnit) &#123;        logger.info(&quot;Redis写入数据 key：&#123;&#125; val：&#123;&#125; timeout：&#123;&#125; timeUnit：&#123;&#125;&quot;, key, value, timeout, timeUnit.toString());        dataMap.put(key, value);    &#125;    public void del(String key) &#123;        logger.info(&quot;Redis删除数据 key：&#123;&#125;&quot;, key);        dataMap.remove(key);    &#125;&#125;</code></pre><ul><li>模拟集群EGM</li></ul><pre><code class="java">public class EGM &#123;    private Logger logger = LoggerFactory.getLogger(EGM.class);    private Map&lt;String, String&gt; dataMap = new ConcurrentHashMap&lt;String, String&gt;();    public String gain(String key) &#123;        logger.info(&quot;EGM获取数据 key：&#123;&#125;&quot;, key);        return dataMap.get(key);    &#125;    public void set(String key, String value) &#123;        logger.info(&quot;EGM写入数据 key：&#123;&#125; val：&#123;&#125;&quot;, key, value);        dataMap.put(key, value);    &#125;    public void setEx(String key, String value, long timeout, TimeUnit timeUnit) &#123;        logger.info(&quot;EGM写入数据 key：&#123;&#125; val：&#123;&#125; timeout：&#123;&#125; timeUnit：&#123;&#125;&quot;, key, value, timeout, timeUnit.toString());        dataMap.put(key, value);    &#125;    public void delete(String key) &#123;        logger.info(&quot;EGM删除数据 key：&#123;&#125;&quot;, key);        dataMap.remove(key);    &#125;&#125;</code></pre><ul><li>模拟集群IIR</li></ul><pre><code class="java">public class IIR &#123;    private Logger logger = LoggerFactory.getLogger(IIR.class);    private Map&lt;String, String&gt; dataMap = new ConcurrentHashMap&lt;String, String&gt;();    public String get(String key) &#123;        logger.info(&quot;IIR获取数据 key：&#123;&#125;&quot;, key);        return dataMap.get(key);    &#125;    public void set(String key, String value) &#123;        logger.info(&quot;IIR写入数据 key：&#123;&#125; val：&#123;&#125;&quot;, key, value);        dataMap.put(key, value);    &#125;    public void setExpire(String key, String value, long timeout, TimeUnit timeUnit) &#123;        logger.info(&quot;IIR写入数据 key：&#123;&#125; val：&#123;&#125; timeout：&#123;&#125; timeUnit：&#123;&#125;&quot;, key, value, timeout, timeUnit.toString());        dataMap.put(key, value);    &#125;    public void del(String key) &#123;        logger.info(&quot;IIR删除数据 key：&#123;&#125;&quot;, key);        dataMap.remove(key);    &#125;&#125;</code></pre><p>两套集群,实现了同样的功能</p><h3 id="1-2-2-单集群代码使用"><a href="#1-2-2-单集群代码使用" class="headerlink" title="1.2.2  单集群代码使用"></a>1.2.2  单集群代码使用</h3><p><img src="https://gitee.com/DylanToT99/images/raw/master/images2/image-20240318130700401.png" alt="image-20240318130700401"></p><h3 id="1-2-3-普通方式实现单机升级为集群-if-else"><a href="#1-2-3-普通方式实现单机升级为集群-if-else" class="headerlink" title="1.2.3 普通方式实现单机升级为集群(if else)"></a>1.2.3 普通方式实现单机升级为集群(if else)</h3><pre><code class="java">public class normalServiceImpl implements normalService &#123;    private RedisUtils redisUtils = new RedisUtils();    private EGM egm = new EGM();    private IIR iir = new IIR();    @Override    public String get(String key, int redisType) &#123;        if (1 == redisType) &#123;            return egm.gain(key);        &#125;        if (2 == redisType) &#123;            return iir.get(key);        &#125;        return redisUtils.get(key);    &#125;    @Override    public void set(String key, String value, int redisType) &#123;        if (1 == redisType) &#123;            egm.set(key, value);            return;        &#125;        if (2 == redisType) &#123;            iir.set(key, value);            return;        &#125;        redisUtils.set(key, value);    &#125;    @Override    public void set(String key, String value, long timeout, TimeUnit timeUnit, int redisType) &#123;        if (1 == redisType) &#123;            egm.setEx(key, value, timeout, timeUnit);            return;        &#125;        if (2 == redisType) &#123;            iir.setExpire(key, value, timeout, timeUnit);            return;        &#125;        redisUtils.set(key, value, timeout, timeUnit);    &#125;    @Override    public void del(String key, int redisType) &#123;        if (1 == redisType) &#123;            egm.delete(key);            return;        &#125;        if (2 == redisType) &#123;            iir.del(key);            return;        &#125;        redisUtils.del(key);    &#125;&#125;</code></pre><p>显然,核心就是在每个方法中都使用if和else判断传入的集群类型</p><h3 id="1-2-4-抽象工厂模式实现重构"><a href="#1-2-4-抽象工厂模式实现重构" class="headerlink" title="1.2.4 抽象工厂模式实现重构"></a>1.2.4 抽象工厂模式实现重构</h3><p>这里的抽象工厂的创建和获取方式，会采用代理类的方式进行实现。所被代理的类就是目前的Redis操作方法类，让这个类在不需要任何修改下，就可以实现调用集群A和集群B的数据服务。</p><p>并且这里还有一点非常重要，由于集群A和集群B在部分方法提供上是不同的，因此需要做一个接口适配，而这个适配类就相当于工厂中的工厂，用于创建把不同的服务抽象为统一的接口做相同的业务</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images2/image-20240318131513407.png" alt="image-20240318131513407"></p><p>适配接口:</p><pre><code class="java">public interface ICacheAdapter &#123;    String get(String key);    void set(String key, String value);    void set(String key, String value, long timeout, TimeUnit timeUnit);    void del(String key);&#125;</code></pre><hr><ul><li>这个类的主要作用是让所有集群的提供方，能在统一的方法名称下进行操作。也方面后续的拓展。</li></ul><p><strong>EGMCacheAdapter</strong></p><pre><code class="java">public class EGMCacheAdapter implements ICacheAdapter &#123;    private EGM egm = new EGM();    public String get(String key) &#123;        return egm.gain(key);    &#125;    public void set(String key, String value) &#123;        egm.set(key, value);    &#125;    public void set(String key, String value, long timeout, TimeUnit timeUnit) &#123;        egm.setEx(key, value, timeout, timeUnit);    &#125;    public void del(String key) &#123;        egm.delete(key);    &#125;&#125;    </code></pre><p><strong>IIRCacheAdapter</strong></p><pre><code class="java">public class IIRCacheAdapter implements ICacheAdapter &#123;    private IIR iir = new IIR();    public String get(String key) &#123;        return iir.get(key);    &#125;    public void set(String key, String value) &#123;        iir.set(key, value);    &#125;    public void set(String key, String value, long timeout, TimeUnit timeUnit) &#123;        iir.setExpire(key, value, timeout, timeUnit);    &#125;    public void del(String key) &#123;        iir.del(key);    &#125;&#125;</code></pre><p>抽象工程代理类实现:</p><p><strong>JDKProxy</strong></p><pre><code class="java">public static &lt;T&gt; T getProxy(Class&lt;T&gt; interfaceClass, ICacheAdapter cacheAdapter) throws Exception &#123;    InvocationHandler handler = new JDKInvocationHandler(cacheAdapter);    ClassLoader classLoader = Thread.currentThread().getContextClassLoader();    Class&lt;?&gt;[] classes = interfaceClass.getInterfaces();    return (T) Proxy.newProxyInstance(classLoader, new Class[]&#123;classes[0]&#125;, handler);&#125;    </code></pre><ul><li>这里主要的作用就是完成代理类，同时对于使用哪个集群有外部通过入参进行传递。</li></ul><p><strong>JDKInvocationHandler</strong></p><pre><code class="java">public class JDKInvocationHandler implements InvocationHandler &#123;    private ICacheAdapter cacheAdapter;    public JDKInvocationHandler(ICacheAdapter cacheAdapter) &#123;        this.cacheAdapter = cacheAdapter;    &#125;    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;        return ICacheAdapter.class.getMethod(method.getName(), ClassLoaderUtils.getClazzByArgs(args)).invoke(cacheAdapter, args);    &#125;&#125;    </code></pre><ul><li>在代理类的实现中其实也非常简单，通过穿透进来的集群服务进行方法操作。</li><li>另外在<code>invoke</code>中通过使用获取方法名称反射方式，调用对应的方法功能，也就简化了整体的使用。</li><li>到这我们就已经将整体的功能实现完成了，关于抽象工厂这部分也可以使用非代理的方式进行实现</li></ul><p>测试:</p><pre><code class="java">@Testpublic void test_CacheService() throws Exception &#123;    CacheService proxy_EGM = JDKProxy.getProxy(CacheServiceImpl.class, new EGMCacheAdapter());    proxy_EGM.set(&quot;user_name_01&quot;,&quot;Dylan&quot;);    String val01 = proxy_EGM.get(&quot;user_name_01&quot;);    System.out.println(val01);        CacheService proxy_IIR = JDKProxy.getProxy(CacheServiceImpl.class, new IIRCacheAdapter());    proxy_IIR.set(&quot;user_name_01&quot;,&quot;Dylan&quot;);    String val02 = proxy_IIR.get(&quot;user_name_01&quot;);    System.out.println(val02);&#125;    </code></pre>]]></content>
      
      
      <categories>
          
          <category> design mode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>秒杀实战</title>
      <link href="/2024/01/11/miao-sha-xiang-mu/"/>
      <url>/2024/01/11/miao-sha-xiang-mu/</url>
      
        <content type="html"><![CDATA[<h1 id="一-项目前导"><a href="#一-项目前导" class="headerlink" title="一. 项目前导"></a>一. 项目前导</h1><h2 id="1-1-前后端分离-如何解决跨域问题"><a href="#1-1-前后端分离-如何解决跨域问题" class="headerlink" title="1.1 前后端分离,如何解决跨域问题"></a>1.1 前后端分离,如何解决跨域问题</h2><p>在微服务项目中 ,请求到达服务前一般会经过网关服务, 所以跨域问题可以交由网关解决. 本项目的网关采用了springcloud-gateway, 编辑配置类:</p><pre><code class="java">@Configurationpublic class CorsConfig &#123;    @Bean    public CorsWebFilter corsFilter() &#123;        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(new PathPatternParser());        CorsConfiguration config = new CorsConfiguration();        // 允许cookies跨域        config.setAllowCredentials(true);        // #允许向该服务器提交请求的URI，*表示全部允许，在SpringMVC中，如果设成*，会自动转成当前请求头中的Origin        config.addAllowedOrigin(&quot;*&quot;);        // #允许访问的头信息,*表示全部        config.addAllowedHeader(&quot;*&quot;);        // 预检请求的缓存时间（秒），即在这个时间段里，对于相同的跨域请求不会再预检了        config.setMaxAge(18000L);        // 允许提交请求的方法，*表示全部允许        config.addAllowedMethod(&quot;*&quot;);        source.registerCorsConfiguration(&quot;/**&quot;, config);        return new CorsWebFilter(source);    &#125;&#125;</code></pre><h2 id="1-2-在微服务中如何获取用户真实登录的ip"><a href="#1-2-在微服务中如何获取用户真实登录的ip" class="headerlink" title="1.2 在微服务中如何获取用户真实登录的ip"></a>1.2 在微服务中如何获取用户真实登录的ip</h2><p>请求线路:</p><p><strong>用户ip—&gt;  网关(网关ip)—&gt; 微服务</strong></p><p>要想服务能够获取用户ip, 则在网关层面需要将用户ip加入到请求明文中, 也就是请求头中</p><p>通过过滤器实现:</p><pre><code class="java">@Componentpublic class CommonFilter implements GlobalFilter &#123;    @Autowired    private StringRedisTemplate redisTemplate;    @Override    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) &#123;        /**         * pre拦截逻辑         * 在请求去到微服务之前，做了两个处理         * 1.把客户端真实IP通过请求头的方式传递给微服务         * 2.在请求头中添加FEIGN_REQUEST的请求头，值为0，标记请求不是Feign调用，而是客户端调用         */        ServerHttpRequest request = exchange.getRequest().mutate().                //拿到ip地址,将其添加到请求头中发到为服务里                header(CommonConstants.REAL_IP,exchange.getRequest().getRemoteAddress().getHostString()).                header(CommonConstants.FEIGN_REQUEST_KEY,CommonConstants.FEIGN_REQUEST_FALSE).                build();        return chain.filter(exchange.mutate().request(request).build()).then(Mono.fromRunnable(()-&gt;&#123;            /**             * post拦截逻辑             * 在请求执行完微服务之后,需要刷新token在redis的时间             * 判断token不为空 &amp;&amp; Redis还存在这个token对于的key,这时候需要延长Redis中对应key的有效时间.             */            String token,redisKey;            if(!StringUtils.isEmpty(token =exchange.getRequest().getHeaders().getFirst(CommonConstants.TOKEN_NAME))                    &amp;&amp; redisTemplate.hasKey(redisKey = CommonRedisKey.USER_TOKEN.getRealKey(token)))&#123;                redisTemplate.expire(redisKey, CommonRedisKey.USER_TOKEN.getExpireTime(), CommonRedisKey.USER_TOKEN.getUnit());            &#125;        &#125;));    &#125;&#125;</code></pre><p>此filter做了两件事:</p><ol><li>将来自客户端的请求(CommonConstants.FEIGN_REQUEST_KEY,CommonConstants.FEIGN_REQUEST_FALSE)而不是微服务之间的远程调用, 其请求ip添加到请求头中</li><li>在客户端请求完微服务后,刷新token在redis中的时间</li></ol><h2 id="1-3-登录流程"><a href="#1-3-登录流程" class="headerlink" title="1.3 登录流程"></a>1.3 登录流程</h2><p><img src="https://gitee.com/DylanToT99/images/raw/master/images2/image-20240320115329599.png" alt="image-20240320115329599"></p><h2 id="1-4-清理七天未登录的用户"><a href="#1-4-清理七天未登录的用户" class="headerlink" title="1.4 清理七天未登录的用户"></a>1.4 清理七天未登录的用户</h2><p>上图中伴随token一起存入redis的userInfo设置有过期时间, redis会自动清除. 但是写入redis中的hash和zset的userlogin没有设置过期时间, 若用户长期未登录就会浪费内存空间:</p><p>我们使用xxl-job来清理超过七天未登录的用户:</p><pre><code class="java">/** * 用于处理用户缓存的定时任务 * 为了保证Redis中的内存的有效使用。 * 我们默认保留7天内的用户缓存数据，每天凌晨的时候会把7天前的用户登录缓存数据删除掉 */@Component@Setter@Getter@RefreshScope@Slf4jpublic class UserCacheJob implements SimpleJob &#123;    @Value(&quot;$&#123;job.userCache.cron&#125;&quot;)    private String cron;    @Autowired    private StringRedisTemplate redisTemplate;    @Override    public void execute(ShardingContext shardingContext) &#123;        doWork();    &#125;    private void doWork() &#123;        // 获取日历对象        Calendar calendar = Calendar.getInstance();        // 在当前时间天数的基础上做加法操作        // 7天前 = 当前天 - 7        calendar.add(Calendar.DATE, -7);        //获取7天前的日期        Long max = calendar.getTime().getTime();        String userZSetKey = JobRedisKey.USER_ZSET.join(&quot;&quot;);        String userHashKey = JobRedisKey.USER_HASH.join(&quot;&quot;);        //根据排序找到在七天前登录的用户        Set&lt;String&gt; ids = redisTemplate.opsForZSet().rangeByScore(userZSetKey, 0, max);        //删除7天前的用户缓存数据        if (ids.size() &gt; 0) &#123;            redisTemplate.opsForHash().delete(userHashKey, ids.toArray());            redisTemplate.opsForZSet().removeRangeByScore(userZSetKey, 0, max);        &#125;    &#125;&#125;</code></pre><h2 id="1-5-未认证用户拦截-feign请求放行"><a href="#1-5-未认证用户拦截-feign请求放行" class="headerlink" title="1.5 未认证用户拦截&amp;feign请求放行"></a>1.5 未认证用户拦截&amp;feign请求放行</h2><p>首先在共用模块服务封装了一个feign方法拦截器,在每个feign请求前为其添加新的请求头, 标记这是一个feign请求</p><pre><code class="java">public class FeignRequestInterceptor implements RequestInterceptor &#123;    @Override    public void apply(RequestTemplate template) &#123;        // 发起 Feign 请求之前执行        // 往 Feign 请求中携带新的请求头，标识这一次请求是 Feign 请求        template.header(CommonConstants.FEIGN_REQUEST_KEY, CommonConstants.FEIGN_REQUEST_TRUE);    &#125;&#125;</code></pre><p>再新增一个拦截器:</p><pre><code class="java">public class RequireLoginInterceptor implements HandlerInterceptor &#123;    private StringRedisTemplate redisTemplate;    public RequireLoginInterceptor(StringRedisTemplate redisTemplate) &#123;        this.redisTemplate = redisTemplate;    &#125;    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;        // 判断当前请求是否是一个 api 请求        if (handler instanceof HandlerMethod) &#123;            HandlerMethod handlerMethod = (HandlerMethod) handler;            // 从请求头中获取 Feign 请求标识，以此来判断该请求是否是 Feign            String feignRequest = request.getHeader(CommonConstants.FEIGN_REQUEST_KEY);            // Feign请求标识不为空 &amp;&amp; 不是 Feign 请求 &amp;&amp; 访问的接口方法贴了 @RequireLogin            if (!StringUtils.isEmpty(feignRequest)                    &amp;&amp; CommonConstants.FEIGN_REQUEST_FALSE.equals(feignRequest)                    &amp;&amp; handlerMethod.getMethodAnnotation(RequireLogin.class) != null) &#123;                // 设置响应类型为 json                response.setContentType(&quot;application/json;charset=utf-8&quot;);                // 从请求头中获取 token                String token = request.getHeader(CommonConstants.TOKEN_NAME);                if (StringUtils.isEmpty(token)) &#123;                    // 如果 token 为空，返回 token 无效信息                    response.getWriter().write(JSON.toJSONString(Result.error(CommonCodeMsg.TOKEN_INVALID)));                    return false;                &#125;                UserInfo userInfo = JSON.parseObject(redisTemplate.opsForValue().get(CommonRedisKey.USER_TOKEN.getRealKey(token)), UserInfo.class);                // 基于 token 从 redis 中获取当前用户，如果获取不到，说明 token 无效                if (userInfo == null) &#123;                    response.getWriter().write(JSON.toJSONString(Result.error(CommonCodeMsg.TOKEN_INVALID)));                    return false;                &#125;                // 从请求头中获取 ip 地址                /*String ip = request.getHeader(CommonConstants.REAL_IP);                if (!userInfo.getLoginIp().equals(ip)) &#123;                    // 判断如果用户时的 ip 与当前访问接口的 ip 地址不一致，就拦截并提示 ip 已经改变，请重新登录                    response.getWriter().write(JSON.toJSONString(Result.error(CommonCodeMsg.LOGIN_IP_CHANGE)));                    return false;                &#125;*/            &#125;        &#125;        // 如果不是接口请求，就直接放行        return true;    &#125;&#125;</code></pre><p>逻辑:</p><ol><li><p>如果feign请求标识不为空 &amp;&amp; 不是feign请求 &amp;&amp; 方法接口标有@RequireLogin注解, 说明这是由外部访问服务的需要登录后的接口:</p><p>取出登录的token, 如果token为空或者token无效,则拦截请求</p></li><li><p>如果登录时的ip发生改变, 也需要重新登录</p></li><li><p>若是内部接口或者不需要登录就可访问的接口,则直接放行</p></li></ol><h2 id="1-6-聚合秒杀商品列表和定时缓存"><a href="#1-6-聚合秒杀商品列表和定时缓存" class="headerlink" title="1.6 聚合秒杀商品列表和定时缓存"></a>1.6 聚合秒杀商品列表和定时缓存</h2><p>数据库中有两张表, 分别是秒杀库中的seckill-product和商品库中的product,我们要将这两张表中的部分信息聚合在一起展示到前端的秒杀页面中:</p><pre><code class="java">@Overridepublic List&lt;SeckillProductVo&gt; selectTodayListByTime(Integer time) &#123;    // 1. 调用秒杀服务接口, 基于今天的时间, 查询今天的所有秒杀商品数据    List&lt;SeckillProduct&gt; todayList = seckillProductMapper.queryCurrentlySeckillProduct(time);    if (todayList.size() == 0) &#123;        return Collections.emptyList();    &#125;    // 2. 遍历秒杀商品列表, 得到商品 id 列表    List&lt;Long&gt; productIdList = todayList.stream() // Stream&lt;SeckillProduct&gt;            .map(SeckillProduct::getProductId) // SeckillProduct =&gt; Long            .distinct()            .collect(Collectors.toList());    // 3. 根据商品 id 列表, 调用商品服务查询接口, 得到商品列表    Result&lt;List&lt;Product&gt;&gt; result = productFeignApi.selectByIdList(productIdList);    /**     * result 可能存在的几种情况:     *  1. 远程接口正常返回, code == 200, data == 想要的数据     *  2. 远程接口出现异常, code != 200     *  3. 接口被熔断降级, data == null     */    if (result.hasError() || result.getData() == null) &#123;        throw new BusinessException(new CodeMsg(result.getCode(), result.getMsg()));    &#125;    List&lt;Product&gt; products = result.getData();    // 4. 遍历秒杀商品列表, 将商品对象与秒杀商品对象聚合到一起    // List&lt;SeckillProduct&gt; =&gt; List&lt;SeckillProductVo&gt;    List&lt;SeckillProductVo&gt; productVoList = todayList.stream()            .map(sp -&gt; &#123;                SeckillProductVo vo = new SeckillProductVo();                BeanUtils.copyProperties(sp, vo);                // 遍历远程查询的商品列表，判断是否与当前的秒杀商品关联的商品对象一致                // 如果是一致的，将该对象返回并将属性拷贝到 vo 对象中                List&lt;Product&gt; list = products.stream().filter(p -&gt; sp.getProductId().equals(p.getId())).collect(Collectors.toList());                if (!list.isEmpty()) &#123;                    Product product = list.get(0);                    BeanUtils.copyProperties(product, vo);                &#125;                vo.setId(sp.getId());                return vo;            &#125;) // Stream&lt;SeckillProductVo&gt;            .collect(Collectors.toList());    return productVoList;&#125;</code></pre><p>一般场景下,秒杀会有预热, 每天将需要秒杀的商品提前存入到redis中, 后续的查询也从redis中查询</p><pre><code class="java">@Overridepublic List&lt;SeckillProductVo&gt; selectTodayListByTimeFromRedis(Integer time) &#123;    String key = SeckillRedisKey.SECKILL_PRODUCT_LIST.join(time + &quot;&quot;);    //拿到所有数据    List&lt;String&gt; stringList = redisTemplate.opsForList().range(key, 0, -1);    if (stringList == null || stringList.size() == 0) &#123;        log.warn(&quot;[秒杀商品] 查询秒杀商品列表异常, Redis 中没有数据, 从 DB 中查询...&quot;);        return this.selectTodayListByTime(time);    &#125;    return stringList.stream().map(json -&gt; JSON.parseObject(json, SeckillProductVo.class)).collect(Collectors.toList());&#125;</code></pre><p>每天的预热任务:</p><pre><code class="java">@Component@Setter@Getter@RefreshScope@Slf4jpublic class SeckillProductInitJob implements SimpleJob &#123;    @Value(&quot;$&#123;job.seckillProduct.cron&#125;&quot;)    private String cron;    @Value(&quot;$&#123;job.seckillProduct.shardingCount&#125;&quot;)    private Integer shardingCount;    @Value(&quot;$&#123;job.seckillProduct.shardingParameters&#125;&quot;)    private String shardingParameters;    @Value(&quot;$&#123;job.seckillProduct.dataFlow&#125;&quot;)    private boolean dataFlow;    @Autowired    private SeckillProductFeignApi seckillProductFeignApi;    @Autowired    private StringRedisTemplate stringRedisTemplate;    @Override    public void execute(ShardingContext shardingContext) &#123;        // 分片参数利用场次进行分片        String time = shardingContext.getShardingParameter();        // 先清空之前的数据        String key = SeckillRedisKey.SECKILL_PRODUCT_LIST.join(time);        stringRedisTemplate.delete(key);        // 调用秒杀服务的接口, 查询秒杀商品 数据        Result&lt;List&lt;SeckillProductVo&gt;&gt; result = seckillProductFeignApi.selectTodayListByTime(Integer.valueOf(time));        if (result.hasError() || result.getData() == null) &#123;            log.warn(&quot;[秒杀商品数据预热] 查询秒杀商品数据失败, 远程服务异常. res=&#123;&#125;&quot;, JSON.toJSONString(result));            return;        &#125;        List&lt;SeckillProductVo&gt; productVoList = result.getData();        log.info(&quot;[秒杀商品数据预热] 准备开始预热秒杀商品数据, 当前场次:&#123;&#125;, 本次缓存的数据:&#123;&#125;&quot;, time, productVoList.size());        // 将数据存入 Redis : List        // key=TODAY:&#123;time&#125;:SECKILL:PRODUCTS        // value=SeckillProductVo =&gt; &#123;json&#125;        for (SeckillProductVo vo : productVoList) &#123;            String json = JSON.toJSONString(vo);            stringRedisTemplate.opsForList().rightPush(key, json);        &#125;        log.info(&quot;[秒杀商品数据预热] 数据预热完成...&quot;);    &#125;&#125;</code></pre><h1 id="二-秒杀功能"><a href="#二-秒杀功能" class="headerlink" title="二.秒杀功能"></a>二.秒杀功能</h1><h2 id="2-1-用户参数解析器"><a href="#2-1-用户参数解析器" class="headerlink" title="2.1 用户参数解析器"></a>2.1 用户参数解析器</h2><p>进行秒杀功能的前提是用户必须登录, 同时从前端传入的token中拿到用户的信息, 每次都需要用token在接口中去取.</p><p>很不方便.springboot提供了参数解析器的功能,其可以在从controller前将参数解析完毕,并传入到接口方法中. 比如</p><p>@RequestHeader(“token”)String token, 该注解就可以将请求头中的token解析到token参数中.</p><p>实现原理:</p><p>类RequestHeaderMethodArgumentResolver专门用来解析@RequestHeader,</p><p>其继承了HandlerMethodArgumentResolver接口:</p><pre><code class="java">public interface HandlerMethodArgumentResolver &#123;    //支持的类型    boolean supportsParameter(MethodParameter parameter);    //解析的逻辑    @Nullable    Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,          NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception;&#125;</code></pre><p>实现的方法:</p><pre><code class="java">    @Override    public boolean supportsParameter(MethodParameter parameter) &#123;        return (parameter.hasParameterAnnotation(RequestHeader.class) &amp;&amp;                !Map.class.isAssignableFrom(parameter.nestedIfOptional().getNestedParameterType()));    &#125;</code></pre><p>我们只需要仿照该方式即可完成自己的参数解析器</p><p>自定义注解:</p><pre><code class="java">@Target(ElementType.PARAMETER)@Retention(RetentionPolicy.RUNTIME)public @interface RequestUser &#123;&#125;</code></pre><p>参数解析器:</p><pre><code class="java">public class UserInfoMethodArgumentResolver implements HandlerMethodArgumentResolver &#123;    @Resource    private  StringRedisTemplate redisTemplate;    //该解析器是否支持这个参数    @Override    public boolean supportsParameter(MethodParameter parameter) &#123;        //判断参数类型是否是要处理的类型,并且注解了@RequestUser        return parameter.hasParameterAnnotation(RequestUser.class)&amp;&amp;parameter.getParameterType()== UserInfo.class;    &#125;    @Override    public Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer, NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception &#123;        //从请求头中获取token        String token = webRequest.getHeader(&quot;token&quot;);        return JSON.parseObject(redisTemplate.opsForValue().get(CommonRedisKey.USER_TOKEN.getRealKey(token)), UserInfo.class);    &#125;&#125;</code></pre><p>在秒杀模块中引入该解析器</p><pre><code class="java">@Beanpublic UserInfoMethodArgumentResolver userInfoMethodArgumentResolver()&#123;    return new UserInfoMethodArgumentResolver();&#125;    @Override    public void addArgumentResolvers(List&lt;HandlerMethodArgumentResolver&gt; resolvers) &#123;        resolvers.add(userInfoMethodArgumentResolver());    &#125;</code></pre><p>之后, 在任何服务再想拿到登录的用户信息就很方便了</p><h2 id="2-2-分布式锁解决超卖问题"><a href="#2-2-分布式锁解决超卖问题" class="headerlink" title="2.2 分布式锁解决超卖问题"></a>2.2 分布式锁解决超卖问题</h2><h3 id="2-2-1超卖"><a href="#2-2-1超卖" class="headerlink" title="2.2.1超卖"></a>2.2.1超卖</h3><p>用户下单流程:</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images2/image-20240320155647902.png" alt="image-20240320155647902"></p><p>当加锁时, 需要考虑到加锁的粒度问题.</p><p>首先分析超卖的原因:</p><p>当多个线程同时访问到商品对象时,其拿到的商品对象都是一样的,因此库存数也相同, 所以能够同时减去库存数目:</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images2/image-20240320160033861.png" alt="image-20240320160033861"></p><p>若在方法入口加锁,则粒度过大,让多线程模式直接变为串行,不符合高性能的要求</p><p>思考一下,问题的关键在于查看的库存和即将扣减库存的行为不是原子性的, 因此我们只需要在扣减库存前再查一次库存,将这两个行为同时加锁,即可缩小粒度</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images2/image-20240320160504391.png" alt="image-20240320160504391"></p><h3 id="2-2-2-基础版"><a href="#2-2-2-基础版" class="headerlink" title="2.2.2 基础版"></a>2.2.2 基础版</h3><ul><li>锁的对象: 指定的商品</li><li>当多个线程同时加锁,只能有一个线程加锁成功&#x3D;&gt;redis的setnx, setnx 秒杀场次+id xxx</li><li>当线程获取不到锁时,执行什么策略: 阻塞&#x2F;自旋(限制次数)&#x2F;抛出异常</li></ul><p><strong>redis锁</strong></p><pre><code class="java"> @Override    @CacheEvict(key=&quot;&#39;selectByIdAndTime:&#39; + #id&quot;)    public void decrStockCount(Long id, Integer time)  &#123;        String key=&quot;seckill:product:stockcount:&quot; + time + &quot;:&quot; + id;        try &#123;            //如果自旋次数超过5,则抛出异常            int count=0;            Boolean absent;            do&#123;                //注意,当一个进程拿到了锁但jvm突然挂掉时, 该锁就永远不会释放,造成死锁                absent = redisTemplate.opsForValue().setIfAbsent(key, Thread.currentThread().getName());               if (Boolean.FALSE.equals(absent))&#123;                   Thread.sleep(10);               &#125;               AssertUtils.isTrue((count++) &lt; 5, &quot;系统繁忙,请稍后再试&quot;);            &#125; while (Boolean.FALSE.equals(absent));            int stockCount = seckillProductMapper.getStockCount(id);            AssertUtils.isTrue(stockCount&gt;0,&quot;库存不足&quot;);            seckillProductMapper.decrStock(id);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125; finally &#123;            //释放锁            redisTemplate.delete(key);        &#125;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
          <category> redis </category>
          
          <category> 微服务 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>springboot中间件开发</title>
      <link href="/2023/03/24/zhong-jian-jian-kai-fa-springboot/"/>
      <url>/2023/03/24/zhong-jian-jian-kai-fa-springboot/</url>
      
        <content type="html"><![CDATA[<h1 id="一-统一白名单控制"><a href="#一-统一白名单控制" class="headerlink" title="一. 统一白名单控制"></a>一. 统一白名单控制</h1><h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1.背景:"></a>1.背景:</h2><p>虽然在测试环境、预发环境都有了相应功能的验证，但在真实的用户场景下可能还会存在其他隐患问题。那么为了更好的控制系统风险，通<strong>常需要研发人员在代码的接口层，提供白名单控制。</strong>上线初期先提供可配置的白名单用户进行访问验证，控制整体的交付风险程度。</p><p>白名单确实可以解决接口功能或者服务入口的访问范围风险，那么这里有一个技术方案实现问题。就是如果研发人员在所有的接口上都加这样的白名单功能，那么就会非常耗费精力，同时在功能不再需要时可能还需要将代码删除。在这个大量添加和修改重复功能的代码过程中，也在一定程度上造成了研发成本和操作风险。所以站在整体的系统建设角度来说，我们需要有一个<strong>通用的白名单服务系统，减少研发在这方面的重复开发。</strong></p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images2/FoJcE5VVsQB17rHXoxQc5EAui9CD.png" alt="img"></p><h2 id="2-设计"><a href="#2-设计" class="headerlink" title="2.设计"></a>2.设计</h2><p>白名单控制中间件整个实现工程并不复杂，其核心点在于对切面的理解和运用，以及一些配置项需要按照 SpringBoot 中的实现方式进行开发。</p><ol><li>DoWhiteList，是一个自定义注解。它作用就是在需要使用到的白名单服务的接口上，添加此注解并配置必要的信息。<em>接口入参提取字段属性名称、拦截后的返回信息</em></li><li>WhiteListAutoConfigure，配置下是对 SpringBoot yml 文件的使用，这样就可以把配置到 yml 文件的中白名单信息读取到中间件中。</li><li>DoJoinPoint，是整个中间件的核心部分，<strong>它负责对所有添加自定义注解的方法进行拦截和逻辑处理。</strong></li></ol><h2 id="3-实现"><a href="#3-实现" class="headerlink" title="3.实现"></a>3.实现</h2><h3 id="3-1核心注解"><a href="#3-1核心注解" class="headerlink" title="3.1核心注解"></a>3.1核心注解</h3><pre><code class="java">/** * @author Dylan * @version 1.0 * @date 2023/4/2 18:23 * @description * @Retention 是注解的注解，也称作元注解。这个注解里面有一个入参信息 RetentionPolicy.RUNTIME * 在它的注释中有这样一段描述：Annotations are to be recorded in the class file by the compiler and retained by the VM at run time, so they may be read reflectively.  其实说的就是加了这个注解，它的信息会被带到JVM运行时，当你在调用方法时可以通过反射拿到注解信息。除此之外，RetentionPolicy 还有两个属性 SOURCE、CLASS，其实这三个枚举正式对应了Java代码的加载和运行顺序， * Java源码文件 -&gt; .class文件 -&gt; 内存字节码。并且后者范围大于前者，所以一般情况下只需要使用 RetentionPolicy.RUNTIME 即可。 **/@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.METHOD)@Inheritedpublic @interface DoWhiteList &#123;    /**     *  @DoWhiteList 中有两个属性 key、returnJson。     *  key 的作用是配置当前接口入参需要提取的属性，returnJson 的作用是在我们拦截到用户请求后需要给一个返回信息。     */    String key() default &quot;&quot;;    String returnJson() default &quot;&quot;;&#125;</code></pre><h3 id="3-2-配置"><a href="#3-2-配置" class="headerlink" title="3.2 配置"></a>3.2 配置</h3><pre><code class="java">@ConfigurationProperties(prefix = &quot;bugstack.whitelist&quot;)public class WhiteListProperties &#123;    private String users;    public String getUsers() &#123;        return users;    &#125;    public void setUsers(String users) &#123;        this.users = users;    &#125;&#125;</code></pre><p>@ConfigurationProperties，用于创建指定前缀( prefix &#x3D; “dylan.whitelist” )的自定义配置信息，这样就在 yml 或者 properties 中读取到我们自己设定的配置信息。</p><pre><code class="java">@Configuration@ConditionalOnClass(WhiteListProperties.class)@EnableConfigurationProperties(WhiteListProperties.class)public class WhiteListAutoConfigure &#123;    @Bean(&quot;whiteListConfig&quot;)    @ConditionalOnMissingBean    public String whiteListConfig(WhiteListProperties properties) &#123;        return properties.getUsers();    &#125;&#125;</code></pre><ol><li>@Configuration，可以算作是一个组件注解，在 SpringBoot 启动时可以进行加载创建出 Bean 文件。<em>因为 @Configuration 注解有一个 @Component 注解</em></li><li>@ConditionalOnClass(<a href="http://whitelistproperties.class/">WhiteListProperties.class</a>)，当 WhiteListProperties 位于当前类路径上，才会实例化一个类。除此之外还有其他属于此系列的常用的注解。</li><li>@ConditionalOnBean 仅仅在当前上下文中存在某个对象时，才会实例化一个 Bean</li><li>@ConditionalOnClass 某个 CLASS 位于类路径上，才会实例化一个 Bean</li><li>@ConditionalOnExpression 当表达式为 true 的时候，才会实例化一个 Bean</li><li>@ConditionalOnMissingBean 仅仅在当前上下文中不存在某个对象时，才会实例化一个 Bean</li><li>@ConditionalOnMissingClass 某个 CLASS 类路径上不存在的时候，才会实例化一个 Bean</li><li>@Bean，在 whiteListConfig 方法上我们添加了这个注解以及方法入参 WhiteListProperties properties。这里面包括如下几个内容：</li><li>properties 配置会被注入进来，当然你也可以选择使用 @Autowired 的方式配置注入在使用属性。</li><li>整个方法会在配置信息和Bean注册完成后，开始被实例化加载到 Spring 中。</li><li>@ConditionalOnMissingBean，现在就用到了这个方法上，代表只会实例化一个 Bean 对象。</li></ol><h3 id="3-3-核心逻辑实现"><a href="#3-3-核心逻辑实现" class="headerlink" title="3.3 核心逻辑实现"></a>3.3 核心逻辑实现</h3><pre><code class="java">@Aspect@Componentpublic class DoJoinPoint &#123;    private Logger logger = LoggerFactory.getLogger(DoJoinPoint.class);    @Resource    private String whiteListConfig;    @Pointcut(&quot;@annotation(cn.dylan.middleware.whitelist.annotation.DoWhiteList)&quot;)    public void aopPoint() &#123;    &#125;    @Around(&quot;aopPoint()&quot;)    public Object doRouter(ProceedingJoinPoint jp) throws Throwable &#123;        // 获取内容        Method method = getMethod(jp);        DoWhiteList whiteList = method.getAnnotation(DoWhiteList.class);        // 获取字段值        String keyValue = getFiledValue(whiteList.key(), jp.getArgs());        logger.info(&quot;middleware whitelist handler method：&#123;&#125; value：&#123;&#125;&quot;, method.getName(), keyValue);        if (null == keyValue || &quot;&quot;.equals(keyValue)) return jp.proceed();        String[] split = whiteListConfig.split(&quot;,&quot;);        // 白名单过滤        for (String str : split) &#123;            if (keyValue.equals(str)) &#123;                return jp.proceed();            &#125;        &#125;        // 拦截        return returnObject(whiteList, method);    &#125;    private Method getMethod(JoinPoint jp) throws NoSuchMethodException &#123;        Signature sig = jp.getSignature();        MethodSignature methodSignature = (MethodSignature) sig;        return jp.getTarget().getClass().getMethod(methodSignature.getName(), methodSignature.getParameterTypes());    &#125;    // 返回对象    private Object returnObject(DoWhiteList whiteList, Method method) throws IllegalAccessException, InstantiationException &#123;        Class&lt;?&gt; returnType = method.getReturnType();        String returnJson = whiteList.returnJson();        if (&quot;&quot;.equals(returnJson)) &#123;            return returnType.newInstance();        &#125;        return JSON.parseObject(returnJson, returnType);    &#125;    // 获取属性值    private String getFiledValue(String filed, Object[] args) &#123;        String filedValue = null;        for (Object arg : args) &#123;            try &#123;                if (null == filedValue || &quot;&quot;.equals(filedValue)) &#123;                    filedValue = BeanUtils.getProperty(arg, filed);                &#125; else &#123;                    break;                &#125;            &#125; catch (Exception e) &#123;                if (args.length == 1) &#123;                    return args[0].toString();                &#125;            &#125;        &#125;        return filedValue;    &#125;&#125;</code></pre><h1 id="二-服务治理-超时熔断"><a href="#二-服务治理-超时熔断" class="headerlink" title="二.服务治理,超时熔断"></a>二.服务治理,超时熔断</h1><h2 id="1-背景-1"><a href="#1-背景-1" class="headerlink" title="1.背景"></a>1.背景</h2><p>保证支付系统的可靠性需要考虑的点非常多，但这里有一个最直接和重点的内容就支付响应时长，如果支付时间过长，那么暴增的支付请求可能会把整个服务拖垮，最终导致所有服务瘫痪。</p><p>这时你可能会想到一个功能组件，超时熔断 hystrix。这也是大多数支付系统中必用的组件，但怎么用呢，我们是在所有的接口上都加一个这样的功能组件吗？显然这样做是不合适的，一般类似这样的组件可能会嵌入到你的RPC接口或者自研的网关上，也可能是在整个服务治理层的功能编排上。总之，它不会轻易的暴漏给你，让你硬编码到业务逻辑实现中。</p><h2 id="2-方案设计"><a href="#2-方案设计" class="headerlink" title="2.方案设计"></a>2.方案设计</h2><p>很多时候你遇到的复杂场景问题，市面基本都有相应的解决方案，尤其是一些常见的问题都可以找到对应的技术实现工具。就像我们本章节所需要的调用超时要熔断保护系统，就有相应的技术组件 hystrix，它是 Netflix 公司开源的一款容错框架，在大部分 RPC 服务中也都有引入使用。</p><p>那如果我们只是想方便、简单并且不需要关心如何创建和返回结果的使用这样一个服务，就可以把 hystrix 的框架包装在中间里，屏蔽调用逻辑。</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images2/FhB_2X0tHz4pylrkrTqR7FBCKOg7.png" alt="img"></p><ol><li>使用自定义注解和切面技术，拦截需要被熔断保护的方法。</li><li>拦截后到方法后，就可以通过 hystrix 给方法设定已配置好的超时熔断处理</li></ol><h2 id="3-实现-1"><a href="#3-实现-1" class="headerlink" title="3.实现"></a>3.实现</h2><h3 id="3-1定义注解"><a href="#3-1定义注解" class="headerlink" title="3.1定义注解"></a>3.1定义注解</h3><pre><code class="java">@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.METHOD)public @interface DoHystrix &#123;    //失败结果    String returnJson()default &quot;&quot;;    //超时时间    int timeoutValue()default 0;&#125;</code></pre><h3 id="3-2熔断包装"><a href="#3-2熔断包装" class="headerlink" title="3.2熔断包装"></a>3.2熔断包装</h3><pre><code class="java">public class HystrixValveImpl extends HystrixCommand&lt;Object&gt;implements IValveService &#123;    private ProceedingJoinPoint jp;    private Method method;    private DoHystrix doHystrix;    public HystrixValveImpl()&#123;        /*********************************************************************************************         * 置HystrixCommand的属性         * GroupKey：            该命令属于哪一个组，可以帮助我们更好的组织命令。         * CommandKey：          该命令的名称         * ThreadPoolKey：       该命令所属线程池的名称，同样配置的命令会共享同一线程池，若不配置，会默认使用GroupKey作为线程池名称。         * CommandProperties：   该命令的一些设置，包括断路器的配置，隔离策略，降级设置，以及一些监控指标等。         * ThreadPoolProperties：关于线程池的配置，包括线程池大小，排队队列的大小等         *********************************************************************************************/        super(Setter.withGroupKey(HystrixCommandGroupKey.Factory.asKey(&quot;GovernGroup&quot;))                .andCommandKey(HystrixCommandKey.Factory.asKey(&quot;GovernKey&quot;))                .andThreadPoolKey(HystrixThreadPoolKey.Factory.asKey(&quot;GovernThreadPool&quot;))                .andCommandPropertiesDefaults(HystrixCommandProperties.Setter()                        .withExecutionIsolationStrategy(HystrixCommandProperties.ExecutionIsolationStrategy.THREAD))                .andThreadPoolPropertiesDefaults(HystrixThreadPoolProperties.Setter().withCoreSize(10))        );    &#125;    @Override    public Object access(ProceedingJoinPoint jp, Method method, DoHystrix doHystrix, Object[] args) throws Throwable &#123;        this.jp = jp;        this.method = method;        this.doHystrix = doHystrix;        // 设置熔断超时时间        Setter.withGroupKey(HystrixCommandGroupKey.Factory.asKey(&quot;GovernGroup&quot;))                .andCommandPropertiesDefaults(HystrixCommandProperties.Setter()                        .withExecutionTimeoutInMilliseconds(doHystrix.timeoutValue()));        return this.execute();    &#125;    @Override    protected Object run() throws Exception &#123;        try &#123;            return jp.proceed();        &#125; catch (Throwable e) &#123;            return null;        &#125;    &#125;    @Override    protected Object getFallback() &#123;        return JSON.parseObject(doHystrix.returnJson(),method.getReturnType());    &#125;&#125;</code></pre><h3 id="3-3-定义切面"><a href="#3-3-定义切面" class="headerlink" title="3.3 定义切面"></a>3.3 定义切面</h3><pre><code class="java">@Aspect@Componentpublic class DoHystrixPoint &#123;    //定义切点    @Pointcut(&quot;@annotation(cn.dylan.middleware.hystrix.annotation.DoHystrix)&quot;)    public void aopPoint() &#123;    &#125;    @Around(&quot;aopPoint()&amp;&amp;  @annotation(doGovern)&quot;)    public Object doRouter(ProceedingJoinPoint jp, DoHystrix doGovern) throws Throwable &#123;        IValveService valveService = new HystrixValveImpl();        return valveService.access(jp, getMethod(jp), doGovern, jp.getArgs());    &#125;    private Method getMethod(JoinPoint jp) throws NoSuchMethodException &#123;        Signature sig = jp.getSignature();        MethodSignature methodSignature = (MethodSignature) sig;        return jp.getTarget().getClass().getMethod(methodSignature.getName(), methodSignature.getParameterTypes());    &#125;&#125;</code></pre><h1 id="三-服务治理-调用限流"><a href="#三-服务治理-调用限流" class="headerlink" title="三.服务治理,调用限流"></a>三.服务治理,调用限流</h1><h2 id="1-背景-2"><a href="#1-背景-2" class="headerlink" title="1.背景"></a>1.背景</h2><p>通常我们可以知道一个系统服务在正常的业务增速下的流量大小，基本也是基于这个流量大小的几倍来扩容服务和系统压测验证的。如果后续有相应的业务推广或者活动，一般都会提前报备，再由研发侧做相应的扩容。</p><p>但如果我们的系统服务已经基本稳定在一个可承载的安全体量范围，对于突发或者恶意攻击的访问都需要拦截在外，避免系统被这样的流量拖垮或者打挂掉。</p><p>因此我们需要在系统开发中使用限流机制来保护系统，但同样的这部分功能并不属于业务系统逻辑范围，它只是通用非业务的一部分共性需求，所以我们提出统一的解决方案，免去所有研发都做重复的工作。</p><h2 id="2-设计-1"><a href="#2-设计-1" class="headerlink" title="2.设计"></a>2.设计</h2><p>RateLimiter 是令牌桶思想的一个实现，可实现流量整形、资源访问速率控制，在分布式部署的系统中大多数也是使用 RateLimiter 做限流处理。</p><p>这里的方案是为了简化对于 RateLimiter 的使用，也就是不需要研发人员关心怎么实例化到硬编码在业务代码中。因此我们需要把这样的组件型功能服务，包装到中间件里，让使用方可以更简单的集成到开发系统中。整体的设计方案如图 5-1 调用限流中间件框架设计。</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images2/FpHU29heo-6IvKtyR3qimkJYIFdP.png" alt="img"></p><h2 id="3-实现-2"><a href="#3-实现-2" class="headerlink" title="3.实现"></a>3.实现</h2><h3 id="3-1注解定义"><a href="#3-1注解定义" class="headerlink" title="3.1注解定义"></a>3.1注解定义</h3><pre><code class="java">@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.METHOD)public @interface DoRateLimiter &#123;    double permitsPerSecond() default 0D;   // 限流许可量    String returnJson() default &quot;&quot;;         // 失败结果 JSON&#125;</code></pre><h3 id="3-2定义缓存map"><a href="#3-2定义缓存map" class="headerlink" title="3.2定义缓存map"></a>3.2定义缓存map</h3><pre><code class="java">public class Constants &#123;    public static Map&lt;String, RateLimiter&gt;rateLimiterMap= Collections.synchronizedMap(new HashMap&lt;&gt;());    &#125;</code></pre><h3 id="3-3定义包装类"><a href="#3-3定义包装类" class="headerlink" title="3.3定义包装类"></a>3.3定义包装类</h3><pre><code class="java">public class RateLimiterValve implements IValveService &#123;    @Override    public Object access(ProceedingJoinPoint jp, Method method, DoRateLimiter doRateLimiter, Object[] args) throws Throwable &#123;        if(doRateLimiter.permitsPerSecond()==0)&#123;            //未开启限流            return jp.proceed();        &#125;        String clazzName = jp.getTarget().getClass().getName();        String methodName = method.getName();        String key = clazzName + &quot;.&quot; + methodName;        if (null == Constants.rateLimiterMap.get(key)) &#123;            Constants.rateLimiterMap.put(key, RateLimiter.create(doRateLimiter.permitsPerSecond()));        &#125;        RateLimiter rateLimiter = Constants.rateLimiterMap.get(key);        if (rateLimiter.tryAcquire()) &#123;            return jp.proceed();        &#125;        return JSON.parseObject(doRateLimiter.returnJson(), method.getReturnType());    &#125;&#125;</code></pre><h3 id="3-4定义切面"><a href="#3-4定义切面" class="headerlink" title="3.4定义切面"></a>3.4定义切面</h3><pre><code class="java">@Aspect@Componentpublic class DoRateLimiterPoint &#123;    @Pointcut(&quot;@annotation(cn.dylan.middleware.ratelimiter.annotation.DoRateLimiter)&quot;)    public void aopPoint() &#123;    &#125;    @Around(&quot;aopPoint() &amp;&amp; @annotation(doRateLimiter)&quot;)    public Object doRouter(ProceedingJoinPoint jp, DoRateLimiter doRateLimiter) throws Throwable &#123;        IValveService valveService = new RateLimiterValve();        return valveService.access(jp, getMethod(jp), doRateLimiter, jp.getArgs());    &#125;    private Method getMethod(JoinPoint jp) throws NoSuchMethodException &#123;        Signature sig = jp.getSignature();        MethodSignature methodSignature = (MethodSignature) sig;        return jp.getTarget().getClass().getMethod(methodSignature.getName(), methodSignature.getParameterTypes());    &#125;    &#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring,中间件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>仿牛客项目</title>
      <link href="/2023/03/21/niu-ke-shou-ye-xiang-mu/"/>
      <url>/2023/03/21/niu-ke-shou-ye-xiang-mu/</url>
      
        <content type="html"><![CDATA[<h1 id="一-开发社区首页"><a href="#一-开发社区首页" class="headerlink" title="一.开发社区首页"></a>一.开发社区首页</h1><p>开发流程:</p><ul><li>一次请求的过程</li></ul><p>分步实现</p><ul><li>开发社区首页,显示前十个帖子</li><li>开发分页组件,分页显示所有帖子</li></ul><h2 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h2><h3 id="关键点一"><a href="#关键点一" class="headerlink" title="关键点一:"></a>关键点一:</h3><p>​由于查询discussPost表时会查询到用户id,而我们在前端页面上现实的是用户的姓名,那么就需要根据用户id查询姓名. 作法有两种,第一种是连表查询. 第二种是根据查到的id到用户表中查找姓名,最后再同一封装给前端:本项目采用第一种方案:</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230217210317222.png" alt="image-20230217210317222"></p><h3 id="关键点二"><a href="#关键点二" class="headerlink" title="关键点二:"></a>关键点二:</h3><p>关于springmvc对于方法中的model和其他参数的问题:</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230217210546363.png" alt="image-20230217210546363"></p><h2 id="前端-thymeleaf"><a href="#前端-thymeleaf" class="headerlink" title="前端(thymeleaf)"></a>前端(thymeleaf)</h2><h3 id="关键点一-1"><a href="#关键点一-1" class="headerlink" title="关键点一:"></a>关键点一:</h3><p>关于thymeleaf的语法问题:</p><p>通常使用  <strong>${}</strong> 的形式接受后端传过来的参数,而使用 xx: **${yy}**可以为参数取别名:</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230217210824347.png" alt="image-20230217210824347"></p><p><strong>th:if</strong>用于判断条件,条件成立则显示html的内容,否则不显示:</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230217211008030.png" alt="image-20230217211008030"></p><p>thymeleaf关于时间日期的格式转换,采用内置的函数#dates.format(date,format):</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230217211238698.png" alt="image-20230217211238698"></p><p><strong>th:utext</strong>会将特殊字符转义,th:text则不会</p><h3 id="关键点二-1"><a href="#关键点二-1" class="headerlink" title="关键点二:"></a>关键点二:</h3><p>有一些相对路径的静态资源时,通常需要使用</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230217211422825.png" alt="image-20230217211422825"></p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230217211433609.png" alt="image-20230217211433609"></p><p>这样就会让程序从static目录下寻找静态资源了</p><p>而在请求路径中这样写是相对于整个项目的路径如:</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230217212449870.png" alt="image-20230217212449870"></p><p>请求路径为:<a href="http://localhost:8080/community/index?current=1">http://localhost:8080/community/index?current=1</a></p><h3 id="关键点三"><a href="#关键点三" class="headerlink" title="关键点三:"></a>关键点三:</h3><p>动态为html标签添加类:| 固定类名,  ${条件语句} |</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230217212634231.png" alt="image-20230217212634231"></p><p>同时,themeleaf还有创建连续数数组<img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230217212758254.png" alt="image-20230217212758254">的方法,#numbers.sequence(a,b)—&gt;创建从a到b的数组</p><h1 id="二-发送邮件"><a href="#二-发送邮件" class="headerlink" title="二.发送邮件"></a>二.发送邮件</h1><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230218141925711.png" alt="image-20230218141925711"></p><h2 id="1-启动代发送邮件客户端的smtp功能"><a href="#1-启动代发送邮件客户端的smtp功能" class="headerlink" title="1.启动代发送邮件客户端的smtp功能,"></a>1.启动代发送邮件客户端的smtp功能,</h2><p>本人使用的是qq邮箱,那么就要从设置中启用:</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230218164836043.png" alt="image-20230218164836043"></p><h2 id="2-导入spring-email相关的jar包"><a href="#2-导入spring-email相关的jar包" class="headerlink" title="2.导入spring email相关的jar包"></a>2.导入spring email相关的jar包</h2><pre><code class="xml">  &lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-mail --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt;            &lt;version&gt;2.7.8&lt;/version&gt;        &lt;/dependency&gt;</code></pre><h2 id="3-配置邮箱参数"><a href="#3-配置邮箱参数" class="headerlink" title="3.配置邮箱参数"></a>3.配置邮箱参数</h2><pre><code class="properties">spring.mail.host=smtp.qq.comspring.mail.port=465spring.mail.username=1975131479@qq.comspring.mail.password=idhhgkpulgrufaacspring.mail.protocol=smtpsspring.mail.properties.mail.smtp.ssl.enable=truespring.mail.properties.mail.smtl.auth=truespring.mail.properties.mail.smtp.starttls.enable=truespring.mail.properties.mail.smtp.starttls.required=true</code></pre><h2 id="4-使用JavaMailSender发送邮件"><a href="#4-使用JavaMailSender发送邮件" class="headerlink" title="4.使用JavaMailSender发送邮件"></a>4.使用JavaMailSender发送邮件</h2><p>创建发送工具类:</p><pre><code class="java">@Componentpublic class MailClient &#123;    private static final Logger logger= LoggerFactory.getLogger(MailClient.class);    @Resource    private JavaMailSender mailSender;        @Value(&quot;$&#123;spring.mail.username&#125;&quot;)    private String from;    public void sendMail(String to,String subject,String content)&#123;        try &#123;            MimeMessage message=mailSender.createMimeMessage();            MimeMessageHelper helper=new MimeMessageHelper(message);            helper.setFrom(from);            helper.setTo(to);            helper.setSubject(subject);            helper.setText(content,true);            mailSender.send(helper.getMimeMessage());        &#125; catch (MessagingException e) &#123;           logger.error(&quot;发送邮件失败:&quot;+e.getMessage());        &#125;    &#125;&#125;</code></pre><p>测试:</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230218165210336.png" alt="image-20230218165210336"></p><h2 id="5-引入thymeleaf引擎发送html邮件"><a href="#5-引入thymeleaf引擎发送html邮件" class="headerlink" title="5.引入thymeleaf引擎发送html邮件:"></a>5.引入thymeleaf引擎发送html邮件:</h2><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230218165309093.png" alt="image-20230218165309093"></p><h1 id="三-开发注册功能"><a href="#三-开发注册功能" class="headerlink" title="三.开发注册功能"></a>三.开发注册功能</h1><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230218145913743.png" alt="image-20230218145913743"></p><h2 id="1-开发访问注册页面"><a href="#1-开发访问注册页面" class="headerlink" title="1.开发访问注册页面"></a>1.开发访问注册页面</h2><p>控制层中直接加入代码:</p><pre><code class="java">@GetMapping(&quot;/register&quot;)public String getRegisterPage()&#123;    return &quot;/site/register&quot;;&#125;</code></pre><h2 id="2-提交注册数据-注册激活账号"><a href="#2-提交注册数据-注册激活账号" class="headerlink" title="2.提交注册数据,注册激活账号"></a>2.提交注册数据,注册激活账号</h2><p>业务层中加入如下代码:</p><pre><code class="java">@Value(&quot;$&#123;community.path.domain&#125;&quot;)private String domain;@Value(&quot;$&#123;server.servlet.context-path&#125;&quot;)private String contextPath;public User findUserById(int id)&#123;    return userMapper.selectById(id);&#125;//注册方法public Map&lt;String,Object&gt;register(User user)&#123;    //map作为传给前端的值    Map&lt;String,Object&gt;map=new HashMap&lt;&gt;();    //对空值进行判断处理    if(user==null)&#123;        throw new IllegalArgumentException(&quot;参数不能为空!&quot;);    &#125;    if(StringUtils.isBlank(user.getUsername()))&#123;        map.put(&quot;usernameMessage&quot;,&quot;账号不能为空&quot;);        return map;    &#125;    if(StringUtils.isBlank(user.getPassword()))&#123;        map.put(&quot;passwordMessage&quot;,&quot;密码不能为空&quot;);        return map;    &#125;    if(StringUtils.isBlank(user.getEmail()))&#123;        map.put(&quot;emailMessage&quot;,&quot;邮箱不能为空&quot;);        return map;    &#125;    //验证账号是否已经存在    User user1 = userMapper.selectByName(user.getUsername());    if(user1!=null)&#123;        map.put(&quot;usernameMessage&quot;,&quot;该账号已经存在&quot;);        return map;    &#125;    //验证邮箱    User user2 = userMapper.selectByEmail(user.getEmail());    if(user2!=null)&#123;        map.put(&quot;emailMessage&quot;,&quot;该邮箱已被注册&quot;);        return map;    &#125;    //注册用户    //盐的长度设置为5位    user.setSalt(CommunityUtil.generateUUID().substring(0,5));    user.setPassword(CommunityUtil.md5(user.getPassword()+user.getSalt()));    user.setType(0);    //0表示暂未激活    user.setStatus(0);    //生成激活码    user.setActivationCode(CommunityUtil.generateUUID());    user.setHeaderUrl(String.format(&quot;http://images.nowcoder.com/head/%dt.png&quot;,new Random().nextInt(1000)));    user.setCreateTime(new Date());    userMapper.insertUser(user);    //发送激活邮件    Context context=new Context();    context.setVariable(&quot;email&quot;,user.getEmail());    //通过地址的方式传递账户id和激活码,用户只需要点击一下激活就可以    //http://localhost:8080/community/activation/101/code    String url=domain+contextPath+&quot;/activation/&quot;+user.getId()+&quot;/&quot;+user.getActivationCode();    context.setVariable(&quot;url&quot;,url);    String content=templateEngine.process(&quot;/mail/activation&quot;,context);    mailClient.sendMail(user.getEmail(),&quot;激活牛客账号&quot;,content);    return map;&#125;</code></pre><p>其中注册成功和激活成功的结果都是返回同一个页面,但是页面的内容根据结果而定:</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230218170058916.png" alt="image-20230218170058916"></p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230218170122721.png" alt="image-20230218170122721"></p><p>该页面的关键点在于提示信息,和跳转的页面</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230218170212433.png" alt="image-20230218170212433"></p><h1 id="四-生成验证码"><a href="#四-生成验证码" class="headerlink" title="四.生成验证码"></a>四.生成验证码</h1><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230219134332696.png" alt="image-20230219134332696"></p><h2 id="1-导入jar包"><a href="#1-导入jar包" class="headerlink" title="1.导入jar包"></a>1.导入jar包</h2><pre><code class="xml"> &lt;!--验证码--&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.github.penggle&lt;/groupId&gt;            &lt;artifactId&gt;kaptcha&lt;/artifactId&gt;            &lt;version&gt;2.3.2&lt;/version&gt;        &lt;/dependency&gt;</code></pre><h2 id="2-编辑配置类"><a href="#2-编辑配置类" class="headerlink" title="2.编辑配置类"></a>2.编辑配置类</h2><pre><code class="java">@Configurationpublic class KaptchaConfig &#123;    @Bean    public Producer kaptchaProducer()&#123;        Properties properties=new Properties();        properties.setProperty(&quot;kaptcha.image.width&quot;,&quot;100&quot;);        properties.setProperty(&quot;kaptcha.image.height&quot;,&quot;40&quot;);        properties.setProperty(&quot;kaptcha.textproducer.font.size&quot;,&quot;32&quot;);        properties.setProperty(&quot;kaptcha.textproducer.font.color&quot;,&quot;0,0,0&quot;);        properties.setProperty(&quot;kaptcha.textproducer.char.string&quot;,&quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;);        properties.setProperty(&quot;kaptcha.textproducer.char.length&quot;,&quot;4&quot;);        properties.setProperty(&quot;kaptcha.noise.impl&quot;,&quot;com.google.code.kaptcha.impl.NoNoise&quot;);        DefaultKaptcha kaptcha=new DefaultKaptcha();        Config config=new Config(properties);        kaptcha.setConfig(config);        return kaptcha;    &#125;&#125;</code></pre><h2 id="3-生成随机验证码"><a href="#3-生成随机验证码" class="headerlink" title="3.生成随机验证码"></a>3.生成随机验证码</h2><pre><code class="java">@GetMapping(&quot;/kaptcha&quot;)public void getKaptcha(HttpServletResponse response, HttpSession session)&#123;    //生成验证码    String text = kaptchaProducer.createText();    //生成验证码图片    BufferedImage image = kaptchaProducer.createImage(text);    //把验证码存入session    session.setAttribute(&quot;kaptcha&quot;,text);    //将图片输出给浏览器    response.setContentType(&quot;image/png&quot;);    try &#123;        OutputStream os = response.getOutputStream();        //输出图片的工具类        ImageIO.write(image,&quot;png&quot;,os);    &#125; catch (IOException e) &#123;       logger.error(&quot;响应验证码失败:&quot;+e.getMessage());    &#125;&#125;</code></pre><h1 id="五-登录-退出功能"><a href="#五-登录-退出功能" class="headerlink" title="五.登录,退出功能"></a>五.登录,退出功能</h1><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230219143026346.png" alt="image-20230219143026346"></p><h2 id="1-验证账号-密码-验证码"><a href="#1-验证账号-密码-验证码" class="headerlink" title="1.验证账号,密码,验证码"></a>1.验证账号,密码,验证码</h2><p>验证账号密码的逻辑写在业务层,并且也附带一些提示信息:</p><pre><code class="java">//登录public Map&lt;String,Object&gt;login(String username,String password,int expiredSeconds)&#123;    Map&lt;String,Object&gt;map=new HashMap&lt;&gt;();    //空值处理    if (StringUtils.isBlank(username)) &#123;        map.put(&quot;usernameMsg&quot;,&quot;账号不能为空!&quot;);        return map;    &#125;    if(StringUtils.isBlank(password))&#123;        map.put(&quot;passwordMsg&quot;,&quot;密码不能为空&quot;);        return map;    &#125;    //验证账号    User user = userMapper.selectByName(username);    if(user==null)&#123;        map.put(&quot;usernameMsg&quot;,&quot;该账号不存在&quot;);        return map;    &#125;    //验证是否激活    if(user.getStatus()==0)&#123;        map.put(&quot;usernameMsg&quot;,&quot;该账号未激活&quot;);        return map;    &#125;    //user.setPassword(CommunityUtil.md5(user.getPassword()+user.getSalt()));    //验证密码    if(!CommunityUtil.md5(password + user.getSalt()).equals(user.getPassword()))&#123;        map.put(&quot;passwordMsg&quot;,&quot;输入的密码不正确,请再次输入&quot;);        return map;    &#125;    //全部通过之后,成功登录,生成登录凭证    LoginTicket loginTicket=new LoginTicket();    //登录凭证由随机字符组成    loginTicket.setTicket(CommunityUtil.generateUUID());    loginTicket.setUserId(user.getId());    loginTicket.setStatus(0);    //登录凭证的过期时间    loginTicket.setExpired(new Date(System.currentTimeMillis()+expiredSeconds* 1000L));        loginTicketMapper.insertLoginTicket(loginTicket);    map.put(&quot;ticket&quot;,loginTicket.getTicket());    return map;&#125;</code></pre><p>在控制层:</p><p>验证用户输入的验证码和session中存放的是否一致:</p><pre><code class="java">//检查验证码String kaptcha = (String) session.getAttribute(&quot;kaptcha&quot;);if (StringUtils.isBlank(code)||StringUtils.isBlank(kaptcha)||!kaptcha.equalsIgnoreCase(code)) &#123;    model.addAttribute(&quot;codeMsg&quot;,&quot;验证码不正确&quot;);    return &quot;/site/login&quot;;&#125;</code></pre><p>检查账号密码以及重定向逻辑:</p><pre><code class="java">//检查账号密码int expiredSeconds=rememberMe?REMEMBER_EXPIRED_SECONDS:DEFAULT_EXPIRED_SECONDS;Map&lt;String, Object&gt; map = userService.login(username, password, expiredSeconds);//如果mao中包含&quot;ticket&quot;,则说明用户的账号密码信息正确,可以登录if(map.containsKey(&quot;ticket&quot;))&#123;    //拿到cookie信息    Cookie cookie=new Cookie(&quot;ticket&quot;,map.get(&quot;ticket&quot;).toString());    //设置cookie有效的路径: 整个项目    cookie.setPath(contextPath);    cookie.setMaxAge(expiredSeconds);    //将设置好的cookie返回给浏览器    response.addCookie(cookie);    return &quot;redirect:/index&quot;;&#125;else&#123;    //用户在登录的某一环节出了差错    model.addAttribute(&quot;usernameMsg&quot;,map.get(&quot;usernameMsg&quot;));    model.addAttribute(&quot;passwordMsg&quot;,map.get(&quot;passwordMsg&quot;));    return &quot;/site/login&quot;;&#125;</code></pre><h2 id="2-前端登录处理"><a href="#2-前端登录处理" class="headerlink" title="2.前端登录处理:"></a>2.前端登录处理:</h2><p>注意:</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230219180535635.png" alt="image-20230219180535635"></p><p>正常的java类型写在了参数列表里, springmvc不会自动将其加入到model中(自定义的一些类可以).虽然能为input标签添加name属性将其自动注入到参数中,但是前端无法通过model再次访问这些值. </p><p>解决方法: 1.手动添加到model中</p><p>​2.thymeleaf为我们提供了param字段,相当于可以通过request得到请求携带的参数(request.getParameter(…))</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230219181225032.png" alt="image-20230219181225032"></p><p>这样处理的好处是可以在输入错误后,将上一次输入的结果保留到输入框内</p><h2 id="3-登出功能"><a href="#3-登出功能" class="headerlink" title="3.登出功能"></a>3.登出功能</h2><p>登出功能的逻辑就是:</p><p> 将上一次登录的cookie设置为失效状态,然后重定向到登录界面</p><pre><code class="java">public void logout(String ticket)&#123;    loginTicketMapper.updateStatus(ticket,1);&#125;</code></pre><pre><code class="java">@RequestMapping(path = &quot;/logout&quot;,method = RequestMethod.GET)public String logout(@CookieValue(&quot;ticket&quot;)String ticket)&#123;    userService.logout(ticket);    //默认get请求    return &quot;redirect:/login&quot;;&#125;</code></pre><p>@CookieValue注解可以直接从本地获得存放的cookie字符串</p><h1 id="六-显示登录信息"><a href="#六-显示登录信息" class="headerlink" title="六.显示登录信息"></a>六.显示登录信息</h1><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230219160834081.png" alt="image-20230219160834081"></p><h2 id="1-定义拦截器-在请求开始前查询登录用户"><a href="#1-定义拦截器-在请求开始前查询登录用户" class="headerlink" title="1.定义拦截器,在请求开始前查询登录用户"></a>1.定义拦截器,在请求开始前查询登录用户</h2><p>定义工具类,每个线程对应一个user对象:</p><pre><code class="java">@Componentpublic class HostHolder &#123;    private ThreadLocal&lt;User&gt; userThreadLocal=new ThreadLocal&lt;&gt;();    public void setUser(User user)&#123;        userThreadLocal.set(user);    &#125;    public User getUser()&#123;        return userThreadLocal.get();    &#125;    public void clear()&#123;        userThreadLocal.remove();    &#125;&#125;</code></pre><pre><code class="java">@Componentpublic class LoginTicketInterceptor implements HandlerInterceptor &#123;    @Resource    private UserService userService;    @Resource    private HostHolder hostHolder;    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;        //从cookie中获取凭证        String ticket = CookieUtil.getValue(request, &quot;ticket&quot;);        if(ticket!=null)&#123;            //表示登录了            //查询凭证            LoginTicket loginTicket = userService.findLoginTicket(ticket);            //检查凭证是否有效            if(loginTicket!=null&amp;&amp;loginTicket.getStatus()==0&amp;&amp;loginTicket.getExpired().after(new Date()))&#123;                //根据凭证查询用户                User user = userService.findUserById(loginTicket.getUserId());                //在本次请求中持有用户                hostHolder.setUser(user);            &#125;        &#125;        return true;    &#125;</code></pre><p>配置拦截器:</p><pre><code class="java">@Configurationpublic class WebMvcConfig implements WebMvcConfigurer &#123;    @Resource    private LoginTicketInterceptor loginTicketInterceptor;    @Override    public void addInterceptors(InterceptorRegistry registry) &#123;        registry.addInterceptor(loginTicketInterceptor)                //放行下面的路径,其他的全部拦截                .excludePathPatterns(&quot;/**/*.css&quot;,&quot;/**/*.js&quot;,&quot;/**/*.png&quot;,&quot;/**/*.jpg&quot;,&quot;/**/*.jpeg&quot;);    &#125;&#125;</code></pre><h2 id="2-在模板视图上显示用户数据-且登录或者未登录的情况下显示的状态栏应该不同"><a href="#2-在模板视图上显示用户数据-且登录或者未登录的情况下显示的状态栏应该不同" class="headerlink" title="2.在模板视图上显示用户数据. 且登录或者未登录的情况下显示的状态栏应该不同:"></a>2.在模板视图上显示用户数据. 且登录或者未登录的情况下显示的状态栏应该不同:</h2><pre><code class="java">@Overridepublic void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;    User user = hostHolder.getUser();    //将持有的用户数据放给视图层    if(user!=null&amp;&amp;modelAndView!=null)&#123;        modelAndView.addObject(&quot;loginUser&quot;,user);    &#125;&#125;@Overridepublic void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;    //清理用户数据    hostHolder.clear();&#125;</code></pre><p>根据登录或者未登录的状态,修改index导航栏得相关信息:</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230219182230298.png" alt="image-20230219182230298"></p><h1 id="七-账号设置"><a href="#七-账号设置" class="headerlink" title="七.账号设置"></a>七.账号设置</h1><h2 id="1-上传文件"><a href="#1-上传文件" class="headerlink" title="1.上传文件"></a>1.上传文件</h2><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230220160818386.png" alt="image-20230220160818386"></p><p>携带表单信息,所以必须得是post请求</p><p>表单中得添加属性: (上传文件的标识)</p><pre><code class="html">enctype=&quot;multipart/form-data&quot;</code></pre><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230220192958424.png" alt="image-20230220192958424"></p><p>开发步骤</p><h3 id="1-将用户上传的图像保存在服务器"><a href="#1-将用户上传的图像保存在服务器" class="headerlink" title="(1)将用户上传的图像保存在服务器:"></a>(1)将用户上传的图像保存在服务器:</h3><ul><li>检查格式</li><li>生成随机文件名</li><li>保存在指定路径</li><li>更新用户保存的头像路径</li><li>重定向到首页</li></ul><pre><code class="java">public String uploadHeaderImg(MultipartFile headerImg, Model model)&#123;    if(headerImg==null)&#123;        model.addAttribute(&quot;error&quot;,&quot;您还没有选择图片&quot;);        return &quot;/site/setting&quot;;    &#125;    String originalFilename = headerImg.getOriginalFilename();    //解析文件后缀    String suffix = originalFilename.substring(originalFilename.lastIndexOf(&quot;.&quot;)+1);    if (StringUtils.isBlank(suffix)) &#123;        model.addAttribute(&quot;error&quot;,&quot;文件的格式不正确&quot;);        return &quot;/site/setting&quot;;    &#125;    if(!(suffix.equals(&quot;png&quot;)||suffix.equals(&quot;jpg&quot;)||suffix.equals(&quot;jpeg&quot;)))&#123;        model.addAttribute(&quot;error&quot;,&quot;文件的格式不正确&quot;);        return &quot;/site/setting&quot;;    &#125;    //生成随机文件名    String filename = CommunityUtil.generateUUID() +&quot;.&quot;+ suffix;    //确定文件存放的路径    File dest=new File(uploadPath+&quot;/&quot;+filename);    try &#123;        //存储文件        headerImg.transferTo(dest);    &#125; catch (IOException e) &#123;        logger.error(&quot;上传文件失败&quot;+e.getMessage());        throw new RuntimeException(&quot;上传文件失败,服务器异常&quot;,e);    &#125;    //更新当前用户头像的路径(web路径)    User user = hostHolder.getUser();    String headerUrl=domain+contextPath+&quot;/user/header/&quot;+filename;    userService.updateHeaderImg(user.getId(),headerUrl);    return &quot;redirect:/index&quot;;&#125;</code></pre><h3 id="2-创建访问文件路径"><a href="#2-创建访问文件路径" class="headerlink" title="(2)创建访问文件路径"></a>(2)创建访问文件路径</h3><pre><code class="java">//设置头像的访问路径@RequestMapping(path = &quot;header/&#123;filename&#125;&quot;,method = RequestMethod.GET)public void getHeader(@PathVariable(&quot;filename&quot;)String filename, HttpServletResponse response)&#123;    //服务器存放的路径:    filename=uploadPath+&quot;/&quot;+filename;    //输出图片    //文件后缀    String suffix = filename.substring(filename.lastIndexOf(&quot;.&quot;)+1);    //响应图片    response.setContentType(&quot;image/&quot;+suffix);    //在try括号里的流,都会在finally里中自动关闭    try ( FileInputStream fis=new FileInputStream(filename))&#123;        OutputStream os=response.getOutputStream();        //缓冲区        byte[]buffer=new byte[1024];        int b=0;        while ((b=fis.read(buffer))!=-1)&#123;            os.write(buffer,0,b);        &#125;    &#125; catch (IOException e) &#123;        logger.error(&quot;读取头像失败&quot;+e.getMessage());    &#125;&#125;</code></pre><h2 id="2-修改密码"><a href="#2-修改密码" class="headerlink" title="2.修改密码"></a>2.修改密码</h2><pre><code class="java">//修改密码@LoginRequired@PostMapping(&quot;/updatePassword&quot;)public String updatePassword(String oldPassword,String newPassword1,String newPassword2,Model model)&#123;    //获取当前用户    User user = hostHolder.getUser();    if (StringUtils.isBlank(oldPassword)) &#123;        model.addAttribute(&quot;oldPasswordMsg&quot;,&quot;密码不能为空!&quot;);        return &quot;/site/setting&quot;;    &#125;    //若原密码不正确    if(!user.getPassword().equals(CommunityUtil.md5(oldPassword+user.getSalt())))&#123;        model.addAttribute(&quot;oldPasswordMsg&quot;,&quot;原密码错误,请重新输入!&quot;);        return &quot;/site/setting&quot;;    &#125;    //若新密码为空:    if(StringUtils.isBlank(newPassword1))&#123;        model.addAttribute(&quot;newPasswordMsg1&quot;,&quot;新密码不能为空&quot;);        return &quot;/site/setting&quot;;    &#125;    //若两次输入的密码不一致    if(!newPassword1.equals(newPassword2))&#123;        model.addAttribute(&quot;newPasswordMsg2&quot;,&quot;两次输入的密码不一致,请重新输入!&quot;);        return &quot;/site/setting&quot;;    &#125;    //若新密码和原密码一致:    if(user.getPassword().equals(CommunityUtil.md5(newPassword1+user.getSalt())))&#123;        model.addAttribute(&quot;newPasswordMsg1&quot;,&quot;新密码不能与原密码一致!&quot;);        return &quot;/site/setting&quot;;    &#125;    //加密    newPassword2=CommunityUtil.md5(newPassword2+user.getSalt());    userService.updatePassword(user.getId(),newPassword2);    return &quot;redirect:/logout&quot;;&#125;</code></pre><h1 id="八-检查登录状态"><a href="#八-检查登录状态" class="headerlink" title="八.检查登录状态"></a>八.检查登录状态</h1><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230220191030200.png" alt="image-20230220191030200"></p><p>有一些路径在未登录的状态下不允许访问,例如个人的设置页. 这种情况下虽然我们在前端隐藏了,但是还是可以通过输入访问路径的方式来得到页面,这是不安全的. 解决方法是使用拦截器.</p><p>工作中常见的除了直接指定拦截路径外,还可以指定拦截器作用的方法,通过自定义注解了来实现:</p><h2 id="1-自定义注解"><a href="#1-自定义注解" class="headerlink" title="1.自定义注解"></a>1.自定义注解</h2><pre><code class="java">/** * @author Dylan * @version 1.0 * @date 2023/2/20 19:15 * @description 用来标记哪些方法是需要拦截的 **/@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface LoginRequired &#123;&#125;</code></pre><h2 id="2-拦截器"><a href="#2-拦截器" class="headerlink" title="2.拦截器"></a>2.拦截器</h2><p>prehandle方法参数中的Object handler可以得到拦截的对象,强制转换为HandlerMethod对拦截的方法进行操作.</p><pre><code class="java">@Componentpublic class LoginRequiredInterceptor implements HandlerInterceptor &#123;    @Resource    private HostHolder hostHolder;    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;        //若拦截对象是方法        if(handler instanceof HandlerMethod)&#123;            //强转            HandlerMethod handlerMethod=(HandlerMethod)handler;            //得到方法            Method method = handlerMethod.getMethod();            //获取方法的自定义标记注解            LoginRequired loginRequired = method.getAnnotation(LoginRequired.class);            //若注解对象不为空且未处在登录状态            if(loginRequired!=null&amp;&amp;hostHolder.getUser()==null)&#123;                //重定向                response.sendRedirect(request.getContextPath()+&quot;/login&quot;);                return false;            &#125;        &#125;        return true;    &#125;&#125;</code></pre><h1 id="九-过滤敏感词"><a href="#九-过滤敏感词" class="headerlink" title="九.过滤敏感词"></a>九.过滤敏感词</h1><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230221105339374.png" alt="image-20230221105339374"></p><p>前缀树特点: </p><ul><li>根节点为空</li><li>每个节点只携带一个字符</li><li>每个节点的下一层不能有相同元素</li><li>可以快速查询检索字符串</li><li>核心思想是用空间换取时间</li></ul><h2 id="1-前缀树的定义"><a href="#1-前缀树的定义" class="headerlink" title="1.前缀树的定义"></a>1.前缀树的定义</h2><p>定义为私有内部类的方式:</p><pre><code class="java">//描述前缀树的节点private class TrieNode&#123;    //关键词结束的标识    private boolean isKeyWordEnd=false;    //当前节点的子节点(key是下级节点的字符,value是下级节点    //使用map存储    private Map&lt;Character,TrieNode&gt;subNodes=new HashMap&lt;&gt;();    //是否是关键词汇的最后一个字符    public boolean isKeyWordEnd() &#123;        return isKeyWordEnd;    &#125;    public void setKeyWordEnd(boolean keyWordEnd) &#123;        isKeyWordEnd = keyWordEnd;    &#125;    //添加子节点的方法    public void addSubNode(Character c,TrieNode node)&#123;        subNodes.put(c,node);    &#125;    //获取子节点的方法    public TrieNode getSubNode(Character c)&#123;        return subNodes.get(c);    &#125;&#125;</code></pre><h2 id="2-根据敏感词初始化前缀树"><a href="#2-根据敏感词初始化前缀树" class="headerlink" title="2.根据敏感词初始化前缀树"></a>2.根据敏感词初始化前缀树</h2><pre><code class="java">//改注解表示这是一个初始化方法,当容器初始化后,这个方法会自动被调用@PostConstructpublic void init()&#123;    //读文件的字符    try (        //类加载器读取文件流            InputStream inputStream = this.getClass().getClassLoader().getResourceAsStream(&quot;sensitive-words.txt&quot;);             BufferedReader reader=new BufferedReader(new InputStreamReader(inputStream));    ) &#123;            String keyword;            while ((keyword=reader.readLine())!=null)&#123;                //添加到前缀树                this.addKeyword(keyword);            &#125;    &#125;catch (IOException e)&#123;        logger.error(&quot;加载敏感词异常:&quot;+e.getMessage());    &#125;&#125;//将一个敏感词添加到前缀树private void addKeyword(String keyword)&#123;    TrieNode tem=root;    for (int i = 0; i &lt; keyword.length(); i++) &#123;        char c = keyword.charAt(i);        TrieNode subNode = tem.getSubNode(c);        if(tem.getSubNode(c)==null)&#123;            subNode = new TrieNode();            tem.addSubNode(c,subNode);        &#125;            tem= subNode;            //设置结束的标识            if(i==keyword.length()-1)&#123;                tem.setKeyWordEnd(true);            &#125;    &#125;&#125;</code></pre><h2 id="3-编写过滤词汇的方法"><a href="#3-编写过滤词汇的方法" class="headerlink" title="3.编写过滤词汇的方法"></a>3.编写过滤词汇的方法</h2><pre><code class="java">//实现检索敏感词的过程//过滤敏感词并返回过滤后的结果public String filter(String text)&#123;    if(StringUtils.isBlank(text))&#123;        return null;    &#125;    //指针1:指向树的节点    TrieNode tem=root;    //指针2    int begin=0;    //指针3    int end=0;    //结果    StringBuilder stringBuilder=new StringBuilder();    while (end&lt;text.length())&#123;        char c = text.charAt(end);        //跳过符号        if(isSymbol(c))&#123;            //若指针1是根节点,将该符号计入结果,让指针2向下走            if(tem==root)&#123;                stringBuilder.append(c);                begin++;            &#125;            //无论符号在开头还是中间,指针3都向下走            end++;            continue;        &#125;        //字符不是特殊字符        //检查下级节点        tem=tem.getSubNode(c);        if(tem==null)&#123;            //以begin开头的字符串不是敏感词            stringBuilder.append(c);            begin++;            end=begin;            //重新指向根节点            tem=root;        &#125;else if(!tem.isKeyWordEnd)&#123;            //该字符不是最后一个敏感字符            end++;        &#125;else&#123;            //该字符是最后一个敏感字符:            stringBuilder.append(REPLACEMENT);            end++;            begin=end;            //重新指向根节点            tem=root;        &#125;    &#125;    //将最后一批计入结果    stringBuilder.append(text.substring(begin));    return stringBuilder.toString();&#125;//判断是否为符号private boolean isSymbol(Character c)&#123;    //是特殊字符的话返回true,普通字符返回false         东亚的文字范围    return !CharUtils.isAsciiAlphanumeric(c)&amp;&amp;(c&lt;0x2E80||c&gt;0x9FFF);&#125;</code></pre><h1 id="十-发布帖子"><a href="#十-发布帖子" class="headerlink" title="十.发布帖子"></a>十.发布帖子</h1><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230221152115978.png" alt="image-20230221152115978"></p><h2 id="1-处理后端插入数据的代码"><a href="#1-处理后端插入数据的代码" class="headerlink" title="1.处理后端插入数据的代码"></a>1.处理后端插入数据的代码</h2><p>由于是插入一条帖子的字段,所以dao层的方法应该为:</p><pre><code class="java">int insertDiscussPost(DiscussPost post);</code></pre><p>mapper.xml的内容:</p><pre><code class="xml">&lt;sql id=&quot;insertFields&quot;&gt;        user_id,title,content,type,status,create_time,comment_count,score    &lt;/sql&gt;&lt;insert id=&quot;insertDiscussPost&quot; parameterType=&quot;DiscussPost&quot; keyProperty=&quot;id&quot;&gt;    insert into discuss_post(&lt;include refid=&quot;insertFields&quot;&gt;&lt;/include&gt;)    values(#&#123;userId&#125;,#&#123;title&#125;,#&#123;content&#125;,#&#123;type&#125;,#&#123;status&#125;,#&#123;createTime&#125;,#&#123;commentCount&#125;,#&#123;score&#125;)&lt;/insert&gt;</code></pre><h2 id="2-编写业务层逻辑"><a href="#2-编写业务层逻辑" class="headerlink" title="2.编写业务层逻辑"></a>2.编写业务层逻辑</h2><pre><code class="java">public int addDiscussPost(DiscussPost discussPost)&#123;    if(discussPost==null)&#123;        throw new IllegalArgumentException(&quot;参数不能为空!&quot;);    &#125;    //处理标签    //转义HTML标签(比如在标题或内容中写&lt;h1&gt;你好&lt;h1&gt;,会将大于号小于号视为普通字符而不是标签)    discussPost.setTitle(HtmlUtils.htmlEscape(discussPost.getTitle()));    discussPost.setContent(HtmlUtils.htmlEscape(discussPost.getContent()));    //过滤敏感词    discussPost.setTitle(sensitiveFilter.filter(discussPost.getTitle()));    discussPost.setContent(sensitiveFilter.filter(discussPost.getContent()));    //插入    return discussPostMapper.insertDiscussPost(discussPost);&#125;</code></pre><h2 id="3-控制层逻辑"><a href="#3-控制层逻辑" class="headerlink" title="3.控制层逻辑"></a>3.控制层逻辑</h2><p>一些简单的检查:</p><pre><code class="java">@PostMapping(&quot;/add&quot;)@ResponseBodypublic String addDiscussPost(String title,String content)&#123;    User user = holder.getUser();    if(user==null)&#123;        return CommunityUtil.getJsonString(403,&quot;您还未登录,请登录后再进行发帖&quot;);    &#125;    if(StringUtils.isBlank(title)||StringUtils.isBlank(content))&#123;        return CommunityUtil.getJsonString(1,&quot;标题或内容不能为空&quot;);    &#125;    DiscussPost post=new DiscussPost();    post.setTitle(title);    post.setUserId(user.getId());    post.setContent(content);    post.setCreateTime(new Date());    discussPostService.addDiscussPost(post);    //报错将来统一处理    return CommunityUtil.getJsonString(0,&quot;发布成功!&quot;);&#125;</code></pre><h2 id="4-利用ajax异步发送请求"><a href="#4-利用ajax异步发送请求" class="headerlink" title="4.利用ajax异步发送请求"></a>4.利用ajax异步发送请求</h2><p>前端利用ajax异步发送请求:</p><pre><code class="js">$(function()&#123;   $(&quot;#publishBtn&quot;).click(publish);&#125;);function publish() &#123;   $(&quot;#publishModal&quot;).modal(&quot;hide&quot;);   //获取标题和内容   let title=$(&quot;#recipient-name&quot;).val();   let content=$(&quot;#message-text&quot;).val();   //发送异步请求   $.post(      CONTEXT_PATH+&quot;/discuss/add&quot;,      //参数      &#123;&quot;title&quot;:title,&quot;content&quot;:content&#125;,      function (data)&#123;         data=$.parseJSON(data)         //在提示框中显示返回的消息         $(&quot;#hintBody&quot;).text(data.msg);         //显示提示框         $(&quot;#hintModal&quot;).modal(&quot;show&quot;);         //两秒后自动隐藏提示框         setTimeout(function()&#123;            $(&quot;#hintModal&quot;).modal(&quot;hide&quot;);            //成功发布刷新页面            if (data.code === 0) &#123;               window.location.reload();            &#125;         &#125;, 2000);      &#125;   )&#125;</code></pre><h1 id="十一-帖子详情"><a href="#十一-帖子详情" class="headerlink" title="十一.帖子详情"></a>十一.帖子详情</h1><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230221171350640.png" alt="image-20230221171350640"></p><h2 id="1-处理后端查询数据的代码"><a href="#1-处理后端查询数据的代码" class="headerlink" title="1.处理后端查询数据的代码:"></a>1.处理后端查询数据的代码:</h2><pre><code class="xml">&lt;select id=&quot;selectDiscussPostById&quot; resultType=&quot;DiscussPost&quot;&gt;    select &lt;include refid=&quot;selectFields&quot;&gt;&lt;/include&gt;    from discuss_post    where id=#&#123;id&#125;&lt;/select&gt;</code></pre><h2 id="2-处理业务层代码"><a href="#2-处理业务层代码" class="headerlink" title="2.处理业务层代码:"></a>2.处理业务层代码:</h2><p>直接调用</p><h2 id="3-处理控制层"><a href="#3-处理控制层" class="headerlink" title="3.处理控制层"></a>3.处理控制层</h2><p>因为查询帖子会用到用户的信息,可以有两种解决方案, </p><ul><li>一种是连表查询</li><li>第二种是根据帖子自带的用户id再查询一次user,这样效率比较低但是可以后期利用缓存.</li></ul><pre><code class="java">@GetMapping(&quot;/detail/&#123;discussPostId&#125;&quot;)public String getDiscussPost(@PathVariable(&quot;discussPostId&quot;)int id, Model model)&#123;    DiscussPost post = discussPostService.selectDiscussPostById(id);    model.addAttribute(&quot;post&quot;,post);    User user = userService.findUserById(post.getUserId());    model.addAttribute(&quot;user&quot;,user);    return &quot;/site/discuss-detail&quot;;&#125;</code></pre><h2 id="4-处理前端的逻辑"><a href="#4-处理前端的逻辑" class="headerlink" title="4.处理前端的逻辑"></a>4.处理前端的逻辑</h2><p>前端首页只需要将标题上的超链接改为帖子详情的路径:</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230221175213206.png" alt="image-20230221175213206"></p><p>但是有一个点需要注意,thymeleaf在路径有变量有常量时,不能直接字符串拼接. 而是使用| |将常量和变量括起来,然后变量自取</p><h1 id="十二-显示评论"><a href="#十二-显示评论" class="headerlink" title="十二.显示评论"></a>十二.显示评论</h1><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230223114033384.png" alt="image-20230223114033384"></p><h2 id="1-处理数据访问层"><a href="#1-处理数据访问层" class="headerlink" title="1.处理数据访问层"></a>1.处理数据访问层</h2><p>首先需要对comment表有一个细致的了解.</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230223114439016.png" alt="image-20230223114439016"></p><p>首先每个post表都有包含评论该post表的评论数量.</p><p>而comment表中的user_id是发表该评论的userId. </p><p>entity_type的字段表示评论的类型(1代表回复帖子的评论,2代表回复帖子里评论的评论)</p><p>当entity_type是1时,entity_id就是回复的主题帖子的id</p><p>当entity_type是2时,entity_id就是评论的楼主的id,无论该楼里是否有楼中楼,每个楼中楼的entity_id都是楼主的id</p><p>如果target_id不为0的话,说明该条评论是回复别人的,也就是楼中楼,那么targetId就是回复对象的id</p><p>mybatis的xml文件:</p><pre><code class="xml">&lt;sql id=&quot;selectFields&quot;&gt;    id,user_id,entity_type,entity_id,target_id,content,status,create_time&lt;/sql&gt;&lt;sql id=&quot;insertFields&quot;&gt;    user_id,entity_type,entity_id,target_id,content,status,create_time&lt;/sql&gt;&lt;select id=&quot;selectCommentByEntity&quot; resultType=&quot;Comment&quot;&gt;    select &lt;include refid=&quot;selectFields&quot;&gt;&lt;/include&gt;    from comment    where status=0    and entity_type=#&#123;entityType&#125; and entity_id=#&#123;entityId&#125;    order by create_time asc    limit #&#123;offset&#125;,#&#123;limit&#125;&lt;/select&gt;&lt;select id=&quot;selectCountByEntity&quot; resultType=&quot;int&quot;&gt;    select count(id)    from comment    where status=0    and entity_type=#&#123;entityType&#125; and entity_id=#&#123;entityId&#125;&lt;/select&gt;&lt;insert id=&quot;insertComment&quot; parameterType=&quot;comment&quot; keyProperty=&quot;id&quot;&gt;    insert into comment(&lt;include refid=&quot;insertFields&quot;&gt;&lt;/include&gt;)    values (#&#123;userId&#125;,#&#123;entityType&#125;,#&#123;entityId&#125;,#&#123;targetId&#125;,#&#123;content&#125;,#&#123;status&#125;,#&#123;createTime&#125;)&lt;/insert&gt;</code></pre><h2 id="2-业务层逻辑"><a href="#2-业务层逻辑" class="headerlink" title="2.业务层逻辑"></a>2.业务层逻辑</h2><pre><code class="java">@Resourceprivate CommentMapper commentMapper;@Resourceprivate DiscussPostService discussPostService;@Resourceprivate SensitiveFilter sensitiveFilter;public List&lt;Comment&gt;findCommentByEntity(int entityType,int entityId,int offset,int limit)&#123;    return commentMapper.selectCommentByEntity(entityType,entityId,offset,limit);&#125;public int findCommentCount(int entityType,int entityId)&#123;    return commentMapper.selectCountByEntity(entityType,entityId);&#125;/** * 添加帖子 */@Transactional(isolation = Isolation.READ_COMMITTED,propagation = Propagation.REQUIRED)public int addComment(Comment comment)&#123;    if(comment==null)&#123;        throw new IllegalArgumentException(&quot;评论不能为空&quot;);    &#125;    //过滤html标签    comment.setContent(HtmlUtils.htmlUnescape(comment.getContent()));    //过滤敏感词    comment.setContent(sensitiveFilter.filter(comment.getContent()));    //添加评论    int rows = commentMapper.insertComment(comment);    //更新回复给帖子的评论数量    if(comment.getEntityType()==ENTITY_TYPE_POST)&#123;        //        int count = commentMapper.selectCountByEntity(comment.getEntityType(), comment.getEntityId());        discussPostService.updateCommentCount(comment.getEntityId(),count);    &#125;    return rows;&#125;</code></pre><h2 id="3-控制层-评论详情"><a href="#3-控制层-评论详情" class="headerlink" title="3.控制层,评论详情"></a>3.控制层,评论详情</h2><pre><code class="java">@GetMapping(&quot;/detail/&#123;discussPostId&#125;&quot;)public String getDiscussPost(@PathVariable(&quot;discussPostId&quot;)int id, Model model, Page page)&#123;    //帖子    DiscussPost post = discussPostService.selectDiscussPostById(id);    model.addAttribute(&quot;post&quot;,post);    //作者    User user = userService.findUserById(post.getUserId());    model.addAttribute(&quot;user&quot;,user);    //评论的分页信息    page.setLimit(5);    page.setPath(&quot;/discuss/detail/&quot;+id);    //单个帖子的评论总数    page.setRows(post.getCommentCount());    //给帖子的评论:评论    //给评论的评论:回复    List&lt;Comment&gt; commentList =            commentService.findCommentByEntity(ENTITY_TYPE_POST, post.getId(), page.getOffset(), page.getLimit());    //评论的列表    List&lt;Map&lt;String,Object&gt;&gt;commentVoList=new ArrayList&lt;&gt;();    if(commentList!=null&amp;&amp;!commentList.isEmpty())&#123;        for (Comment comment : commentList) &#123;            //一个评论的vo            Map&lt;String,Object&gt;commentVo=new HashMap&lt;&gt;();            //评论            commentVo.put(&quot;comment&quot;,comment);            //评论的作者            commentVo.put(&quot;user&quot;,userService.findUserById(comment.getUserId()));            //查询回复列表            List&lt;Comment&gt; replyList =                    commentService.findCommentByEntity(ENTITY_TYPE_COMMENT, comment.getId(), 0, Integer.MAX_VALUE);            //回复VO列表            List&lt;Map&lt;String,Object&gt;&gt;replyVoList=new ArrayList&lt;&gt;();            if(replyList!=null)&#123;                for (Comment reply : replyList) &#123;                    Map&lt;String,Object&gt;replyVo=new HashMap&lt;&gt;();                    //存回复:                    replyVo.put(&quot;reply&quot;,reply);                    replyVo.put(&quot;user&quot;,userService.findUserById(reply.getUserId()));                    //回复的目标                    if(reply.getTargetId()!=0)&#123;                        User target = userService.findUserById(reply.getTargetId());                        replyVo.put(&quot;target&quot;,target);                    &#125;else&#123;                        replyVo.put(&quot;target&quot;,null);                    &#125;                    replyVoList.add(replyVo);                &#125;            &#125;            commentVo.put(&quot;replys&quot;,replyVoList);            //回复的数量            int commentCount = commentService.findCommentCount(ENTITY_TYPE_COMMENT, comment.getId());            commentVo.put(&quot;replyCount&quot;,commentCount);            commentVoList.add(commentVo);        &#125;        model.addAttribute(&quot;comments&quot;,commentVoList);    &#125;    return &quot;/site/discuss-detail&quot;;&#125;</code></pre><h2 id="4-前端页面"><a href="#4-前端页面" class="headerlink" title="4.前端页面"></a>4.前端页面</h2><p>注意一个点</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230223120650954.png" alt="image-20230223120650954"></p><p>当需要知道循环次数时,往往需要在别名后面加上Stat如rvoStat再取count就为当时处在第几次循环</p><h1 id="十三-添加评论"><a href="#十三-添加评论" class="headerlink" title="十三.添加评论"></a>十三.添加评论</h1><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230223114101675.png" alt="image-20230223114101675"></p><h2 id="1-业务层"><a href="#1-业务层" class="headerlink" title="1.业务层"></a>1.业务层</h2><p>因为添加帖子时,会影响到另外一张表discuss_post的数据. 所以我们要使用到spring为我们提供的事务管理方法;</p><p>在本次方法上就使用注解的方式进行事务管理</p><pre><code class="java">/** * 添加帖子 */@Transactional(isolation = Isolation.READ_COMMITTED,propagation = Propagation.REQUIRED)public int addComment(Comment comment)&#123;    if(comment==null)&#123;        throw new IllegalArgumentException(&quot;评论不能为空&quot;);    &#125;    //过滤html标签    comment.setContent(HtmlUtils.htmlUnescape(comment.getContent()));    //过滤敏感词    comment.setContent(sensitiveFilter.filter(comment.getContent()));    //添加评论      int rows = commentMapper.insertComment(comment);    //更新回复给帖子的评论数量    if(comment.getEntityType()==ENTITY_TYPE_POST)&#123;        //        int count = commentMapper.selectCountByEntity(comment.getEntityType(), comment.getEntityId());        discussPostService.updateCommentCount(comment.getEntityId(),count);    &#125;    return rows;&#125;</code></pre><h2 id="2-控制层"><a href="#2-控制层" class="headerlink" title="2.控制层"></a>2.控制层</h2><pre><code class="java">@Controller@RequestMapping(&quot;/comment&quot;)public class CommentController &#123;    @Resource    private CommentService commentService;    @Resource    private HostHolder holder;    @RequestMapping(path = &quot;/add/&#123;discussPostId&#125;&quot;,method = RequestMethod.POST)    public String addComment(@PathVariable(&quot;discussPostId&quot;)int discussPostId, Comment comment)&#123;        if(comment.getContent()==null||&quot;&quot;.equals(comment.getContent()))&#123;            return &quot;redirect:/discuss/detail&quot;+discussPostId;        &#125;         comment.setUserId(holder.getUser().getId());         comment.setStatus(0);         comment.setCreateTime(new Date());         commentService.addComment(comment);        return &quot;redirect:/discuss/detail/&quot;+discussPostId;    &#125;&#125;</code></pre><h1 id="十四-私信列表"><a href="#十四-私信列表" class="headerlink" title="十四.私信列表"></a>十四.私信列表</h1><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230223114155129.png" alt="image-20230223114155129"></p><h2 id="1-数据访问层"><a href="#1-数据访问层" class="headerlink" title="1.数据访问层"></a>1.数据访问层</h2><p>message的表结构:</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230223121834387.png" alt="image-20230223121834387"></p><p>xml文件:</p><pre><code class="xml">&lt;sql id=&quot;selectFields&quot;&gt;    id,from_id,to_id,conversation_id,content,status,create_time&lt;/sql&gt;&lt;select id=&quot;selectConversations&quot; resultType=&quot;message&quot;&gt;    select &lt;include refid=&quot;selectFields&quot;&gt;&lt;/include&gt;    from message where id in(        select max(id) from message        where status!=2        and `from_id`!=1        and (from_id=#&#123;userId&#125; or to_id=#&#123;userId&#125;)        GROUP BY conversation_id    )    order by id desc    limit #&#123;offset&#125;,#&#123;limit&#125;&lt;/select&gt;&lt;select id=&quot;selectConversationCount&quot; resultType=&quot;int&quot;&gt;    SELECT count(*) from        (            select count(id) from message            where status!=2 and from_id!=1         and (from_id=#&#123;userId&#125; or to_id=#&#123;userId&#125;)            group by conversation_id        )a&lt;/select&gt;&lt;select id=&quot;selectLetters&quot; resultType=&quot;message&quot;&gt;    select &lt;include refid=&quot;selectFields&quot;&gt;&lt;/include&gt;    from message    where status!=2 and from_id!=1 and conversation_id=#&#123;conversationId&#125;    order by id desc    limit #&#123;offset&#125;,#&#123;limit&#125;&lt;/select&gt;&lt;select id=&quot;selectLetterCount&quot; resultType=&quot;int&quot;&gt;    select count(id) from message    where status!=2 and from_id!=1 and conversation_id=#&#123;conversationId&#125;&lt;/select&gt;&lt;select id=&quot;selectUnReadLetterCount&quot; resultType=&quot;int&quot;&gt;    select count(id) from message    where status=0 and `from_id`!=1 and to_id=#&#123;userId&#125;    &lt;if test=&quot;conversationId!=null&quot;&gt;        and conversation_id=#&#123;conversationId&#125;    &lt;/if&gt;&lt;/select&gt;</code></pre><h2 id="2-控制层-1"><a href="#2-控制层-1" class="headerlink" title="2.控制层"></a>2.控制层</h2><pre><code class="java">//用户的私信列表@RequestMapping(path = &quot;/letter/list&quot;,method = RequestMethod.GET)public String getLetterList(Model model, Page page)&#123;    //配置分页信息    User user = holder.getUser();    page.setLimit(5);    page.setPath(&quot;/letter/list&quot;);    page.setRows(messageService.findConversationCount(user.getId()));        List&lt;Message&gt; conversations = messageService.findConversations(user.getId(), page.getOffset(), page.getLimit());    List&lt;Map&lt;String,Object&gt;&gt;conversationList=new ArrayList&lt;&gt;();    if (conversations!=null) &#123;        for (Message conversation : conversations) &#123;            Map&lt;String,Object&gt;map=new HashMap&lt;&gt;();            map.put(&quot;conversation&quot;,conversation);            //用户未读消息数量            map.put(&quot;unreadCount&quot;,messageService.findUnreadLetter(user.getId(), conversation.getConversationId()));            //某一条会话的消息数量            map.put(&quot;letterCount&quot;,messageService.findLetterCount(conversation.getConversationId()));            int targetId=user.getId()==conversation.getFromId()?conversation.getToId():conversation.getFromId();            map.put(&quot;target&quot;,userService.findUserById(targetId));            conversationList.add(map);        &#125;    &#125;    model.addAttribute(&quot;conversations&quot;,conversationList);    //总共的未读数量    int unreadLetterTotal = messageService.findUnreadLetter(user.getId(), null);    model.addAttribute(&quot;unreadLetterTotal&quot;,unreadLetterTotal);    return &quot;/site/letter&quot;;&#125;//用户某一条私信的具体详情@GetMapping(&quot;/letter/detail/&#123;conversationId&#125;&quot;)public String getLetterDetail(@PathVariable(&quot;conversationId&quot;)String conversationId,Page page,Model model)&#123;    page.setLimit(5);    page.setPath(&quot;/letter/detail/&quot;+conversationId);    page.setRows(messageService.findLetterCount(conversationId));    //私信具体列表    List&lt;Message&gt; letterList = messageService.findLetters(conversationId, page.getOffset(), page.getLimit());    List&lt;Map&lt;String,Object&gt;&gt;letters=new ArrayList&lt;&gt;();    if(letterList!=null)&#123;        for (Message message : letterList) &#123;            Map&lt;String,Object&gt;map=new HashMap&lt;&gt;();            map.put(&quot;letter&quot;,message);            map.put(&quot;fromUser&quot;,userService.findUserById(message.getFromId()));            letters.add(map);        &#125;    &#125;    model.addAttribute(&quot;letters&quot;,letters);    model.addAttribute(&quot;target&quot;,targetUser(conversationId));    return &quot;/site/letter-detail&quot;;&#125;//分解conversationIdprivate User targetUser(String conversationId)&#123;    String[] strings = conversationId.split(&quot;_&quot;);    int id1=Integer.parseInt(strings[0]);    int id2=Integer.parseInt(strings[1]);    if(holder.getUser().getId()==id1)&#123;        return userService.findUserById(id2);    &#125;else&#123;        return userService.findUserById(id1);    &#125;&#125;</code></pre><h1 id="十五-发送私信"><a href="#十五-发送私信" class="headerlink" title="十五.发送私信"></a>十五.发送私信</h1><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230223122150688.png" alt="image-20230223122150688"></p><h2 id="1-数据层"><a href="#1-数据层" class="headerlink" title="1.数据层"></a>1.数据层</h2><p>发送私信主要操作的是message表</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230224124209233.png" alt="image-20230224124209233"></p><p>status为1代表消息已读,status为2代表消息被删除</p><p>status为0代表消息未读</p><p>发送消息和读取消息主要涉及到消息的插入和更新(主要更新的是status的值)</p><p>而每个消息框都要显示最新的消息内容,因为id是自动增长的,所以我们不用通过操作时间的方式来显示查询最新消息,只要获取id最大的message字段就行</p><pre><code class="xml">&lt;select id=&quot;selectConversations&quot; resultType=&quot;message&quot;&gt;    select &lt;include refid=&quot;selectFields&quot;&gt;&lt;/include&gt;    from message where id in(        select max(id) from message        where status!=2        and `from_id`!=1        and (from_id=#&#123;userId&#125; or to_id=#&#123;userId&#125;)        GROUP BY conversation_id    )    order by id desc    limit #&#123;offset&#125;,#&#123;limit&#125;&lt;/select&gt;&lt;select id=&quot;selectConversationCount&quot; resultType=&quot;int&quot;&gt;    SELECT count(*) from        (            select count(id) from message            where status!=2 and from_id!=1         and (from_id=#&#123;userId&#125; or to_id=#&#123;userId&#125;)            group by conversation_id        )a&lt;/select&gt;&lt;select id=&quot;selectLetters&quot; resultType=&quot;message&quot;&gt;    select &lt;include refid=&quot;selectFields&quot;&gt;&lt;/include&gt;    from message    where status!=2 and from_id!=1 and conversation_id=#&#123;conversationId&#125;    order by id desc    limit #&#123;offset&#125;,#&#123;limit&#125;&lt;/select&gt;&lt;select id=&quot;selectLetterCount&quot; resultType=&quot;int&quot;&gt;    select count(id) from message    where status!=2 and from_id!=1 and conversation_id=#&#123;conversationId&#125;&lt;/select&gt;&lt;select id=&quot;selectUnReadLetterCount&quot; resultType=&quot;int&quot;&gt;    select count(id) from message    where status=0 and `from_id`!=1 and to_id=#&#123;userId&#125;    &lt;if test=&quot;conversationId!=null&quot;&gt;        and conversation_id=#&#123;conversationId&#125;    &lt;/if&gt;&lt;/select&gt;&lt;insert id=&quot;insertMessage&quot; keyProperty=&quot;id&quot; parameterType=&quot;message&quot;&gt;    insert into message (&lt;include refid=&quot;insertFields&quot;&gt;&lt;/include&gt;)    values (#&#123;fromId&#125;,#&#123;toId&#125;,#&#123;conversationId&#125;,#&#123;content&#125;,#&#123;status&#125;,#&#123;createTime&#125;)&lt;/insert&gt;&lt;update id=&quot;updateStatus&quot;&gt;    update message set status=#&#123;status&#125;    where id in    &lt;foreach collection=&quot;ids&quot; item=&quot;id&quot; open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot;&gt;        #&#123;id&#125;    &lt;/foreach&gt;&lt;/update&gt;</code></pre><h2 id="2-业务层"><a href="#2-业务层" class="headerlink" title="2.业务层"></a>2.业务层</h2><p>业务层有一点需要注意的是,当点进某个具体的消息会话内时,to_id为点进去的用户的id的所有未读消息的状态都要被设置为已读</p><h2 id="3-控制层"><a href="#3-控制层" class="headerlink" title="3.控制层"></a>3.控制层</h2><pre><code class="java">    //用户某一条私信的具体详情    @GetMapping(&quot;/letter/detail/&#123;conversationId&#125;&quot;)    public String getLetterDetail(@PathVariable(&quot;conversationId&quot;)String conversationId,Page page,Model model)&#123;        page.setLimit(5);        page.setPath(&quot;/letter/detail/&quot;+conversationId);        page.setRows(messageService.findLetterCount(conversationId));        //私信具体列表        List&lt;Message&gt; letterList = messageService.findLetters(conversationId, page.getOffset(), page.getLimit());        List&lt;Map&lt;String,Object&gt;&gt;letters=new ArrayList&lt;&gt;();        if(letterList!=null)&#123;            for (Message message : letterList) &#123;                Map&lt;String,Object&gt;map=new HashMap&lt;&gt;();                map.put(&quot;letter&quot;,message);                map.put(&quot;fromUser&quot;,userService.findUserById(message.getFromId()));                letters.add(map);            &#125;        &#125;        model.addAttribute(&quot;letters&quot;,letters);        model.addAttribute(&quot;target&quot;,targetUser(conversationId));        //设置已读        List&lt;Integer&gt;ids=getLetterIds(letterList);        if(!ids.isEmpty())&#123;             messageService.readMessage(ids);        &#125;        return &quot;/site/letter-detail&quot;;    &#125;//得到集合中未读的消息的idprivate List&lt;Integer&gt; getLetterIds(List&lt;Message&gt;letterList)&#123;    List&lt;Integer&gt;ids=new ArrayList&lt;&gt;();    if (letterList!=null) &#123;        for (Message message : letterList) &#123;            //当前用户是否是接受者            if(holder.getUser().getId()==message.getToId()&amp;&amp;message.getStatus()==0)&#123;                ids.add(message.getId());            &#125;        &#125;    &#125;    return ids;&#125;//分解conversationIdprivate User targetUser(String conversationId)&#123;    String[] strings = conversationId.split(&quot;_&quot;);    int id1=Integer.parseInt(strings[0]);    int id2=Integer.parseInt(strings[1]);    if(holder.getUser().getId()==id1)&#123;        return userService.findUserById(id2);    &#125;else&#123;        return userService.findUserById(id1);    &#125;&#125;//异步请求@RequestMapping(path = &quot;/letter/send&quot;,method = RequestMethod.POST)@ResponseBodypublic String sendLetter(String toName,String content)&#123;    User target = userService.findUserByName(toName);    if(target==null)&#123;        return CommunityUtil.getJsonString(1,&quot;目标用户不存在&quot;);    &#125;    Message message=new Message();    message.setFromId(holder.getUser().getId());    message.setToId(target.getId());    message.setContent(content);    if (message.getFromId()&lt;message.getToId()) &#123;        message.setConversationId(message.getFromId()+&quot;_&quot;+message.getToId());    &#125;else&#123;        message.setConversationId(message.getToId()+&quot;_&quot;+message.getFromId());    &#125;    message.setStatus(0);    message.setCreateTime(new Date());    messageService.addMessage(message);    return CommunityUtil.getJsonString(0);&#125;</code></pre><h2 id="4-前端"><a href="#4-前端" class="headerlink" title="4.前端"></a>4.前端</h2><pre><code class="javascript">$(function()&#123;   $(&quot;#sendBtn&quot;).click(send_letter);   $(&quot;.close&quot;).click(delete_msg);&#125;);function send_letter() &#123;   $(&quot;#sendModal&quot;).modal(&quot;hide&quot;);   let toName=$(&quot;#recipient-name&quot;).val();   let content=$(&quot;#message-text&quot;).val();   $.post(      CONTEXT_PATH+&quot;/letter/send&quot;,      &#123;&quot;toName&quot;:toName,&quot;content&quot;:content&#125;,      function (data)&#123;         data=$.parseJSON(data);         if(data.code===0)&#123;            $(&quot;#hintBody&quot;).text(&quot;发送成功&quot;)         &#125;else&#123;            $(&quot;#hintBody&quot;).text(data.msg)         &#125;         $(&quot;#hintModal&quot;).modal(&quot;show&quot;);         setTimeout(function()&#123;            $(&quot;#hintModal&quot;).modal(&quot;hide&quot;);            location.reload();         &#125;, 2000);      &#125;   )&#125;</code></pre><h1 id="十六-统一处理异常"><a href="#十六-统一处理异常" class="headerlink" title="十六.统一处理异常"></a>十六.统一处理异常</h1><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230223133010699.png" alt="image-20230223133010699"></p><p>advice包下:</p><pre><code class="java">//扫描带有controller的bean@ControllerAdvice(annotations = Controller.class)public class ExceptionAdvice &#123;    private static final Logger logger= LoggerFactory.getLogger(ExceptionAdvice.class);    @ExceptionHandler(&#123;Exception.class&#125;)    public void handleException(Exception e, HttpServletRequest request, HttpServletResponse response) throws IOException &#123;        logger.error(&quot;服务器发生异常:&quot;+e.getMessage());        for (StackTraceElement stackTraceElement : e.getStackTrace()) &#123;            logger.error(stackTraceElement.toString());        &#125;        //获取请求方式        String xRequestedWith = request.getHeader(&quot;x-requested-with&quot;);        //该请求是异步请求,返回json        if (&quot;XMLHttpRequest&quot;.equals(xRequestedWith))&#123;            //设置响应格式为普通文本            response.setContentType(&quot;application/plain;charset=utf-8&quot;);            PrintWriter writer=response.getWriter();            writer.write(CommunityUtil.getJsonString(1,&quot;服务器异常&quot;));        &#125;else &#123;            //普通请求            //普通请求直接重定向到error界面            response.sendRedirect(request.getContextPath()+&quot;/error&quot;);        &#125;    &#125;&#125;</code></pre><h1 id="十七-统一记录日志"><a href="#十七-统一记录日志" class="headerlink" title="十七.统一记录日志"></a>十七.统一记录日志</h1><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230223141027338.png" alt="image-20230223141027338"></p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230223141318952.png" alt="image-20230223141318952"></p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230223141734679.png" alt="image-20230223141734679"></p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230223142344480.png" alt="image-20230223142344480"></p><h2 id="引入jar包-编写织入程序"><a href="#引入jar包-编写织入程序" class="headerlink" title="引入jar包,编写织入程序:"></a>引入jar包,编写织入程序:</h2><pre><code class="xml">&lt;!--aspect--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>aspect包下:</p><pre><code class="java">@Component@Aspectpublic class ServiceLogAspect &#123;    private static final Logger logger= LoggerFactory.getLogger(ServiceLogAspect.class);    //织入到service上的方法    @Pointcut(&quot;execution(* com.newcode.community.service.*.*(..))&quot;)    public void pointcut()&#123;    &#125;    @Before(&quot;pointcut()&quot;)    public void before(JoinPoint point)&#123;        //用户(ip)+在[时间],访问了[com.newcode.community.service.xxx()]        ServletRequestAttributes requestAttributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();        HttpServletRequest request = requestAttributes.getRequest();        //获取ip        String ip = request.getRemoteHost();        String date = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;).format(new Date());        //类名+方法名        String target = point.getSignature().getDeclaringTypeName() + &quot;.&quot; + point.getSignature().getName();        logger.info(String.format(&quot;用户[%s]在[%s]访问了[%s].&quot;,ip,date,target));    &#125;&#125;</code></pre><h1 id="十八-springboot整合redis"><a href="#十八-springboot整合redis" class="headerlink" title="十八.springboot整合redis"></a>十八.springboot整合redis</h1><p>​<img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230223151757059.png" alt="image-20230223151757059"></p><h2 id="1-引入redis"><a href="#1-引入redis" class="headerlink" title="1.引入redis:"></a>1.引入redis:</h2><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><h2 id="2-重新装配redisTemplate"><a href="#2-重新装配redisTemplate" class="headerlink" title="2.重新装配redisTemplate"></a>2.重新装配redisTemplate</h2><pre><code class="java">@Configurationpublic class redisConfig &#123;    @Bean    @SuppressWarnings(&quot;all&quot;)    public RedisTemplate&lt;String,Object&gt;redisTemplate(RedisConnectionFactory factory)&#123;        RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;();        template.setConnectionFactory(factory);        //设置key的序列化方式        template.setKeySerializer(RedisSerializer.string());        //设置value的序列化方式        template.setValueSerializer(RedisSerializer.json());        //设置hash的key的序列化方式        template.setHashKeySerializer(RedisSerializer.string());        //设置hash的value的序列化方式        template.setHashValueSerializer(RedisSerializer.json());        template.afterPropertiesSet();        return template;    &#125;&#125;</code></pre><h2 id="3-配置配置文件"><a href="#3-配置配置文件" class="headerlink" title="3.配置配置文件"></a>3.配置配置文件</h2><pre><code class="properties">#redis#library indexspring.redis.database=11spring.redis.host=43.143.232.99spring.redis.password=*****spring.redis.port=6379</code></pre><h2 id="4-测试"><a href="#4-测试" class="headerlink" title="4.测试"></a>4.测试</h2><pre><code class="java">@SpringBootTest@ContextConfiguration(classes = NewCodeApplication.class)@RunWith(SpringRunner.class)public class redisTest &#123;    @Resource    private RedisTemplate redisTemplate;    @Resource    private StringRedisTemplate stringRedisTemplate;    @Test    public void test()&#123;        //String redisKey=&quot;test:count&quot;;        //redisTemplate.opsForValue().set(redisKey,1);        //System.out.println(redisTemplate.opsForValue().get(redisKey));        //        //System.out.println(redisTemplate.opsForValue().increment(redisKey));        //System.out.println(redisTemplate.opsForValue().decrement(redisKey));        String testHash=&quot;test:hash1&quot;;        redisTemplate.opsForHash().put(testHash,&quot;id&quot;,1);        redisTemplate.opsForHash().put(testHash,&quot;username&quot;,&quot;张三&quot;);        redisTemplate.opsForHash().get(testHash,&quot;username&quot;);    &#125;    //编程式事务    @Test    public void testTransactional()&#123;        Object execute = redisTemplate.execute(new SessionCallback() &#123;            @Override            public Object execute(RedisOperations operations) throws DataAccessException &#123;                String redisKey = &quot;test:tx&quot;;                operations.multi();                operations.opsForSet().add(redisKey, &quot;张三&quot;);                operations.opsForSet().add(redisKey, &quot;李四&quot;);                operations.opsForSet().add(redisKey, &quot;王五&quot;);                System.out.println(operations.opsForSet().members(redisKey));                return operations.exec();            &#125;        &#125;);        System.out.println(execute);    &#125;    //多次对一个key操作    @Test    public void testBound()&#123;        String redisKey=&quot;test:bound1&quot;;        redisTemplate.opsForValue().set(redisKey,1);        BoundValueOperations operations=redisTemplate.boundValueOps(redisKey);        operations.increment();        operations.increment();        operations.increment();    &#125;    @Test    public void test1()&#123;        stringRedisTemplate.opsForValue().set(&quot;test:count1&quot;,&quot;2&quot;);    &#125;&#125;</code></pre><h1 id="十九-点赞"><a href="#十九-点赞" class="headerlink" title="十九.点赞"></a>十九.点赞</h1><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230223155524642.png" alt="image-20230223155524642"></p><p>点赞或者取消点赞:</p><p>实现的逻辑是利用Redis的set数据结构, 点赞的数量统计为该结构内点赞用户id的数量,取消点赞就直接将用户id去除,判断是否点赞直接判断用户id是否在set内即可:</p><h2 id="1-业务层-1"><a href="#1-业务层-1" class="headerlink" title="1.业务层"></a>1.业务层</h2><pre><code class="java">/** *点赞法则: * 帖子的赞的entityType为1 * 回复或者楼中楼的entityType为2 *///点赞public void like(int userId,int entityType,int entityId)&#123;    String entityLikeKey= redisKeyUtil.getEntityLike(entityType,entityId);    //判断用户是否已经点过赞    Boolean isMember = redisTemplate.opsForSet().isMember(entityLikeKey, userId);    if(isMember)&#123;        //取消赞        redisTemplate.opsForSet().remove(entityLikeKey,userId);    &#125;else&#123;        redisTemplate.opsForSet().add(entityLikeKey,userId);    &#125;&#125;//点赞数量public long findEntityLikeCount(int entityType,int entityId)&#123;    String entityLikeKey= redisKeyUtil.getEntityLike(entityType,entityId);    return redisTemplate.opsForSet().size(entityLikeKey);&#125;//查询某人对某实体有没有点过赞//public int findEntityLikeStatus(int userId,int entityType,int entityId)&#123;    String entityLikeKey= redisKeyUtil.getEntityLike(entityType,entityId);    //1已经点赞,0未点赞    return redisTemplate.opsForSet().isMember(entityLikeKey,userId)?1:0;&#125;</code></pre><h2 id="2-控制层-2"><a href="#2-控制层-2" class="headerlink" title="2.控制层"></a>2.控制层</h2><pre><code class="java">@Controllerpublic class LikeController &#123;    @Resource    private LikeService likeService;    @Resource    private HostHolder holder;    @PostMapping(&quot;/like&quot;)    @ResponseBody    public String like(int entityType,int entityId)&#123;        User user = holder.getUser();        //点赞        likeService.like(user.getId(),entityType,entityId);        //点赞的数量        long count = likeService.findEntityLikeCount(entityType, entityId);        //点赞的数量        int entityLikeStatus = likeService.findEntityLikeStatus(user.getId(), entityType, entityId);        Map&lt;String,Object&gt;map=new HashMap&lt;&gt;();        map.put(&quot;likeCount&quot;,count);        map.put(&quot;status&quot;,entityLikeStatus);        return CommunityUtil.getJsonString(0,null,map);    &#125;&#125;</code></pre><h2 id="3-前端"><a href="#3-前端" class="headerlink" title="3.前端"></a>3.前端</h2><p>前端通过ajax异步发送请求实现点赞&#x2F;取消点赞效果</p><pre><code class="js">function like(btn,entityType,entityId)&#123;    $.post(        CONTEXT_PATH+&quot;/like&quot;,        &#123;&quot;entityType&quot;:entityType,&quot;entityId&quot;:entityId&#125;,        function (data)&#123;            data=$.parseJSON(data);            if(data.code===0)&#123;                $(btn).children(&quot;i&quot;).text(data.likeCount)                $(btn).children(&quot;b&quot;).text(data.status===1?&#39;已赞&#39;:&#39;赞&#39;)            &#125;else&#123;                alert(data.msg)            &#125;        &#125;    )&#125;</code></pre><h1 id="二十-我收到的赞"><a href="#二十-我收到的赞" class="headerlink" title="二十.我收到的赞"></a>二十.我收到的赞</h1><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230224131207299.png" alt="image-20230224131207299"></p><p>重构点赞功能,增加以用户id构建的key:</p><pre><code class="java">//点赞public void like(int userId,int entityType,int entityId,int entityUserId)&#123;    redisTemplate.execute(new SessionCallback() &#123;        @Override        public Object execute(RedisOperations operations) throws DataAccessException &#123;            //实体获得的赞            String entityLikeKey= redisKeyUtil.getEntityLike(entityType,entityId);            //用户总共获得的赞            String userLikeKey = redisKeyUtil.getUserLikeKey(entityUserId);            Boolean isMember = operations.opsForSet().isMember(entityLikeKey, userId);            //开启事务            operations.multi();            if(isMember)&#123;                operations.opsForSet().remove(entityLikeKey,userId);                operations.opsForValue().decrement(userLikeKey);            &#125;else&#123;                operations.opsForSet().add(entityLikeKey,userId);                operations.opsForValue().increment(userLikeKey);            &#125;                    //执行事务            return operations.exec();        &#125;    &#125;);&#125;//某个用户总共获得的数量public int findUserLikeCount(int userId)&#123;    String userLikeKey = redisKeyUtil.getUserLikeKey(userId);    Integer count = (Integer) redisTemplate.opsForValue().get(userLikeKey);    return count==null?0:count;&#125;//帖子或者回复的点赞数量public long findEntityLikeCount(int entityType,int entityId)&#123;    String entityLikeKey= redisKeyUtil.getEntityLike(entityType,entityId);    return redisTemplate.opsForSet().size(entityLikeKey);&#125;//查询某人对某实体有没有点过赞public int findEntityLikeStatus(int userId,int entityType,int entityId)&#123;    String entityLikeKey= redisKeyUtil.getEntityLike(entityType,entityId);    //1已经点赞,0未点赞    return redisTemplate.opsForSet().isMember(entityLikeKey,userId)?1:0;&#125;</code></pre><h1 id="二十一-关注-取消关注-关注列表-粉丝列表"><a href="#二十一-关注-取消关注-关注列表-粉丝列表" class="headerlink" title="二十一.关注&#x2F;取消关注 关注列表&#x2F;粉丝列表"></a>二十一.关注&#x2F;取消关注 关注列表&#x2F;粉丝列表</h1><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230224141844224.png" alt="image-20230224141844224"></p><p>本项目的粉丝列表只针对用户,但是帖子也可以调用该功能(用在帖子上就为收藏该帖子的用户)</p><h2 id="1-key的设计"><a href="#1-key的设计" class="headerlink" title="1.key的设计"></a>1.key的设计</h2><pre><code class="java">/** * 关注的行为只能发生在用户身上,但是关注的对象可以是其他用户或者帖子(关注帖子默认为收藏帖子) * 帖子实体type为1,用户实体为3 *///某个用户关注的实体(关注了谁)            实体的id   关注的时间//      用户的id    关注的实体类型---&gt;zset(entityId,nowDate)//followee:userId:entityTypepublic static String getFolloweeKey(int userId,int entityType)&#123;    return PREFIX_FOLLOWEE+SPLIT+userId+SPLIT+entityType;&#125;//某个实体的关注者,粉丝(谁关注了我)//follower:entityId:entityType----&gt;zset(userId,nowdate)public static String getFollowerKey(int entityId,int entityType)&#123;    return PREFIX_FOLLOWER+SPLIT+entityId+SPLIT+entityType;&#125;//验证码的keypublic static String getKaptchaKey(String owner)&#123;    return PREFIX_KAPTCHA+SPLIT+owner;&#125;//登录凭证public static String getTicketKey(String ticket)&#123;    return PREFIX_TICKET+SPLIT+ticket;&#125;public static String getUserKey(int userId)&#123;    return PREFIX_User+SPLIT+userId;&#125;</code></pre><h2 id="2-业务层-1"><a href="#2-业务层-1" class="headerlink" title="2.业务层"></a>2.业务层</h2><p>使用redis的sorted-set结构, 按照一定的分数对元素进行排序</p><ul><li>由于关注时间也要传到前端,</li></ul><pre><code class="java">//关注某个实体public void follow(int userId,int entityId,int entityType)&#123;    redisTemplate.execute(new SessionCallback() &#123;        @Override        public Object execute(RedisOperations operations) throws DataAccessException &#123;            //被哪些用户关注的key            String followerKey = redisKeyUtil.getFollowerKey(entityId, entityType);            //关注了哪些实体key            String followeeKey = redisKeyUtil.getFolloweeKey(userId, entityType);            //redis进入事务            operations.multi();            //将自己的id添加到被哪些用户关注的key            operations.opsForZSet().add(followerKey,userId,System.currentTimeMillis());            //将该实体添加到自己的关注列表            operations.opsForZSet().add(followeeKey,entityId,System.currentTimeMillis());            //提交事务            return operations.exec();        &#125;    &#125;);&#125;//取消关注public void unfollow(int userId,int entityId,int entityType)&#123;    redisTemplate.execute(new SessionCallback() &#123;        @Override        public Object execute(RedisOperations operations) throws DataAccessException &#123;            //被哪些用户关注的key            String followerKey = redisKeyUtil.getFollowerKey(entityId, entityType);            //关注了哪些实体key            String followeeKey = redisKeyUtil.getFolloweeKey(userId, entityType);            operations.multi();            //将自己的id从到被哪些用户关注的key中删除            operations.opsForZSet().remove(followerKey,userId);            //将该实体从到自己的关注列表删除            operations.opsForZSet().remove(followeeKey,entityId);            return operations.exec();        &#125;    &#125;);&#125;//查询某个用户关注实体的数量public long findFolloweeCount(int userId,int entityType)&#123;    String followeeKey = redisKeyUtil.getFolloweeKey(userId, entityType);    return redisTemplate.opsForZSet().zCard(followeeKey);&#125;//查询用户的关注public List&lt;Map&lt;String,Object&gt;&gt;getFollowees(int entityType, int userId,int offset,int limit)&#123;    String followerKey = redisKeyUtil.getFolloweeKey(userId, entityType);    //获得所有有序集合内的元素按照分数从高到低排序    Set&lt;Integer&gt; targetSet = redisTemplate.opsForZSet().reverseRange(followerKey, offset, limit + limit - 1);    if(targetSet==null)&#123;        return null;    &#125;    List&lt;Map&lt;String,Object&gt;&gt;list=new ArrayList&lt;&gt;();    for (Integer targetId : targetSet) &#123;        Map&lt;String,Object&gt;map=new HashMap&lt;&gt;();        //粉丝实体        User user = userService.findUserById(targetId);        map.put(&quot;user&quot;,user);        //关注时间        Double score = redisTemplate.opsForZSet().score(followerKey, targetId);        map.put(&quot;followTime&quot;,new Date(score.longValue()));        list.add(map);    &#125;    return list;&#125;//查询某个实体的粉丝数量public long findFollowerCount(int entityType,int entityId)&#123;    String followerKey = redisKeyUtil.getFollowerKey(entityId, entityType);    //zcard命令查询该key结构内的所有元素数量    return redisTemplate.opsForZSet().zCard(followerKey);&#125;//查询某个实体粉丝的idspublic List&lt;Map&lt;String,Object&gt;&gt;getFollowers(int entityType, int entityId,int offset,int limit)&#123;    String followerKey = redisKeyUtil.getFollowerKey(entityId, entityType);    //获得所有有序集合内的元素按照分数从高到低排序    Set&lt;Integer&gt; fanSet = redisTemplate.opsForZSet().reverseRange(followerKey, offset, limit + limit - 1);    if(fanSet==null)&#123;        return null;    &#125;    List&lt;Map&lt;String,Object&gt;&gt;list=new ArrayList&lt;&gt;();    for (Integer fanId : fanSet) &#123;        Map&lt;String,Object&gt;map=new HashMap&lt;&gt;();        //粉丝实体        User user = userService.findUserById(fanId);        map.put(&quot;user&quot;,user);        //关注时间        Double score = redisTemplate.opsForZSet().score(followerKey, fanId);        map.put(&quot;followTime&quot;,new Date(score.longValue()));        list.add(map);    &#125;    return list;&#125;//查询当前用户是否关注该实体public boolean hasFollowed(int userId,int entityType,int entityId)&#123;    String followeeKey = redisKeyUtil.getFolloweeKey(userId, entityType);    return redisTemplate.opsForZSet().score(followeeKey,entityId)!=null;&#125;</code></pre><h2 id="3-控制层-1"><a href="#3-控制层-1" class="headerlink" title="3.控制层"></a>3.控制层</h2><pre><code class="java">@PostMapping(&quot;/follow&quot;)@ResponseBodypublic String follow(int entityId,int entityType)&#123;    User user = holder.getUser();    if(user.getId()==entityId&amp;&amp;entityType==ENTITY_TYPE_USER)&#123;        return CommunityUtil.getJsonString(1,&quot;用户不能关注自己&quot;);    &#125;    followService.follow(user.getId(),entityId,entityType);    return CommunityUtil.getJsonString(0,&quot;已关注&quot;);&#125;@PostMapping(&quot;/unfollow&quot;)@ResponseBodypublic String unfollow(int entityId,int entityType)&#123;    User user = holder.getUser();    followService.unfollow(user.getId(),entityId,entityType);    return CommunityUtil.getJsonString(0,&quot;已取消关注&quot;);&#125;@GetMapping(&quot;/follower/&#123;userId&#125;&quot;)public String follower(Model model, Page page, @PathVariable(&quot;userId&quot;)int userId)&#123;    //查询用户    User user = userService.findUserById(userId);    if(user==null)&#123;        throw new IllegalArgumentException(&quot;该用户不存在&quot;);    &#125;    model.addAttribute(&quot;user&quot;,user);    page.setLimit(5);    page.setPath(&quot;/follower/&quot;+user.getId());    page.setRows((int)followService.findFolloweeCount(userId,ENTITY_TYPE_USER));    List&lt;Map&lt;String,Object&gt;&gt; userList=followService.getFollowers(ENTITY_TYPE_USER,user.getId(),page.getOffset(),page.getLimit());    if (userList!=null)&#123;        for (Map&lt;String, Object&gt; map : userList) &#123;            //关注的人            User u = (User)map.get(&quot;user&quot;);            boolean hasFollowed = hasFollowed(u.getId());            map.put(&quot;hasFollowed&quot;,hasFollowed);        &#125;    &#125;    model.addAttribute(&quot;users&quot;,userList);    return &quot;/site/follower&quot;;&#125;@GetMapping(&quot;/followee/&#123;userId&#125;&quot;)public String followee(Model model, Page page, @PathVariable(&quot;userId&quot;)int userId)&#123;    //查询用户    User user = userService.findUserById(userId);    if(user==null)&#123;        throw new IllegalArgumentException(&quot;该用户不存在&quot;);    &#125;    model.addAttribute(&quot;user&quot;,user);    page.setLimit(5);    page.setPath(&quot;/followee/&quot;+user.getId());    page.setRows((int)followService.findFolloweeCount(userId,ENTITY_TYPE_USER));    List&lt;Map&lt;String,Object&gt;&gt; userList=followService.getFollowees(ENTITY_TYPE_USER,user.getId(),page.getOffset(),page.getLimit());    if (userList!=null)&#123;        for (Map&lt;String, Object&gt; map : userList) &#123;            //关注的人的关注的人            User u = (User)map.get(&quot;user&quot;);            boolean hasFollowed = hasFollowed(u.getId());            map.put(&quot;hasFollowed&quot;,hasFollowed);        &#125;    &#125;    model.addAttribute(&quot;users&quot;,userList);    return &quot;/site/followee&quot;;&#125;//当前用户是否关注传入的用户private boolean hasFollowed(int userId)&#123;    if(holder.getUser()==null)&#123;        return false;    &#125;    return followService.hasFollowed(holder.getUser().getId(),ENTITY_TYPE_USER,userId);&#125;</code></pre><h2 id="4-前端-1"><a href="#4-前端-1" class="headerlink" title="4.前端"></a>4.前端</h2><pre><code class="js">$(function()&#123;   $(&quot;.follow-btn&quot;).click(follow);&#125;);function follow() &#123;   var btn = this;   if ($(btn).hasClass(&quot;btn-info&quot;)) &#123;      // 关注TA      $.post(         CONTEXT_PATH + &quot;/follow&quot;,         &#123;&quot;entityType&quot;: 3, &quot;entityId&quot;: $(btn).prev().val()&#125;,         function (data) &#123;            data = $.parseJSON(data)            if (data.code === 0) &#123;               window.location.reload();            &#125; else &#123;               alert(data.msg)            &#125;         &#125;      )   &#125; else &#123;      // 取消关注      if ($(btn).hasClass(&quot;btn-secondary&quot;)) &#123;         // 关注TA         $.post(            CONTEXT_PATH + &quot;/unfollow&quot;,            &#123;&quot;entityType&quot;: 3, &quot;entityId&quot;: $(btn).prev().val()&#125;,            function (data) &#123;               data = $.parseJSON(data)               if (data.code === 0) &#123;                  window.location.reload();               &#125; else &#123;                  alert(data.msg)               &#125;            &#125;         )      &#125;   &#125;&#125;</code></pre><h1 id="二十二-优化登录模块"><a href="#二十二-优化登录模块" class="headerlink" title="二十二.优化登录模块"></a>二十二.优化登录模块</h1><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230224170234266.png" alt="image-20230224170234266"></p><h2 id="1-优化验证码"><a href="#1-优化验证码" class="headerlink" title="1.优化验证码"></a>1.优化验证码</h2><p>由于用户在验证码阶段未登录,所以无法获得userId. 那么我们需要创造一个短暂的唯一标识标记本次用户验证码的行为.</p><p>刷新验证码时利用uuid创造一个标识,存入cookie中</p><pre><code class="java">//验证码的归属者String kaptchaOwner = CommunityUtil.generateUUID();Cookie cookie=new Cookie(&quot;kaptchaOwner&quot;,kaptchaOwner);//验证码有效时间:120scookie.setMaxAge(120);cookie.setPath(contextPath);response.addCookie(cookie);</code></pre><p>然后利用该标识创造一段rediskey连同验证码存入到redis中:</p><pre><code class="java">//将验证码存入redisString redisKey = redisKeyUtil.getKaptchaKey(kaptchaOwner);//有效时间120sredisTemplate.opsForValue().set(redisKey,text,120, TimeUnit.SECONDS);</code></pre><p>之后就从redis中获取正确的验证码:</p><pre><code class="java">@PostMapping(&quot;/login&quot;)    public String login(String username, String password, String code, boolean rememberMe,                        Model model, HttpServletResponse response,                        @CookieValue(&quot;kaptchaOwner&quot;)String kaptchaOwner)&#123;        //检查验证码        //String kaptcha = (String) session.getAttribute(&quot;kaptcha&quot;);        if (StringUtils.isBlank(kaptchaOwner))&#123;            model.addAttribute(&quot;codeMsg&quot;,&quot;验证码已经过期,请重新输入&quot;);            return &quot;/site/login&quot;;        &#125;        String redisKey = redisKeyUtil.getKaptchaKey(kaptchaOwner);        String kaptchaCode =(String) redisTemplate.opsForValue().get(redisKey);        if (StringUtils.isBlank(code)||StringUtils.isBlank(kaptchaCode)||!kaptchaCode.equalsIgnoreCase(code)) &#123;            model.addAttribute(&quot;codeMsg&quot;,&quot;验证码不正确&quot;);            return &quot;/site/login&quot;;        &#125;</code></pre><h2 id="2-使用redis存储登录凭证"><a href="#2-使用redis存储登录凭证" class="headerlink" title="2.使用redis存储登录凭证"></a>2.使用redis存储登录凭证</h2><p>登录凭证的结构:</p><pre><code class="java">@Datapublic class LoginTicket &#123;    private int id;    private int userId;    //1为删除 0为正常使用    private int status;    //过期时间    private Date expired;    //标识    private String ticket;&#125;</code></pre><p>将原本的mapper设置为废弃:</p><pre><code class="java">@Mapper@Deprecatedpublic interface LoginTicketMapper &#123;</code></pre><p>在登录成功后生成登录凭证传给redis:</p><pre><code class="java">//全部通过之后,成功登录,生成登录凭证LoginTicket loginTicket=new LoginTicket();loginTicket.setTicket(CommunityUtil.generateUUID());loginTicket.setUserId(user.getId());loginTicket.setStatus(0);//过期时间loginTicket.setExpired(new Date(System.currentTimeMillis()+expiredSeconds* 1000L));//loginTicketMapper.insertLoginTicket(loginTicket);String ticketKey = redisKeyUtil.getTicketKey(loginTicket.getTicket());redisTemplate.opsForValue().set(ticketKey,loginTicket);map.put(&quot;ticket&quot;,loginTicket.getTicket());return map;</code></pre><p>登出时将登录凭证设置为不可用:</p><pre><code class="java">public void logout(String ticket)&#123;    //loginTicketMapper.updateStatus(ticket,1);    String ticketKey = redisKeyUtil.getTicketKey(ticket);    LoginTicket loginTicket =(LoginTicket) redisTemplate.opsForValue().get(ticketKey);    loginTicket.setStatus(1);    redisTemplate.opsForValue().set(ticketKey,loginTicket);&#125;</code></pre><p>在用户登录状态下如果凭证失效时间与当前时间相差小于两个小时,那么刷新凭证的有效时间,添加两个小时:</p><p>(防止用户使用网站用着用着就要返回登录)</p><p>在LoginTicketInterceptor中操作:</p><pre><code class="java">if(ticket!=null)&#123;    //表示登录了    //查询凭证    LoginTicket loginTicket = userService.findLoginTicket(ticket);    //检查凭证是否有效    if(loginTicket!=null&amp;&amp;loginTicket.getStatus()==0&amp;&amp;loginTicket.getExpired().after(new Date()))&#123;        //根据凭证查询用户        User user = userService.findUserById(loginTicket.getUserId());        //在本次请求中持有用户        hostHolder.setUser(user);        //增加登录凭证的有效时间        Date now = new Date();        //相差的毫秒数        long diff=loginTicket.getExpired().getTime()-now.getTime();        if(diff/(1000*60*60)&lt;2)&#123;            //凭证加两个小时            long newTime=now.getTime()+2*60*60*1000;            Date newExpired = new Date(newTime);            loginTicket.setExpired(newExpired);            String ticketKey = redisKeyUtil.getTicketKey(loginTicket.getTicket());            redisTemplate.opsForValue().set(ticketKey,ticket);        &#125;    &#125;&#125;return true;</code></pre><h2 id="3-缓存用户信息"><a href="#3-缓存用户信息" class="headerlink" title="3.缓存用户信息"></a>3.缓存用户信息</h2><pre><code class="java"> //优先从缓存中取值    private User getUserFromCache(int userId)&#123;        String userKey = redisKeyUtil.getUserKey(userId);        return (User) redisTemplate.opsForValue().get(userKey);    &#125;    //取不到初始化缓存数据    private User InitCache(int userId)&#123;        User user = userMapper.selectById(userId);        String userKey = redisKeyUtil.getUserKey(userId);        redisTemplate.opsForValue().set(userKey,user,60*60*2, TimeUnit.SECONDS);        return user;    &#125;    //数据变化时清除缓存数据    private void clearCache(int userId)&#123;        String userKey = redisKeyUtil.getUserKey(userId);        redisTemplate.delete(userKey);    &#125;</code></pre><pre><code class="java">public User findUserById(int id)&#123;    //return userMapper.selectById(id);    User userFromCache = getUserFromCache(id);    if(userFromCache==null)&#123;        userFromCache = InitCache(id);    &#125;    return userFromCache;&#125;</code></pre><p>用户更新信息时,让缓存失效,例如:</p><pre><code class="java">//激活状态码public int activation(int userId,String code)&#123;    User user = userMapper.selectById(userId);    if(user==null)&#123;        return ACTIVATION_FAILURE;    &#125;    if(user.getStatus()==1)&#123;        //已经激活过了        return ACTIVATION_REPEAT;    &#125;    if(user.getActivationCode().equals(code))&#123;        userMapper.updateStatus(userId,1);        clearCache(userId);        return ACTIVATION_SUCCESS;    &#125;else&#123;        return ACTIVATION_FAILURE;    &#125;&#125;  public int updateHeaderImg(int userId,String url)&#123;        int col = userMapper.updateHeaderUrl(userId, url);        clearCache(userId);        return col;    &#125;    public int updatePassword(int userId,String newPassword)&#123;        int col = userMapper.updatePassword(userId, newPassword);        clearCache(userId);        return col;    &#125;</code></pre><h1 id="二十三-阻塞队列"><a href="#二十三-阻塞队列" class="headerlink" title="二十三.阻塞队列"></a>二十三.阻塞队列</h1><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230225125903848.png" alt="image-20230225125903848"></p><h1 id="二十四-kafka"><a href="#二十四-kafka" class="headerlink" title="二十四.kafka"></a>二十四.kafka</h1><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230225130622534.png" alt="image-20230225130622534"></p><h2 id="1启动kafka步骤"><a href="#1启动kafka步骤" class="headerlink" title="1启动kafka步骤"></a>1启动kafka步骤</h2><p>(在版本号的目录下,windows环境)<br>开启zookeeper的命令: bin\windows\zookeeper-server-start.bat config\zookeeper.properties</p><p>开启kafka的命令: bin\windows\kafka-server-start.bat config\server.properties</p><p>创建topic(test)的命令: bin\windows\kafka-topics.bat –create –bootstrap-server localhost:9092 –replication-factor 1 –partitions 1 –topic test</p><p>生产者: bin\windows\kafka-console-producer.bat –broker-list localhost:9092 –topic test</p><p>消费者: bin\windows\kafka-console-consumer.bat –bootstrap-server localhost:9092 –topic test –from-beginning</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230225133538730.png" alt="image-20230225133538730"></p><h2 id="2配置文件"><a href="#2配置文件" class="headerlink" title="2配置文件:"></a>2配置文件:</h2><pre><code class="properties">#kafkaPropertiesspring.kafka.bootstrap-servers=localhost:9092spring.kafka.consumer.group-id=test-consumer-groupspring.kafka.consumer.enable-auto-commit=truespring.kafka.consumer.auto-commit-interval=3000s</code></pre><h2 id="3-测试kafka"><a href="#3-测试kafka" class="headerlink" title="3.测试kafka"></a>3.测试kafka</h2><pre><code class="java">@SpringBootTest@ContextConfiguration(classes = NewCodeApplication.class)@RunWith(SpringRunner.class)public class kafkaTest &#123;    @Resource    private kafkaProduce kafkaProduce;    @Test    public void testKafka() throws InterruptedException &#123;        kafkaProduce.sendMessage(&quot;test&quot;,&quot;howareyou&quot;);        kafkaProduce.sendMessage(&quot;test&quot;,&quot;ok?&quot;);    &#125;&#125;@Componentclass kafkaProduce&#123;    @Resource    private KafkaTemplate kafkaTemplate;    public void sendMessage(String topic,String content)&#123;        kafkaTemplate.send(topic,content);    &#125;&#125;@Componentclass kafkaConsumer&#123;    @KafkaListener(topics = &#123;&quot;test&quot;&#125;)    public void handleMessage(ConsumerRecord record)&#123;        System.out.println(record.value());    &#125;&#125;</code></pre><h1 id="二十五-发布系统通知"><a href="#二十五-发布系统通知" class="headerlink" title="二十五.发布系统通知"></a>二十五.发布系统通知</h1><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230225153859011.png" alt="image-20230225153859011"></p><p>当用户点赞,评论或者关注后. 系统用户都会发送一条message给被点赞,关注和评论的人. 这个功能需要用到kafka</p><p>我们把点赞,关注和评论当做一种事件, 当事件发生时,用kafka做自动推送</p><h2 id="1-事件的实体"><a href="#1-事件的实体" class="headerlink" title="1.事件的实体:"></a>1.事件的实体:</h2><pre><code class="java">//主题private String topic;//产生事件的用户idprivate int userId;//事件作用对象的typeprivate int entityType;//事件作用对象的Idprivate int entityId;//事件作用对象的userID(如果是关注,那么userid=entityID)private int entityUserId;//携带的数据private Map&lt;String,Object&gt;data=new HashMap&lt;&gt;();public String getTopic() &#123;    return topic;&#125;public Event setTopic(String topic) &#123;    this.topic = topic;    return this;&#125;public int getUserId() &#123;    return userId;&#125;public Event setUserId(int userId) &#123;    this.userId = userId;    return this;&#125;public int getEntityType() &#123;    return entityType;&#125;public Event setEntityType(int entityType) &#123;    this.entityType = entityType;    return this;&#125;public int getEntityId() &#123;    return entityId;&#125;public Event setEntityId(int entityId) &#123;    this.entityId = entityId;    return this;&#125;public int getEntityUserId() &#123;    return entityUserId;&#125;public Event setEntityUserId(int entityUserId) &#123;    this.entityUserId = entityUserId;    return this;&#125;public Map&lt;String, Object&gt; getData() &#123;    return data;&#125;public Event setData(String key,Object value) &#123;    this.data.put(key,value);    return this;&#125;</code></pre><h2 id="2-事件的生产者"><a href="#2-事件的生产者" class="headerlink" title="2.事件的生产者"></a>2.事件的生产者</h2><pre><code class="java">@Componentpublic class EventProducer &#123;    @Resource    private KafkaTemplate kafkaTemplate;    //提供处理事件的方法    public void fireEvent(Event event)&#123;        //将事件发布到指定的主题        //将事件实体以JSON字符串的形式发送        kafkaTemplate.send(event.getTopic(), JSONObject.toJSONString(event));    &#125;&#125;</code></pre><h2 id="3-事件的消费者"><a href="#3-事件的消费者" class="headerlink" title="3.事件的消费者"></a>3.事件的消费者</h2><pre><code class="java">@Componentpublic class EventConsumer implements CommunityConstant &#123;    private static final Logger logger= LoggerFactory.getLogger(EventConsumer.class);    @Resource    private MessageService messageService;    //往message表中插入数据    @KafkaListener(topics = &#123;TOPIC_COMMENT,TOPIC_FOLLOW,TOPIC_LIKE&#125;)    public void handleCommentMessage(ConsumerRecord record)&#123;        if(record==null||record.value()==null)&#123;            logger.error(&quot;消息的内容为空&quot;);            return;        &#125;        Event event = JSONObject.parseObject(record.value().toString(), Event.class);        if(event==null)&#123;            logger.error(&quot;消息格式错误&quot;);        &#125;        //发送站内通知        Message message = new Message();        //来自系统        message.setFromId(SYSTEM_USER_ID);        message.setCreateTime(new Date());        message.setToId(event.getEntityUserId());        message.setConversationId(event.getTopic());        //消息为未读        message.setStatus(0);        //        Map&lt;String,Object&gt;map=new HashMap&lt;&gt;();        //map携带产生事件的userID        map.put(&quot;userId&quot;,event.getUserId());        //事件作用对象的type        map.put(&quot;entityType&quot;,event.getEntityType());        //事件作用对象的id        map.put(&quot;evtityId&quot;,event.getEntityId());        if(event.getData()!=null)&#123;            for (Map.Entry&lt;String, Object&gt; stringObjectEntry : event.getData().entrySet()) &#123;                map.put(stringObjectEntry.getKey(),stringObjectEntry.getValue());            &#125;        &#125;        message.setContent(JSONObject.toJSONString(map));        messageService.addMessage(message);    &#125;&#125;</code></pre><h2 id="4-拿点赞举例"><a href="#4-拿点赞举例" class="headerlink" title="4.拿点赞举例"></a>4.拿点赞举例</h2><pre><code class="java">//触发点赞事件if(entityLikeStatus==1)&#123;    Event event=new Event();    event.setTopic(TOPIC_LIKE)            .setUserId(user.getId())            .setEntityType(entityType)            .setEntityId(entityId)            .setEntityUserId(entityUserId)            //data里面存储点赞所在的帖子的id(点赞的不一定是帖子,也可能是回复)            .setData(&quot;postId&quot;,postId);    producer.fireEvent(event);&#125;</code></pre><h1 id="二十六-显示系统通知"><a href="#二十六-显示系统通知" class="headerlink" title="二十六.显示系统通知"></a>二十六.显示系统通知</h1><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230225153835023.png" alt="image-20230225153835023"></p><h2 id="1-数据层-1"><a href="#1-数据层-1" class="headerlink" title="1.数据层"></a>1.数据层</h2><pre><code class="xml">&lt;!--查询最新的一条通知--&gt;&lt;select id=&quot;selectLatestNotice&quot; resultType=&quot;message&quot;&gt;    select &lt;include refid=&quot;selectFields&quot;&gt;&lt;/include&gt; from message    where id in(        select max(id) from message        where status!=2 and from_id=1 and to_id=#&#123;userId&#125;         and conversation_id=#&#123;topic&#125;    )&lt;/select&gt;&lt;!--查询通知总数--&gt;&lt;select id=&quot;selectNoticeCount&quot; resultType=&quot;int&quot;&gt;    select count(id) from message    where status!=2 and from_id=1 and to_id=#&#123;userId&#125;      and conversation_id=#&#123;topic&#125;&lt;/select&gt;&lt;!--查询未读的通知数量--&gt;&lt;select id=&quot;selectNoticeUnreadCount&quot; resultType=&quot;int&quot;&gt;    select count(id) from message    where status=0 and from_id=1 and to_id=#&#123;userId&#125;        &lt;if test=&quot;topic!=null&quot;&gt;            and conversation_id=#&#123;topic&#125;        &lt;/if&gt;&lt;/select&gt;&lt;!--查询通知,带有分页条件--&gt;&lt;select id=&quot;selectNotice&quot; resultType=&quot;message&quot;&gt;    select &lt;include refid=&quot;selectFields&quot;&gt;&lt;/include&gt; from message    where status!=2 and from_id=1 and to_id=#&#123;userId&#125;  and conversation_id=#&#123;topic&#125;    order by id desc    limit #&#123;offset&#125;,#&#123;limit&#125;&lt;/select&gt;</code></pre><h2 id="2-控制层-3"><a href="#2-控制层-3" class="headerlink" title="2.控制层"></a>2.控制层</h2><pre><code class="java">@GetMapping(&quot;/notice/list&quot;)public String getNoticeList(Model model)&#123;    User user = holder.getUser();    //查询评论内容    //最新的一条评论通知    Message message=messageService.findLatestNotice(user.getId(),TOPIC_COMMENT);    Map&lt;String,Object&gt;messageVo=new HashMap&lt;&gt;();    messageVo.put(&quot;message&quot;,message);    if(message!=null)&#123;        //将json字符串里的特殊字符转义        String content= HtmlUtils.htmlUnescape(message.getContent());        //content是以JSON对象存储的        HashMap&lt;String,Object&gt; data = JSONObject.parseObject(content, HashMap.class);        //产生事件的user        messageVo.put(&quot;user&quot;,userService.findUserById((int)data.get(&quot;userId&quot;)));        //实体的类型        messageVo.put(&quot;entityType&quot;,data.get(&quot;entityType&quot;));        //实体的id        messageVo.put(&quot;entityId&quot;,data.get(&quot;entityId&quot;));        //帖子的id        messageVo.put(&quot;postId&quot;,data.get(&quot;postId&quot;));        //查询评论通知数量总数        int count=messageService.findNoticeCount(user.getId(),TOPIC_COMMENT);        messageVo.put(&quot;count&quot;,count);        //查询未读的评论通知数量        int unreadCount=messageService.findNoticeUnreadCount(user.getId(),TOPIC_COMMENT);        messageVo.put(&quot;unread&quot;,unreadCount);        model.addAttribute(&quot;commentNotice&quot;,messageVo);         //查询未读消息数量        int unreadLetterCount = messageService.findUnreadLetter(user.getId(), null);        model.addAttribute(&quot;unreadLetterCount&quot;,unreadLetterCount);        //查询总共未读的通知数量        int noticeUnreadCount=messageService.findNoticeUnreadCount(user.getId(),null);        model.addAttribute(&quot;noticeUnreadCount&quot;,noticeUnreadCount);        return &quot;/site/notice&quot;;        &#125;    &#125;</code></pre><h2 id="3-具体的消息内容"><a href="#3-具体的消息内容" class="headerlink" title="3.具体的消息内容"></a>3.具体的消息内容</h2><pre><code class="java">@GetMapping(&quot;/notice/detail/&#123;topic&#125;&quot;)public String noticeDetail(@PathVariable(&quot;topic&quot;)String topic,Model model,Page page)&#123;    User user = holder.getUser();    page.setLimit(5);    page.setPath(&quot;/notice/detail/&quot;+topic);    page.setRows(messageService.findNoticeCount(user.getId(),topic));    List&lt;Message&gt; notices = messageService.findNotices(user.getId(), topic, page.getOffset(), page.getLimit());    List&lt;Map&lt;String,Object&gt;&gt;noticeVoList=new ArrayList&lt;&gt;();    if (notices!=null)&#123;        for (Message notice : notices) &#123;            Map&lt;String,Object&gt;map=new HashMap&lt;&gt;();            //通知            map.put(&quot;notice&quot;,notice);            //内容            String content = HtmlUtils.htmlUnescape(notice.getContent());            HashMap&lt;String,Object&gt; data = JSONObject.parseObject(content, HashMap.class);            map.put(&quot;user&quot;,userService.findUserById((int)data.get(&quot;userId&quot;)));            map.put(&quot;entityType&quot;,data.get(&quot;entityType&quot;));            map.put(&quot;entityId&quot;,data.get(&quot;entityId&quot;));            map.put(&quot;postId&quot;,data.get(&quot;postId&quot;));            //通知的作者            User fromUser = userService.findUserById(notice.getFromId());            map.put(&quot;fromUser&quot;,fromUser);            noticeVoList.add(map);        &#125;    &#125;    model.addAttribute(&quot;notices&quot;,noticeVoList);    //设置已读    List&lt;Integer&gt;ids=getLetterIds(notices);    if(ids!=null&amp;&amp; !ids.isEmpty())&#123;        messageService.readMessage(ids);    &#125;    return &quot;/site/notice-detail&quot;;&#125;</code></pre><h1 id="二十七-Elasticsearch入门-社区搜索"><a href="#二十七-Elasticsearch入门-社区搜索" class="headerlink" title="二十七.Elasticsearch入门(社区搜索)"></a>二十七.Elasticsearch入门(社区搜索)</h1><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230226135521624.png" alt="image-20230226135521624"></p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230226150344717.png" alt="image-20230226150344717"></p><h2 id="1-配置"><a href="#1-配置" class="headerlink" title="1.配置:"></a>1.配置:</h2><pre><code class="properties">spring.data.elasticsearch.cluster-node=127.0.0.1:9300spring.elasticsearch.uris= http://localhost:9200elasticSearch.url=127.0.0.1:9200</code></pre><p>配置文件</p><pre><code class="java">@Configurationpublic class EsConfig &#123;    @Value(&quot;$&#123;elasticSearch.url&#125;&quot;)    String esUrl;    @Bean    public RestHighLevelClient client()&#123;        return new RestHighLevelClient(                RestClient.builder(new HttpHost(&quot;127.0.0.1&quot;, 9200, &quot;http&quot;))                        .setRequestConfigCallback(new RestClientBuilder.RequestConfigCallback() &#123;                            @Override                            public RequestConfig.Builder customizeRequestConfig(RequestConfig.Builder builder) &#123;                                return builder.setConnectTimeout(5000 * 1000) // 连接超时（默认为1秒）                                        .setSocketTimeout(6000 * 1000);// 套接字超时（默认为30秒）//更改客户端的超时限制默认30秒现在改为100*1000分钟                            &#125;                        &#125;)        );    &#125;&#125;</code></pre><h2 id="2-es接口层"><a href="#2-es接口层" class="headerlink" title="2.es接口层"></a>2.es接口层</h2><pre><code class="java">@Repositorypublic interface DiscussPostRepository extends ElasticsearchRepository&lt;DiscussPost,Integer&gt; &#123;&#125;</code></pre><p>添加一个返回类作为分页工具</p><pre><code class="java">@Data@NoArgsConstructor@AllArgsConstructorpublic class SearchResult &#123;    private List&lt;DiscussPost&gt; list;    private long total;&#125;</code></pre><h2 id="3-业务层"><a href="#3-业务层" class="headerlink" title="3.业务层"></a>3.业务层</h2><pre><code class="java">@Servicepublic class ElasticSearchService &#123;    @Resource    private DiscussPostRepository discussPostRepository;    @Resource    @Qualifier(&quot;client&quot;)    private RestHighLevelClient restHighLevelClient;    public void saveDiscussPost(DiscussPost discussPost)&#123;        discussPostRepository.save(discussPost);    &#125;    public void deleteDiscussPost(int id)&#123;        discussPostRepository.deleteById(id);    &#125;    public SearchResult SearchResult(String keyword, int current, int limit)&#123;        SearchRequest searchRequest=new SearchRequest(&quot;discusspost&quot;);        //高亮        HighlightBuilder highlightBuilder=new HighlightBuilder();        highlightBuilder.field(&quot;title&quot;);        highlightBuilder.field(&quot;content&quot;);        highlightBuilder.requireFieldMatch(false);        highlightBuilder.preTags(&quot;&lt;span style=&#39;color:red&#39;&gt;&quot;);        highlightBuilder.postTags(&quot;&lt;/span&gt;&quot;);        //构建搜索条件        SearchSourceBuilder searchSourceBuilder  = new SearchSourceBuilder()                .query(QueryBuilders.multiMatchQuery(keyword, &quot;title&quot;, &quot;content&quot;))                .sort(SortBuilders.fieldSort(&quot;type&quot;).order(SortOrder.DESC))                .sort(SortBuilders.fieldSort(&quot;score&quot;).order(SortOrder.DESC))                .sort(SortBuilders.fieldSort(&quot;createTime&quot;).order(SortOrder.DESC))                .from(current)// 指定从哪条开始查询                .size(limit)// 需要查出的总记录条数                .highlighter(highlightBuilder);        searchRequest.source(searchSourceBuilder);        SearchResponse searchResponse= null;        long total=0L;        try &#123;            searchResponse = restHighLevelClient.search(searchRequest, RequestOptions.DEFAULT);             total=searchResponse.getHits().getTotalHits().value;        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;        List&lt;DiscussPost&gt; list=new ArrayList&lt;&gt;();        for (SearchHit hit : searchResponse.getHits().getHits()) &#123;            DiscussPost discussPost = JSONObject.parseObject(hit.getSourceAsString(), DiscussPost.class);            // 处理高亮显示的结果            HighlightField titleField = hit.getHighlightFields().get(&quot;title&quot;);            if (titleField != null) &#123;                discussPost.setTitle(titleField.getFragments()[0].toString());            &#125;            HighlightField contentField = hit.getHighlightFields().get(&quot;content&quot;);            if (contentField != null) &#123;                discussPost.setContent(contentField.getFragments()[0].toString());            &#125;            list.add(discussPost);        &#125;        return new SearchResult(list,total);    &#125;&#125;</code></pre><h2 id="4-消息队列同步数据"><a href="#4-消息队列同步数据" class="headerlink" title="4.消息队列同步数据"></a>4.消息队列同步数据</h2><p>当回复一个帖子或者发布帖子时,我们通过kafka将数据同步到es中:</p><pre><code class="java">//消费发布事件@KafkaListener(topics = &#123;TOPIC_PUBLISH_POST&#125;)public void handlePublishMessage(ConsumerRecord record)&#123;    if(record==null||record.value()==null)&#123;        logger.error(&quot;消息的内容为空&quot;);        return;    &#125;    Event event = JSONObject.parseObject(record.value().toString(), Event.class);    if(event==null)&#123;        logger.error(&quot;消息格式错误&quot;);    &#125;    DiscussPost post = discussPostService.selectDiscussPostById(event.getEntityId());    //存到es中    elasticSearchService.saveDiscussPost(post);&#125;</code></pre><h2 id="5-控制层"><a href="#5-控制层" class="headerlink" title="5.控制层"></a>5.控制层</h2><p>CommentController:</p><p>添加回复方法的最后追加:</p><pre><code class="java">//回复帖子相当于修改了帖子的状态,需要修改信息到esif(comment.getEntityType()==ENTITY_TYPE_POST)&#123;    //触发评论事件--&gt;搜索    event=new Event().setTopic(TOPIC_PUBLISH_POST)            .setUserId(comment.getId())            .setEntityId(ENTITY_TYPE_POST)            .setEntityId(discussPostId);    eventProducer.fireEvent(event);&#125;</code></pre><p>DiscussPostControlle添加帖子的最后追加:</p><pre><code class="java">Event event=new Event().setTopic(TOPIC_PUBLISH_POST)        .setUserId(user.getId())        .setEntityId(ENTITY_TYPE_POST)        .setEntityId(post.getId());eventProducer.fireEvent(event);</code></pre><p>搜索视图层:</p><pre><code class="java">@GetMapping(&quot;/search&quot;)public String search(String keyword, Page page, Model model)&#123;    SearchResult searchResult = elasticSearchService.SearchResult(keyword, page.getOffset(), page.getLimit());    List&lt;Map&lt;String,Object&gt;&gt;discussPosts=new ArrayList&lt;&gt;();    List&lt;DiscussPost&gt; list = searchResult.getList();    if(list!=null)&#123;        for (DiscussPost post : list) &#123;            Map&lt;String,Object&gt;map=new HashMap&lt;&gt;();            map.put(&quot;post&quot;,post);            map.put(&quot;user&quot;,userService.findUserById(post.getUserId()));            map.put(&quot;likeCount&quot;,likeService.findEntityLikeCount(ENTITY_TYPE_POST,post.getId()));            discussPosts.add(map);        &#125;    &#125;    model.addAttribute(&quot;discussPosts&quot;,discussPosts);    model.addAttribute(&quot;keyword&quot;,keyword);    //分页信息    page.setPath(&quot;/search?keyword=&quot;+keyword);    page.setRows(searchResult.getTotal()==0?0:(int)searchResult.getTotal());    return &quot;/site/search&quot;;&#125;</code></pre><h1 id="二十八-springsecurity"><a href="#二十八-springsecurity" class="headerlink" title="二十八.springsecurity"></a>二十八.springsecurity</h1><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230227120845866.png" alt="image-20230227120845866"></p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230227120831437.png" alt="image-20230227120831437"></p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230227161909892.png" alt="image-20230227161909892"></p><p>入门springsecurity博文:</p><p><a href="https://blog.csdn.net/liuminglei1987/article/details/107538666?spm=1001.2014.3001.5506">https://blog.csdn.net/liuminglei1987/article/details/107538666?spm=1001.2014.3001.5506</a></p><h1 id="二十九-置顶-加精-删除"><a href="#二十九-置顶-加精-删除" class="headerlink" title="二十九.置顶,加精,删除"></a>二十九.置顶,加精,删除</h1><h2 id="0-引入依赖"><a href="#0-引入依赖" class="headerlink" title="0.引入依赖"></a>0.引入依赖</h2><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.thymeleaf.extras/thymeleaf-extras-springsecurity5 --&gt;&lt;!--thymeleaf与springsecurity整合的依赖--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.thymeleaf.extras&lt;/groupId&gt;    &lt;artifactId&gt;thymeleaf-extras-springsecurity5&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><h2 id="1-数据层-2"><a href="#1-数据层-2" class="headerlink" title="1.数据层"></a>1.数据层</h2><p>修改帖子中的type和status</p><pre><code class="java">    int updateType(int id,int type);    int updateStatus(int id,int status);&#125;</code></pre><h2 id="2-逻辑层"><a href="#2-逻辑层" class="headerlink" title="2.逻辑层"></a>2.逻辑层</h2><pre><code class="java">public int updateType(int id,int type)&#123;    return discussPostMapper.updateType(id,type);&#125;public int updateStatus(int id,int status)&#123;    return discussPostMapper.updateStatus(id,status);&#125;</code></pre><h2 id="3-权限控制"><a href="#3-权限控制" class="headerlink" title="3.权限控制"></a>3.权限控制</h2><pre><code class="java">@Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter implements CommunityConstant  &#123;    @Override    public void configure(WebSecurity web) throws Exception &#123;        web.ignoring().antMatchers(&quot;/resources/**&quot;);    &#125;        //@Override    //protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;    //    super.configure(auth);    //&#125;    @Override    protected void configure(HttpSecurity http) throws Exception &#123;        //授权        http.authorizeRequests()                //需要登录才能访问的路径                .antMatchers(                    &quot;/user/setting&quot;,                        &quot;/user/upload&quot;,                        &quot;/discuss/add&quot;,                        &quot;/comment/add/**&quot;,                        &quot;/letter/**&quot;,                        &quot;/notice/**&quot;,                        &quot;/like&quot;,                        &quot;/follow&quot;,                        &quot;/unfollow&quot;                )                //这三个任意一个都可以                .hasAnyAuthority(                    AUTHORITY_ADMIN,AUTHORITY_USER,AUTHORITY_MODERATOR                )                .antMatchers(                    &quot;/discuss/top&quot;,                        &quot;/discuss/wonderful&quot;                ).hasAnyAuthority(                        AUTHORITY_MODERATOR                ) .antMatchers(                        &quot;/discuss/delete&quot;                ).hasAnyAuthority(                        AUTHORITY_ADMIN                )                //除了上面的几个请求,其他的谁都可以访问                .anyRequest().permitAll().and()                //禁用csrf检查，正式环境需要开开                .csrf().disable();        //权限不够时怎么处理        http.exceptionHandling()                //没有登录时怎么处理                .authenticationEntryPoint(new AuthenticationEntryPoint() &#123;                    @Override                    public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException e) throws IOException, ServletException &#123;                        //判断当前请求是普通请求还是异步请求                        String xRequestedWith = request.getHeader(&quot;x-requested-with&quot;);                        if(&quot;XMLHttpRequest&quot;.equals(xRequestedWith))&#123;                            //是异步请求                            response.setContentType(&quot;application/plain;charset=utf-8&quot;);                            PrintWriter writer = response.getWriter();                            writer.write(CommunityUtil.getJsonString(403,&quot;您还未登录&quot;));                        &#125;else&#123;                            //是普通请求                            response.sendRedirect(request.getContextPath()+&quot;/login&quot;);                        &#125;                    &#125;                &#125;)                //权限不足时怎么处理                .accessDeniedHandler(new AccessDeniedHandler() &#123;                    @Override                    public void handle(HttpServletRequest request, HttpServletResponse response, AccessDeniedException e) throws IOException, ServletException &#123;                        //判断当前请求是普通请求还是异步请求                        String xRequestedWith = request.getHeader(&quot;x-requested-with&quot;);                        if(&quot;XMLHttpRequest&quot;.equals(xRequestedWith))&#123;                            //是异步请求                            response.setContentType(&quot;application/plain;charset=utf-8&quot;);                            PrintWriter writer = response.getWriter();                            writer.write(CommunityUtil.getJsonString(403,&quot;您没有访问此功能的权限&quot;));                        &#125;else&#123;                            //是普通请求                            response.sendRedirect(request.getContextPath()+&quot;/denied&quot;);                        &#125;                    &#125;                &#125;);        //Security默认会拦截/logout的请求,进行退出处理        //覆盖它默认的逻辑,才能执行我们自己退出的代码        http.logout()                .logoutUrl(&quot;/security/logout&quot;);    &#125;</code></pre><p>同时在LoginTicketInterceptor中去除LoginRequiredInterceptor的作用:</p><p>在其中修改方法:</p><pre><code class="java">@Overridepublic boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;    //从cookie中获取凭证    String ticket = CookieUtil.getValue(request, &quot;ticket&quot;);    if(ticket!=null)&#123;        //表示登录了        //查询凭证        LoginTicket loginTicket = userService.findLoginTicket(ticket);        //检查凭证是否有效        if(loginTicket!=null&amp;&amp;loginTicket.getStatus()==0&amp;&amp;loginTicket.getExpired().after(new Date()))&#123;            //根据凭证查询用户            User user = userService.findUserById(loginTicket.getUserId());            //在本次请求中持有用户            hostHolder.setUser(user);            //构建用户认证的结果,并存入securityContext,便于security授权            Authentication authentication=new UsernamePasswordAuthenticationToken(                    user,user.getPassword(),userService.getAuthorities(user.getId()));            SecurityContextHolder.setContext(new SecurityContextImpl(authentication));            //增加登录凭证的有效时间            Date now = new Date();            //相差的毫秒数            long diff=loginTicket.getExpired().getTime()-now.getTime();            if(diff/(1000*60*60)&lt;2)&#123;                //凭证加两个小时                long newTime=now.getTime()+2*60*60*1000;                Date newExpired = new Date(newTime);                loginTicket.setExpired(newExpired);                String ticketKey = redisKeyUtil.getTicketKey(loginTicket.getTicket());                redisTemplate.opsForValue().set(ticketKey,ticket);            &#125;        &#125;    &#125;    return true;&#125;</code></pre><p>在UserService添加方法:</p><pre><code class="java">//获得用户权限public Collection&lt;? extends GrantedAuthority&gt;getAuthorities(int userId)&#123;    User user = this.findUserById(userId);    List&lt;GrantedAuthority&gt;list=new ArrayList&lt;&gt;();    list.add(new GrantedAuthority() &#123;        @Override        public String getAuthority() &#123;            switch (user.getType())&#123;                case 1:                    return AUTHORITY_ADMIN;                case 2:                    return AUTHORITY_MODERATOR;                default:return AUTHORITY_USER;            &#125;        &#125;    &#125;);    return list;&#125;</code></pre><h2 id="4-前端-2"><a href="#4-前端-2" class="headerlink" title="4.前端"></a>4.前端</h2><p>发送请求:</p><pre><code class="js">$(function ()&#123;    $(&quot;#topBtn&quot;).click(setTop)    $(&quot;#wonderfulBtn&quot;).click(setWonderful)    $(&quot;#deleteBtn&quot;).click(setDelete)&#125;)//置顶function setTop()&#123;    $.post(        CONTEXT_PATH+&quot;/discuss/top&quot;,        &#123;&quot;id&quot;:$(&quot;#postId&quot;).val()&#125;,        function (data)&#123;            data=$.parseJSON(data)            if(data.code===0)&#123;                $(&quot;#topBtn&quot;).attr(&quot;disabled&quot;,&quot;disabled&quot;)            &#125;else&#123;                alert(data.msg);            &#125;        &#125;    )&#125;function setWonderful()&#123;    $.post(        CONTEXT_PATH+&quot;/discuss/wonderful&quot;,        &#123;&quot;id&quot;:$(&quot;#postId&quot;).val()&#125;,        function (data)&#123;            data=$.parseJSON(data)            if(data.code===0)&#123;                $(&quot;#wonderfulBtn&quot;).attr(&quot;disabled&quot;,&quot;disabled&quot;)            &#125;else&#123;                alert(data.msg);            &#125;        &#125;    )&#125;function setDelete()&#123;    $.post(        CONTEXT_PATH+&quot;/discuss/top&quot;,        &#123;&quot;id&quot;:$(&quot;#postId&quot;).val()&#125;,        function (data)&#123;            data=$.parseJSON(data)            if(data.code===0)&#123;               location.href=CONTEXT_PATH+&quot;/index&quot;;            &#125;else&#123;                alert(data.msg);            &#125;        &#125;    )&#125;</code></pre><p>页面:</p><pre><code class="html">&lt;!doctype html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot; xmlns:sec=&quot;http://www.thymeleaf.org/extras/spring-security&quot;&gt;&lt;head&gt;   &lt;meta charset=&quot;utf-8&quot;&gt;   &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, shrink-to-fit=no&quot;&gt;   &lt;link rel=&quot;icon&quot; href=&quot;https://static.nowcoder.com/images/logo_87_87.png&quot;/&gt;   &lt;link rel=&quot;stylesheet&quot; href=&quot;https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css&quot; crossorigin=&quot;anonymous&quot;&gt;   &lt;link rel=&quot;stylesheet&quot; th:href=&quot;@&#123;/css/global.css&#125;&quot; /&gt;   &lt;link rel=&quot;stylesheet&quot; th:href=&quot;@&#123;/css/discuss-detail.css&#125;&quot; /&gt;   &lt;title&gt;牛客网-帖子详情&lt;/title&gt;&lt;/head&gt;                &lt;h6 class=&quot;mb-4&quot;&gt;                    &lt;img src=&quot;http://static.nowcoder.com/images/img/icons/ico-discuss.png&quot;/&gt;                    &lt;span th:utext=&quot;$&#123;post.title&#125;&quot;&gt;备战春招，面试刷题跟他复习，一个月全搞定！&lt;/span&gt;                    &lt;div class=&quot;float-right&quot;&gt;                        &lt;input id=&quot;postId&quot; th:value=&quot;$&#123;post.id&#125;&quot;&gt;                        &lt;button type=&quot;button&quot; class=&quot;btn btn-danger btn-sm&quot; id=&quot;topBtn&quot;                                th:disabled=&quot;$&#123;post.type==1&#125;&quot; sec:authorize=&quot;hasAnyAuthority(&#39;moderator&#39;)&quot;&gt;                            置顶&lt;/button&gt;                        &lt;button type=&quot;button&quot; class=&quot;btn btn-danger btn-sm&quot; id=&quot;wonderfulBtn&quot;                                th:disabled=&quot;$&#123;post.status==1&#125;&quot; sec:authorize=&quot;hasAnyAuthority(&#39;moderator&#39;)&quot;&gt;加精&lt;/button&gt;                        &lt;button type=&quot;button&quot; class=&quot;btn btn-danger btn-sm&quot; id=&quot;deleteBtn&quot;                                th:disabled=&quot;$&#123;post.status==2&#125;&quot; sec:authorize=&quot;hasAnyAuthority(&#39;admin&#39;)&quot;&gt;删除&lt;/button&gt;                    &lt;/div&gt;                &lt;/h6&gt;</code></pre><h1 id="三十-Redis高级数据类型"><a href="#三十-Redis高级数据类型" class="headerlink" title="三十.Redis高级数据类型"></a>三十.Redis高级数据类型</h1><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230228132231779.png" alt="image-20230228132231779"></p><p>HyperLog</p><pre><code class="java">@SpringBootTestpublic class hyperLogTest &#123;    @Resource    private StringRedisTemplate stringRedisTemplate;    @Test    void hyperLog() &#123;        String[]values=new String[1000];        int j=0;        for (int i = 0; i &lt; 1000000; i++) &#123;            j=i%1000;            values[j]=&quot;userTest_&quot;+i;            if(j==999)&#123;                stringRedisTemplate.opsForHyperLogLog().add(&quot;hl2&quot;,values);            &#125;        &#125;        //统计数量        Long hl2 = stringRedisTemplate.opsForHyperLogLog().size(&quot;hl2&quot;);        System.out.println(&quot;count=&quot;+hl2);    &#125;    //opsForHyperLogLog也可以合并几个key到新一个新的key,但是value重复的会被合并    @Test    void Union()&#123;        String redisKey1=&quot;testLog:1&quot;;        for (int i = 0; i &lt; 10000; i++) &#123;            stringRedisTemplate.opsForHyperLogLog().add(redisKey1,&quot;&quot;+i);        &#125;        String redisKey2=&quot;testLog:2&quot;;        for (int i = 5000; i &lt; 15000; i++) &#123;            stringRedisTemplate.opsForHyperLogLog().add(redisKey2,&quot;&quot;+i);        &#125;        String redisKey3=&quot;testLog:3&quot;;        for (int i = 15000; i &lt; 20000; i++) &#123;            stringRedisTemplate.opsForHyperLogLog().add(redisKey3,&quot;&quot;+i);        &#125;        String redisKeyUnion=&quot;testUnion&quot;;        //        stringRedisTemplate.opsForHyperLogLog().union(redisKeyUnion, redisKey1, redisKey2, redisKey3);        Long size = stringRedisTemplate.opsForHyperLogLog().size(redisKeyUnion);        System.out.println(size);    &#125;&#125;</code></pre><p>BitMap</p><pre><code class="java">/** * 签到功能: */@Testvoid sign()&#123;    String redisSignKey=&quot;userSign&quot;;    //假设今天是3月十号, 而三月五号未签到,其他天都签到了    for (int i = 1; i &lt;11 ; i++) &#123;        if(i!=5)&#123;            stringRedisTemplate.opsForValue().setBit(redisSignKey,i-1,true);        &#125;    &#125;    int count=0;    int index=10;    // 获取本月截止今天为止的所有的签到记录，返回的是一个十进制的数字 BITFIELD sign:5:202203 GET u14 0    List&lt;Long&gt; longs = stringRedisTemplate.opsForValue().bitField(redisSignKey            , BitFieldSubCommands.create().get(BitFieldSubCommands.BitFieldType.unsigned(index)).valueAt(0));    if(longs==null||longs.isEmpty())&#123;        return;    &#125;    Long num = longs.get(0);    if(num==null||num==0)&#123;        return;    &#125;    //查询总共签到了几次:    Object o = stringRedisTemplate.execute(new RedisCallback&lt;Object&gt;() &#123;        @Override        public Object doInRedis(RedisConnection connection) throws DataAccessException &#123;            return connection.bitCount(redisSignKey.getBytes());        &#125;    &#125;);    System.out.println(o);    //查询连续签到了几天    while (true)&#123;        if((num&amp;1)==0)&#123;            break;        &#125;else&#123;            count++;            num&gt;&gt;&gt;=1;        &#125;    &#125;    System.out.println(&quot;连续签到了几天: &quot;+count);&#125;</code></pre><h1 id="三十一-网站数据统计"><a href="#三十一-网站数据统计" class="headerlink" title="三十一.网站数据统计"></a>三十一.网站数据统计</h1><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230228144737349.png" alt="image-20230228144737349"></p><h2 id="1-业务层-2"><a href="#1-业务层-2" class="headerlink" title="1.业务层"></a>1.业务层</h2><p>使用HyperLogLog统计:</p><p>利用每天的日期,生成一个Key,将ip作为值加入HyperlogLog中,最后可以统计出改天总共的UV量:</p><pre><code class="java">@Resourceprivate RedisTemplate redisTemplate;private SimpleDateFormat simpleDateFormat=new SimpleDateFormat(&quot;yyyyMMdd&quot;);//将指定ip计入UVpublic void recordUV(String ip)&#123;    String redisKey = redisKeyUtil.getUVKey(simpleDateFormat.format(new Date()));    redisTemplate.opsForHyperLogLog().add(redisKey,ip);&#125;</code></pre><p>统计指定日期的UV:</p><pre><code class="java">//统计指定日期范围内的UVpublic long calculateUV(Date start,Date end)&#123;    if(start==null||end==null)&#123;        throw new IllegalArgumentException(&quot;参数不能为空&quot;);    &#125;    //整理日期范围内的key    List&lt;String&gt;keyList=new ArrayList&lt;&gt;();    //利用CalenDar判断给定的日期的先后顺序    Calendar calendar=Calendar.getInstance();    calendar.setTime(start);    //若设定的日期小于或等于end    while (!calendar.getTime().after(end))&#123;        //得到指定的日期的UVKey        String uvKey = redisKeyUtil.getUVKey(simpleDateFormat.format(calendar.getTime()));               keyList.add(uvKey);        //往后推一天        calendar.add(Calendar.DATE,1);    &#125;    //合并这些数据    if (keyList.isEmpty())&#123;        return 0;    &#125;    String uvKey = redisKeyUtil.getUVKey(simpleDateFormat.format(start), simpleDateFormat.format(end));    redisTemplate.opsForHyperLogLog().union(uvKey, keyList.toArray());    //返回统计的数据大小    return redisTemplate.opsForHyperLogLog().size(uvKey);&#125;</code></pre><p>类似的,DAU也是该种逻辑:</p><p>用户登录网站后,利用当前的登陆日期生成key,将该key的bitmap位(用户id的位次,比如用户id为102,就将102位设置为1):</p><p>之后再统计指定日期范围内的bitmap有多少位1:</p><pre><code class="java">//将指定用户计入DAUpublic void recordDAU(int userId)&#123;    String dauKey = redisKeyUtil.getDAUKey(simpleDateFormat.format(new Date()));    //用户id是多少,就把多少位设置为1    redisTemplate.opsForValue().setBit(dauKey,userId,true);&#125;//指定日期范围内的DAUpublic long calculateDAU(Date start,Date end)&#123;    if(start==null||end==null)&#123;        throw new IllegalArgumentException(&quot;参数不能为空&quot;);    &#125;    //整理日期范围内的key    List&lt;byte[]&gt;keyList=new ArrayList&lt;&gt;();    Calendar calendar=Calendar.getInstance();    calendar.setTime(start);    while (!calendar.getTime().after(end))&#123;        String dauKey = redisKeyUtil.getDAUKey(simpleDateFormat.format(calendar.getTime()));        keyList.add(dauKey.getBytes());        calendar.add(Calendar.DATE,1);    &#125;    //进行运算    return (long)redisTemplate.execute(new RedisCallback() &#123;        @Override        public Object doInRedis(RedisConnection redisConnection) throws DataAccessException &#123;            String dauKey = redisKeyUtil.getDAUKey(simpleDateFormat.format(start), simpleDateFormat.format(end));            redisConnection.bitOp(RedisStringCommands.BitOperation.OR,                    dauKey.getBytes(),keyList.toArray(new byte[0][0]));            return redisConnection.bitCount(dauKey.getBytes());        &#125;    &#125;);&#125;</code></pre><h2 id="2-拦截器-1"><a href="#2-拦截器-1" class="headerlink" title="2.拦截器"></a>2.拦截器</h2><p>由于在每个请求到达controller前都要将访问数据写入到redis中,所以最好使用拦截器完成这个工作:</p><p>拦截器将每次请求的ip和userid写入到redis中,以供后续表现层获取数据</p><pre><code class="java">@Componentpublic class DataInterceptor implements HandlerInterceptor &#123;    @Resource    private DataService dataService;    @Resource    private HostHolder holder;    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;        //统计UV        String ip=request.getRemoteHost();        dataService.recordUV(ip);        //统计DAU        User user = holder.getUser();        if(user!=null)&#123;            dataService.recordDAU(user.getId());        &#125;        return true;    &#125;&#125;</code></pre><h2 id="3-表现层"><a href="#3-表现层" class="headerlink" title="3.表现层"></a>3.表现层</h2><pre><code class="java">@Controllerpublic class DataController &#123;    @Resource    private DataService dataService;    @RequestMapping(path = &quot;/data&quot;,method = &#123;RequestMethod.GET,RequestMethod.POST&#125;)    public String getDataPage()&#123;        return &quot;/site/admin/data&quot;;    &#125;    //统计UV情况    @PostMapping(&quot;/data/uv&quot;)      //@DateTimeFormat指定日期格式    public String getUV(@DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;) Date start            , @DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;) Date end, Model model)&#123;        long uv = dataService.calculateUV(start, end);        model.addAttribute(&quot;uv&quot;,uv);        model.addAttribute(&quot;uvStartDate&quot;,start);        model.addAttribute(&quot;uvEndDate&quot;,end);        return &quot;forward:/data&quot;;    &#125;    //统计网站DAU    @PostMapping(&quot;/data/dau&quot;)    public String getDAU(@DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;) Date start            , @DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;) Date end, Model model)&#123;        long dau = dataService.calculateDAU(start, end);        model.addAttribute(&quot;dau&quot;,dau);        model.addAttribute(&quot;dauStartDate&quot;,start);        model.addAttribute(&quot;dauEndDate&quot;,end);        return &quot;forward:/data&quot;;    &#125;&#125;</code></pre><h1 id="三十二-任务调度与执行"><a href="#三十二-任务调度与执行" class="headerlink" title="三十二.任务调度与执行"></a>三十二.任务调度与执行</h1><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230228190138987.png" alt="image-20230228190138987"></p><h1 id="三十三-热帖排行"><a href="#三十三-热帖排行" class="headerlink" title="三十三.热帖排行"></a>三十三.热帖排行</h1><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230228194831352.png" alt="image-20230228194831352"></p><p>使用quartz进行分布式任务调度</p><p>quartz第一次运行时会将配置信息读入到数据库中,之后会从数据库中读取,不再从配置信息中读取</p><h2 id="1-引入pom文件"><a href="#1-引入pom文件" class="headerlink" title="1.引入pom文件:"></a>1.引入pom文件:</h2><pre><code class="xml">&lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-quartz --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-quartz&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><h2 id="2-编写任务类"><a href="#2-编写任务类" class="headerlink" title="2.编写任务类:"></a>2.编写任务类:</h2><p>按照上面给的分数公式计算. 每次加精,评论,点赞都会让帖子分数增加.所以我们在处理这些请求的方法中将帖子id加入到redis中(加入到set集合中). 每过一段时间利用quartz定时计算帖子的分数:</p><pre><code class="java">//计算帖子分数String postScoreKey = redisKeyUtil.getPostScoreKey();redisTemplate.opsForSet().add(postScoreKey,post.getId());</code></pre><p>具体的逻辑:</p><pre><code class="java">public class PostScoreRefreshJob implements Job, CommunityConstant &#123;    private Logger logger= LoggerFactory.getLogger(PostScoreRefreshJob.class);    @Resource    private RedisTemplate redisTemplate;    @Resource    private DiscussPostService discussPostService;    @Resource    private LikeService likeService;    @Resource    private ElasticSearchService elasticSearchService;    //牛客纪元    private static final Date epoch;    static &#123;        try &#123;            epoch=new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;).parse(&quot;2014-08-01 00:00:00&quot;);        &#125; catch (ParseException e) &#123;            throw new RuntimeException(&quot;初始化牛客纪元失败&quot;);        &#125;    &#125;    //统计分数    @Override    public void execute(JobExecutionContext jobExecutionContext) throws JobExecutionException &#123;        String postScoreKey = redisKeyUtil.getPostScoreKey();        BoundSetOperations Operations=redisTemplate.boundSetOps(postScoreKey);        //没有任何变化        if(Operations.size()==0)&#123;            logger.info(&quot;任务取消,没有需要刷新的帖子&quot;);            return;        &#125;        logger.info(&quot;[任务开始],正在刷新帖子分数:&quot;+Operations.size());        while (Operations.size()&gt;0)&#123;            //刷新帖子的分数            this.refresh((Integer)Operations.pop());        &#125;        logger.info(&quot;[任务结束]帖子分数刷新完毕&quot;);    &#125;    private void refresh(int postId)&#123;        DiscussPost post = discussPostService.selectDiscussPostById(postId);        if(post==null)&#123;            logger.error(&quot;该帖子不存在: id=&quot;+postId);            return;        &#125;        //是否加精        boolean wonderful = post.getStatus() == 1;        //评论数量        int commentCount = post.getCommentCount();        //点赞数量        long likeCount = likeService.findEntityLikeCount(ENTITY_TYPE_POST, postId);        //计算权重        double w=(wonderful?75:0)+commentCount*10+likeCount*2;        //分数=帖子的权重加上距离天数        double score=Math.log10(Math.max(w,1))                +(post.getCreateTime().getTime()-epoch.getTime())/(1000*60*60*24);        //更新帖子分数        discussPostService.updateScore(postId,score);        //同步es        post.setScore(score);        elasticSearchService.saveDiscussPost(post);    &#125;&#125;</code></pre><h2 id="3-编写配置类"><a href="#3-编写配置类" class="headerlink" title="3.编写配置类"></a>3.编写配置类</h2><pre><code class="java">//配置刷新帖子分数任务@Beanpublic JobDetailFactoryBean postScoreRefreshJobDetail()&#123;    JobDetailFactoryBean factoryBean=new JobDetailFactoryBean();    factoryBean.setJobClass(PostScoreRefreshJob.class);    factoryBean.setName(&quot;postScoreRefreshJob&quot;);    factoryBean.setGroup(&quot;communityJobGroup&quot;);    //任务是长久保存    factoryBean.setDurability(true);    //任务是否是可恢复的    factoryBean.setRequestsRecovery(true);    return factoryBean;&#125;//                      简单                      复杂//配置trigger(SimpleTriggerFactoryBean or CronTriggerFactoryBean)@Beanpublic SimpleTriggerFactoryBean postScoreRefreshTrigger(JobDetail postScoreRefreshJobDetail)&#123;    SimpleTriggerFactoryBean stfb=new SimpleTriggerFactoryBean();    stfb.setJobDetail(postScoreRefreshJobDetail);    stfb.setName(&quot;postScoreRefreshTrigger&quot;);    stfb.setGroup(&quot;communityTriggerGroup&quot;);    //五分钟执行一遍    stfb.setRepeatInterval(1000*60*5);    stfb.setJobDataMap(new JobDataMap());    return stfb;&#125;</code></pre><h2 id="4-重构帖子查询逻辑"><a href="#4-重构帖子查询逻辑" class="headerlink" title="4.重构帖子查询逻辑"></a>4.重构帖子查询逻辑</h2><p>现在就需要加判断是佛需要按照score排序的逻辑了</p><pre><code class="java">//查询评论,带有分页List&lt;DiscussPost&gt;selectDiscussPosts(int userId,int offset,int limit,int orderMode);</code></pre><pre><code class="xml">&lt;select id=&quot;selectDiscussPosts&quot; resultType=&quot;DiscussPost&quot;&gt;    select &lt;include refid=&quot;selectFields&quot;&gt;&lt;/include&gt;    from discuss_post    where status!=2    &lt;if test=&quot;userId!=0&quot;&gt;        and user_id=#&#123;userId&#125;    &lt;/if&gt;    &lt;if test=&quot;orderMode==0&quot;&gt;        order by type desc,create_time desc    &lt;/if&gt;    &lt;if test=&quot;orderMode==1&quot;&gt;        order by type desc,score desc,create_time desc    &lt;/if&gt;    limit #&#123;offset&#125;,#&#123;limit&#125;&lt;/select&gt;</code></pre><p>orderMode在请求地址的查询参数中:</p><pre><code class="java">@RequestMapping(path = &quot;/index&quot;,method = RequestMethod.GET)public String getIndexPage(Model model, Page page,@RequestParam(name = &quot;orderMode&quot;,defaultValue = &quot;0&quot;) int orderMode)&#123;</code></pre><pre><code class="html">&lt;li class=&quot;nav-item&quot;&gt;   &lt;a th:class=&quot;|nav-link $&#123;orderMode==1?&#39;active&#39;:&#39;&#39;&#125;|&quot; th:href=&quot;@&#123;/index(orderMode=1)&#125;&quot;&gt;最热&lt;/a&gt;&lt;/li&gt;</code></pre><h1 id="三十四-生成长图"><a href="#三十四-生成长图" class="headerlink" title="三十四.生成长图"></a>三十四.生成长图</h1><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230301133515711.png" alt="image-20230301133515711"></p><p>下载完安装包之后,可以在控制台直接输入即可将网址内容保存为pdf</p><pre><code class="shell">wkhtmltopdf 网址 存储地址</code></pre><p>同理:</p><pre><code>wkhtmltoimage 网址 存储地址</code></pre><p>保存为图像</p><p>使用java</p><pre><code class="java">@GetMapping(&quot;/share&quot;)@ResponseBody//查询参数为(?htmlUrl=www.xxx....)public String share(String htmlUrl)&#123;    //文件名    String filename = CommunityUtil.generateUUID();    //异步生成长图    Event event=new Event()            .setTopic(TOPIC_Share)            .setData(&quot;htmlUrl&quot;,htmlUrl)            .setData(&quot;filename&quot;,filename)            .setData(&quot;suffix&quot;,&quot;.png&quot;);    eventProducer.fireEvent(event);    //返回访问路径    Map&lt;String,Object&gt;map=new HashMap&lt;&gt;();    //map.put(&quot;setUrl&quot;,domain+context+&quot;/share/image/&quot;+filename);    map.put(&quot;setUrl&quot;,shareBucketUrl+&quot;/&quot;+filename);    return CommunityUtil.getJsonString(0,null,map);&#125;</code></pre><pre><code class="java">//废弃@GetMapping(&quot;/share/image/&#123;filename&#125;&quot;)public void getSetImage(@PathVariable(&quot;filename&quot;)String filename, HttpServletResponse response)  &#123;    if(StringUtils.isBlank(filename))&#123;        throw new IllegalArgumentException(&quot;文件名不能为空&quot;);    &#125;    response.setContentType(&quot;image/png&quot;);    File file = new File(storage + &quot;/&quot; + filename + &quot;.png&quot;);    try &#123;        OutputStream outputStream = response.getOutputStream();        FileInputStream fis=new FileInputStream(file);        byte[] buffer=new byte[1024];        int flag=0;        while((flag=fis.read(buffer))!=-1)&#123;            outputStream.write(buffer,0,flag);        &#125;            &#125; catch (IOException e) &#123;        logger.error(&quot;获取长图失败: &quot;+e.getMessage());    &#125;&#125;</code></pre><h1 id="三十五-将文件上传至服务器"><a href="#三十五-将文件上传至服务器" class="headerlink" title="三十五.将文件上传至服务器"></a>三十五.将文件上传至服务器</h1><p>​<img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230301151854517.png" alt="image-20230301151854517"></p><p>​申请七牛云的对象存储权限之后进行配置:</p><pre><code class="properties">#qiniuqiniu.key.acess=-FpCBBfKorbxyem5I4UmOlHFxnwpDvhe8HpaZM_-qiniu.key.secret=AxeHBUcTxreXioMLI16uZcte9c4cAwszZF5g7aBjqiniu.bucket.header.name=dylan-newcodeqiniu.bucket.header.url=http://rqu0l3xtz.hn-bkt.clouddn.comqiniu.bucket.share.name=dylan-newcode-shareqiniu.bucket.share.url=http://rqu0rpjdh.hd-bkt.clouddn.com</code></pre><h2 id="1-将头像上传到七牛云"><a href="#1-将头像上传到七牛云" class="headerlink" title="1.将头像上传到七牛云:"></a>1.将头像上传到七牛云:</h2><pre><code class="java">@LoginRequired@GetMapping(&quot;/setting&quot;)public String getSettingPage(Model model)&#123;    //上传文件名称    String filename = CommunityUtil.generateUUID();    //设置响应信息    StringMap police=new StringMap();    police.put(&quot;returnBody&quot;,CommunityUtil.getJsonString(0));    //上传身份凭证    Auth auth=Auth.create(accessKey,secretKey);    String uploadToken = auth.uploadToken(headerBucketName, filename, 3600, police);    //String uploadToken = auth.uploadToken(headerBucketName);    model.addAttribute(&quot;uploadToken&quot;,uploadToken);     model.addAttribute(&quot;filename&quot;,filename);         return &quot;/site/setting&quot;;&#125;</code></pre><h3 id="前端"><a href="#前端" class="headerlink" title="前端:"></a>前端:</h3><pre><code class="html">&lt;form class=&quot;mt-5&quot; id=&quot;uploadForm&quot;&gt;   &lt;div class=&quot;form-group row mt-4&quot;&gt;      &lt;label class=&quot;col-sm-2 col-form-label text-right&quot;&gt;选择头像:&lt;/label&gt;      &lt;div class=&quot;col-sm-10&quot;&gt;         &lt;div class=&quot;custom-file&quot;&gt;            &lt;input type=&quot;hidden&quot; name=&quot;token&quot; th:value=&quot;$&#123;uploadToken&#125;&quot;&gt;            &lt;input type=&quot;hidden&quot; name=&quot;key&quot; th:value=&quot;$&#123;filename&#125;&quot;&gt;            &lt;input type=&quot;file&quot; class=&quot;custom-file-input&quot;                  name=&quot;file&quot; id=&quot;head-image&quot; lang=&quot;es&quot; required=&quot;&quot;&gt;            &lt;label class=&quot;custom-file-label&quot; for=&quot;head-image&quot; data-browse=&quot;文件&quot;&gt;选择一张图片&lt;/label&gt;            &lt;div class=&quot;invalid-feedback&quot;&gt;               xx            &lt;/div&gt;         &lt;/div&gt;      &lt;/div&gt;   &lt;/div&gt;   &lt;div class=&quot;form-group row mt-4&quot;&gt;      &lt;div class=&quot;col-sm-2&quot;&gt;&lt;/div&gt;      &lt;div class=&quot;col-sm-10 text-center&quot;&gt;         &lt;button type=&quot;submit&quot; class=&quot;btn btn-info text-white form-control&quot;&gt;立即上传&lt;/button&gt;      &lt;/div&gt;   &lt;/div&gt;&lt;/form&gt;</code></pre><pre><code class="js">$(function()&#123;    $(&quot;#uploadForm&quot;).submit(upload);&#125;);function upload() &#123;    $.ajax(&#123;        url: &quot;http://upload-z2.qiniup.com&quot;,        method: &quot;post&quot;,        processData: false,        contentType: false,        data: new FormData($(&quot;#uploadForm&quot;)[0]),        success: function(data) &#123;            if(data &amp;&amp; data.code === 0) &#123;                // 更新头像访问路径                $.post(                    CONTEXT_PATH + &quot;/user/header/url&quot;,                    &#123;&quot;filename&quot;:$(&quot;input[name=&#39;key&#39;]&quot;).val()&#125;,                    function(data) &#123;                        data = $.parseJSON(data);                        if(data.code === 0) &#123;                            window.location.reload();                        &#125; else &#123;                            alert(data.msg);                        &#125;                    &#125;                );            &#125; else &#123;                alert(&quot;上传失败!&quot;);            &#125;        &#125;    &#125;);    return false;&#125;</code></pre><h2 id="2-将分享的长图上传到云服务器"><a href="#2-将分享的长图上传到云服务器" class="headerlink" title="2.将分享的长图上传到云服务器"></a>2.将分享的长图上传到云服务器</h2><pre><code class="java">@GetMapping(&quot;/share&quot;)@ResponseBody//查询参数为(?htmlUrl=www.xxx....)public String share(String htmlUrl)&#123;    //文件名    String filename = CommunityUtil.generateUUID();    //异步生成长图    Event event=new Event()            .setTopic(TOPIC_Share)            .setData(&quot;htmlUrl&quot;,htmlUrl)            .setData(&quot;filename&quot;,filename)            .setData(&quot;suffix&quot;,&quot;.png&quot;);    eventProducer.fireEvent(event);    //返回访问路径    Map&lt;String,Object&gt;map=new HashMap&lt;&gt;();    //map.put(&quot;setUrl&quot;,domain+context+&quot;/share/image/&quot;+filename);    map.put(&quot;setUrl&quot;,shareBucketUrl+&quot;/&quot;+filename);    return CommunityUtil.getJsonString(0,null,map);&#125;</code></pre><pre><code class="java">    @Resource    private ThreadPoolTaskScheduler taskScheduler;//消费分享事件@KafkaListener(topics = &#123;TOPIC_Share&#125;)public void handleShare(ConsumerRecord record)&#123;    if(record==null||record.value()==null)&#123;        logger.error(&quot;消息的内容为空&quot;);        return;    &#125;    Event event = JSONObject.parseObject(record.value().toString(), Event.class);    if(event==null)&#123;        logger.error(&quot;消息格式错误&quot;);    &#125;    String htmlUrl =(String) event.getData().get(&quot;htmlUrl&quot;);    String filename=(String) event.getData().get(&quot;filename&quot;);    String suffix=(String) event.getData().get(&quot;suffix&quot;);    //命令字符串    String cmd=command+&quot; --quality 75 &quot;+htmlUrl+&quot; &quot;+storage+&quot;/&quot;+filename+suffix;    try &#123;        Runtime.getRuntime().exec(cmd);        logger.info(&quot;生成长图&quot;);    &#125; catch (IOException e) &#123;        logger.error(&quot;生成长图失败: &quot;+e.getMessage());    &#125;    //启用定时器,监视该图片,一旦生成了图片,就上传七牛云    uploadTask uploadTask=new uploadTask(filename,suffix);    Future future = taskScheduler.scheduleAtFixedRate(uploadTask, 500);    uploadTask.setFuture(future);&#125;class uploadTask implements Runnable&#123;    //文件名称    private String filename;    //名称后缀    private String suffix;    //启动任务的返回值,用来停止定时器    private Future future;    //开始时间    private long startTime;    //上传次数    private int count;    public void setFuture(Future future) &#123;        this.future = future;    &#125;    public uploadTask(String filename, String suffix) &#123;        this.filename = filename;        this.suffix = suffix;        this.startTime=System.currentTimeMillis();    &#125;    @Override    public void run() &#123;        //生成图片失败        if(System.currentTimeMillis()-startTime&gt;30000)&#123;            logger.error(&quot;执行时间过长,终止任务 &quot;+filename);            future.cancel(true);            return;        &#125;        //上传失败        if(count&gt;=6)&#123;            logger.error(&quot;上传次数过多,终止任务:&quot; +filename);            future.cancel(true);            return;        &#125;        String path=storage+&quot;/&quot;+filename+suffix;        File file=new File(path);        if(file.exists())&#123;            logger.info(String.format(&quot;开始第%d次上传[%s]&quot;,++count,filename));            //设置响应信息            StringMap policy = new StringMap();            policy.put(&quot;returnBody&quot;, CommunityUtil.getJsonString(0));            //生成上传凭证            Auth auth=Auth.create(accessKey,secretKey);            String uploadToken = auth.uploadToken(shareBucketName, filename, 3600, policy);            //指定上传的机房            UploadManager uploadManager=new UploadManager(new Configuration(Region.huadong()));            try &#123;                Thread.sleep(3000);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            try &#123;                //开始上传图片                Response response=uploadManager.put(                        path,filename,uploadToken,null,&quot;image&quot;+suffix,false                );                //处理响应结果                JSONObject jsonObject = JSONObject.parseObject(response.bodyString());                System.out.println(jsonObject.get(&quot;code&quot;));                if(jsonObject==null||jsonObject.get(&quot;code&quot;)==null||!jsonObject.get(&quot;code&quot;).toString().equals(&quot;0&quot;))&#123;                    logger.info(String.format(&quot;第%d上传失败[%s]&quot;,count,filename));                &#125;else&#123;                    logger.info(String.format(&quot;第%d上传成功[%s]&quot;,count,filename));                    future.cancel(true);                &#125;            &#125;catch (QiniuException e)&#123;                logger.info(String.format(&quot;第%d上传失败[%s]&quot;,count,filename));            &#125;        &#125;else&#123;            logger.info(&quot;等待图片生成 [&quot;+filename+&quot;]&quot;);        &#125;    &#125;&#125;</code></pre><p>使用spring自带的异步线程池需要配置:</p><pre><code class="java">@Configuration@EnableScheduling@EnableAsyncpublic class ThreadPoolConfig &#123;&#125;</code></pre><h1 id="三十六-优化网站的性能"><a href="#三十六-优化网站的性能" class="headerlink" title="三十六.优化网站的性能"></a>三十六.优化网站的性能</h1><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230302133451485.png" alt="image-20230302133451485"></p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230302145706823.png" alt="image-20230302145706823"></p><h1 id="三十七-总结"><a href="#三十七-总结" class="headerlink" title="三十七.总结"></a>三十七.总结</h1><h2 id="1-单元测试"><a href="#1-单元测试" class="headerlink" title="1.单元测试"></a>1.单元测试</h2><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230302150141005.png" alt="image-20230302150141005"></p><pre><code class="java">@SpringBootTest@ContextConfiguration(classes = NewCodeApplication.class)@RunWith(SpringRunner.class)public class springbootTest &#123;    @Autowired    private DiscussPostService discussPostService;    private DiscussPost data;    //测试启动前被调用一次    @BeforeClass    public static void beforeClass() &#123;        System.out.println(&quot;beforeClass&quot;);    &#125;    //测试启动后被调用一次    @AfterClass    public static void afterClass() &#123;        System.out.println(&quot;afterClass&quot;);    &#125;    //每个方法之前都会调用    //测试前创造数据    @Before    public void before() &#123;        System.out.println(&quot;before&quot;);        // 初始化测试数据        data = new DiscussPost();        data.setUserId(111);        data.setTitle(&quot;Test Title&quot;);        data.setContent(&quot;Test Content&quot;);        data.setCreateTime(new Date());        discussPostService.addDiscussPost(data);    &#125;    //每个方法之=之后都会调用    //测试后删除数据    @After    public void after() &#123;        System.out.println(&quot;after&quot;);        // 删除测试数据        discussPostService.updateStatus(data.getId(), 2);    &#125;    @Test    public void test1() &#123;        System.out.println(&quot;test1&quot;);    &#125;    @Test    public void test2() &#123;        System.out.println(&quot;test2&quot;);    &#125;    @Test    public void testFindById() &#123;        DiscussPost post = discussPostService.selectDiscussPostById(data.getId());        //断言        Assert.assertNotNull(post);        Assert.assertEquals(data.getTitle(), post.getTitle());        Assert.assertEquals(data.getContent(), post.getContent());    &#125;    @Test    public void testUpdateScore() &#123;        int rows = discussPostService.updateScore(data.getId(), 2000.00);        Assert.assertEquals(1, rows);        DiscussPost post = discussPostService.selectDiscussPostById(data.getId());        Assert.assertEquals(2000.00, post.getScore(), 2);    &#125;&#125;</code></pre><h2 id="2-项目监控"><a href="#2-项目监控" class="headerlink" title="2.项目监控"></a>2.项目监控</h2><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230302151754621.png" alt="image-20230302151754621"></p><h2 id="3-部署"><a href="#3-部署" class="headerlink" title="3.部署"></a>3.部署</h2><p>暂时跳过</p><h2 id="4-项目总结"><a href="#4-项目总结" class="headerlink" title="4.项目总结"></a>4.项目总结</h2><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230302160812156.png" alt="image-20230302160812156"></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> spring </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>手写springIOC,AOP核心原理</title>
      <link href="/2023/02/09/spring-mini/"/>
      <url>/2023/02/09/spring-mini/</url>
      
        <content type="html"><![CDATA[<h1 id="一-bean的注册以及获取"><a href="#一-bean的注册以及获取" class="headerlink" title="一.bean的注册以及获取"></a>一.bean的注册以及获取</h1><p><img src="https://gitee.com/DylanToT99/images/raw/master/images2/image-20230411142709639-16818892013251.png" alt="image-20230411142709639"></p><ol><li><p>BeanFactoy: 获取bean的工厂,定义了getBean的方法,是顶级接口</p></li><li><p>SingletonBeanRegistry: 注册单例bean的接口,由DefaultSingletonBeanFactory实现方法(主要作用为bean的缓存)</p></li><li><p>BeanDefinitionRegistry: 注册BeanDefinition的接口,由DefaultListableBeanFactory实现方法</p></li><li><p>DefaultSingletonBeanRegistry: 实现了SingletonBeanRegistry,并维护了一个单例对象的一级缓存singletonObjects</p><pre><code class="java">    //单例变量的一级缓存    private final Map&lt;String,Object&gt;singletonObjects=new HashMap&lt;&gt;();    @Override    public Object getSingleTon(String beanName) &#123;        return singletonObjects.get(beanName);    &#125;    //添加单例变量到一级缓存中    protected void addSingleton(String beanName, Object singletonObject) &#123;        singletonObjects.put(beanName, singletonObject);    &#125;</code></pre></li><li><p>AbstractBeanFactory: 抽象bean工厂, 继承了DefaultSingletonBeanRegistry,实现了BeanFactory接口,利用模板方法目视定义了getBean方法: 该类为集成单例bean缓存和getBean的桥接类</p></li></ol><pre><code class="java">@Overridepublic Object getBean(String name) throws BeansException &#123;    Object singleTon = getSingleTon(name);    if(singleTon!=null)&#123;        return singleTon;    &#125;    //一级缓存中找不到就从beanDefinitionMap中取    BeanDefinition beanDefinition = getBeanDefinition(name);    return createBean(name,beanDefinition);&#125;protected abstract BeanDefinition getBeanDefinition(String beanName)throws BeansException;protected abstract Object createBean(String beanName,BeanDefinition beanDefinition)throws BeansException;</code></pre><ol start="6"><li><p>AbstractAutowireCapableBeanFactory继承了AbstractBeanFactory,并且实现了抽象方法createBean(String beanName, BeanDefinition beanDefinition)</p></li><li><p>DefaultListableBeanFactory继承了AbstractAutowireCapableBeanFactory,实现了BeanDefinitionRegistry,bean的信息(beanDefinition)的定义注册,以及bean的获取都可以该类完成.</p></li></ol><h1 id="二-基于Cglib实现含构造函数的类实例化策略"><a href="#二-基于Cglib实现含构造函数的类实例化策略" class="headerlink" title="二.基于Cglib实现含构造函数的类实例化策略"></a>二.基于Cglib实现含构造函数的类实例化策略</h1><p>由于之前我们的BeanFactory只能接受无参的构造器创造bean,这显然是不够的</p><p>现在我们引入CGLib来帮助实现自动创建带参数的构造器的bean的创建</p><h2 id="基于CGlib的自动创建bean的方式"><a href="#基于CGlib的自动创建bean的方式" class="headerlink" title="基于CGlib的自动创建bean的方式:"></a>基于CGlib的自动创建bean的方式:</h2><pre><code class="java">public class CglibSubclassingInstantiationStrategy implements InstantiationStrategy&#123;    //使用cglib实例化bean    @Override    public Object instantiate(String beanName, BeanDefinition beanDefinition, Constructor ctor, Object[] args) throws BeansException &#123;        //获取增强类        Enhancer enhancer=new Enhancer();        //设置类信息        enhancer.setSuperclass(beanDefinition.getBeanClass());        //回调方法        enhancer.setCallback(new NoOp() &#123;            @Override            public int hashCode() &#123;                return super.hashCode();            &#125;        &#125;);        if(ctor==null)&#123;            //如果构造器为空,那么就直接无参构造            return enhancer.create();        &#125;        //使用有参构造器进行构造        return enhancer.create(ctor.getParameterTypes(),args);    &#125;&#125;</code></pre><h2 id="基于JDK的方式"><a href="#基于JDK的方式" class="headerlink" title="基于JDK的方式"></a>基于JDK的方式</h2><pre><code class="java">public class SimpleInstantiationStrategy implements InstantiationStrategy&#123;    /**     *     * @param beanName     * @param beanDefinition     * @param ctor     * @param args     * @return     * @throws BeansException     * 首先通过 beanDefinition 获取 Class 信息，这个 Class 信息是在 Bean 定义的时候传递进去的。     * 接下来判断 ctor 是否为空，如果为空则是无构造函数实例化，否则就是需要有构造函数的实例化。     * 这里我们重点关注有构造函数的实例化，     * 实例化方式为 clazz.getDeclaredConstructor(ctor.getParameterTypes()).newInstance(args);，把入参信息传递给 newInstance 进行实例化。     */    @Override    public Object instantiate(String beanName, BeanDefinition beanDefinition, Constructor ctor, Object[] args) throws BeansException &#123;        Class beanClass = beanDefinition.getBeanClass();        try &#123;            if(ctor!=null)&#123;                return beanClass.getDeclaredConstructor(ctor.getParameterTypes()).newInstance(args);            &#125;else &#123;                return beanClass.getDeclaredConstructor().newInstance();            &#125;        &#125;catch (NoSuchMethodException | InstantiationException | IllegalAccessException | InvocationTargetException e)&#123;            throw new BeansException(&quot;Failed to instantiate [&quot; + beanClass.getName() + &quot;]&quot;, e);        &#125;    &#125;&#125;</code></pre><h1 id="三-为Bean对象注入属性和依赖Bean的功能实现"><a href="#三-为Bean对象注入属性和依赖Bean的功能实现" class="headerlink" title="三.为Bean对象注入属性和依赖Bean的功能实现"></a>三.为Bean对象注入属性和依赖Bean的功能实现</h1><p>添加了BeanReference表示bean之间的引用,PropertyValue表示bean的属性值,PropertyValues表示属性值的包装</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images2/spring-5-01.png" alt="img5515020"></p><h2 id="BeanReference"><a href="#BeanReference" class="headerlink" title="BeanReference"></a>BeanReference</h2><pre><code class="java">/** * @author Dylan * @version 1.0 * @date 2023/4/11 15:45 * @description bean之间的引用 **/public class BeanReference &#123;    private final String name;    public BeanReference(String name) &#123;        this.name = name;    &#125;    public String getName() &#123;        return name;    &#125;&#125;</code></pre><h2 id="PropertyValue"><a href="#PropertyValue" class="headerlink" title="PropertyValue"></a>PropertyValue</h2><pre><code class="java">/** * @author Dylan * @version 1.0 * @date 2023/4/11 15:46 * @description TODO **/public class PropertyValue &#123;    private final String name;    private final Object value;    public PropertyValue(String name, Object value) &#123;        this.name = name;        this.value = value;    &#125;    public String getName() &#123;        return name;    &#125;    public Object getValue() &#123;        return value;    &#125;&#125;</code></pre><h2 id="PropertyValues"><a href="#PropertyValues" class="headerlink" title="PropertyValues"></a>PropertyValues</h2><pre><code class="java">/** * @author Dylan * @version 1.0 * @date 2023/4/11 15:47 * @description 属性值的包装类 **/public class PropertyValues &#123;    private final List&lt;PropertyValue&gt;list=new ArrayList&lt;&gt;();    public void addPropertyValue(PropertyValue pv)&#123;        list.add(pv);    &#125;    public PropertyValue[] getPropertyValues() &#123;        return this.list.toArray(new PropertyValue[0]);    &#125;    public PropertyValue getPropertyValue(String propertyName) &#123;        for (PropertyValue pv : this.list) &#123;            if (pv.getName().equals(propertyName)) &#123;                return pv;            &#125;        &#125;        return null;    &#125;&#125;</code></pre><h2 id="修改AbstractAutowireCapableBeanFactory的createBean方法-将属性注入的功能添加上"><a href="#修改AbstractAutowireCapableBeanFactory的createBean方法-将属性注入的功能添加上" class="headerlink" title="修改AbstractAutowireCapableBeanFactory的createBean方法,将属性注入的功能添加上"></a>修改AbstractAutowireCapableBeanFactory的createBean方法,将属性注入的功能添加上</h2><pre><code class="java">@Overrideprotected Object createBean(String beanName, BeanDefinition beanDefinition,Object[]args) throws BeansException &#123;    Object bean;    try &#123;        //反射创建bean对象       bean =createBeanInstance(beanDefinition,beanName,args);       //为bean填充属性        applyPropertyValues(beanName,bean,beanDefinition);    &#125; catch (Exception e)&#123;        throw new BeansException(&quot;Instantiation of bean failed&quot;,e);    &#125;    addSingleton(beanName,bean);    return bean;&#125;</code></pre><pre><code class="java">/** * bean的属性填充 * @param beanName * @param bean * @param beanDefinition */protected void applyPropertyValues(String beanName,Object bean,BeanDefinition beanDefinition)&#123;    String name=&quot;&quot;;    try &#123;        PropertyValues propertyValues = beanDefinition.getPropertyValues();        //如果bean没有参数的话,直接跳过        if(propertyValues==null)&#123;            return;        &#125;        //填充参数        for (PropertyValue propertyValue : propertyValues.getPropertyValues()) &#123;            name = propertyValue.getName();            Object value = propertyValue.getValue();            if(value instanceof BeanReference)&#123;                //A依赖B,获取B的实例化                BeanReference beanReference=(BeanReference) value;                value=getBean(beanReference.getName());            &#125;            //属性填充            BeanUtil.setFieldValue(bean,name,value);        &#125;    &#125;catch (Exception e)&#123;        throw new BeansException(&quot;Error setting property values：&quot; + beanName+&quot;,setting &quot;+name+&quot; error&quot;);    &#125;&#125;</code></pre><h1 id="四-资源加载器的实现"><a href="#四-资源加载器的实现" class="headerlink" title="四.资源加载器的实现"></a>四.资源加载器的实现</h1><p><img src="https://gitee.com/DylanToT99/images/raw/master/images2/spring-6-02.png" alt="imgwe1q515ewq"></p><h2 id="定义顶级接口Resource"><a href="#定义顶级接口Resource" class="headerlink" title="定义顶级接口Resource"></a>定义顶级接口Resource</h2><p>resource是获取输入流的统一入口:</p><pre><code class="java">public interface Resource &#123;    InputStream getInputStream()throws IOException;&#125;</code></pre><p>之后可以根据用途,分别定义三种实现类:</p><h3 id="类路径文件读取输入流"><a href="#类路径文件读取输入流" class="headerlink" title="类路径文件读取输入流:"></a>类路径文件读取输入流:</h3><pre><code class="java">public class ClassPathResource implements Resource&#123;    private final String path;    private ClassLoader classLoader;    public ClassPathResource(String path) &#123;        this(path, (ClassLoader) null);    &#125;    public ClassPathResource(String path, ClassLoader classLoader) &#123;        Assert.notNull(path, &quot;Path must not be null&quot;);        this.path = path;        this.classLoader = (classLoader != null ? classLoader : ClassUtils.getDefaultClassLoader());    &#125;    @Override    public InputStream getInputStream() throws IOException &#123;        InputStream inputStream = classLoader.getResourceAsStream(path);        if (inputStream==null)&#123;            throw new FileNotFoundException(                    this.path + &quot; cannot be opened because it does not exist&quot;);        &#125;        return inputStream;    &#125;&#125;</code></pre><h3 id="文件读取输入流"><a href="#文件读取输入流" class="headerlink" title="文件读取输入流"></a>文件读取输入流</h3><pre><code class="java">public class FileSystemResource implements Resource&#123;    private final File file;    private final String path;    public FileSystemResource(File file) &#123;        this.file = file;        this.path = file.getPath();    &#125;    public FileSystemResource(String path) &#123;        this.file = new File(path);        this.path = path;    &#125;    @Override    public InputStream getInputStream() throws IOException &#123;        //拿到当前类的输入流        return new FileInputStream(this.file);    &#125;    public final String getPath() &#123;        return this.path;    &#125;    &#125;</code></pre><h3 id="网络url读取输入流"><a href="#网络url读取输入流" class="headerlink" title="网络url读取输入流"></a>网络url读取输入流</h3><pre><code class="java">public class URLResource implements Resource&#123;    private final URL url;    public URLResource(URL url) &#123;        Assert.notNull(url,&quot;URL must not be null&quot;);        this.url = url;    &#125;    @Override    public InputStream getInputStream() throws IOException &#123;        URLConnection con = this.url.openConnection();        try &#123;            return con.getInputStream();        &#125;        catch (IOException ex)&#123;            if (con instanceof HttpURLConnection)&#123;                ((HttpURLConnection) con).disconnect();            &#125;            throw ex;        &#125;    &#125;&#125;</code></pre><h2 id="定义ResourceLoader顶级接口"><a href="#定义ResourceLoader顶级接口" class="headerlink" title="定义ResourceLoader顶级接口:"></a>定义ResourceLoader顶级接口:</h2><p>从给定的路径下获取resource:</p><pre><code class="java">public interface ResourceLoader &#123;    /**     * Pseudo URL prefix for loading from the class path: &quot;classpath:&quot;     */    String CLASSPATH_URL_PREFIX = &quot;classpath:&quot;;    Resource getResource(String location);&#125;</code></pre><p>默认的实现类:</p><pre><code class="java">public class DefaultResourceLoader implements ResourceLoader&#123;    @Override    public Resource getResource(String location) &#123;        Assert.notNull(location);        if (location.startsWith(CLASSPATH_URL_PREFIX))&#123;            return new ClassPathResource(location.substring(CLASSPATH_URL_PREFIX.length()));        &#125;else&#123;            try &#123;                URL url = new URL(location);                return new URLResource(url);            &#125; catch (MalformedURLException e) &#123;                return new FileSystemResource(location);            &#125;        &#125;    &#125;&#125;</code></pre><h2 id="定义BeanDefinitionReader顶级接口"><a href="#定义BeanDefinitionReader顶级接口" class="headerlink" title="定义BeanDefinitionReader顶级接口"></a>定义BeanDefinitionReader顶级接口</h2><pre><code class="java">/** * @author Dylan * @version 1.0 * @date 2023/4/12 11:06 * @description TODO **/public interface BeanDefinitionReader &#123;    BeanDefinitionRegistry getRegistry();    ResourceLoader getResourceLoader();    void loadBeanDefinitions(Resource resource) throws BeansException;    void loadBeanDefinitions(Resource... resources) throws BeansException;    void loadBeanDefinitions(String location) throws BeansException;&#125;</code></pre><p>前面两个方法是为后面三个方法服务的(获取beanDefinitionRegistry接口,当拿到beanDefinition时用来注册)</p><p>ResourceLoader则是用来加载文件内容</p><h3 id="定义抽象类AbstractBeanDefinitionReader实现该顶级接口"><a href="#定义抽象类AbstractBeanDefinitionReader实现该顶级接口" class="headerlink" title="定义抽象类AbstractBeanDefinitionReader实现该顶级接口"></a>定义抽象类AbstractBeanDefinitionReader实现该顶级接口</h3><pre><code class="java">public abstract class AbstractBeanDefinitionReader implements BeanDefinitionReader&#123;    private final BeanDefinitionRegistry beanDefinitionRegistry;    private ResourceLoader resourceLoader;    protected AbstractBeanDefinitionReader(BeanDefinitionRegistry beanDefinitionRegistry)&#123;        this(beanDefinitionRegistry,new DefaultResourceLoader());    &#125;    public AbstractBeanDefinitionReader(BeanDefinitionRegistry registry, ResourceLoader resourceLoader) &#123;        this.beanDefinitionRegistry = registry;        this.resourceLoader = resourceLoader;    &#125;    @Override    public BeanDefinitionRegistry getRegistry() &#123;        return beanDefinitionRegistry;    &#125;    @Override    public ResourceLoader getResourceLoader() &#123;        return resourceLoader;    &#125;&#125;</code></pre><p>该抽象类实现了前两个方法</p><h3 id="定义XmlBeanDefinitionReader实现类"><a href="#定义XmlBeanDefinitionReader实现类" class="headerlink" title="定义XmlBeanDefinitionReader实现类"></a>定义XmlBeanDefinitionReader实现类</h3><pre><code class="java">public class XmlBeanDefinitionReader extends AbstractBeanDefinitionReader &#123;    public XmlBeanDefinitionReader(BeanDefinitionRegistry beanDefinitionRegistry) &#123;        super(beanDefinitionRegistry);    &#125;    public XmlBeanDefinitionReader(BeanDefinitionRegistry registry, ResourceLoader resourceLoader) &#123;        super(registry, resourceLoader);    &#125;    @Override    public void loadBeanDefinitions(Resource resource) throws BeansException &#123;        try( InputStream inputStream = resource.getInputStream();) &#123;           doLoadBeanDefinitions(inputStream);        &#125;catch (IOException | ClassNotFoundException e)&#123;            throw new BeansException(&quot;IOException parsing XML document from &quot; + resource, e);        &#125;    &#125;    @Override    public void loadBeanDefinitions(Resource... resources) throws BeansException &#123;        for (Resource resource : resources) &#123;            loadBeanDefinitions(resource);        &#125;    &#125;    @Override    public void loadBeanDefinitions(String location) throws BeansException &#123;        ResourceLoader resourceLoader = getResourceLoader();        Resource resource = resourceLoader.getResource(location);        loadBeanDefinitions(resource);    &#125;    protected void doLoadBeanDefinitions(InputStream inputStream)throws ClassNotFoundException&#123;        Document document = XmlUtil.readXML(inputStream);        Element root = document.getDocumentElement();        NodeList childNodes = root.getChildNodes();        for (int i = 0; i &lt; childNodes.getLength(); i++) &#123;            //判断元素            if(!(childNodes.item(i) instanceof Element))continue;            //判断对象            if(!&quot;bean&quot;.equals(childNodes.item(i).getNodeName()))continue;            //解析标签            Element bean = (Element) childNodes.item(i);            String id = bean.getAttribute(&quot;id&quot;);            String name = bean.getAttribute(&quot;name&quot;);            String className = bean.getAttribute(&quot;class&quot;);            Class&lt;?&gt; aClass = Class.forName(className);            //优先级: id&gt;name            String beanName=StrUtil.isNotEmpty(id)?id:name;            if(StrUtil.isEmpty(beanName))&#123;                //bean的名字为首位小写                beanName=StrUtil.lowerFirst(aClass.getSimpleName());            &#125;            //定义bean            BeanDefinition beanDefinition = new BeanDefinition(aClass);            for (int j = 0; j &lt; bean.getChildNodes().getLength(); j++) &#123;                if (!(bean.getChildNodes().item(j) instanceof Element)) continue;                if (!&quot;property&quot;.equals(bean.getChildNodes().item(j).getNodeName())) continue;                // 解析标签：property                Element element=(Element) bean.getChildNodes().item(j);                String attrName = element.getAttribute(&quot;name&quot;);                String attrValue = element.getAttribute(&quot;value&quot;);                String attrRef = element.getAttribute(&quot;ref&quot;);                //获取属性值                Object value = StrUtil.isNotEmpty(attrRef) ? new BeanReference(attrRef) : attrValue;                //创建属性信息                PropertyValue propertyValue=new PropertyValue(attrName,value);                beanDefinition.getPropertyValues().addPropertyValue(propertyValue);            &#125;            if (getRegistry().containsBeanDefinition(beanName))&#123;                throw new BeansException(&quot;重复创建&quot;+beanName);            &#125;            //注册            getRegistry().registerBeanDefinition(beanName,beanDefinition);        &#125;    &#125;&#125;</code></pre><h1 id="五-实现应用上下文"><a href="#五-实现应用上下文" class="headerlink" title="五.实现应用上下文"></a>五.实现应用上下文</h1><p>在对容器中 Bean 的实例化过程添加扩展机制的同时，还需要把目前关于 Spring.xml 初始化和加载策略进行优化，因为我们不太可能让面向 Spring 本身开发的 <code>DefaultListableBeanFactory</code> 服务，直接给予用户使用。修改点如下：</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images2/spring-7-01.png" alt="imgweq1e4w6qe1"></p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images2/ClassPathXmlApplicationContext.png" alt="imagewe1q451we1q"></p><p>可以看出applicationContext只是实现了BeanFactory接口,并没有实现加载配置文件的功能.而真正做出串联起加载[配置文件和注册bean的功能是抽象类AbstractApplicationContext,它使用了模板方法模式,规定了几个方法的执行顺序. 并将具体的实现交给子类</p><pre><code class="java"> @Override    public void refresh() throws BeansException &#123;        //创建beanFactory并加载BeanDefinition---&gt;由子类完成        refreshBeanFactory();        //获取beanFactory    ---&gt;由子类完成        ConfigurableListableBeanFactory beanFactory = getBeanFactory();        // 3. 在 Bean 实例化之前，执行 BeanFactoryPostProcessor (Invoke factory processors registered as beans in the context.)        invokeBeanFactoryPostProcessors(beanFactory);        // 4. BeanPostProcessor 需要提前于其他 Bean 对象实例化之前执行注册操作        registerBeanPostProcessors(beanFactory);        //提前创建单例bean        beanFactory.preInstantiateSingletons();    &#125;</code></pre><p>抽象类AbstractRefreshableApplicationContext继承了AbstractApplicationContext并实现了refreshBeanFactory:</p><pre><code class="java">    private DefaultListableBeanFactory beanFactory;    //加载BeanFactory    @Override    protected void refreshBeanFactory() throws BeansException &#123;        //创建beanFactory的方法        DefaultListableBeanFactory beanFactory = createBeanFactory();        //从资源中加载配置文件---&lt;交由子类完成        loadBeanDefinitions(beanFactory);        this.beanFactory=beanFactory;    &#125;    private DefaultListableBeanFactory createBeanFactory()&#123;        return new DefaultListableBeanFactory();    &#125;    protected abstract void loadBeanDefinitions(DefaultListableBeanFactory beanFactory);    @Override    public DefaultListableBeanFactory getBeanFactory() &#123;        return beanFactory;    &#125;</code></pre><p>抽象类AbstractXmlApplicationContext继续继承AbstractRefreshableApplicationContext,实现其交代下来的loadBeanDefinitions.并定义了一个抽象方法getConfigLocations交由子类完成,其作用是拿到配置文件的路径信息</p><pre><code class="java">@Overrideprotected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) &#123;    XmlBeanDefinitionReader beanDefinitionReader=new XmlBeanDefinitionReader(beanFactory,this);    String[] configLocations = getConfigLocations();    if(configLocations!=null)&#123;        beanDefinitionReader.loadBeanDefinitions(configLocations);    &#125;&#125;protected abstract String[]getConfigLocations();</code></pre><p>ClassPathXmlApplicationContext是最后的实现类,继承了AbstractXmlApplicationContext,其实现了最后一个抽象方法getConfigLocations(),将</p><p>加载文件资源和注册bean的功能集成到了一起.</p><h1 id="六-初始化和销毁方法"><a href="#六-初始化和销毁方法" class="headerlink" title="六.初始化和销毁方法"></a>六.初始化和销毁方法</h1><p>当我们的类创建的 Bean 对象，交给 Spring 容器管理以后，这个类对象就可以被赋予更多的使用能力。就像我们在上一章节已经给类对象添加了修改注册Bean定义未实例化前的属性信息修改和初始化过程中的前置和后置处理，这些额外能力的实现，都可以让我们对现有工程中的类对象做相应的扩展处理。</p><p>那么除此之外我们还希望可以在 Bean 初始化过程，执行一些操作。比如帮我们做一些数据的加载执行，链接注册中心暴露RPC接口以及在Web程序关闭时执行链接断开，内存销毁等操作。<em>如果说没有Spring我们也可以通过构造函数、静态方法以及手动调用的方式实现，但这样的处理方式终究不如把诸如此类的操作都交给 Spring 容器来管理更加合适。</em> 因此你会看到到 spring.xml 中有如下操作：</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images2/spring-8-02-16818892568073.png" alt="imweqwqE4g"></p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images2/spring-8-03-16818892607615.png" alt="img1684we8q051weq"></p><p>销毁方法和初始化方法都在xml文件中定义,因此加载xml文件资源时需要加载这些内容到beanDefinition中.</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images2/image-20230412160500276-16818892666807.png" alt="image-20230412160500276"></p><p>将方法信息注册到BeanDefinition中之后,注册BeanDefinition;</p><pre><code class="java">//注册getRegistry().registerBeanDefinition(beanName,beanDefinition);</code></pre><p>之后在创建单例bean的时候,会在合适的时机执行相应的方法.</p><pre><code class="java"> @Override    protected Object createBean(String beanName, BeanDefinition beanDefinition,Object[]args) throws BeansException &#123;        Object bean;        try &#123;            //反射创建bean对象           bean =createBeanInstance(beanDefinition,beanName,args);           //为bean填充属性            applyPropertyValues(beanName,bean,beanDefinition);            //执行bean的初始化方法            //这个方法也会判断bean是否实现了BeanPostProcessor和DisposableBean,若实现了就会在相应的步骤上执行实现的方法            initializeBean(beanName,bean,beanDefinition);        &#125; catch (Exception e)&#123;            throw new BeansException(&quot;Instantiation of bean failed&quot;,e);        &#125;        // 注册实现了 DisposableBean 接口的 Bean 对象        registerDisposableBeanIfNecessary(beanName,bean,beanDefinition);                addSingleton(beanName,bean);        return bean;    &#125;</code></pre><pre><code class="java"> //注册需要销毁的bean    protected void registerDisposableBeanIfNecessary(String beanName,Object bean,BeanDefinition beanDefinition)&#123;        if(bean instanceof DisposableBean|| StrUtil.isNotEmpty(beanDefinition.getDestroyMethodName()))&#123;            registerDisposableBean(beanName,new DisposableBeanAdapter(bean,beanName,beanDefinition));        &#125;    &#125;</code></pre><pre><code class="java">private Object initializeBean(String beanName, Object bean, BeanDefinition beanDefinition) throws Exception &#123;    // 1. 执行 BeanPostProcessor Before 处理    Object wrappedBean = applyBeanPostProcessorsBeforeInitialization(bean, beanName);    //invokeInitMethods(beanName, wrappedBean, beanDefinition);    invokeInitMethods(beanName, wrappedBean, beanDefinition);    // 2. 执行BeanPostProcessor After 处理    wrappedBean = applyBeanPostProcessorsAfterInitialization(bean, beanName);    return wrappedBean;&#125;</code></pre><p>在AbstractApplicationContext中的registerShutdownHook生命周期钩子:</p><pre><code class="java">    @Override    public void registerShutdownHook() &#123;        System.out.println(&quot;close&quot;);        //程序结束后执行该方法        Runtime.getRuntime().addShutdownHook(new Thread(this::close));    &#125;    @Override    public void close() &#123;        //销毁所有待销毁的对象        getBeanFactory().destroySingletons();    &#125;</code></pre><pre><code class="java">@Overridepublic void destroySingletons() &#123;    Set&lt;String&gt; keySet = this.disposableBeans.keySet();    Object[] disposableBeanNames = keySet.toArray();    for (int i = disposableBeanNames.length - 1; i &gt;= 0; i--) &#123;        Object beanName = disposableBeanNames[i];        DisposableBean disposableBean = disposableBeans.remove(beanName);        try &#123;            disposableBean.destroy();        &#125; catch (Exception e) &#123;            throw new BeansException(&quot;Destroy method on bean with name &#39;&quot; + beanName + &quot;&#39; threw an exception&quot;, e);        &#125;    &#125;&#125;</code></pre><h1 id="七-Aware接口感知bean的基本信息"><a href="#七-Aware接口感知bean的基本信息" class="headerlink" title="七.Aware接口感知bean的基本信息"></a>七.Aware接口感知bean的基本信息</h1><p>如果说我希望拿到 Spring 框架中一些提供的资源，那么首先需要考虑以一个什么方式去获取，之后你定义出来的获取方式，在 Spring 框架中该怎么去承接，实现了这两项内容，就可以扩展出你需要的一些属于 Spring 框架本身的能力了。</p><p>在关于 Bean 对象实例化阶段我们操作过一些额外定义、属性、初始化和销毁的操作，其实我们如果像获取 Spring 一些如 BeanFactory、ApplicationContext 时，也可以通过此类方式进行实现。那么我们需要定义一个标记性的接口，这个接口不需要有方法，它只起到标记作用就可以，而具体的功能由继承此接口的其他功能性接口定义具体方法，最终这个接口就可以通过 <code>instanceof</code> 进行判断和调用了。整体设计结构如下图：</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images2/spring-9-01-16818892735599.png" alt="imgwqe51564we6q20"></p><ul><li>定义接口 Aware，在 Spring 框架中它是一种感知标记性接口，具体的子类定义和实现能感知容器中的相关对象。<em>也就是通过这个桥梁，向具体的实现类中提供容器服务</em></li><li>继承 Aware 的接口包括：BeanFactoryAware、BeanClassLoaderAware、BeanNameAware和ApplicationContextAware，当然在 Spring 源码中还有一些其他关于注解的，不过目前我们还是用不到。</li><li>在具体的接口实现过程中你可以看到，一部分(<em>BeanFactoryAware、BeanClassLoaderAware、BeanNameAware</em>)在 factory 的 support 文件夹下，另外 ApplicationContextAware 是在 context 的 support 中，这是因为不同的内容获取需要在不同的包下提供。所以，在 AbstractApplicationContext 的具体实现中会用到向 beanFactory 添加 BeanPostProcessor 内容的 <code>ApplicationContextAwareProcessor</code> 操作，最后由 AbstractAutowireCapableBeanFactory 创建 createBean 时处理相应的调用操作。</li></ul><h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://gitee.com/DylanToT99/images/raw/master/images2/spring-9-02-168188927884411.png" alt="weq5165weq02"></h2><h2 id="定义包装器"><a href="#定义包装器" class="headerlink" title="定义包装器:"></a>定义包装器:</h2><pre><code class="java">public class ApplicationContextAwareProcessor implements BeanPostProcessor &#123;    private final ApplicationContext applicationContext;    public ApplicationContextAwareProcessor(ApplicationContext applicationContext) &#123;        this.applicationContext = applicationContext;    &#125;    @Override    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123;        if (bean instanceof ApplicationContextAware)&#123;            ((ApplicationContextAware) bean).setApplicationContext(applicationContext);        &#125;        return bean;    &#125;    @Override    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123;        return bean;    &#125;&#125;</code></pre><p>由于 ApplicationContext 的获取并不能直接在创建 Bean 时候就可以拿到，所以需要在 refresh 操作时，把 ApplicationContext 写入到一个包装的 BeanPostProcessor 中去，再由 AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsBeforeInitialization 方法调用。</p><p>其他的信息可以在创建bean的时候拿到,因此其他的接口则需要在AbstractAutowireCapableBeanFactory中的initializeBean方法中获取:</p><pre><code class="java">//初始化beanprivate Object initializeBean(String beanName, Object bean, BeanDefinition beanDefinition) throws Exception &#123;    //invokeAwareMethods    if(bean instanceof Aware)&#123;        if(bean instanceof BeanNameAware)&#123;            ((BeanNameAware)bean).setBeanName(beanName);        &#125;        if(bean instanceof BeanFactoryAware)&#123;            ((BeanFactoryAware)bean).setBeanFactory(this);        &#125;        if (bean instanceof BeanClassLoaderAware)&#123;            ((BeanClassLoaderAware)bean).setBeanClassLoader(getBeanClassLoader());        &#125;    &#125;    // 1. 执行 BeanPostProcessor Before 处理    Object wrappedBean = applyBeanPostProcessorsBeforeInitialization(bean, beanName);    //invokeInitMethods(beanName, wrappedBean, beanDefinition);    invokeInitMethods(beanName, wrappedBean, beanDefinition);    // 2. 执行BeanPostProcessor After 处理    wrappedBean = applyBeanPostProcessorsAfterInitialization(bean, beanName);    return wrappedBean;&#125;</code></pre><h1 id="八-对象的作用域与FactoryBean"><a href="#八-对象的作用域与FactoryBean" class="headerlink" title="八.对象的作用域与FactoryBean"></a>八.对象的作用域与FactoryBean</h1><p>关于提供一个能让使用者定义复杂的 Bean 对象，功能点非常不错，意义也非常大，因为这样做了之后 Spring 的生态种子孵化箱就此提供了，谁家的框架都可以在此标准上完成自己服务的接入。</p><p>但这样的功能逻辑设计上并不复杂，因为整个 Spring 框架在开发的过程中就已经提供了各项扩展能力的<code>接茬</code>，你只需要在合适的位置提供一个接茬的处理接口调用和相应的功能逻辑实现即可，像这里的目标实现就是对外提供一个可以二次从 FactoryBean 的 getObject 方法中获取对象的功能即可，这样所有实现此接口的对象类，就可以扩充自己的对象功能了。<em>MyBatis 就是实现了一个 MapperFactoryBean 类，在 getObject 方法中提供 SqlSession 对执行 CRUD 方法的操作</em> 整体设计结构如下图：</p><p>这样的功能逻辑设计上并不复杂，因为整个 Spring 框架在开发的过程中就已经提供了各项扩展能力的<code>接茬</code>，你只需要在合适的位置提供一个接茬的处理接口调用和相应的功能逻辑实现即可，像这里的目标实现就是对外提供一个可以二次从 FactoryBean 的 getObject 方法中获取对象的功能即可，这样所有实现此接口的对象类，就可以扩充自己的对象功能了。<em>MyBatis 就是实现了一个 MapperFactoryBean 类，在 getObject 方法中提供 SqlSession 对执行 CRUD 方法的操作</em> 整体设计结构如下图：</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images2/spring-10-01-168188928499113.png" alt="imweq451qwe20g"></p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images2/spring-10-02-168188928885015.png" alt="10wqe1454qw2e2"></p><ul><li>以上整个类关系图展示的就是添加 Bean 的实例化是单例还是原型模式以及 FactoryBean 的实现。</li><li>其实整个实现的过程并不复杂，只是在现有的 AbstractAutowireCapableBeanFactory 类以及继承的抽象类 AbstractBeanFactory 中进行扩展。</li><li>不过这次我们把 AbstractBeanFactory 继承的 DefaultSingletonBeanRegistry 类，中间加了一层 FactoryBeanRegistrySupport，这个类在 Spring 框架中主要是处理关于 FactoryBean 注册的支撑操作。</li></ul><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>bean的作用域信息被添加到了BeanDefinition中,每次创建BeanDefinition都需要设置bean的scope:</p><pre><code class="java"> protected void doLoadBeanDefinitions(InputStream inputStream) throws ClassNotFoundException &#123;              for (int i = 0; i &lt; childNodes.getLength(); i++) &#123;            // 判断元素            if (!(childNodes.item(i) instanceof Element)) continue;            // 判断对象            if (!&quot;bean&quot;.equals(childNodes.item(i).getNodeName())) continue;            // 解析标签            Element bean = (Element) childNodes.item(i);            String id = bean.getAttribute(&quot;id&quot;);            String name = bean.getAttribute(&quot;name&quot;);            String className = bean.getAttribute(&quot;class&quot;);            String initMethod = bean.getAttribute(&quot;init-method&quot;);            String destroyMethodName = bean.getAttribute(&quot;destroy-method&quot;);            String beanScope = bean.getAttribute(&quot;scope&quot;);            // 获取 Class，方便获取类中的名称            Class&lt;?&gt; clazz = Class.forName(className);            // 优先级 id &gt; name            String beanName = StrUtil.isNotEmpty(id) ? id : name;            if (StrUtil.isEmpty(beanName)) &#123;                beanName = StrUtil.lowerFirst(clazz.getSimpleName());            &#125;            // 定义Bean            BeanDefinition beanDefinition = new BeanDefinition(clazz);            beanDefinition.setInitMethodName(initMethod);            beanDefinition.setDestroyMethodName(destroyMethodName);            //设置scope            if (StrUtil.isNotEmpty(beanScope)) &#123;                beanDefinition.setScope(beanScope);            &#125;                        // ...                        // 注册 BeanDefinition            getRegistry().registerBeanDefinition(beanName, beanDefinition);        &#125;    &#125;</code></pre><p>同样,创建bean是需要根据scope判断是否需要放入缓存中,以及非单例bean不需要执行销毁方法:</p><pre><code class="java">  @Override    protected Object createBean(String beanName, BeanDefinition beanDefinition, Object[] args) throws BeansException &#123;        Object bean = null;        try &#123;            bean = createBeanInstance(beanDefinition, beanName, args);            // 给 Bean 填充属性            applyPropertyValues(beanName, bean, beanDefinition);            // 执行 Bean 的初始化方法和 BeanPostProcessor 的前置和后置处理方法            bean = initializeBean(beanName, bean, beanDefinition);        &#125; catch (Exception e) &#123;            throw new BeansException(&quot;Instantiation of bean failed&quot;, e);        &#125;        // 注册实现了 DisposableBean 接口的 Bean 对象        registerDisposableBeanIfNecessary(beanName, bean, beanDefinition);        // 判断 SCOPE_SINGLETON、SCOPE_PROTOTYPE        if (beanDefinition.isSingleton()) &#123;            addSingleton(beanName, bean);        &#125;        return bean;    &#125;    protected void registerDisposableBeanIfNecessary(String beanName, Object bean, BeanDefinition beanDefinition) &#123;        // 非 Singleton 类型的 Bean 不执行销毁方法        if (!beanDefinition.isSingleton()) return;        if (bean instanceof DisposableBean || StrUtil.isNotEmpty(beanDefinition.getDestroyMethodName())) &#123;            registerDisposableBean(beanName, new DisposableBeanAdapter(bean, beanName, beanDefinition));        &#125;    &#125;</code></pre><h2 id="FactoryBean"><a href="#FactoryBean" class="headerlink" title="FactoryBean"></a>FactoryBean</h2><pre><code class="java">public interface FactoryBean&lt;T&gt; &#123;    T getObject() throws Exception;    Class&lt;?&gt; getObjectType();    boolean isSingleton();&#125;</code></pre><p>FactoryBean 中需要提供3个方法，获取对象、对象类型，以及是否是单例对象，如果是单例对象依然会被放到内存中。</p><h3 id="实现一个-FactoryBean-注册服务"><a href="#实现一个-FactoryBean-注册服务" class="headerlink" title="实现一个 FactoryBean 注册服务"></a>实现一个 FactoryBean 注册服务</h3><pre><code class="java">public abstract class FactoryBeanRegistrySupport extends DefaultSingletonBeanRegistry &#123;    /**     * Cache of singleton objects created by FactoryBeans: FactoryBean name --&gt; object     */    private final Map&lt;String, Object&gt; factoryBeanObjectCache = new ConcurrentHashMap&lt;String, Object&gt;();    protected Object getCachedObjectForFactoryBean(String beanName) &#123;        Object object = this.factoryBeanObjectCache.get(beanName);        return (object != NULL_OBJECT ? object : null);    &#125;    protected Object getObjectFromFactoryBean(FactoryBean factory, String beanName) &#123;        if (factory.isSingleton()) &#123;            Object object = this.factoryBeanObjectCache.get(beanName);            if (object == null) &#123;                object = doGetObjectFromFactoryBean(factory, beanName);                this.factoryBeanObjectCache.put(beanName, (object != null ? object : NULL_OBJECT));            &#125;            return (object != NULL_OBJECT ? object : null);        &#125; else &#123;            return doGetObjectFromFactoryBean(factory, beanName);        &#125;    &#125;    private Object doGetObjectFromFactoryBean(final FactoryBean factory, final String beanName)&#123;        try &#123;            return factory.getObject();        &#125; catch (Exception e) &#123;            throw new BeansException(&quot;FactoryBean threw exception on object[&quot; + beanName + &quot;] creation&quot;, e);        &#125;    &#125;&#125;</code></pre><ul><li>FactoryBeanRegistrySupport 类主要处理的就是关于 FactoryBean 此类对象的注册操作，之所以放到这样一个单独的类里，就是希望做到不同领域模块下只负责各自需要完成的功能，避免因为扩展导致类膨胀到难以维护。</li><li>同样这里也定义了缓存操作 factoryBeanObjectCache，用于存放单例类型的对象，避免重复创建。<em>在日常使用用，基本也都是创建的单例对象</em></li><li>doGetObjectFromFactoryBean 是具体的获取 FactoryBean#getObject() 方法，因为既有缓存的处理也有对象的获取，所以额外提供了 getObjectFromFactoryBean 进行逻辑包装，这部分的操作方式是不和你日常做的业务逻辑开发非常相似。<em>从Redis取数据，如果为空就从数据库获取并写入Redis</em></li></ul><h3 id="扩展-AbstractBeanFactory-创建对象逻辑"><a href="#扩展-AbstractBeanFactory-创建对象逻辑" class="headerlink" title="扩展 AbstractBeanFactory 创建对象逻辑"></a>扩展 AbstractBeanFactory 创建对象逻辑</h3><pre><code class="java">public abstract class AbstractBeanFactory extends FactoryBeanRegistrySupport implements ConfigurableBeanFactory &#123;    protected &lt;T&gt; T doGetBean(final String name, final Object[] args) &#123;        Object sharedInstance = getSingleton(name);        if (sharedInstance != null) &#123;            // 如果是 FactoryBean，则需要调用 FactoryBean#getObject            return (T) getObjectForBeanInstance(sharedInstance, name);        &#125;        BeanDefinition beanDefinition = getBeanDefinition(name);        Object bean = createBean(name, beanDefinition, args);        return (T) getObjectForBeanInstance(bean, name);    &#125;         private Object getObjectForBeanInstance(Object beanInstance, String beanName) &#123;        if (!(beanInstance instanceof FactoryBean)) &#123;            return beanInstance;        &#125;        Object object = getCachedObjectForFactoryBean(beanName);        if (object == null) &#123;            FactoryBean&lt;?&gt; factoryBean = (FactoryBean&lt;?&gt;) beanInstance;            object = getObjectFromFactoryBean(factoryBean, beanName);        &#125;        return object;    &#125;            // ...&#125;</code></pre><ul><li>首先这里把 AbstractBeanFactory 原来继承的 DefaultSingletonBeanRegistry，修改为继承 FactoryBeanRegistrySupport。因为需要扩展出创建 FactoryBean 对象的能力，所以这就想一个链条服务上，截出一个段来处理额外的服务，并把链条再链接上。</li><li>此处新增加的功能主要是在 doGetBean 方法中，添加了调用 <code>(T) getObjectForBeanInstance(sharedInstance, name)</code> 对获取 FactoryBean 的操作。</li><li>在 getObjectForBeanInstance 方法中做具体的 instanceof 判断，另外还会从 FactoryBean 的缓存中获取对象，如果不存在则调用 FactoryBeanRegistrySupport#getObjectFromFactoryBean，执行具体的操作</li></ul><h1 id="九-容器事件和监听器事件"><a href="#九-容器事件和监听器事件" class="headerlink" title="九.容器事件和监听器事件"></a>九.容器事件和监听器事件</h1><p>在 Spring 中有一个 Event 事件功能，它可以提供事件的定义、发布以及监听事件来完成一些自定义的动作。比如你可以定义一个新用户注册的事件，当有用户执行注册完成后，在事件监听中给用户发送一些优惠券和短信提醒，这样的操作就可以把属于基本功能的注册和对应的策略服务分开，降低系统的耦合。以后在扩展注册服务，比如需要添加风控策略、添加实名认证、判断用户属性等都不会影响到依赖注册成功后执行的动作。</p><p>那么在本章节我们需要以观察者模式的方式，设计和实现 Spring Event 的容器事件和事件监听器功能，最终可以让我们在现有实现的 Spring 框架中可以定义、监听和发布自己的事件信息。</p><p>在功能实现上我们需要定义出事件类、事件监听、事件发布，而这些类的功能需要结合到 Spring 的 AbstractApplicationContext#refresh()，以便于处理事件初始化和注册事件监听器的操作。整体设计结构如下图：</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images2/spring-11-01-168188929660317.png" alt="imweq5616we5q0g"></p><ul><li>在整个功能实现过程中，仍然需要在面向用户的应用上下文 <code>AbstractApplicationContext</code> 中添加相关事件内容，包括：初始化事件发布者、注册事件监听器、发布容器刷新完成事件。</li><li>使用观察者模式定义事件类、监听类、发布类，同时还需要完成一个广播器的功能，接收到事件推送时进行分析处理符合监听事件接受者感兴趣的事件，也就是使用 isAssignableFrom 进行判断。</li><li>isAssignableFrom 和 instanceof 相似，不过 isAssignableFrom 是用来判断子类和父类的关系的，或者接口的实现类和接口的关系的，默认所有的类的终极父类都是Object。如果A.isAssignableFrom(B)结果是true，证明B可以转换成为A,也就是A可以由B转换而来</li></ul><h2 id="事件的定义"><a href="#事件的定义" class="headerlink" title="事件的定义"></a>事件的定义</h2><p>定义抽象事件ApplicationEvent继承于EventObject,这个事件类是顶级类,之后派生的具有各种功能的类都有这个类而生.</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images2/image-20230413171449786-168188930003119.png" alt="image-20230413171449786"></p><p>例如: ContextClosedEvent:</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images2/image-20230413171719699-168188930347121.png" alt="image-20230413171719699"></p><p>或者自定义的CustomEvent</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images2/image-20230413171805346-168188930639323.png" alt="image-20230413171805346"></p><h2 id="监听器的定义"><a href="#监听器的定义" class="headerlink" title="监听器的定义"></a>监听器的定义</h2><p>ApplicationListener继承顶级接口EventListener:</p><pre><code class="java">public interface ApplicationListener &lt;E extends ApplicationEvent&gt;extends EventListener &#123;    /**     * Handle an application event.     * @param event the event to respond to     */    void onApplicationEvent(E event);&#125;</code></pre><p>并且提供了一个触发事件的方法供具体的类去实现</p><p>例如:</p><pre><code class="java">public class CustomEventListener implements ApplicationListener&lt;CustomEvent&gt; &#123;    @Override    public void onApplicationEvent(CustomEvent event) &#123;        System.out.println(&quot;收到: &quot;+event.getSource()+&quot;消息;时间: &quot;+new Date());        System.out.println(&quot;消息: &quot;+event.getId()+&quot;: &quot;+event.getMessage());    &#125;&#125;</code></pre><h2 id="事件的发布"><a href="#事件的发布" class="headerlink" title="事件的发布"></a>事件的发布</h2><p>事件的发布由上下文实现,我们定义了一个顶级接口ApplicationEventPublisher,实现该接口的类具有发布事件的功能</p><pre><code class="java">public interface ApplicationEventPublisher &#123;    /**     * Notify all listeners registered with this application of an application     * event. Events may be framework events (such as RequestHandledEvent)     * or application-specific events.     * @param event the event to publish     */    void publishEvent(ApplicationEvent event);&#125;</code></pre><p>发布事件这一功能在抽象类AbstractApplicationContext中实现:</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images2/image-20230413172355500-168188931056825.png" alt="image-20230413172355500"></p><pre><code class="java">@Overridepublic void publishEvent(ApplicationEvent event) &#123;    applicationEventMulticaster.multicastEvent(event);&#125;</code></pre><p>它实现的逻辑就是将加载到的事件发布到事件路由器中,然后执行:</p><pre><code class="java">public class SimpleApplicationEventMulticaster extends AbstractApplicationEventMulticaster&#123;    public SimpleApplicationEventMulticaster(BeanFactory beanFactory) &#123;        setBeanFactory(beanFactory);    &#125;    @Override    public void multicastEvent(ApplicationEvent event) &#123;        for (final ApplicationListener listener : getApplicationListener(event)) &#123;            //执行事件            listener.onApplicationEvent(event);        &#125;    &#125;&#125;</code></pre><h2 id="事件广播器"><a href="#事件广播器" class="headerlink" title="事件广播器"></a>事件广播器</h2><p>事件的发布到事件被具体的监听器执行这一步骤是由广播路由的,广播由一个顶级接口ApplicationEventMulticaster实现:</p><pre><code class="java">public interface ApplicationEventMulticaster &#123;    /**     * Add a listener to be notified of all events.     * @param listener the listener to add     */    //添加监听器    void addApplicationListener(ApplicationListener&lt;?&gt; listener);    /**     * Remove a listener from the notification list.     * @param listener the listener to remove     */    void removeApplicationListener(ApplicationListener&lt;?&gt; listener);    /**     * Multicast the given application event to appropriate listeners.     * @param event the event to multicast     */    void multicastEvent(ApplicationEvent event);&#125;</code></pre><p>该接口的核心功能由AbstractApplicationEventMulticaster实现</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images2/image-20230413172659092-168188931443727.png" alt="image-20230413172659092"></p><pre><code class="java">public final Set&lt;ApplicationListener&lt;ApplicationEvent&gt;&gt; applicationListeners = new LinkedHashSet&lt;&gt;();private BeanFactory beanFactory;//添加事件监听器@Overridepublic void addApplicationListener(ApplicationListener&lt;?&gt; listener) &#123;    applicationListeners.add((ApplicationListener&lt;ApplicationEvent&gt;) listener);&#125;//移除事件监听器@Overridepublic void removeApplicationListener(ApplicationListener&lt;?&gt; listener) &#123;    applicationListeners.remove(listener);&#125;@Overridepublic final void setBeanFactory(BeanFactory beanFactory) &#123;    this.beanFactory = beanFactory;&#125;//由具体的事件,获取到该事件所属的监听器protected Collection&lt;ApplicationListener&gt;getApplicationListener(ApplicationEvent event)&#123;    LinkedList&lt;ApplicationListener&gt; allListeners = new LinkedList&lt;&gt;();    for (ApplicationListener&lt;ApplicationEvent&gt; listener : applicationListeners) &#123;        if (supportsEvent(listener, event)) allListeners.add(listener);    &#125;    return allListeners;&#125;/** * 监听器是否对该事件感兴趣---就是判断这个监听器的泛型是不是这个事件 */protected boolean supportsEvent(ApplicationListener&lt;ApplicationEvent&gt; applicationListener, ApplicationEvent event) &#123;    Class&lt;? extends ApplicationListener&gt; listenerClass = applicationListener.getClass();    // 按照 CglibSubclassingInstantiationStrategy、SimpleInstantiationStrategy 不同的实例化类型，    // 需要判断后获取目标class(被代理之前的class)    Class&lt;?&gt; targetClass = ClassUtils.isCglibProxyClass(listenerClass) ? listenerClass.getSuperclass() : listenerClass;    //拿到上层接口---&gt;ApplicationListener &lt;E extends ApplicationEvent&gt;    Type genericInterface = targetClass.getGenericInterfaces()[0];    //拿到泛型中的类的类型    Type actualTypeArgument = ((ParameterizedType) genericInterface).getActualTypeArguments()[0];    //拿到类名    String className = actualTypeArgument.getTypeName();    Class&lt;?&gt; eventClassName;    try &#123;        eventClassName = Class.forName(className);    &#125; catch (ClassNotFoundException e) &#123;        throw new BeansException(&quot;wrong event class name: &quot; + className);    &#125;    //判定此eventClassName 对象所表示的类或接口与指定的 event.getClass() 参数所表示的类或接口是否相同，或是否是其超类或超接口。    //isAssignableFrom是用来判断子类和父类的关系的，或者接口的实现类和接口的关系的，默认所有的类的终极父类都是Object。    // 如果A.isAssignableFrom(B)结果是true，证明B可以转换成为A,也就是A可以由B转换而来。    return eventClassName.isAssignableFrom(event.getClass());&#125;</code></pre><p><strong>由getApplicationListener方法完成事件到监听器的路由</strong></p><h2 id="执行逻辑"><a href="#执行逻辑" class="headerlink" title="执行逻辑"></a>执行逻辑</h2><p>在上下文的refresh()方法中,定义了事件相关类的注册和执行顺序:</p><pre><code class="java">@Overridepublic void refresh() throws BeansException &#123;    //1.创建beanFactory并加载BeanDefinition---&gt;由子类完成    refreshBeanFactory();    //2.获取beanFactory ---&gt;由子类完成    ConfigurableListableBeanFactory beanFactory = getBeanFactory();    //3.添加ApplicationContextAwareProcessor.使继承ApplicationContextAware的bean对象都能够感知所属的applicationContext    beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));    //4. 在 Bean实例化之前，执行 BeanFactoryPostProcessor    invokeBeanFactoryPostProcessors(beanFactory);    //5. BeanPostProcessor 需要提前于其他 Bean 对象实例化之前执行注册操作    registerBeanPostProcessors(beanFactory);    //6.初始化事件发布者    initApplicationEventMulticaster();    // 7. 注册事件监听器    registerListeners();    //8.提前创建单例bean    beanFactory.preInstantiateSingletons();    // 9. 发布容器刷新完成事件    finishRefresh();&#125;</code></pre><p>首先初始化事件广播器:</p><pre><code class="java">//初始化事件广播器private void initApplicationEventMulticaster() &#123;    //获取默认BeanFactory    ConfigurableListableBeanFactory beanFactory = getBeanFactory();    //创建默认事件广播器    applicationEventMulticaster = new SimpleApplicationEventMulticaster(beanFactory);    //将广播器添加到单例池中    beanFactory.registerSingleton(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, applicationEventMulticaster);&#125;</code></pre><p>再注册事件监听器:</p><pre><code class="java">//注册事件的listenerprivate void registerListeners() &#123;    //在默认的BeanFactory中,拿到class属性是ApplicationListener.class的BeanDefinition的缓存    Collection&lt;ApplicationListener&gt; applicationListeners = getBeansOfType(ApplicationListener.class).values();    for (ApplicationListener listener : applicationListeners) &#123;        //向广播中添加listener        applicationEventMulticaster.addApplicationListener(listener);    &#125;&#125;</code></pre><p>最后由上下文发布事件:</p><pre><code class="java">private void finishRefresh() &#123;    publishEvent(new ContextRefreshedEvent(this));&#125;@Override    public void publishEvent(ApplicationEvent event) &#123;        applicationEventMulticaster.multicastEvent(event);    &#125;</code></pre><h1 id="十-使用JDK-Cglib实现Aop切面"><a href="#十-使用JDK-Cglib实现Aop切面" class="headerlink" title="十.使用JDK,Cglib实现Aop切面"></a>十.使用JDK,Cglib实现Aop切面</h1><h2 id="基于JDK"><a href="#基于JDK" class="headerlink" title="基于JDK"></a>基于JDK</h2><p>这个功能我想使用自顶向下的方式叙述.</p><p>首先,切面的核心是实现代理对象. 因此,我们可以有两种创建代理对象的方式.一种是基于jdk代理,另外一种是基于Cglib代理</p><p>既然是代理对象,我们需要实现一个自定义的代理对象接口:</p><pre><code class="java">public interface AopProxy &#123;    //用于返回代理对象    Object getProxy();&#125;</code></pre><p>为了方便,让代理对象类实现InvocationHandler接口,可以直接使用代理对象调用invoke方法:</p><pre><code class="java">public class JdkDynamicAopProxy implements AopProxy, InvocationHandler &#123;    //AdvisedSupport，包装了目标对象、用户自己实现的拦截方法以及方法匹配表达式    private final AdvisedSupport advised;    public JdkDynamicAopProxy(AdvisedSupport advisedSupport)&#123;        this.advised=advisedSupport;    &#125;    //用jdk提供的方式创建代理对象    @Override    public Object getProxy() &#123;        return Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(),                advised.getTargetSource().getTargetClass(), this);    &#125;    //调用包装类中的方法拦截器对方法进行拦截,并进行增强    @Override    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;        if(advised.getMethodMatcher().matches(method,advised.getTargetSource().getTarget().getClass()))&#123;            MethodInterceptor methodInterceptor = advised.getMethodInterceptor();            return methodInterceptor.invoke(new ReflectiveMethodInvocation(advised.getTargetSource().getTarget(),                    method,args));        &#125;        return method.invoke(advised.getTargetSource().getTarget(),args);    &#125;&#125;</code></pre><p>再来看看AdvisedSupport包装类:</p><pre><code class="java">// 被代理的目标对象private TargetSource targetSource;// 方法拦截器private MethodInterceptor methodInterceptor;// 方法匹配器(检查目标方法是否符合通知条件)private MethodMatcher methodMatcher;</code></pre><p>它包装了被代理的目标对象,方法拦截器,方法匹配器. 囊括了aop的所有要素</p><h2 id="基于Cglib"><a href="#基于Cglib" class="headerlink" title="基于Cglib"></a>基于Cglib</h2><pre><code class="java">public class Cglib2AopProxy implements AopProxy&#123;    //包装类    private final AdvisedSupport advised;    public Cglib2AopProxy(AdvisedSupport advised)&#123;        this.advised=advised;    &#125;    //使用cglib提供的创建代理对象的方法    @Override    public Object getProxy() &#123;        Enhancer enhancer=new Enhancer();        enhancer.setSuperclass(advised.getTargetSource().getTarget().getClass());        enhancer.setInterfaces(advised.getTargetSource().getTargetClass());        //回调方法是自定义的私有类的重写方法        enhancer.setCallback(new DynamicAdvisedInterceptor(advised));        return enhancer.create();    &#125;    //方法拦截器    private static class DynamicAdvisedInterceptor implements MethodInterceptor&#123;        private final AdvisedSupport advised;        public DynamicAdvisedInterceptor(AdvisedSupport advised)&#123;            this.advised=advised;        &#125;        @Override        public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123;            CglibMethodInvocation methodInvocation=new CglibMethodInvocation(advised.getTargetSource().getTarget(),method,args,proxy);            //若方法匹配            if(advised.getMethodMatcher().matches(method,advised.getTargetSource().getTarget().getClass()))&#123;                //执行拦截器的方法                return advised.getMethodInterceptor().invoke(methodInvocation);            &#125;            return methodInvocation.proceed();        &#125;    &#125;    //私有类继承ReflectiveMethodInvocation    private static class CglibMethodInvocation extends ReflectiveMethodInvocation &#123;        private final MethodProxy methodProxy;        public CglibMethodInvocation(Object target, Method method, Object[] arguments, MethodProxy methodProxy) &#123;            super(target, method, arguments);            this.methodProxy = methodProxy;        &#125;        @Override        public Object proceed() throws Throwable &#123;            return this.methodProxy.invoke(this.target, this.arguments);        &#125;    &#125;&#125;</code></pre><h1 id="十一-将AOP拓展到bean的生命周期中"><a href="#十一-将AOP拓展到bean的生命周期中" class="headerlink" title="十一.将AOP拓展到bean的生命周期中"></a>十一.将AOP拓展到bean的生命周期中</h1><p>在有了一个 AOP 核心功能的实现后，我们可以通过单元测试的方式进行验证切面功能对方法进行拦截，但如果这是一个面向用户使用的功能，就不太可能让用户这么复杂且没有与 Spring 结合的方式单独使用 AOP，虽然可以满足需求，但使用上还是过去分散。</p><p>因此我们完成 AOP 核心功能与 Spring 框架的整合，最终能通过在 Spring 配置的方式完成切面的操作。</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images2/spring-13-01-168188932173329.png" alt="imgweqe232fds2"></p><ul><li>为了可以让对象创建过程中，能把xml中配置的代理对象也就是切面的一些类对象实例化，就需要用到 BeanPostProcessor 提供的方法，<strong>因为这个类的中的方法可以分别作用与 Bean 对象执行初始化前后修改 Bean 的对象的扩展信息</strong>。但这里需要集合于 BeanPostProcessor 实现新的接口和实现类，这样才能定向获取对应的类信息。</li><li>但因为创建的是代理对象不是之前流程里的普通对象，所以我们需要前置于其他对象的创建，所以在实际开发的过程中，需要在 AbstractAutowireCapableBeanFactory#createBean 优先完成 Bean 对象的判断，是否需要代理，有则直接返回代理对象。<em>在Spring的源码中会有 createBean 和 doCreateBean 的方法拆分</em></li><li>这里还包括要解决方法拦截器的具体功能，提供一些 BeforeAdvice、AfterAdvice 的实现，让用户可以更简化的使用切面功能。除此之外还包括需要包装切面表达式以及拦截方法的整合，以及提供不同类型的代理方式的代理工厂，来包装我们的切面服务。</li></ul><p>UML类图:</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images2/spring-13-02-168188932579331.png" alt="wqesad120-2"></p><ul><li>整个类关系图中可以看到，在以 BeanPostProcessor 接口实现继承的 InstantiationAwareBeanPostProcessor 接口后，做了一个自动代理创建的类 DefaultAdvisorAutoProxyCreator，这个类的就是用于处理整个 AOP 代理融入到 Bean 生命周期中的核心类。</li><li>DefaultAdvisorAutoProxyCreator 会依赖于拦截器、代理工厂和Pointcut与Advisor的包装服务 AspectJExpressionPointcutAdvisor，由它提供切面、拦截方法和表达式。</li><li>Spring 的 AOP 把 Advice 细化了 BeforeAdvice、AfterAdvice、AfterReturningAdvice、ThrowsAdvice，目前我们做的测试案例中只用到了 BeforeAdvice，这部分可以对照 Spring 的源码进行补充测试。</li></ul><h2 id="1-定义Advice拦截器链"><a href="#1-定义Advice拦截器链" class="headerlink" title="1.定义Advice拦截器链"></a>1.定义Advice拦截器链</h2><pre><code class="java">public interface BeforeAdvice extends Advice &#123;&#125;</code></pre><pre><code class="java">public interface MethodBeforeAdvice extends BeforeAdvice &#123;    /**     * Callback before a given method is invoked.     *     * @param method method being invoked     * @param args   arguments to the method     * @param target target of the method invocation. May be &lt;code&gt;null&lt;/code&gt;.     * @throws Throwable if this object wishes to abort the call.     *                   Any exception thrown will be returned to the caller if it&#39;s     *                   allowed by the method signature. Otherwise the exception     *                   will be wrapped as a runtime exception.     */    void before(Method method, Object[] args, Object target) throws Throwable;&#125;</code></pre><p>在 Spring 框架中，Advice 都是通过方法拦截器 MethodInterceptor 实现的。环绕 Advice 类似一个拦截器的链路，Before Advice、After advice等，不过暂时我们需要那么多就只定义了一个 MethodBeforeAdvice 的接口定义</p><h2 id="2-定义Advisor访问者"><a href="#2-定义Advisor访问者" class="headerlink" title="2.定义Advisor访问者"></a>2.定义Advisor访问者</h2><pre><code class="java">public interface Advisor &#123;    /**     * Return the advice part of this aspect. An advice may be an     * interceptor, a before advice, a throws advice, etc.     * @return the advice that should apply if the pointcut matches     * @see org.aopalliance.intercept.MethodInterceptor     * @see BeforeAdvice     */    Advice getAdvice();&#125;</code></pre><pre><code class="java">public interface PointcutAdvisor extends Advisor &#123;    /**     * Get the Pointcut that drives this advisor.     */    Pointcut getPointcut();&#125;</code></pre><ul><li>PointcutAdvisor 承担了 Pointcut 和 Advice 的组合，Pointcut 用于获取 JoinPoint，而 Advice 决定于 JoinPoint 执行什么操作。</li></ul><pre><code class="java">public class AspectJExpressionPointcutAdvisor implements PointcutAdvisor &#123;    // 切面    private AspectJExpressionPointcut pointcut;    // 具体的拦截方法    private Advice advice;    // 表达式    private String expression;    public void setExpression(String expression)&#123;        this.expression = expression;    &#125;    @Override    public Pointcut getPointcut() &#123;        if (null == pointcut) &#123;            pointcut = new AspectJExpressionPointcut(expression);        &#125;        return pointcut;    &#125;    @Override    public Advice getAdvice() &#123;        return advice;    &#125;    public void setAdvice(Advice advice)&#123;        this.advice = advice;    &#125;&#125;</code></pre><p>AspectJExpressionPointcutAdvisor 实现了 PointcutAdvisor 接口，把切面 pointcut、拦截方法 advice 和具体的拦截表达式包装在一起。这样就可以在 xml 的配置中定义一个 pointcutAdvisor 切面拦截器了</p><h2 id="3-方法拦截器"><a href="#3-方法拦截器" class="headerlink" title="3.方法拦截器"></a>3.方法拦截器</h2><pre><code class="java">public class MethodBeforeAdviceInterceptor implements MethodInterceptor &#123;    private MethodBeforeAdvice advice;    public MethodBeforeAdviceInterceptor(MethodBeforeAdvice advice) &#123;        this.advice = advice;    &#125;    public MethodBeforeAdvice getAdvice() &#123;        return advice;    &#125;    public void setAdvice(MethodBeforeAdvice advice) &#123;        this.advice = advice;    &#125;    @Override    public Object invoke(MethodInvocation methodInvocation) throws Throwable &#123;        this.advice.before(methodInvocation.getMethod(), methodInvocation.getArguments(), methodInvocation.getThis());        return methodInvocation.proceed();    &#125;&#125;</code></pre><ul><li>MethodBeforeAdviceInterceptor 实现了 MethodInterceptor 接口，在 invoke 方法中调用 advice 中的 before 方法，传入对应的参数信息。</li><li>而这个 advice.before 则是用于自己实现 MethodBeforeAdvice 接口后做的相应处理。</li></ul><h2 id="4-代理工厂"><a href="#4-代理工厂" class="headerlink" title="4.代理工厂"></a>4.代理工厂</h2><pre><code class="java">public class ProxyFactory &#123;    private AdvisedSupport advisedSupport;    public ProxyFactory(AdvisedSupport advisedSupport) &#123;        this.advisedSupport = advisedSupport;    &#125;    public Object getProxy() &#123;        return createAopProxy().getProxy();    &#125;    private AopProxy createAopProxy() &#123;        if (advisedSupport.isProxyTargetClass()) &#123;            return new Cglib2AopProxy(advisedSupport);        &#125;        return new JdkDynamicAopProxy(advisedSupport);    &#125;&#125;</code></pre><p>这个代理工厂主要解决的是关于 JDK 和 Cglib 两种代理的选择问题，有了代理工厂就可以按照不同的创建需求进行控制。</p><h2 id="5-融入Bean生命周期的自动代理创建者"><a href="#5-融入Bean生命周期的自动代理创建者" class="headerlink" title="5.融入Bean生命周期的自动代理创建者"></a>5.融入Bean生命周期的自动代理创建者</h2><pre><code class="java">public class DefaultAdvisorAutoProxyCreator implements InstantiationAwareBeanPostProcessor, BeanFactoryAware &#123;    private DefaultListableBeanFactory beanFactory;    @Override    public void setBeanFactory(BeanFactory beanFactory) throws BeansException &#123;        this.beanFactory = (DefaultListableBeanFactory) beanFactory;    &#125;    @Override    public Object postProcessBeforeInstantiation(Class&lt;?&gt; beanClass, String beanName) throws BeansException &#123;        if (isInfrastructureClass(beanClass)) return null;        Collection&lt;AspectJExpressionPointcutAdvisor&gt; advisors = beanFactory.getBeansOfType(AspectJExpressionPointcutAdvisor.class).values();        for (AspectJExpressionPointcutAdvisor advisor : advisors) &#123;            ClassFilter classFilter = advisor.getPointcut().getClassFilter();            if (!classFilter.matches(beanClass)) continue;            AdvisedSupport advisedSupport = new AdvisedSupport();            TargetSource targetSource = null;            try &#123;                targetSource = new TargetSource(beanClass.getDeclaredConstructor().newInstance());            &#125; catch (Exception e) &#123;                e.printStackTrace();            &#125;            advisedSupport.setTargetSource(targetSource);            advisedSupport.setMethodInterceptor((MethodInterceptor) advisor.getAdvice());            advisedSupport.setMethodMatcher(advisor.getPointcut().getMethodMatcher());            advisedSupport.setProxyTargetClass(false);            return new ProxyFactory(advisedSupport).getProxy();        &#125;        return null;    &#125;    </code></pre><ul><li>这个 DefaultAdvisorAutoProxyCreator 类的主要核心实现在于 postProcessBeforeInstantiation 方法中，从通过 beanFactory.getBeansOfType 获取 AspectJExpressionPointcutAdvisor 开始。</li><li>获取了 advisors 以后就可以遍历相应的 AspectJExpressionPointcutAdvisor 填充对应的属性信息，包括：目标对象、拦截方法、匹配器，之后返回代理对象即可。</li><li>那么现在调用方获取到的这个 Bean 对象就是一个已经被切面注入的对象了，当调用方法的时候，则会被按需拦截，处理用户需要的信息</li></ul><h2 id="6-融入到Bean的生命周期"><a href="#6-融入到Bean的生命周期" class="headerlink" title="6.融入到Bean的生命周期"></a>6.融入到Bean的生命周期</h2><pre><code class="java">public abstract class AbstractAutowireCapableBeanFactory extends AbstractBeanFactory implements AutowireCapableBeanFactory &#123;    private InstantiationStrategy instantiationStrategy = new CglibSubclassingInstantiationStrategy();    @Override    protected Object createBean(String beanName, BeanDefinition beanDefinition, Object[] args) throws BeansException &#123;        Object bean = null;        try &#123;            // 判断是否返回代理 Bean 对象            bean = resolveBeforeInstantiation(beanName, beanDefinition);            if (null != bean) &#123;                return bean;            &#125;            bean = createBeanInstance(beanDefinition, beanName, args);            // 给 bean 填充属性            applyPropertyValues(beanName, bean, beanDefinition);            // 执行 Bean 的初始化方法和 BeanPostProcessor 的前置和后置处理方法            bean = initializeBean(beanName, bean, beanDefinition);        &#125; catch (Exception e) &#123;            throw new BeansException(&quot;Instantiation of bean failed.&quot;, e);        &#125;        // 注册实现了 DisposableBean 接口的 Bean 对象        registerDisposableBeanIfNecessary(beanName, bean, beanDefinition);        // 判断 SCOPE_SINGLETON，SCOPE_PROTOTYPE        if (beanDefinition.isSingleton()) &#123;            registerSingleton(beanName, bean);        &#125;        return bean;    &#125;    protected Object resolveBeforeInstantiation(String beanName, BeanDefinition beanDefinition) &#123;        Object bean = applyBeanPostProcessorBeforeInstantiation(beanDefinition.getBeanClass(), beanName);        if (null != bean) &#123;            bean = applyBeanPostProcessorAfterInitialization(bean, beanName);        &#125;        return bean;    &#125;    // 注意，此方法为新增方法，与 “applyBeanPostProcessorBeforeInitialization” 是两个方法    public Object applyBeanPostProcessorBeforeInstantiation(Class&lt;?&gt; beanClass, String beanName) throws BeansException &#123;        for (BeanPostProcessor processor : getBeanPostProcessors()) &#123;            if (processor instanceof InstantiationAwareBeanPostProcessor) &#123;                Object result = ((InstantiationAwareBeanPostProcessor)processor).postProcessBeforeInstantiation(beanClass, beanName);                if (null != result) return result;            &#125;        &#125;        return null;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker入门</title>
      <link href="/2023/01/23/docker-ru-men-xue-xi/"/>
      <url>/2023/01/23/docker-ru-men-xue-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker实用篇"><a href="#Docker实用篇" class="headerlink" title="Docker实用篇"></a>Docker实用篇</h1><h1 id="1-初识Docker"><a href="#1-初识Docker" class="headerlink" title="1.初识Docker"></a>1.初识Docker</h1><h2 id="1-1-什么是Docker"><a href="#1-1-什么是Docker" class="headerlink" title="1.1.什么是Docker"></a>1.1.什么是Docker</h2><p>微服务虽然具备各种各样的优势，但服务的拆分通用给部署带来了很大的麻烦。</p><ul><li>分布式系统中，依赖的组件非常多，不同组件之间部署时往往会产生一些冲突。</li><li>在数百上千台服务中重复部署，环境不一定一致，会遇到各种问题</li></ul><h3 id="1-1-1-应用部署的环境问题"><a href="#1-1-1-应用部署的环境问题" class="headerlink" title="1.1.1.应用部署的环境问题"></a>1.1.1.应用部署的环境问题</h3><p>大型项目组件较多，运行环境也较为复杂，部署时会碰到一些问题：</p><ul><li><p>依赖关系复杂，容易出现兼容性问题</p></li><li><p>开发、测试、生产环境有差异</p></li></ul><p><img src="https://gitee.com/DylanToT99/images/raw/master/images2/image-20210731141907366.png" alt="image-202107311419073662"></p><p>例如一个项目中，部署时需要依赖于node.js、Redis、RabbitMQ、MySQL等，这些服务部署时所需要的函数库、依赖项各不相同，甚至会有冲突。给部署带来了极大的困难。</p><h3 id="1-1-2-Docker解决依赖兼容问题"><a href="#1-1-2-Docker解决依赖兼容问题" class="headerlink" title="1.1.2.Docker解决依赖兼容问题"></a>1.1.2.Docker解决依赖兼容问题</h3><p>而Docker确巧妙的解决了这些问题，Docker是如何实现的呢？</p><p>Docker为了解决依赖的兼容问题的，采用了两个手段：</p><ul><li><p>将应用的Libs（函数库）、Deps（依赖）、配置与应用一起打包</p></li><li><p>将每个应用放到一个隔离<strong>容器</strong>去运行，避免互相干扰</p></li></ul><p><img src="https://gitee.com/DylanToT99/images/raw/master/images2/image-20210731142219735.png" alt="image-202107311422197353"></p><p>这样打包好的应用包中，既包含应用本身，也保护应用所需要的Libs、Deps，无需再操作系统上安装这些，自然就不存在不同应用之间的兼容问题了。</p><p>虽然解决了不同应用的兼容问题，但是开发、测试等环境会存在差异，操作系统版本也会有差异，怎么解决这些问题呢？</p><h3 id="1-1-3-Docker解决操作系统环境差异"><a href="#1-1-3-Docker解决操作系统环境差异" class="headerlink" title="1.1.3.Docker解决操作系统环境差异"></a>1.1.3.Docker解决操作系统环境差异</h3><p>要解决不同操作系统环境差异问题，必须先了解操作系统结构。以一个Ubuntu操作系统为例，结构如下：</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images2/image-20210731143401460.png" alt="image-202107311434014620"></p><p>结构包括：</p><ul><li>计算机硬件：例如CPU、内存、磁盘等</li><li>系统内核：所有Linux发行版的内核都是Linux，例如CentOS、Ubuntu、Fedora等。内核可以与计算机硬件交互，对外提供<strong>内核指令</strong>，用于操作计算机硬件。</li><li>系统应用：操作系统本身提供的应用、函数库。这些函数库是对内核指令的封装，使用更加方便。</li></ul><p>应用于计算机交互的流程如下：</p><p>1）应用调用操作系统应用（函数库），实现各种功能</p><p>2）系统函数库是对内核指令集的封装，会调用内核指令</p><p>3）内核指令操作计算机硬件</p><p>Ubuntu和CentOSpringBoot都是基于Linux内核，无非是系统应用不同，提供的函数库有差异：</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images2/image-20210731144304990.png" alt="image-202107311443049950"></p><p>此时，如果将一个Ubuntu版本的MySQL应用安装到CentOS系统，MySQL在调用Ubuntu函数库时，会发现找不到或者不匹配，就会报错了：</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images2/image-20210731144458680.png" alt="image-202107311444583680"></p><p>Docker如何解决不同系统环境的问题？</p><ul><li>Docker将用户程序与所需要调用的系统(比如Ubuntu)函数库一起打包</li><li>Docker运行到不同操作系统时，直接基于打包的函数库，借助于操作系统的Linux内核来运行</li></ul><p>如图：</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images2/image-20210731144820638.png" alt="image-20210731144820638"></p><h3 id="1-1-4-小结"><a href="#1-1-4-小结" class="headerlink" title="1.1.4.小结"></a>1.1.4.小结</h3><p>Docker如何解决大型项目依赖关系复杂，不同组件依赖的兼容性问题？</p><ul><li>Docker允许开发中将应用、依赖、函数库、配置一起<strong>打包</strong>，形成可移植镜像</li><li>Docker应用运行在容器中，使用沙箱机制，相互<strong>隔离</strong></li></ul><p>Docker如何解决开发、测试、生产环境有差异的问题？</p><ul><li>Docker镜像中包含完整运行环境，包括系统函数库，仅依赖系统的Linux内核，因此可以在任意Linux操作系统上运行</li></ul><p>Docker是一个快速交付应用、运行应用的技术，具备下列优势：</p><ul><li>可以将程序及其依赖、运行环境一起打包为一个镜像，可以迁移到任意Linux操作系统</li><li>运行时利用沙箱机制形成隔离容器，各个应用互不干扰</li><li>启动、移除都可以通过一行命令完成，方便快捷</li></ul><h2 id="1-2-Docker和虚拟机的区别"><a href="#1-2-Docker和虚拟机的区别" class="headerlink" title="1.2.Docker和虚拟机的区别"></a>1.2.Docker和虚拟机的区别</h2><p>Docker可以让一个应用在任何操作系统中非常方便的运行。而以前我们接触的虚拟机，也能在一个操作系统中，运行另外一个操作系统，保护系统中的任何应用。</p><p>两者有什么差异呢？</p><p><strong>虚拟机</strong>（virtual machine）是在操作系统中<strong>模拟</strong>硬件设备，然后运行另一个操作系统，比如在 Windows 系统里面运行 Ubuntu 系统，这样就可以运行任意的Ubuntu应用了。</p><p><strong>Docker</strong>仅仅是封装函数库，并没有模拟完整的操作系统，如图：</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images2/image-20210731145914960.png" alt="image-20210731145914960"></p><p>对比来看：</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images2/image-20210731152243765.png" alt="image-20210731152243765"></p><p>小结：</p><p>Docker和虚拟机的差异：</p><ul><li><p>docker是一个系统进程；虚拟机是在操作系统中的操作系统</p></li><li><p>docker体积小、启动速度快、性能好；虚拟机体积大、启动速度慢、性能一般</p></li></ul><h2 id="1-3-Docker架构"><a href="#1-3-Docker架构" class="headerlink" title="1.3.Docker架构"></a>1.3.Docker架构</h2><h3 id="1-3-1-镜像和容器"><a href="#1-3-1-镜像和容器" class="headerlink" title="1.3.1.镜像和容器"></a>1.3.1.镜像和容器</h3><p>Docker中有几个重要的概念：</p><p><strong>镜像（Image）</strong>：Docker将应用程序及其所需的依赖、函数库、环境、配置等文件打包在一起，称为镜像。</p><p><strong>容器（Container）</strong>：镜像中的应用程序运行后形成的进程就是<strong>容器</strong>，只是Docker会给容器进程做隔离，对外不可见。</p><p>一切应用最终都是代码组成，都是硬盘中的一个个的字节形成的<strong>文件</strong>。只有运行时，才会加载到内存，形成进程。</p><p>而<strong>镜像</strong>，就是把一个应用在硬盘上的文件、及其运行环境、部分系统函数库文件一起打包形成的文件包。这个文件包是只读的。</p><p><strong>容器</strong>呢，就是将这些文件中编写的程序、函数加载到内存中允许，形成进程，只不过要隔离起来。因此一个镜像可以启动多次，形成多个容器进程。</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images2/image-20210731153059464.png" alt="image-20210731153059464"></p><p>例如你下载了一个QQ，如果我们将QQ在磁盘上的运行<strong>文件</strong>及其运行的操作系统依赖打包，形成QQ镜像。然后你可以启动多次，双开、甚至三开QQ，跟多个妹子聊天。</p><h3 id="1-3-2-DockerHub"><a href="#1-3-2-DockerHub" class="headerlink" title="1.3.2.DockerHub"></a>1.3.2.DockerHub</h3><p>开源应用程序非常多，打包这些应用往往是重复的劳动。为了避免这些重复劳动，人们就会将自己打包的应用镜像，例如Redis、MySQL镜像放到网络上，共享使用，就像GitHub的代码共享一样。</p><ul><li><p>DockerHub：DockerHub是一个官方的Docker镜像的托管平台。这样的平台称为Docker Registry。</p></li><li><p>国内也有类似于DockerHub 的公开服务，比如 <a href="https://c.163yun.com/hub">网易云镜像服务</a>、<a href="https://cr.console.aliyun.com/">阿里云镜像库</a>等。</p></li></ul><p>我们一方面可以将自己的镜像共享到DockerHub，另一方面也可以从DockerHub拉取镜像：</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images2/image-20210731153743354.png" alt="image-20210731153743354"></p><h3 id="1-3-3-Docker架构"><a href="#1-3-3-Docker架构" class="headerlink" title="1.3.3.Docker架构"></a>1.3.3.Docker架构</h3><p>我们要使用Docker来操作镜像、容器，就必须要安装Docker。</p><p>Docker是一个CS架构的程序，由两部分组成：</p><ul><li><p>服务端(server)：Docker守护进程，负责处理Docker指令，管理镜像、容器等</p></li><li><p>客户端(client)：通过命令或RestAPI向Docker服务端发送指令。可以在本地或远程向服务端发送指令。</p></li></ul><p>如图：</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images2/image-20210731154257653.png" alt="image-20210731154257653"></p><h3 id="1-3-4-小结"><a href="#1-3-4-小结" class="headerlink" title="1.3.4.小结"></a>1.3.4.小结</h3><p>镜像：</p><ul><li>将应用程序及其依赖、环境、配置打包在一起</li></ul><p>容器：</p><ul><li>镜像运行起来就是容器，一个镜像可以运行多个容器</li></ul><p>Docker结构：</p><ul><li><p>服务端：接收命令或远程请求，操作镜像或容器</p></li><li><p>客户端：发送命令或者请求到Docker服务端</p></li></ul><p>DockerHub：</p><ul><li>一个镜像托管的服务器，类似的还有阿里云镜像服务，统称为DockerRegistry</li></ul><h2 id="1-4-安装Docker"><a href="#1-4-安装Docker" class="headerlink" title="1.4.安装Docker"></a>1.4.安装Docker</h2><p>企业部署一般都是采用Linux操作系统，而其中又数CentOS发行版占比最多，因此我们在CentOS下安装Docker。参考课前资料中的文档：</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images2/image-20210731155002425.png" alt="image-20210731155002425"></p><p>Docker 分为 CE 和 EE 两大版本。CE 即社区版（免费，支持周期 7 个月），EE 即企业版，强调安全，付费使用，支持周期 24 个月。</p><p>Docker CE 分为 <code>stable</code> <code>test</code> 和 <code>nightly</code> 三个更新频道。</p><p>官方网站上有各种环境下的 <a href="https://docs.docker.com/install/">安装指南</a>，这里主要介绍 Docker CE 在 CentOS上的安装。</p><h3 id="CentOS安装Docker"><a href="#CentOS安装Docker" class="headerlink" title="CentOS安装Docker"></a>CentOS安装Docker</h3><p>Docker CE 支持 64 位版本 CentOS 7，并且要求内核版本不低于 3.10， CentOS 7 满足最低内核的要求，所以我们在CentOS 7安装Docker。</p><h3 id="1-4-1卸载（可选）"><a href="#1-4-1卸载（可选）" class="headerlink" title="1.4.1卸载（可选）"></a>1.4.1卸载（可选）</h3><p>如果之前安装过旧版本的Docker，可以使用下面命令卸载：</p><pre><code class="sh">yum remove docker \                  docker-client \                  docker-client-latest \                  docker-common \                  docker-latest \                  docker-latest-logrotate \                  docker-logrotate \                  docker-selinux \                  docker-engine-selinux \                  docker-engine \                  docker-ce</code></pre><h3 id="1-4-2安装docker"><a href="#1-4-2安装docker" class="headerlink" title="1.4.2安装docker"></a>1.4.2安装docker</h3><p>首先需要大家虚拟机联网，安装yum工具</p><pre><code class="sh">yum install -y yum-utils \           device-mapper-persistent-data \           lvm2 --skip-broken</code></pre><p>然后更新本地镜像源：</p><pre><code class="shell"># 设置docker镜像源yum-config-manager \    --add-repo \    https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo    sed -i &#39;s/download.docker.com/mirrors.aliyun.com\/docker-ce/g&#39; /etc/yum.repos.d/docker-ce.repoyum makecache fast</code></pre><p>然后输入命令：</p><pre><code class="shell">yum install -y docker-ce</code></pre><p>docker-ce为社区免费版本。稍等片刻，docker即可安装成功。</p><h3 id="1-4-3启动docker"><a href="#1-4-3启动docker" class="headerlink" title="1.4.3启动docker"></a>1.4.3启动docker</h3><p>Docker应用需要用到各种端口，逐一去修改防火墙设置。非常麻烦，因此建议大家直接关闭防火墙！</p><p>启动docker前，一定要关闭防火墙后！！</p><p>启动docker前，一定要关闭防火墙后！！</p><p>启动docker前，一定要关闭防火墙后！！</p><pre><code class="sh"># 关闭systemctl stop firewalld# 禁止开机启动防火墙systemctl disable firewalld</code></pre><p>通过命令启动docker：</p><pre><code class="sh">systemctl start docker  # 启动docker服务systemctl stop docker  # 停止docker服务systemctl restart docker  # 重启docker服务</code></pre><p>然后输入命令，可以查看docker版本：</p><pre><code>docker -v</code></pre><h2 id="1-4-配置镜像加速"><a href="#1-4-配置镜像加速" class="headerlink" title="1.4.配置镜像加速"></a>1.4.配置镜像加速</h2><p>docker官方镜像仓库网速较差，我们需要设置国内镜像服务：</p><p>参考阿里云的镜像加速文档：<a href="https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors">https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors</a></p><h1 id="2-Docker的基本操作"><a href="#2-Docker的基本操作" class="headerlink" title="2.Docker的基本操作"></a>2.Docker的基本操作</h1><h2 id="2-1-镜像操作"><a href="#2-1-镜像操作" class="headerlink" title="2.1.镜像操作"></a>2.1.镜像操作</h2><h3 id="2-1-1-镜像名称"><a href="#2-1-1-镜像名称" class="headerlink" title="2.1.1.镜像名称"></a>2.1.1.镜像名称</h3><p>首先来看下镜像的名称组成：</p><ul><li>镜名称一般分两部分组成：[repository]:[tag]。</li><li>在没有指定tag时，默认是latest，代表最新版本的镜像</li></ul><p>如图：</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images2/image-20210731155141362.png" alt="image-20210731155141362"></p><p>这里的mysql就是repository，5.7就是tag，合一起就是镜像名称，代表5.7版本的MySQL镜像。</p><h3 id="2-1-2-镜像命令"><a href="#2-1-2-镜像命令" class="headerlink" title="2.1.2.镜像命令"></a>2.1.2.镜像命令</h3><p>常见的镜像操作命令如图：</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images2/image-20210731155649535.png" alt="image-20210731155649535"></p><h3 id="2-1-3-案例1-拉取、查看镜像"><a href="#2-1-3-案例1-拉取、查看镜像" class="headerlink" title="2.1.3.案例1-拉取、查看镜像"></a>2.1.3.案例1-拉取、查看镜像</h3><p>需求：从DockerHub中拉取一个nginx镜像并查看</p><p>1）首先去镜像仓库搜索nginx镜像，比如<a href="https://hub.docker.com/">DockerHub</a>:</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images2/image-20210731155844368.png" alt="image-20210731155844368"></p><p>2）根据查看到的镜像名称，拉取自己需要的镜像，通过命令：docker pull nginx</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images2/image-20210731155856199.png" alt="image-20210731155856199"></p><p>3）通过命令：docker images 查看拉取到的镜像</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images2/image-20210731155903037.png" alt="image-20210731155903037"></p><h3 id="2-1-4-案例2-保存、导入镜像"><a href="#2-1-4-案例2-保存、导入镜像" class="headerlink" title="2.1.4.案例2-保存、导入镜像"></a>2.1.4.案例2-保存、导入镜像</h3><p>需求：利用docker save将nginx镜像导出磁盘，然后再通过load加载回来</p><p>1）利用docker xx –help命令查看docker save和docker load的语法</p><p>例如，查看save命令用法，可以输入命令：</p><pre><code class="sh">docker save --help</code></pre><p>结果：</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images2/image-20210731161104732.png" alt="image-20210731161104732"></p><p>命令格式：</p><pre><code class="shell">docker save -o [保存的目标文件名称] [镜像名称]</code></pre><p>2）使用docker save导出镜像到磁盘 </p><p>运行命令：</p><pre><code class="sh">docker save -o nginx.tar nginx:latest</code></pre><p>结果如图：</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images2/image-20210731161354344.png" alt="image-20210731161354344"></p><p>3）使用docker load加载镜像</p><p>先删除本地的nginx镜像：</p><pre><code class="sh">docker rmi nginx:latest</code></pre><p>然后运行命令，加载本地文件：</p><pre><code class="sh">docker load -i nginx.tar</code></pre><p>结果：</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images2/image-20210731161746245.png" alt="image-20210731161746245"></p><h3 id="2-1-5-练习"><a href="#2-1-5-练习" class="headerlink" title="2.1.5.练习"></a>2.1.5.练习</h3><p>需求：去DockerHub搜索并拉取一个Redis镜像</p><p>目标：</p><p>1）去DockerHub搜索Redis镜像</p><p>2）查看Redis镜像的名称和版本</p><p>3）利用docker pull命令拉取镜像</p><p>4）利用docker save命令将 redis:latest打包为一个redis.tar包</p><p>5）利用docker rmi 删除本地的redis:latest</p><p>6）利用docker load 重新加载 redis.tar文件</p><h2 id="2-2-容器操作"><a href="#2-2-容器操作" class="headerlink" title="2.2.容器操作"></a>2.2.容器操作</h2><h3 id="2-2-1-容器相关命令"><a href="#2-2-1-容器相关命令" class="headerlink" title="2.2.1.容器相关命令"></a>2.2.1.容器相关命令</h3><p>容器操作的命令如图：</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images2/image-20210731161950495.png" alt="image-20210731161950495"></p><p>容器保护三个状态：</p><ul><li>运行：进程正常运行</li><li>暂停：进程暂停，CPU不再运行，并不释放内存</li><li>停止：进程终止，回收进程占用的内存、CPU等资源</li></ul><p>其中：</p><ul><li><p>docker run：创建并运行一个容器，处于运行状态</p></li><li><p>docker pause：让一个运行的容器暂停</p></li><li><p>docker unpause：让一个容器从暂停状态恢复运行</p></li><li><p>docker stop：停止一个运行的容器</p></li><li><p>docker start：让一个停止的容器再次运行</p></li><li><p>docker rm：删除一个容器</p></li></ul><h3 id="2-2-2-案例-创建并运行一个容器"><a href="#2-2-2-案例-创建并运行一个容器" class="headerlink" title="2.2.2.案例-创建并运行一个容器"></a>2.2.2.案例-创建并运行一个容器</h3><p>创建并运行nginx容器的命令：</p><pre><code class="sh">docker run --name containerName -p 80:80 -d nginx</code></pre><p>命令解读：</p><ul><li>docker run ：创建并运行一个容器</li><li>–name : 给容器起一个名字，比如叫做mn</li><li>-p ：将宿主机端口与容器端口映射，冒号左侧是宿主机端口，右侧是容器端口</li><li>-d：后台运行容器</li><li>nginx：镜像名称，例如nginx</li></ul><p>这里的<code>-p</code>参数，是将容器端口映射到宿主机端口。</p><p>默认情况下，容器是隔离环境，我们直接访问宿主机的80端口，肯定访问不到容器中的nginx。</p><p>现在，将容器的80与宿主机的80关联起来，当我们访问宿主机的80端口时，就会被映射到容器的80，这样就能访问到nginx了：</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images2/image-20210731163255863.png" alt="image-20210731163255863"></p><h3 id="2-2-3-案例-进入容器，修改文件"><a href="#2-2-3-案例-进入容器，修改文件" class="headerlink" title="2.2.3.案例-进入容器，修改文件"></a>2.2.3.案例-进入容器，修改文件</h3><p><strong>需求</strong>：进入Nginx容器，修改HTML文件内容，添加“传智教育欢迎您”</p><p><strong>提示</strong>：进入容器要用到docker exec命令。</p><p><strong>步骤</strong>：</p><p>1）进入容器。进入我们刚刚创建的nginx容器的命令为：</p><pre><code class="sh">docker exec -it mn bash</code></pre><p>命令解读：</p><ul><li><p>docker exec ：进入容器内部，执行一个命令</p></li><li><p>-it : 给当前进入的容器创建一个标准输入、输出终端，允许我们与容器交互</p></li><li><p>mn ：要进入的容器的名称</p></li><li><p>bash：进入容器后执行的命令，bash是一个linux终端交互命令</p></li></ul><p>2）进入nginx的HTML所在目录 &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html</p><p>容器内部会模拟一个独立的Linux文件系统，看起来如同一个linux服务器一样：</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images2/image-20210731164159811.png" alt="image-20210731164159811"></p><p>nginx的环境、配置、运行文件全部都在这个文件系统中，包括我们要修改的html文件。</p><p>查看DockerHub网站中的nginx页面，可以知道nginx的html目录位置在<code>/usr/share/nginx/html</code></p><p>我们执行命令，进入该目录：</p><pre><code class="sh">cd /usr/share/nginx/html</code></pre><p> 查看目录下文件：</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images2/image-20210731164455818.png" alt="image-20210731164455818"></p><p>3）修改index.html的内容</p><p>容器内没有vi命令，无法直接修改，我们用下面的命令来修改：</p><pre><code class="sh">sed -i -e &#39;s#Welcome to nginx#传智教育欢迎您#g&#39; -e &#39;s#&lt;head&gt;#&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;#g&#39; index.html</code></pre><p>在浏览器访问自己的虚拟机地址，例如我的是：<a href="http://192.168.150.101，即可看到结果：">http://192.168.150.101，即可看到结果：</a></p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images2/image-20210731164717604.png" alt="image-20210731164717604"></p><h3 id="2-2-4-小结"><a href="#2-2-4-小结" class="headerlink" title="2.2.4.小结"></a>2.2.4.小结</h3><p>docker run命令的常见参数有哪些？</p><ul><li>–name：指定容器名称</li><li>-p：指定端口映射</li><li>-d：让容器后台运行</li></ul><p>查看容器日志的命令：</p><ul><li>docker logs</li><li>添加 -f 参数可以持续查看日志</li></ul><p>查看容器状态：</p><ul><li>docker ps</li><li>docker ps -a 查看所有容器，包括已经停止的</li></ul><h2 id="2-3-数据卷（容器数据管理）"><a href="#2-3-数据卷（容器数据管理）" class="headerlink" title="2.3.数据卷（容器数据管理）"></a>2.3.数据卷（容器数据管理）</h2><p>在之前的nginx案例中，修改nginx的html页面时，需要进入nginx内部。并且因为没有编辑器，修改文件也很麻烦。</p><p>这就是因为容器与数据（容器内文件）耦合带来的后果。</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images2/image-20210731172440275.png" alt="image-20210731172440275"></p><p>要解决这个问题，必须将数据与容器解耦，这就要用到数据卷了。</p><h3 id="2-3-1-什么是数据卷"><a href="#2-3-1-什么是数据卷" class="headerlink" title="2.3.1.什么是数据卷"></a>2.3.1.什么是数据卷</h3><p><strong>数据卷（volume）</strong>是一个虚拟目录，指向宿主机文件系统中的某个目录。</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images2/image-20210731173541846.png" alt="image-20210731173541846"></p><p>一旦完成数据卷挂载，对容器的一切操作都会作用在数据卷对应的宿主机目录了。</p><p>这样，我们操作宿主机的&#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes&#x2F;html目录，就等于操作容器内的&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html目录了</p><h3 id="2-3-2-数据集操作命令"><a href="#2-3-2-数据集操作命令" class="headerlink" title="2.3.2.数据集操作命令"></a>2.3.2.数据集操作命令</h3><p>数据卷操作的基本语法如下：</p><pre><code class="sh">docker volume [COMMAND]</code></pre><p>docker volume命令是数据卷操作，根据命令后跟随的command来确定下一步的操作：</p><ul><li>create 创建一个volume</li><li>inspect 显示一个或多个volume的信息</li><li>ls 列出所有的volume</li><li>prune 删除未使用的volume</li><li>rm 删除一个或多个指定的volume</li></ul><h3 id="2-3-3-创建和查看数据卷"><a href="#2-3-3-创建和查看数据卷" class="headerlink" title="2.3.3.创建和查看数据卷"></a>2.3.3.创建和查看数据卷</h3><p><strong>需求</strong>：创建一个数据卷，并查看数据卷在宿主机的目录位置</p><p>① 创建数据卷</p><pre><code class="sh">docker volume create html</code></pre><p>② 查看所有数据</p><pre><code class="sh">docker volume ls</code></pre><p>结果：</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images2/image-20210731173746910.png" alt="image-20210731173746910"></p><p>③ 查看数据卷详细信息卷</p><pre><code class="sh">docker volume inspect html</code></pre><p>结果：</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images2/image-20210731173809877.png" alt="image-20210731173809877"></p><p>可以看到，我们创建的html这个数据卷关联的宿主机目录为<code>/var/lib/docker/volumes/html/_data</code>目录。</p><p><strong>小结</strong>：</p><p>数据卷的作用：</p><ul><li>将容器与数据分离，解耦合，方便操作容器内数据，保证数据安全</li></ul><p>数据卷操作：</p><ul><li>docker volume create：创建数据卷</li><li>docker volume ls：查看所有数据卷</li><li>docker volume inspect：查看数据卷详细信息，包括关联的宿主机目录位置</li><li>docker volume rm：删除指定数据卷</li><li>docker volume prune：删除所有未使用的数据卷</li></ul><h3 id="2-3-4-挂载数据卷"><a href="#2-3-4-挂载数据卷" class="headerlink" title="2.3.4.挂载数据卷"></a>2.3.4.挂载数据卷</h3><p>我们在创建容器时，可以通过 -v 参数来挂载一个数据卷到某个容器内目录，命令格式如下：</p><pre><code class="sh">docker run \  --name mn \  -v html:/root/html \  -p 8080:80  nginx \</code></pre><p>这里的-v就是挂载数据卷的命令：</p><ul><li><code>-v html:/root/htm</code> ：把html数据卷挂载到容器内的&#x2F;root&#x2F;html这个目录中</li></ul><h3 id="2-3-5-案例-给nginx挂载数据卷"><a href="#2-3-5-案例-给nginx挂载数据卷" class="headerlink" title="2.3.5.案例-给nginx挂载数据卷"></a>2.3.5.案例-给nginx挂载数据卷</h3><p><strong>需求</strong>：创建一个nginx容器，修改容器内的html目录内的index.html内容</p><p><strong>分析</strong>：上个案例中，我们进入nginx容器内部，已经知道nginx的html目录所在位置&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html ，我们需要把这个目录挂载到html这个数据卷上，方便操作其中的内容。</p><p><strong>提示</strong>：运行容器时使用 -v 参数挂载数据卷</p><p>步骤：</p><p>① 创建容器并挂载数据卷到容器内的HTML目录</p><pre><code class="sh">docker run --name mn -v html:/usr/share/nginx/html -p 80:80 -d nginx</code></pre><p>② 进入html数据卷所在位置，并修改HTML内容</p><pre><code class="sh"># 查看html数据卷的位置docker volume inspect html# 进入该目录cd /var/lib/docker/volumes/html/_data# 修改文件vi index.html</code></pre><h3 id="2-3-6-案例-给MySQL挂载本地目录"><a href="#2-3-6-案例-给MySQL挂载本地目录" class="headerlink" title="2.3.6.案例-给MySQL挂载本地目录"></a>2.3.6.案例-给MySQL挂载本地目录</h3><p>容器不仅仅可以挂载数据卷，也可以直接挂载到宿主机目录上。关联关系如下：</p><ul><li>带数据卷模式：宿主机目录 –&gt; 数据卷 —&gt; 容器内目录</li><li>直接挂载模式：宿主机目录 —&gt; 容器内目录</li></ul><p>如图：</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images2/image-20210731175155453.png" alt="image-20210731175155453"></p><p><strong>语法</strong>：</p><p>目录挂载与数据卷挂载的语法是类似的：</p><ul><li>-v [宿主机目录]:[容器内目录]</li><li>-v [宿主机文件]:[容器内文件]</li></ul><p>创建mysql容器的同时进行本地文件的挂载</p><pre><code class="shell">docker run \--name mysql -e MYSQL_ROOT_PASSWORD=020609 \-p 3306:3306 -v /tmp/mysql/data/:/var/lib/mysql \-d mysql:8.0.32</code></pre><p><strong>需求</strong>：创建并运行一个MySQL容器，将宿主机目录直接挂载到容器</p><p>实现思路如下：</p><p>1）在将课前资料中的mysql.tar文件上传到虚拟机，通过load命令加载为镜像</p><p>2）创建目录&#x2F;tmp&#x2F;mysql&#x2F;data</p><p>3）创建目录&#x2F;tmp&#x2F;mysql&#x2F;conf，将课前资料提供的hmy.cnf文件上传到&#x2F;tmp&#x2F;mysql&#x2F;conf</p><p>4）去DockerHub查阅资料，创建并运行MySQL容器，要求：</p><p>① 挂载&#x2F;tmp&#x2F;mysql&#x2F;data到mysql容器内数据存储目录</p><p>② 挂载&#x2F;tmp&#x2F;mysql&#x2F;conf&#x2F;hmy.cnf到mysql容器的配置文件</p><p>③ 设置MySQL密码</p><h3 id="2-3-7-小结"><a href="#2-3-7-小结" class="headerlink" title="2.3.7.小结"></a>2.3.7.小结</h3><p>docker run的命令中通过 -v 参数挂载文件或目录到容器中：</p><ul><li>-v volume名称:容器内目录</li><li>-v 宿主机文件:容器内文</li><li>-v 宿主机目录:容器内目录</li></ul><p>数据卷挂载与目录直接挂载的</p><ul><li>数据卷挂载耦合度低，由docker来管理目录，但是目录较深，不好找</li><li>目录挂载耦合度高，需要我们自己管理目录，不过目录容易寻找查看</li></ul><h1 id="3-Dockerfile自定义镜像"><a href="#3-Dockerfile自定义镜像" class="headerlink" title="3.Dockerfile自定义镜像"></a>3.Dockerfile自定义镜像</h1><p>常见的镜像在DockerHub就能找到，但是我们自己写的项目就必须自己构建镜像了。</p><p>而要自定义镜像，就必须先了解镜像的结构才行。</p><h2 id="3-1-镜像结构"><a href="#3-1-镜像结构" class="headerlink" title="3.1.镜像结构"></a>3.1.镜像结构</h2><p>镜像是将应用程序及其需要的系统函数库、环境、配置、依赖打包而成。</p><p>我们以MySQL为例，来看看镜像的组成结构：</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images2/image-20210731175806273.png" alt="image-20210731175806273"></p><p>简单来说，镜像就是在系统函数库、运行环境基础上，添加应用程序文件、配置文件、依赖文件等组合，然后编写好启动脚本打包在一起形成的文件。</p><p>我们要构建镜像，其实就是实现上述打包的过程。</p><h2 id="3-2-Dockerfile语法"><a href="#3-2-Dockerfile语法" class="headerlink" title="3.2.Dockerfile语法"></a>3.2.Dockerfile语法</h2><p>构建自定义的镜像时，并不需要一个个文件去拷贝，打包。</p><p>我们只需要告诉Docker，我们的镜像的组成，需要哪些BaseImage、需要拷贝什么文件、需要安装什么依赖、启动脚本是什么，将来Docker会帮助我们构建镜像。</p><p>而描述上述信息的文件就是Dockerfile文件。</p><p><strong>Dockerfile</strong>就是一个文本文件，其中包含一个个的**指令(Instruction)**，用指令来说明要执行什么操作来构建镜像。每一个指令都会形成一层Layer。</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images2/image-20210731180321133.png" alt="image-20210731180321133"></p><p>更新详细语法说明，请参考官网文档： <a href="https://docs.docker.com/engine/reference/builder">https://docs.docker.com/engine/reference/builder</a></p><h2 id="3-3-构建Java项目"><a href="#3-3-构建Java项目" class="headerlink" title="3.3.构建Java项目"></a>3.3.构建Java项目</h2><h3 id="3-3-1-基于Ubuntu构建Java项目"><a href="#3-3-1-基于Ubuntu构建Java项目" class="headerlink" title="3.3.1.基于Ubuntu构建Java项目"></a>3.3.1.基于Ubuntu构建Java项目</h3><p>需求：基于Ubuntu镜像构建一个新镜像，运行一个java项目</p><ul><li><p>步骤1：新建一个空文件夹docker-demo</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images2/image-20210801101207444.png" alt="image-20210801101207444"></p></li><li><p>步骤2：拷贝课前资料中的docker-demo.jar文件到docker-demo这个目录</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images2/image-20210801101314816.png" alt="image-20210801101314816"></p></li><li><p>步骤3：拷贝课前资料中的jdk8.tar.gz文件到docker-demo这个目录</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images2/image-20210801101410200.png" alt="image-20210801101410200"></p></li><li><p>步骤4：拷贝课前资料提供的Dockerfile到docker-demo这个目录</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images2/image-20210801101455590.png" alt="image-20210801101455590"></p><p>其中的内容如下：</p><pre><code class="dockerfile"># 指定基础镜像FROM ubuntu:16.04# 配置环境变量，JDK的安装目录ENV JAVA_DIR=/usr/local# 拷贝jdk和java项目的包COPY ./jdk8.tar.gz $JAVA_DIR/COPY ./docker-demo.jar /tmp/app.jar# 安装JDKRUN cd $JAVA_DIR \ &amp;&amp; tar -xf ./jdk8.tar.gz \ &amp;&amp; mv ./jdk1.8.0_144 ./java8# 配置环境变量ENV JAVA_HOME=$JAVA_DIR/java8ENV PATH=$PATH:$JAVA_HOME/bin# 暴露端口EXPOSE 8090# 入口，java项目的启动命令ENTRYPOINT java -jar /tmp/app.jar</code></pre></li><li><p>步骤5：进入docker-demo</p><p>将准备好的docker-demo上传到虚拟机任意目录，然后进入docker-demo目录下</p></li><li><p>步骤6：运行命令：</p><pre><code class="sh">docker build -t javaweb:1.0 .</code></pre></li></ul><p>最后访问 <a href="http://192.168.150.101:8090/hello/count%EF%BC%8C%E5%85%B6%E4%B8%AD%E7%9A%84ip%E6%94%B9%E6%88%90%E4%BD%A0%E7%9A%84%E8%99%9A%E6%8B%9F%E6%9C%BAip">http://192.168.150.101:8090/hello/count，其中的ip改成你的虚拟机ip</a></p><h3 id="3-3-2-基于java8构建Java项目"><a href="#3-3-2-基于java8构建Java项目" class="headerlink" title="3.3.2.基于java8构建Java项目"></a>3.3.2.基于java8构建Java项目</h3><p>虽然我们可以基于Ubuntu基础镜像，添加任意自己需要的安装包，构建镜像，但是却比较麻烦。所以大多数情况下，我们都可以在一些安装了部分软件的基础镜像上做改造。</p><p>例如，构建java项目的镜像，可以在已经准备了JDK的基础镜像基础上构建。</p><p>需求：基于java:8-alpine镜像，将一个Java项目构建为镜像</p><p>实现思路如下：</p><ul><li><p>① 新建一个空的目录，然后在目录中新建一个文件，命名为Dockerfile</p></li><li><p>② 拷贝课前资料提供的docker-demo.jar到这个目录中</p></li><li><p>③ 编写Dockerfile文件：</p><ul><li><p>a ）基于java:8-alpine作为基础镜像</p></li><li><p>b ）将app.jar拷贝到镜像中</p></li><li><p>c ）暴露端口</p></li><li><p>d ）编写入口ENTRYPOINT</p><p>内容如下：</p><pre><code class="dockerfile">FROM java:8-alpineCOPY ./app.jar /tmp/app.jarEXPOSE 8090ENTRYPOINT java -jar /tmp/app.jar</code></pre></li></ul></li><li><p>④ 使用docker build命令构建镜像</p></li><li><p>⑤ 使用docker run创建容器并运行</p></li></ul><h2 id="3-4-小结"><a href="#3-4-小结" class="headerlink" title="3.4.小结"></a>3.4.小结</h2><p>小结：</p><ol><li><p>Dockerfile的本质是一个文件，通过指令描述镜像的构建过程</p></li><li><p>Dockerfile的第一行必须是FROM，从一个基础镜像来构建</p></li><li><p>基础镜像可以是基本操作系统，如Ubuntu。也可以是其他人制作好的镜像，例如：java:8-alpine</p></li></ol><h1 id="4-Docker-Compose"><a href="#4-Docker-Compose" class="headerlink" title="4.Docker-Compose"></a>4.Docker-Compose</h1><p>Docker Compose可以基于Compose文件帮我们快速的部署分布式应用，而无需手动一个个创建和运行容器！</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images2/image-20210731180921742.png" alt="image-20210731180921742"></p><h2 id="4-1-初识DockerCompose"><a href="#4-1-初识DockerCompose" class="headerlink" title="4.1.初识DockerCompose"></a>4.1.初识DockerCompose</h2><p>Compose文件是一个文本文件，通过指令定义集群中的每个容器如何运行。格式如下：</p><pre><code class="json">version: &quot;3.8&quot; services:  mysql:    image: mysql:5.7.25    environment:     MYSQL_ROOT_PASSWORD: 123     volumes:     - &quot;/tmp/mysql/data:/var/lib/mysql&quot;     - &quot;/tmp/mysql/conf/hmy.cnf:/etc/mysql/conf.d/hmy.cnf&quot;  web:    build: .    ports:     - &quot;8090:8090&quot;</code></pre><p>上面的Compose文件就描述一个项目，其中包含两个容器：</p><ul><li>mysql：一个基于<code>mysql:5.7.25</code>镜像构建的容器，并且挂载了两个目录</li><li>web：一个基于<code>docker build</code>临时构建的镜像容器，映射端口时8090</li></ul><p>DockerCompose的详细语法参考官网：<a href="https://docs.docker.com/compose/compose-file/">https://docs.docker.com/compose/compose-file/</a></p><p>其实DockerCompose文件可以看做是将多个docker run命令写到一个文件，只是语法稍有差异。</p><h2 id="4-2-安装DockerCompose"><a href="#4-2-安装DockerCompose" class="headerlink" title="4.2.安装DockerCompose"></a>4.2.安装DockerCompose</h2><h3 id="4-2-1-下载"><a href="#4-2-1-下载" class="headerlink" title="4.2.1 下载"></a>4.2.1 下载</h3><pre><code class="sh"># 安装curl -L https://github.com/docker/compose/releases/download/1.23.1/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose</code></pre><p>如果下载速度较慢，或者下载失败，可以使用课前资料提供的docker-compose文件上传到<code>/usr/local/bin/</code>目录也可以。</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20210417133020614.png" alt="image-20210417133020614"></p><h3 id="4-2-2修改文件权限"><a href="#4-2-2修改文件权限" class="headerlink" title="4.2.2修改文件权限"></a>4.2.2修改文件权限</h3><p>修改文件权限：</p><pre><code class="sh"># 修改权限chmod +x /usr/local/bin/docker-compose</code></pre><h3 id="4-2-3-Base自动补全命令："><a href="#4-2-3-Base自动补全命令：" class="headerlink" title="4.2.3.Base自动补全命令："></a>4.2.3.Base自动补全命令：</h3><pre><code class="sh"># 补全命令curl -L https://raw.githubusercontent.com/docker/compose/1.29.1/contrib/completion/bash/docker-compose &gt; /etc/bash_completion.d/docker-compose</code></pre><p>如果这里出现错误，需要修改自己的hosts文件：</p><pre><code class="sh">echo &quot;199.232.68.133 raw.githubusercontent.com&quot; &gt;&gt; /etc/hosts</code></pre><h2 id="4-3-部署微服务集群"><a href="#4-3-部署微服务集群" class="headerlink" title="4.3.部署微服务集群"></a>4.3.部署微服务集群</h2><p><strong>需求</strong>：将之前学习的cloud-demo微服务集群利用DockerCompose部署</p><p><strong>实现思路</strong>：</p><p>① 查看课前资料提供的cloud-demo文件夹，里面已经编写好了docker-compose文件</p><p>② 修改自己的cloud-demo项目，将数据库、nacos地址都命名为docker-compose中的服务名</p><p>③ 使用maven打包工具，将项目中的每个微服务都打包为app.jar</p><p>④ 将打包好的app.jar拷贝到cloud-demo中的每一个对应的子目录中</p><p>⑤ 将cloud-demo上传至虚拟机，利用 docker-compose up -d 来部署</p><h3 id="4-3-1-compose文件"><a href="#4-3-1-compose文件" class="headerlink" title="4.3.1.compose文件"></a>4.3.1.compose文件</h3><p>查看课前资料提供的cloud-demo文件夹，里面已经编写好了docker-compose文件，而且每个微服务都准备了一个独立的目录：</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images2/image-20210731181341330.png" alt="image-20210731181341330"></p><p>内容如下：</p><pre><code class="yaml">version: &quot;3.2&quot;services:  nacos:    image: nacos/nacos-server    environment:      MODE: standalone    ports:      - &quot;8848:8848&quot;  mysql:    image: mysql:5.7.25    environment:      MYSQL_ROOT_PASSWORD: 123    volumes:      - &quot;$PWD/mysql/data:/var/lib/mysql&quot;      - &quot;$PWD/mysql/conf:/etc/mysql/conf.d/&quot;  userservice:    build: ./user-service  orderservice:    build: ./order-service  gateway:    build: ./gateway    ports:      - &quot;10010:10010&quot;</code></pre><p>可以看到，其中包含5个service服务：</p><ul><li><code>nacos</code>：作为注册中心和配置中心<ul><li><code>image: nacos/nacos-server</code>： 基于nacos&#x2F;nacos-server镜像构建</li><li><code>environment</code>：环境变量<ul><li><code>MODE: standalone</code>：单点模式启动</li></ul></li><li><code>ports</code>：端口映射，这里暴露了8848端口</li></ul></li><li><code>mysql</code>：数据库<ul><li><code>image: mysql:5.7.25</code>：镜像版本是mysql:5.7.25</li><li><code>environment</code>：环境变量<ul><li><code>MYSQL_ROOT_PASSWORD: 123</code>：设置数据库root账户的密码为123</li></ul></li><li><code>volumes</code>：数据卷挂载，这里挂载了mysql的data、conf目录，其中有我提前准备好的数据</li></ul></li><li><code>userservice</code>、<code>orderservice</code>、<code>gateway</code>：都是基于Dockerfile临时构建的</li></ul><p>查看mysql目录，可以看到其中已经准备好了cloud_order、cloud_user表：</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images2/image-20210801095205034.png" alt="image-20210801095205034"></p><p>查看微服务目录，可以看到都包含Dockerfile文件：</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images2/image-20210801095320586.png" alt="image-20210801095320586"></p><p>内容如下：</p><pre><code class="dockerfile">FROM java:8-alpineCOPY ./app.jar /tmp/app.jarENTRYPOINT java -jar /tmp/app.jar</code></pre><h3 id="4-3-2-修改微服务配置"><a href="#4-3-2-修改微服务配置" class="headerlink" title="4.3.2.修改微服务配置"></a>4.3.2.修改微服务配置</h3><p>因为微服务将来要部署为docker容器，而容器之间互联不是通过IP地址，而是通过容器名。这里我们将order-service、user-service、gateway服务的mysql、nacos地址都修改为基于容器名的访问。</p><p>如下所示：</p><pre><code class="yaml">spring:  datasource:    url: jdbc:mysql://mysql:3306/cloud_order?useSSL=false    username: root    password: 020609    driver-class-name: com.mysql.jdbc.Driver  application:    name: orderservice  cloud:    nacos:      server-addr: nacos:8848 # nacos服务地址</code></pre><h3 id="4-3-3-打包"><a href="#4-3-3-打包" class="headerlink" title="4.3.3.打包"></a>4.3.3.打包</h3><p>接下来需要将我们的每个微服务都打包。因为之前查看到Dockerfile中的jar包名称都是app.jar，因此我们的每个微服务都需要用这个名称。</p><p>可以通过修改pom.xml中的打包名称来实现，每个微服务都需要修改：</p><pre><code class="xml">&lt;build&gt;  &lt;!-- 服务打包的最终名称 --&gt;  &lt;finalName&gt;app&lt;/finalName&gt;  &lt;plugins&gt;    &lt;plugin&gt;      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;      &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;    &lt;/plugin&gt;  &lt;/plugins&gt;&lt;/build&gt;</code></pre><p>打包后：</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images2/image-20210801095951030.png" alt="image-20210801095951030"></p><h3 id="4-3-4-拷贝jar包到部署目录"><a href="#4-3-4-拷贝jar包到部署目录" class="headerlink" title="4.3.4.拷贝jar包到部署目录"></a>4.3.4.拷贝jar包到部署目录</h3><p>编译打包好的app.jar文件，需要放到Dockerfile的同级目录中。注意：每个微服务的app.jar放到与服务名称对应的目录，别搞错了。</p><p>user-service：</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images2/image-20210801100201253.png" alt="image-20210801100201253"></p><p>order-service：</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images2/image-20210801100231495.png" alt="image-20210801100231495"></p><p>gateway：</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images2/image-20210801100308102.png" alt="image-20210801100308102"></p><h3 id="4-3-5-部署"><a href="#4-3-5-部署" class="headerlink" title="4.3.5.部署"></a>4.3.5.部署</h3><p>最后，我们需要将文件整个cloud-demo文件夹上传到虚拟机中，理由DockerCompose部署。</p><p>上传到任意目录：</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images2/image-20210801100955653.png" alt="image-20210801100955653"></p><p>部署：</p><p>进入cloud-demo目录，然后运行下面的命令：</p><pre><code class="sh">docker-compose up -d</code></pre><h1 id="5-Docker镜像仓库"><a href="#5-Docker镜像仓库" class="headerlink" title="5.Docker镜像仓库"></a>5.Docker镜像仓库</h1><p>搭建镜像仓库可以基于Docker官方提供的DockerRegistry来实现。</p><p>官网地址：<a href="https://hub.docker.com/_/registry">https://hub.docker.com/_/registry</a></p><h2 id="5-1-简化版镜像仓库"><a href="#5-1-简化版镜像仓库" class="headerlink" title="5.1.简化版镜像仓库"></a>5.1.简化版镜像仓库</h2><p>Docker官方的Docker Registry是一个基础版本的Docker镜像仓库，具备仓库管理的完整功能，但是没有图形化界面。</p><p>搭建方式比较简单，命令如下：</p><pre><code class="sh">docker run -d \    --restart=always \    --name registry\    -p 5000:5000 \    -v registry-data:/var/lib/registry \    registry</code></pre><p>命令中挂载了一个数据卷registry-data到容器内的&#x2F;var&#x2F;lib&#x2F;registry 目录，这是私有镜像库存放数据的目录。</p><p>访问<a href="http://yourip:5000/v2/_catalog">http://YourIp:5000/v2/_catalog</a> 可以查看当前私有镜像服务中包含的镜像</p><h2 id="5-2-带有图形化界面版本"><a href="#5-2-带有图形化界面版本" class="headerlink" title="5.2.带有图形化界面版本"></a>5.2.带有图形化界面版本</h2><p>使用DockerCompose部署带有图象界面的DockerRegistry，命令如下：</p><pre><code class="yaml">version: &#39;3.0&#39;services:  registry:    image: registry    volumes:      - ./registry-data:/var/lib/registry  ui:    image: joxit/docker-registry-ui:static    ports:      - 8080:80    environment:      - REGISTRY_TITLE=Dylan的私有docker仓库      - REGISTRY_URL=http://registry:5000    depends_on:      - registry</code></pre><h2 id="5-3-配置Docker信任地址"><a href="#5-3-配置Docker信任地址" class="headerlink" title="5.3.配置Docker信任地址"></a>5.3.配置Docker信任地址</h2><p>我们的私服采用的是http协议，默认不被Docker信任，所以需要做一个配置：</p><pre><code class="sh"># 打开要修改的文件vi /etc/docker/daemon.json# 添加内容：&quot;insecure-registries&quot;:[&quot;http://192.168.146.128:8080&quot;]# 重加载systemctl daemon-reload# 重启dockersystemctl restart docker</code></pre><h2 id="5-2-推送、拉取镜像"><a href="#5-2-推送、拉取镜像" class="headerlink" title="5.2.推送、拉取镜像"></a>5.2.推送、拉取镜像</h2><p><strong>推送镜像到私有镜像服务必须先tag</strong>，步骤如下：      下面换成自己的地址</p><p>① 重新tag本地镜像，名称前缀为私有仓库的地址：1192.168.146.128:8080&#x2F;</p><pre><code class="sh">docker tag nginx:1.19 192.168.146.128:8080/nginx:1.0 </code></pre><p>② 推送镜像</p><pre><code class="sh">docker push 192.168.146.128:8080/nginx:1.0 </code></pre><p>③ 拉取镜像</p><pre><code class="sh">docker pull 192.168.146.128:8080/nginx:1.0 </code></pre>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML,CSS,JS基础实战</title>
      <link href="/2023/01/20/qian-duan-san-jian-tao-lian-xi-zong-jie/"/>
      <url>/2023/01/20/qian-duan-san-jian-tao-lian-xi-zong-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="人物简历—–-前端HTML-CSS入门实践"><a href="#人物简历—–-前端HTML-CSS入门实践" class="headerlink" title="人物简历—–&gt;前端HTML+CSS入门实践"></a>人物简历—–&gt;前端HTML+CSS入门实践</h1><h1 id="一-reset-css的设置"><a href="#一-reset-css的设置" class="headerlink" title="一.reset.css的设置"></a>一.reset.css的设置</h1><p>这是提前预设的css样式, 旨在将一些元素的效果重置或者清除:</p><h2 id="元素内外边距的清除"><a href="#元素内外边距的清除" class="headerlink" title="元素内外边距的清除"></a>元素内外边距的清除</h2><pre><code class="css">body, h1, h2, h3, h4, h5, h6, hr, p,dl, dt, dd, ul, ol, li,pre,fieldset, button, input, textarea,th, td &#123;    margin: 0;    padding: 0;&#125; ---&gt;清除内外边距</code></pre><h2 id="设置默认字体"><a href="#设置默认字体" class="headerlink" title="设置默认字体"></a>设置默认字体</h2><pre><code class="css"> /*设置默认字体 */body,button, input, select, textarea &#123; /* for ie */    font: 12px/1.3 &quot;Microsoft YaHei&quot;,Tahoma, Helvetica, Arial, &quot;\5b8b\4f53&quot;, sans-serif; /* 用 Unicode 字符表示，使得在任何编码下都无问题 */    color: #333;&#125;</code></pre><h2 id="为标题元素设置字体"><a href="#为标题元素设置字体" class="headerlink" title="为标题元素设置字体"></a>为标题元素设置字体</h2><pre><code class="css">h1 &#123; font-size: 18px; /* 18px / 12px = 1.5 */ &#125;h2 &#123; font-size: 16px; &#125;h3 &#123; font-size: 14px; &#125;h4, h5, h6 &#123; font-size: 100%; &#125;</code></pre><h2 id="其他的字体设置"><a href="#其他的字体设置" class="headerlink" title="其他的字体设置"></a>其他的字体设置</h2><pre><code class="css">address, cite, dfn, em, var, i&#123; font-style: normal; &#125; /* 将斜体扶正 */b, strong&#123; font-weight: normal; &#125; /* 将粗体扶细 */code, kbd, pre, samp, tt &#123; font-family: &quot;Courier New&quot;, Courier, monospace; &#125; /* 统一等宽字体 */small &#123; font-size: 12px; &#125; /* 小于 12px 的中文很难阅读，让 small 正常化 */</code></pre><h2 id="重置列表元素"><a href="#重置列表元素" class="headerlink" title="重置列表元素"></a>重置列表元素</h2><pre><code>/* 重置列表元素 */ul, ol &#123; list-style: none; &#125;</code></pre><h2 id="重置文本格式元素"><a href="#重置文本格式元素" class="headerlink" title="重置文本格式元素"></a>重置文本格式元素</h2><pre><code class="css">a &#123; text-decoration: none; color: #666;&#125;---&gt;消除a标签的下划线并且设置文本颜色</code></pre><h2 id="重置表单元素"><a href="#重置表单元素" class="headerlink" title="重置表单元素"></a>重置表单元素</h2><pre><code class="css">legend &#123; color: #000; &#125; /* for ie6 */fieldset, img &#123; border: none; &#125;button, input, select, textarea &#123;    font-size: 100%; /* 使得表单元素在 ie 下能继承字体大小 */&#125;</code></pre><h2 id="重置表格元素"><a href="#重置表格元素" class="headerlink" title="重置表格元素"></a>重置表格元素</h2><pre><code class="css">table &#123;    border-collapse: collapse;/* 将表格设置为单一边框*/    border-spacing: 0;/* 规定相邻单元格之间边框的距离为0*/&#125;</code></pre><h2 id="其他设置"><a href="#其他设置" class="headerlink" title="其他设置"></a>其他设置</h2><pre><code class="css">/* 重置 hr */hr &#123;    border: none;    height: 1px;&#125;/* 让非ie浏览器默认也显示垂直滚动条，防止因滚动条引起的闪烁 */html &#123; overflow-y: scroll; &#125;a:link:hover&#123;     color : lightgreen !important;     text-decoration: underline; &#125;input&#123; /*去除外轮廓*/    outline: none;&#125;img&#123; /*去除行内元素换行符问题*/    display: block;&#125;</code></pre><h1 id="二-less文件的使用"><a href="#二-less文件的使用" class="headerlink" title="二 .less文件的使用"></a>二 .less文件的使用</h1><p>1.当子元素使用浮动效果时, 父元素会出现高度塌陷状况, 此时需要对父元素进行浮动的限制</p><p>如下less文件所示:–&gt;less函数引用的方式是: </p><p>在另一个less文件头部写入:</p><p>@import “mixins&#x2F;clear.less”;</p><p>即可直接</p><pre><code class="css">.clearfix()&#123;  &amp;::after&#123;    clear: both;    display: block;    content: &#39;&#39;;  &#125;&#125;</code></pre><h1 id="三-JavaScript的操作"><a href="#三-JavaScript的操作" class="headerlink" title="三.JavaScript的操作"></a>三.JavaScript的操作</h1><h2 id="1-路径导航数据的渲染"><a href="#1-路径导航数据的渲染" class="headerlink" title="1.路径导航数据的渲染"></a>1.路径导航数据的渲染</h2><p>首先确保js文件是在页面加载完毕后再进行运行的:</p><pre><code>window.onload = function()&#123;    &#125;</code></pre><p>此后所编写的函数均在此函数中</p><pre><code class="js">function navPathDataBind() &#123;    /*     *先获取路径导航的页面元素     * 再来获取所需要的数据     * 由于数据是需要动态产生的,那么相应的DOM元素也应该是动态产生的---&gt;     * 需要创建DOM元素,根据数据的数量来进行创建DOM元素     * 在遍历数据创建DOM元素的最后一条, 只创建a标签, 不创建i标签     */    //1.获取导航的元素对象    var navPath = document.querySelector(&#39;#wrapper #content .contentMain #navPath&#39;);    //2.获取数据    var path = goodData.path;    //3.遍历数据    for (var i = 0; i &lt; path.length; i++) &#123;        if (i === path.length - 1) &#123;            var aNode = document.createElement(&quot;a&quot;);            aNode.textContent = path[i].title;            navPath.appendChild(aNode);        &#125; else &#123;            //4.根据数据的数量创建相应数量的a标签与i标签            var aNode = document.createElement(&quot;a&quot;);            aNode.href = path[i].url;            aNode.textContent = path[i].title;            //创建i标签            var iNode = document.createElement(&#39;i&#39;);            iNode.textContent = &#39;/&#39;;            //让navPath追加a与i标签            navPath.appendChild(aNode);            navPath.appendChild(iNode);        &#125;    &#125;&#125;</code></pre><h2 id="2-放大镜的移入移除效果"><a href="#2-放大镜的移入移除效果" class="headerlink" title="2.放大镜的移入移除效果"></a>2.放大镜的移入移除效果</h2><pre><code class="js">//放大镜的移入移出效果bigClassBind()function bigClassBind() &#123;    /*     * 思路:     * 1.鼠标移入小图框时获取小图框元素对象(onmouseenter)     * 2.鼠标获取小图框元素对象时产生了蒙版和大图框     * 3.移出鼠标时移除蒙版和大图框(onmouseleave)     * */    //  1.鼠标移入小图框时获取小图框元素对象(onmouseenter)    var smallPic = document.querySelector(&#39;#wrapper #content .contentMain #center #left #leftTop #smallPic&#39;);    var leftTop = document.querySelector(&#39;#wrapper #content .contentMain #center #left #leftTop&#39;);    //设置移入的事件    smallPic.onmouseenter = function() &#123;        //获取数据        var imgsrc = goodData.imagessrc;        //2.创建蒙版元素        var maskDiv = document.createElement(&#39;div&#39;);        maskDiv.id = &quot;mask&quot;;        //创建大图框元素        var bigPic = document.createElement(&#39;div&#39;);        bigPic.id = &#39;bigPic&#39;;        //创建大图片元素        var bigImg = document.createElement(&#39;img&#39;);        bigImg.src = imgsrc[bigImgIndex].b;        //大图框追加大图片        bigPic.appendChild(bigImg);        //让小图框追加蒙版        smallPic.appendChild(maskDiv)            //leftTop追加大图框        leftTop.appendChild(bigPic);        //设置移动事件        smallPic.onmousemove = function(event) &#123;            //event.clientX是鼠标距离浏览器左侧X轴的值            //getBoundingClientRect().left: 小图框元素距离浏览器左侧可视left的值            //offsetWidth:为元素的占位宽度            var left = event.clientX - smallPic.getBoundingClientRect().left - maskDiv.offsetWidth / 2;            var top = event.clientY - smallPic.getBoundingClientRect().top - maskDiv.offsetHeight / 2;            if (left &lt; 0) &#123;                left = 0;            &#125; else if (left &gt; smallPic.clientWidth - maskDiv.offsetWidth) &#123;                left = smallPic.clientWidth - maskDiv.offsetWidth            &#125;            if (top &lt; 0) &#123;                top = 0;            &#125; else if (top &gt; smallPic.clientHeight - maskDiv.offsetHeight) &#123;                top = smallPic.clientHeight - maskDiv.offsetHeight            &#125;            //设置蒙版元素的left和top值            maskDiv.style.left = left + &#39;px&#39;;            maskDiv.style.top = top + &#39;px&#39;;            //移动的比例关系=蒙版元素移动的距离/大图片移动的距离            //蒙版元素移动的距离=小图框的宽度-蒙版元素的宽度           //大图片元素移动的距离=大图片宽度-大图框宽度----&gt;很重要, 因为大图框不动, 动的只是大图片, 显示的是大图框中的大图片内容            var scale = (smallPic.clientWidth - maskDiv.offsetWidth) / (bigImg.offsetWidth - bigPic.clientWidth)                // console.log(scale)---scale=0.495            bigImg.style.left = -left / scale + &#39;px&#39;;            bigImg.style.top = -top / scale + &#39;px&#39;;        &#125;        //设置移出鼠标效果        smallPic.onmouseleave = function() &#123;            //让小图框移除蒙版元素            smallPic.removeChild(maskDiv);            //让leftTop的元素移除大图框            leftTop.removeChild(bigPic);        &#125;    &#125;&#125;</code></pre><p>其中,getBoundingClientRect()的作用效果为:</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images2/image-20221006151340304.png" alt="image-20221006151340304"></p><p>offSetWidth为元素的占位宽度:</p><p>offsetWidth 水平方向 width + 左右padding + 左右border-width<br>     * offsetHeight 垂直方向 height + 上下padding + 上下border-width<br>          *<br>          * clientWidth 水平方向 width + 左右padding<br>               * clientHeight 垂直方向 height + 上下padding<br>               *<br>                    * offsetTop 获取当前元素到 定位父节点 的top方向的距离<br>                    * offsetLeft 获取当前元素到 定位父节点 的left方向的距离<br>                         *<br>                         * scrollWidth 元素内容真实的宽度，内容不超出盒子高度时为盒子的clientWidth<br>                              * scrollHeight 元素内容真实的高度，内容不超出盒子高度时为盒子的clientHeight</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images2/image-20221006153535540.png" alt="image-20221006153535540"></p><h2 id="3-动态渲染放大镜缩略图的数据"><a href="#3-动态渲染放大镜缩略图的数据" class="headerlink" title="3.动态渲染放大镜缩略图的数据"></a>3.动态渲染放大镜缩略图的数据</h2><pre><code class="js">thumbnailData()function thumbnailData() &#123;    /*     * 1.先找到picList下的ul元素     * 2.获取data.js下的图片元素     * 3.遍历数组, 根据数组的长度创建li元素     * */    var ul = document.querySelector(&quot;#wrapper #content .contentMain #center #left #leftBottom #picList ul&quot;);    var imgs = goodData.imagessrc;    for (let i = 0; i &lt; imgs.length; i++) &#123;        var newImg = document.createElement(&#39;img&#39;);        newImg.src = imgs[i].s;        var li = document.createElement(&#39;li&#39;);        li.appendChild(newImg);        ul.appendChild(li);    &#125;&#125;</code></pre><h2 id="4-点击缩略图的效果"><a href="#4-点击缩略图的效果" class="headerlink" title="4.点击缩略图的效果"></a>4.点击缩略图的效果</h2><pre><code class="js">thumbnailClick()function thumbnailClick() &#123;    /*     * 1.获取所有的li元素, 并且循环发生点击事件     * 2.点击缩略图需要确定其小图路径和大图路径,并且替换现有的src值     *     * */    var liNodes = document.querySelectorAll(&#39;#wrapper #content .contentMain #center #left #leftBottom #picList ul li&#39;)    var smallImg = document.querySelector(&#39;#wrapper #content .contentMain #center #left #leftTop #smallPic img&#39;)    var ImgSrc = goodData.imagessrc    //小图路径需要默认和imagessrc的第一个元素一致    smallImg.src = ImgSrc[0].s;    for (let i = 0; i &lt; liNodes.length; i++) &#123;        //点击这些事件之前, 给每个元素都添加上自定义的下标        liNodes[i].index = i;        liNodes[i].onclick = function() &#123;            var idx = this.index; /** 事件函数的this永远指向的是实际发生事件的目标源对象*/            bigImgIndex = idx;//bigImgIndex为全局对象            //变换小图路径            smallImg.src = ImgSrc[bigImgIndex].s;        &#125;    &#125;&#125;</code></pre><h2 id="5-点击缩略图箭头的效果"><a href="#5-点击缩略图箭头的效果" class="headerlink" title="5.点击缩略图箭头的效果"></a>5.点击缩略图箭头的效果</h2><pre><code class="js">thumbnailLeftRightClick();function thumbnailLeftRightClick() &#123;    /*    思路:        1.获取左右两端的箭头        2.再获取可视的div以及ul元素和所有的li元素        3.然后再发生点击事件 (计算发生起点和步长,总体运动的距离值)     */    //获取箭头函数    var pre = document.querySelector(&#39;#wrapper #content .contentMain #center #left #leftBottom a.prev&#39;)    var next = document.querySelector(&#39;#wrapper #content .contentMain #center #left #leftBottom a.next&#39;)        //2.再获取可视的div以及ul元素和所有的li元素    var piclist = document.querySelector(&#39;#wrapper #content .contentMain #center #left #leftBottom #picList&#39;)    var ul = document.querySelector(&#39;#wrapper #content .contentMain #center #left #leftBottom #picList ul&#39;)    var liNodes = document.querySelectorAll(&#39;#wrapper #content .contentMain #center #left #leftBottom #picList ul li&#39;)    var start = 0;    //计算步长    var step = (liNodes[0].offsetWidth + 20) * 2        // console.log(step);    //总体能够运动的距离值=ul的宽度-div框的宽度=(图片总数-div显示的图片数量)*(li的宽度+20)    var endPosition = (liNodes.length - 5) * (liNodes[0].offsetWidth + 20)    //发生事件    pre.onclick = function() &#123;        start -= step        if (start &lt; 0) &#123;            start = 0        &#125;        ul.style.left = -start + &#39;px&#39;    &#125;    next.onclick = function() &#123;        start += step;        if (start &gt; endPosition) &#123;            start = endPosition        &#125;        ul.style.left = -start + &#39;px&#39;    &#125;&#125;</code></pre><p>6.商品详情数据的动态渲染</p><pre><code class="js">//商品详情数据的动态渲染rightTopData()function rightTopData() &#123;    /*     * 查找rightTop元素     * 在data.js中找到对应的数据     * 建立字符串变量,将原来的布局结构贴进来,将所对应的数据放在对应的位置上重新渲染rightTop元素     *     * */    var rightTop = document.querySelector(&#39;#wrapper #content .contentMain #center .right .rightTop&#39;)    var goodsDetail = goodData.goodsDetail        // console.log(goodsDetail)        //模板字符串替换数据: $&#123;变量&#125;    var s = ` &lt;h3&gt;$&#123;goodsDetail.title&#125;&lt;/h3&gt;                        &lt;p&gt;$&#123;goodsDetail.recommend&#125;&lt;/p&gt;                        &lt;div class=&quot;priceWrap&quot;&gt;                            &lt;div class=&quot;priceTop&quot;&gt;                                &lt;span&gt;价&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;格&lt;/span&gt;                                &lt;div class=&quot;price&quot;&gt;                                    &lt;span&gt;¥&lt;/span&gt;                                    &lt;p&gt;$&#123;goodsDetail.price&#125;&lt;/p&gt;                                    &lt;i&gt;降价通知&lt;/i&gt;                                &lt;/div&gt;                                &lt;p&gt;                                    &lt;span&gt;累计评价&lt;/span&gt;                                    &lt;span&gt;670000&lt;/span&gt;                                &lt;/p&gt;                            &lt;/div&gt;                            &lt;div class=&quot;priceBottom&quot;&gt;                                &lt;span&gt;促&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;销&lt;/span&gt;                                &lt;p&gt;                                    &lt;span&gt;$&#123;goodsDetail.promoteSales.type&#125;&lt;/span&gt;                                    &lt;span&gt;$&#123;goodsDetail.promoteSales.content&#125;&lt;/span&gt;                                &lt;/p&gt;                            &lt;/div&gt;                        &lt;/div&gt;                        &lt;div class=&quot;support&quot;&gt;                            &lt;span&gt;支&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;持&lt;/span&gt;                            &lt;p&gt;$&#123;goodsDetail.support&#125;&lt;/p&gt;                        &lt;/div&gt;                        &lt;div class=&quot;address&quot;&gt;                            &lt;span&gt;配&amp;nbsp;送&amp;nbsp;至&lt;/span&gt;                            &lt;p&gt;$&#123;goodsDetail.address&#125;&lt;/p&gt;                        &lt;/div&gt;`;    rightTop.innerHTML = s;&#125;</code></pre><h2 id="6-商品数据参数的动态渲染"><a href="#6-商品数据参数的动态渲染" class="headerlink" title="6.商品数据参数的动态渲染"></a>6.商品数据参数的动态渲染</h2><pre><code class="js">rightBottomData();function rightBottomData() &#123;    /*     * 找到rightBottom元素对象     * 查找data.js中的goodsDetail.crumbData[i].对应的属性     * 由于数据是一个数组,需要遍历,有一个元素则需要有有一个动态的dl元素     * */    var chooseWrap = document.querySelector(&#39;#wrapper #content .contentMain #center .right .rightBottom .chooseWrap&#39;)    var crumbData = goodData.goodsDetail.crumbData;    for (let i = 0; i &lt; crumbData.length; i++) &#123;        //创建动态的dl元素对象        var dlNode = document.createElement(&#39;dl&#39;);        //创建dt对象        var dtNode = document.createElement(&#39;dt&#39;);        dtNode.innerText = crumbData[i].title        //dl追加dt        dlNode.appendChild(dtNode);        //继续遍历数组创建dd元素        for (let j = 0; j &lt; crumbData[i].data.length; j++) &#123;            var ddNode = document.createElement(&#39;dd&#39;)            ddNode.innerText = crumbData[i].data[j].type            ddNode.setAttribute(&#39;priceChange&#39;, crumbData[i].data[j].changePrice)            dlNode.appendChild(ddNode)        &#125;        //让chooseWrap追加dl        chooseWrap.appendChild(dlNode)    &#125;&#125;</code></pre><p>7.点击商品参数之后的颜色排他效果以及展示点击的商品参数,以及删除效果</p><pre><code class="js">clickddBind()function clickddBind() &#123;    /*     * 获取所有的dl元素, 取其中的第一个dl元素下的所有dd先做测试, 测试完毕后嵌套循环     * 循环所有的dd元素并且添加点击事件     * 确定实际发生事件的目标源对象并设置为红色然后给其他所有元素颜色都重置为基础颜色     *     * 点击dd后产生Mark标记并展示:     * 首先创建一个可以容纳dd元素值的容器(数组), 确定数组的长度     * 然后再将点击的dd元素的值按照对应下标来写到数组的元素身上     * */    var dlNodes = document.querySelectorAll(&#39;#wrapper #content .contentMain #center .right .rightBottom .chooseWrap dl&#39;)        // console.log(dlNodes)    var arr = new Array(dlNodes.length);    arr.fill(0);    var chosen = document.querySelector(&#39;#wrapper #content .contentMain #center .right .rightBottom .chosen&#39;)    for (let i = 0; i &lt; dlNodes.length; i++) &#123;        let ddNodes = dlNodes[i].querySelectorAll(&#39;dd&#39;);        for (let k = 0; k &lt; ddNodes.length; k++) &#123;            ddNodes[k].onclick = function() &#123;                //清空之前点击产生的mark                chosen.innerHTML = &#39;&#39;;                for (let j = 0; j &lt; ddNodes.length; j++) &#123;                    ddNodes[j].style.color = &#39;#666&#39;;                &#125;                this.style.color = &quot;red&quot;;                // 点击哪一个dd元素, 产生动态的参数标签                arr[i] = this;                priceChange(arr);                // console.log(arr);                arr.forEach(function(value, index) &#123;                        if (value) &#123;                            let markDiv = document.createElement(&#39;div&#39;);                            markDiv.className = &#39;mark&#39;;                            markDiv.innerText = value.innerText;                            let a = document.createElement(&#39;a&#39;);                            //每一个被选择的属性的下标值都要与dl的下标值对应, 通过index                            a.setAttribute(&#39;index&#39;, index)                            a.innerText = &#39;X&#39;;                            markDiv.appendChild(a);                            chosen.appendChild(markDiv);                        &#125;                    &#125;)                    //    获取所有的a标签, 并循环发生点击事件(添加删除效果)                var aNodes = document.querySelectorAll(&#39;#wrapper #content .contentMain #center .right .rightBottom .chosen .mark a&#39;)                for (let j = 0; j &lt; aNodes.length; j++) &#123;                    aNodes[j].onclick = function() &#123;                        let index = this.getAttribute(&#39;index&#39;);                        //查找对应下标的dl行的所有dd元素                        var ddList = dlNodes[index].querySelectorAll(&#39;dd&#39;)                            //遍历所有的dd                        for (let l = 0; l &lt; ddList.length; l++) &#123;                            //点击删除后默认第一个dd为红色,其他dd的元素颜色均为默认                            ddList[l].style.color = &#39;#666&#39;;                        &#125;                        ddList[0].style.color = &#39;red&#39;;                        chosen.removeChild(this.parentNode);                        //删除对应下标的元素后, 原数组相应下标的值也要改为0                        arr[index] = 0;                        //调用价格变动函数                        priceChange(arr);                    &#125;                &#125;            &#125;        &#125;    &#125;&#125;</code></pre><h2 id="7-价格变动函数"><a href="#7-价格变动函数" class="headerlink" title="7.价格变动函数"></a>7.价格变动函数</h2><pre><code class="js">function priceChange(arr) &#123;    /*     * 思路:     * 无论点击什么参数, 最终的价格都是显示在价格上,因此首先需要找到价格元素     *给每一个dd标签上都默认设置一个属性, 用来记录变化的价格     *遍历arr数组, 将dd元素身上的新变化的价格加到原本的price上     * */    let price = document.querySelector(&#39;#wrapper #content .contentMain #center .right .rightTop .priceWrap .priceTop .price p&#39;)        //提出默认的price    let oldPrice = goodData.goodsDetail.price;    for (let i = 0; i &lt; arr.length; i++) &#123;        if (arr[i]) &#123;            let changes = Number(arr[i].getAttribute(&#39;priceChange&#39;))            oldPrice += changes;        &#125;    &#125;    price.innerText = oldPrice;    //将变化后的价格写入左侧标签中    var leftPrice=document.querySelector(&#39;#wrapper #content .contentMain .goodsDetailsWrap .rightDetails .chooseBox .listWrap .left p&#39;)    leftPrice.innerText=&#39;¥&#39;+price.innerText;    var rightPrice=document.querySelector(&#39;#wrapper #content .contentMain .goodsDetailsWrap .rightDetails .chooseBox .right i&#39;)    //判断是否选择其他配套商品, 若选中则加上,未选中则和左侧价格一致    var inputs=document.querySelectorAll(&#39;#wrapper #content .contentMain .goodsDetailsWrap .rightDetails .chooseBox .middle div input&#39;)    for (let i = 0; i &lt;inputs.length; i++) &#123;        if(inputs[i].checked)&#123;            oldPrice+=Number(inputs[i].value)        &#125;    &#125;    rightPrice.innerText=&#39;¥&#39;+oldPrice;&#125;</code></pre><h2 id="8-选择搭配中间区域复选框选中套餐价变动效果"><a href="#8-选择搭配中间区域复选框选中套餐价变动效果" class="headerlink" title="8.选择搭配中间区域复选框选中套餐价变动效果"></a>8.选择搭配中间区域复选框选中套餐价变动效果</h2><pre><code class="js">choosePrice();function choosePrice()&#123;    /**     * 思路:     * 先获取其中所有的复选框元素     * 遍历, 点中几个就将套餐价加相应的价格     * 累加后重新写回标签中     */    var inputs=document.querySelectorAll(&#39;#wrapper #content .contentMain .goodsDetailsWrap .rightDetails .chooseBox .middle div input&#39;)    var leftPrice=document.querySelector(&#39;#wrapper #content .contentMain .goodsDetailsWrap .rightDetails .chooseBox .listWrap .left p&#39;)    var newPrice=document.querySelector(&#39;#wrapper #content .contentMain .goodsDetailsWrap .rightDetails .chooseBox .right i&#39;)    for (let i = 0; i &lt; inputs.length; i++) &#123;        inputs[i].onclick=function ()&#123;            let oldPrice=Number(leftPrice.innerText.slice(1));            for (let j = 0; j &lt; inputs.length; j++) &#123;                if(inputs[j].checked)&#123;                    oldPrice=oldPrice+Number(inputs[j].value);                &#125;            &#125;            //累加后重新写回标签中            newPrice.innerText=&#39;¥&#39;+oldPrice;        &#125;    &#125;&#125;</code></pre><h2 id="9-封装一个公共的选项卡函数"><a href="#9-封装一个公共的选项卡函数" class="headerlink" title="9.封装一个公共的选项卡函数"></a>9.封装一个公共的选项卡函数</h2><pre><code class="js">/** * 1需要被点击的元素 tabBtns * 被切换显示的元素 tabConts * */function Tab(tabBtns,tabConts)&#123;    for (let i = 0; i &lt; tabBtns.length; i++) &#123;        tabBtns[i].index=i;        tabBtns[i].onclick=function ()&#123;            for (let j = 0; j &lt; tabBtns.length; j++) &#123;                tabBtns[j].className=&#39;&#39;;                tabConts[j].className=&#39;&#39;;            &#125;            this.className=&#39;active&#39;;            tabConts[this.index].className=&#39;active&#39;;        &#125;    &#125;&#125;</code></pre><pre><code class="js">//点击左侧选项卡leftTab();function leftTab()&#123;    let h4s=document.querySelectorAll(&#39;#wrapper #content .contentMain .goodsDetailsWrap .leftAside .asideTop h4&#39;);    let divs=document.querySelectorAll(&#39;#wrapper #content .contentMain .goodsDetailsWrap .leftAside .asideBottom&gt;div&#39;);    Tab(h4s,divs)&#125;//点击右侧选项卡rightTab()function rightTab()&#123;    let lis=document.querySelectorAll(&#39;#wrapper #content .contentMain .goodsDetailsWrap .rightDetails .bottomDetail .tabBtns li&#39;)    let divs=document.querySelectorAll(&#39;#wrapper #content .contentMain .goodsDetailsWrap .rightDetails .bottomDetail .tabContents &gt;div&#39;)    Tab(lis,divs);&#125;</code></pre><h2 id="10-右边侧边栏的点击效果"><a href="#10-右边侧边栏的点击效果" class="headerlink" title="10.右边侧边栏的点击效果"></a>10.右边侧边栏的点击效果</h2><pre><code class="js">rightClick();function rightClick()&#123;    /**     * 先找到按钮元素,发生点击事件     */    let btn=document.querySelector(&#39;#wrapper .rightAside .btns&#39;)    //记录初始状态    let flag=true;//关闭    //查找侧边栏元素    let rightAside=document.querySelector(&#39;#wrapper .rightAside&#39;)    //发生点击事件    btn.onclick=function ()&#123;        console.log(1)        //判断        if(flag)&#123;            //展开            btn.className=&#39;btns open&#39;;            rightAside.className=&#39;rightAside asideOpen&#39;;        &#125;else&#123;            //关闭            btn.className=&#39;btns Close&#39;;            rightAside.className=&#39;rightAside asideClose&#39;;        &#125;        flag=!flag    &#125;&#125;</code></pre><h1 id="四-此项目多次用到的定位效果"><a href="#四-此项目多次用到的定位效果" class="headerlink" title="四.此项目多次用到的定位效果"></a>四.此项目多次用到的定位效果</h1><p>css中的position属性用于设置元素位置的确定方式，它有以下几种取值：</p><ul><li>static：默认定位方式，子元素在父容器中挨个摆放</li><li>absolute：绝对定位，元素不占据父容器空间，相当于文档body定位<br>（如果元素的父级节点中有position不等于static的，则相当于最近的非static父节点定位）</li><li>relative：相对定位，占据父容器空间，但显示位置相当于自身位置进行偏移</li><li>fixed：固定定位，元素相当于窗口进行定位<br>（相当于窗口而不是文档定位，所以即使发生进度条滚动时，元素相当于窗口的位置仍然不变）</li><li>sticky：粘性定位，这是一个带过渡效果的定位方式，只有在滚动时才能看出其变化效果<br>当偏移量大于指定值时，以static方式显示<br>当偏移量小于指定值时，以fixed方式显示，但却像relative方式一样占据父容器空间<br>当元素到达父容器边缘时，位置相当于父容器不再变化</li></ul><p>在css中，z-index的意思为“层级，层空间层叠等级”，可以指定一个元素的堆叠顺序，用于确认元素在当前层叠上下文中的层叠级别，拥有更高堆叠顺序的元素总是会处于堆叠顺序较低的元素的前面；语法“元素{z-index ：auto|<integer>}”。</p><p>css中的transition:</p><p>通常情况下，CSS 属性变化是立即生效的，新的属性值在超级短的时间内替换掉旧的属性值，然后浏览器重新绘制样式内容（可能是 reflow 或者 repaint）。大部分情况下会感觉样式变化突兀，而transition则可以添加顺滑的一个变化效果。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JS </category>
          
          <category> HTML </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>用java实现一个mini数据库</title>
      <link href="/2023/01/09/dylandb/"/>
      <url>/2023/01/09/dylandb/</url>
      
        <content type="html"><![CDATA[<h1 id="一-整体架构"><a href="#一-整体架构" class="headerlink" title="一.整体架构"></a>一.整体架构</h1><p>DylanDB 分为后端和前端，前后端通过 socket 进行交互。前端（客户端）的职责很单一，读取用户输入，并发送到后端执行，输出返回结果，并等待下一次输入。DylanDB后端则需要解析 SQL，如果是合法的 SQL，就尝试执行并返回结果。不包括解析器，DylanDB 的后端划分为五个模块，每个模块都又一定的职责，通过接口向其依赖的模块提供方法。五个模块如下：</p><ol><li>Transaction Manager（TM）</li><li>Data Manager（DM）</li><li>Version Manager（VM）</li><li>Index Manager（IM）</li><li>Table Manager（TBM）</li></ol><p>DylanDB 模块依赖</p><p>从这个依赖图中，拓扑排序一下就能看出实现顺序。实现顺序是 TM -&gt; DM -&gt; VM -&gt; IM -&gt; TBM</p><p>每个模块的职责如下：</p><ol><li>TM 通过维护 XID 文件来维护事务的状态，并提供接口供其他模块来查询某个事务的状态。</li><li>DM 直接管理数据库 DB 文件和日志文件。DM 的主要职责有：1) 分页管理 DB 文件，并进行缓存；2) 管理日志文件，保证在发生错误时可以根据日志进行恢复；3) 抽象 DB 文件为 DataItem 供上层模块使用，并提供缓存。</li><li>VM 基于两段锁协议实现了调度序列的可串行化，并实现了 MVCC 以消除读写阻塞。同时实现了两种隔离级别。</li><li>IM 实现了基于 B+ 树的索引，BTW，目前 where 只支持已索引字段。</li><li>TBM 实现了对字段和表的管理。同时，解析 SQL 语句，并根据语句操作表。</li></ol><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230408175308884.png" alt="image-20230408175308884"></p><h2 id="运行示例"><a href="#运行示例" class="headerlink" title="运行示例"></a>运行示例</h2><p>注意首先需要在 pom.xml 中调整编译版本，如果导入 IDE，请更改项目的编译版本以适应你的 JDK</p><p>首先执行以下命令编译源码：</p><pre><code class="shell">mvn compile</code></pre><p>接着执行以下命令以 &#x2F;tmp&#x2F;DylanDB作为路径创建数据库：</p><pre><code class="shell">mvn exec:java -Dexec.mainClass=&quot;cn.dylan.DylanDB.function.Launcher&quot; -Dexec.args=&quot;-create D:/tmp/DylanDB&quot;</code></pre><p>随后通过以下命令以默认参数启动数据库服务：</p><pre><code class="shell">mvn exec:java -Dexec.mainClass=&quot;cn.dylan.DylanDB.function.Launcher&quot; -Dexec.args=&quot;-open  D:/tmp/DylanDB&quot;</code></pre><p>这时数据库服务就已经启动在本机的 9999 端口。重新启动一个终端，执行以下命令启动客户端连接数据库：</p><pre><code class="shell">mvn exec:java -Dexec.mainClass=&quot;cn.dylan.DylanDB.client.Launcher&quot;</code></pre><p>会启动一个交互式命令行，就可以在这里输入类 SQL 语法，回车会发送语句到服务，并输出执行的结果。</p><p>一个执行示例：</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/mydb0example.jpg" alt="mydb0example"></p><h1 id="二-事务管理"><a href="#二-事务管理" class="headerlink" title="二.事务管理"></a>二.事务管理</h1><h2 id="XID-文件"><a href="#XID-文件" class="headerlink" title="XID 文件"></a>XID 文件</h2><p>在 DylanDB 中，每一个事务都有一个 XID，这个 ID 唯一标识了这个事务。事务的 XID 从 1 开始标号，并自增，不可重复。并特殊规定 XID 0 是一个超级事务（Super Transaction）。当一些操作想在没有申请事务的情况下进行，那么可以将操作的 XID 设置为 0。XID 为 0 的事务的状态永远是 committed。</p><p>TransactionManager 维护了一个 XID 格式的文件，用来记录各个事务的状态。DylanDB 中，每个事务都有下面的三种状态：</p><ol><li>active，正在进行，尚未结束</li><li>committed，已提交</li><li>aborted，已撤销（回滚）</li></ol><p>XID 文件给每个事务分配了一个字节的空间，用来保存其状态。同时，在 XID 文件的头部，还保存了一个 8 字节的数字，记录了这个 XID 文件管理的事务的个数。于是，事务 xid 在文件中的状态就存储在 (xid-1)+8 字节处，xid-1 是因为 xid 0（Super XID） 的状态不需要记录。</p><h2 id="事务接口"><a href="#事务接口" class="headerlink" title="事务接口"></a>事务接口</h2><p>TransactionManager 提供了一些接口供其他模块调用，用来创建事务和查询事务状态。更具体的：</p><pre><code class="java">/** * @author Dylan * @version 1.0 * @date 2023/4/8 16:09 * @description 事务接口 **/public interface TransactionManager &#123;    long begin();                       // 开启一个新事务    void commit(long xid);              // 提交一个事务    void abort(long xid);               // 取消一个事务    boolean isActive(long xid);         // 查询一个事务的状态是否是正在进行的状态    boolean isCommitted(long xid);      // 查询一个事务的状态是否是已提交    boolean isAborted(long xid);        // 查询一个事务的状态是否是已取消    void close();                       // 关闭TM&#125;</code></pre><h2 id="实现类"><a href="#实现类" class="headerlink" title="实现类:"></a>实现类:</h2><pre><code class="java">public class TransactionManagerImpl implements TransactionManager&#123;    // XID文件头长度    static final int LEN_XID_HEADER_LENGTH = 8;    // 每个事务的占用长度    private static final int XID_FIELD_SIZE = 1;    // 事务的三种状态    private static final byte FIELD_TRAN_ACTIVE   = 0;   //开启但未提交    private static final byte FIELD_TRAN_COMMITTED = 1;  //已提交    private static final byte FIELD_TRAN_ABORTED  = 2;  //取消    // 超级事务，永远为commited状态    public static final long SUPER_XID = 0;    // XID 文件后缀    static final String XID_SUFFIX = &quot;.xid&quot;;    private RandomAccessFile file;    private FileChannel fc;    private long xidCounter;    //锁    private Lock counterLock;    public TransactionManagerImpl(RandomAccessFile raf, FileChannel fc)&#123;        this.file=raf;        this.fc=fc;    &#125;    /**     * 对xid文件进行合法性判断     * @return     */    public void checkXIDCounter()&#123;        long fileLen=0;        try &#123;            fileLen=file.length();        &#125; catch (IOException e) &#123;            CatchException.catchExc(Error.BadXIDFileException);        &#125;        if(fileLen&lt;LEN_XID_HEADER_LENGTH)&#123;            CatchException.catchExc(Error.BadXIDFileException);        &#125;        ByteBuffer buf=ByteBuffer.allocate(LEN_XID_HEADER_LENGTH);        try &#123;            fc.position(0);            fc.read(buf);        &#125;catch (IOException e)&#123;            CatchException.catchExc(e);        &#125;        this.xidCounter= Parser.parseLong(buf.array());        long end=getXidPosition(this.xidCounter+1);        if(end!=fileLen)&#123;            CatchException.catchExc(Error.BadXIDFileException);        &#125;    &#125;    // 根据事务xid取得其在xid文件中对应的位置    private long getXidPosition(long xid) &#123;        return LEN_XID_HEADER_LENGTH + (xid-1)*XID_FIELD_SIZE;    &#125;    //开启一个事务,并且返回事务id    @Override    public long begin() &#123;        counterLock.lock();        try &#123;            long xid = xidCounter + 1;            updateXID(xid, FIELD_TRAN_ACTIVE);            incrXIDCounter();            return xid;        &#125; finally &#123;            counterLock.unlock();        &#125;    &#125;    // 更新xid事务的状态为status    private void updateXID(long xid, byte status) &#123;        long offset = getXidPosition(xid);        byte[] tmp = new byte[XID_FIELD_SIZE];        tmp[0] = status;        ByteBuffer buf = ByteBuffer.wrap(tmp);        try &#123;            fc.position(offset);            fc.write(buf);        &#125; catch (IOException e) &#123;           CatchException.catchExc(e);        &#125;        try &#123;            fc.force(false);        &#125; catch (IOException e) &#123;            CatchException.catchExc(e);        &#125;    &#125;    // 将XID加一，并更新XID Header    private void incrXIDCounter() &#123;        xidCounter ++;        ByteBuffer buf = ByteBuffer.wrap(Parser.long2Byte(xidCounter));        try &#123;            fc.position(0);            fc.write(buf);        &#125; catch (IOException e) &#123;           CatchException.catchExc(e);        &#125;        try &#123;            fc.force(false);        &#125; catch (IOException e) &#123;            CatchException.catchExc(e);        &#125;    &#125;    // 检测XID事务是否处于status状态    private boolean checkXID(long xid, byte status) &#123;        long offset = getXidPosition(xid);        ByteBuffer buf = ByteBuffer.wrap(new byte[XID_FIELD_SIZE]);        try &#123;            fc.position(offset);            fc.read(buf);        &#125; catch (IOException e) &#123;            CatchException.catchExc(e);        &#125;        return buf.array()[0] == status;    &#125;    /**    注意，这里的所有文件操作，在执行后都需要立刻刷入文件中，防止在崩溃后文件丢失数据，fileChannel 的 force() 方法，强制同步缓存内容到文件中，类似于 BIO 中的 flush() 方法。force 方法的参数是一个布尔，表示是否同步文件的元数据（例如最后修改时间等）。    */    //commit() 和 abort() 方法就可以直接借助 updateXID() 方法实现。    //同样，isActive()、isCommitted() 和 isAborted() 都是检查一个 xid 的状态，可以用一个通用的方法解决：    @Override    public void commit(long xid) &#123;        updateXID(xid,FIELD_TRAN_COMMITTED);    &#125;    @Override    public void abort(long xid) &#123;        updateXID(xid,FIELD_TRAN_ABORTED);    &#125;    @Override    public boolean isActive(long xid) &#123;        if(xid==SUPER_XID)&#123;            return false;        &#125;        return checkXID(xid,FIELD_TRAN_ACTIVE);    &#125;    @Override    public boolean isCommitted(long xid) &#123;        if(xid==SUPER_XID)&#123;            return false;        &#125;        return checkXID(xid,FIELD_TRAN_COMMITTED);    &#125;    @Override    public boolean isAborted(long xid) &#123;        if(xid==SUPER_XID)&#123;            return false;        &#125;        return checkXID(xid,FIELD_TRAN_ABORTED);    &#125;    @Override    public void close() &#123;        try &#123;            fc.close();            file.close();        &#125; catch (IOException e) &#123;            CatchException.catchExc(e);        &#125;    &#125;&#125;</code></pre><p>文件读写都采用了 NIO 方式的 FileChannel，读写方式都和传统 IO 的 Input&#x2F;Output Stream 都有一些区别,在构造函数创建了一个 TransactionManager 之后，首先要对 XID 文件进行校验，以保证这是一个合法的 XID 文件。校验的方式也很简单，<strong>通过文件头的 8 字节数字反推文件的理论长度</strong>，与文件的实际长度做对比。如果不同则认为 XID 文件不合法。</p><p>对于校验没有通过的，会直接通过 <strong>catchExc</strong>方法，强制停机。在一些基础模块中出现错误都会如此处理，无法恢复的错误只能直接停机。</p><h1 id="三-引用计数缓存框架和共享内存数组"><a href="#三-引用计数缓存框架和共享内存数组" class="headerlink" title="三.引用计数缓存框架和共享内存数组"></a>三.引用计数缓存框架和共享内存数组</h1><h2 id="为什么不用LRU"><a href="#为什么不用LRU" class="headerlink" title="为什么不用LRU?"></a>为什么不用LRU?</h2><p>如果使用 LRU 缓存，那么只需要设计一个 <code>get(key)</code> 接口即可，释放缓存可以在缓存满了之后自动完成。设想这样一个场景：某个时刻缓存满了，缓存驱逐了一个资源，这时上层模块想要将某个资源强制刷回数据源，这个资源恰好是刚刚被驱逐的资源。那么上层模块就发现，这个数据在缓存里消失了，这时候就陷入了一种尴尬的境地：是否有必要做回源操作？</p><ol><li>不回源。由于没法确定缓存被驱逐的时间，更没法确定被驱逐之后数据项是否被修改，这样是极其不安全的</li><li>回源。如果数据项被驱逐时的数据和现在又是相同的，那就是一次无效回源</li><li>放回缓存里，等下次被驱逐时回源。看起来解决了问题，但是此时缓存已经满了，这意味着你还需要驱逐一个资源才能放进去。这有可能会导致缓存抖动问题</li></ol><p>当然我们可以记录下资源的最后修改时间，并且让缓存记录下资源被驱逐的时间。但是……</p><p>问题的根源还是，LRU 策略中，资源驱逐不可控，上层模块无法感知。而引用计数策略正好解决了这个问题，只有上层模块主动释放引用，缓存在确保没有模块在使用这个资源了，才会去驱逐资源。</p><p>这就是引用计数法了。增加了一个方法 <code>release(key)</code>，用于在上册模块不使用某个资源时，释放对资源的引用。当引用归零时，缓存就会驱逐这个资源。</p><p>同样，在缓存满了之后，引用计数法无法自动释放缓存，此时应该直接报错（和 JVM 似的，直接 OOM）</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p><code>AbstractCache&lt;T&gt;</code> 是一个抽象类，内部有两个抽象方法，留给实现类去实现具体的操作：</p><pre><code class="java">/** * 当资源不在缓存时的获取行为 */protected abstract T getForCache(long key) throws Exception;/** * 当资源被驱逐时的写回行为 */protected abstract void releaseForCache(T obj);</code></pre><p>引用计数嘛，除了普通的缓存功能，还需要另外维护一个计数。除此以外，为了应对多线程场景，还需要记录哪些资源正在从数据源获取中（从数据源获取资源是一个相对费时的操作）。于是有下面三个 Map：</p><pre><code class="java">private HashMap&lt;Long, T&gt; cache;                     // 实际缓存的数据private HashMap&lt;Long, Integer&gt; references;          // 资源的引用个数private HashMap&lt;Long, Boolean&gt; getting;             // 正在被获取的资源</code></pre><p>于是，在通过 get() 方法获取资源时，首先进入一个死循环，来无限尝试从缓存里获取。首先就需要检查这个时候是否有其他线程正在从数据源获取这个资源，如果有，就过会再来看看</p><pre><code class="java">while(true) &#123;    lock.lock();    if(getting.containsKey(key)) &#123;        // 请求的资源正在被其他线程获取        lock.unlock();        try &#123;            Thread.sleep(1);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();            continue;        &#125;        continue;    &#125;    ...&#125;</code></pre><p>当然如果资源在缓存中，就可以直接获取并返回了，记得要给资源的引用数 +1。否则，如果缓存没满的话，就在 getting 中注册一下，该线程准备从数据源获取资源了。</p><pre><code class="java">while(true) &#123;    if(cache.containsKey(key)) &#123;        // 资源在缓存中，直接返回        T obj = cache.get(key);        references.put(key, references.get(key) + 1);        lock.unlock();        return obj;    &#125;    // 尝试获取该资源    if(maxResource &gt; 0 &amp;&amp; count == maxResource) &#123;        lock.unlock();        throw Error.CacheFullException;    &#125;    count ++;    getting.put(key, true);    lock.unlock();    break;&#125;</code></pre><p>从数据源获取资源就比较简单了，直接调用那个抽象方法即可，获取完成记得从 getting 中删除 key。</p><pre><code class="java">T obj = null;try &#123;    obj = getForCache(key);&#125; catch(Exception e) &#123;    lock.lock();    count --;    getting.remove(key);    lock.unlock();    throw e;&#125;lock.lock();getting.remove(key);cache.put(key, obj);references.put(key, 1);lock.unlock();</code></pre><p>释放一个缓存就简单多了，直接从 references 中减 1，如果已经减到 0 了，就可以回源，并且删除缓存中所有相关的结构了</p><pre><code class="java">/** * 强行释放一个缓存 */protected void release(long key) &#123;    lock.lock();    try &#123;        int ref = references.get(key)-1;        if(ref == 0) &#123;            T obj = cache.get(key);            releaseForCache(obj);            references.remove(key);            cache.remove(key);            count --;        &#125; else &#123;            references.put(key, ref);        &#125;    &#125; finally &#123;        lock.unlock();    &#125;&#125;</code></pre><p>缓存应当还有以一个安全关闭的功能，在关闭时，需要将缓存中所有的资源强行回源。</p><pre><code class="java">lock.lock();try &#123;    Set&lt;Long&gt; keys = cache.keySet();    for (long key : keys) &#123;        release(key);        references.remove(key);        cache.remove(key);    &#125;&#125; finally &#123;    lock.unlock();&#125;</code></pre><h3 id="共享内存数组"><a href="#共享内存数组" class="headerlink" title="共享内存数组"></a>共享内存数组</h3><p>这里得提一个 Java 很蛋疼的地方。</p><p>Java 中，将数组看作一个对象，在内存中，也是以对象的形式存储的。而 c、cpp 和 go 之类的语言，数组是用指针来实现的。这就是为什么有一种说法：</p><blockquote><p>只有 Java 有真正的数组</p></blockquote><p>但这对这个项目似乎不是一个好消息。譬如 golang，可以执行下面语句：</p><pre><code class="java">var array1 [10]int64array2 := array1[5:]</code></pre><p>这种情况下，array2 和 array1 的第五个元素到最后一个元素，是共用同一片内存的，即使这两个数组的长度不同。</p><p>这在 Java 中是无法实现的（什么是高级语言啊~）。</p><p>在 Java 中，当你执行类似 subArray 的操作时，只会在底层进行一个复制，无法同一片内存。</p><p>于是，就有了一个 SubArray 类，来（松散地）规定这个数组的可使用范围：</p><pre><code class="java">public class SubArray &#123;    public byte[] raw;    public int start;    public int end;    public SubArray(byte[] raw, int start, int end) &#123;        this.raw = raw;        this.start = start;        this.end = end;    &#125;&#125;</code></pre><h1 id="四-数据页的缓存与管理"><a href="#四-数据页的缓存与管理" class="headerlink" title="四.数据页的缓存与管理"></a>四.数据页的缓存与管理</h1><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>这里参考大部分数据库的设计，将默认数据页大小定为 8K。如果想要提升向数据库写入大量数据情况下的性能的话，也可以适当增大这个值。</p><p>上一节我们已经实现了一个通用的缓存框架，那么这一节我们需要缓存页面，就可以直接借用那个缓存的框架了。但是首先，需要定义出页面的结构。注意这个页面是存储在内存中的，与已经持久化到磁盘的抽象页面有区别。</p><p>页面:</p><pre><code class="java">public class PageImpl implements Page &#123;    private int pageNumber;    private byte[] data;    private boolean dirty;    private Lock lock;    private PageCache pc;&#125;</code></pre><p>其中，pageNumber 是这个页面的页号，<strong>该页号从 1 开始</strong>(页号为0的有其他用途)。data 就是这个页实际包含的字节数据。dirty 标志着这个页面是否是脏页面，在缓存驱逐的时候，脏页面需要被写回磁盘。这里保存了一个 PageCache（还未定义）的引用，用来方便在拿到 Page 的引用时可以快速对这个页面的缓存进行释放操作。</p><p>定义页面缓存的接口如下：</p><pre><code class="java">public interface PageCache &#123;    int newPage(byte[] initData);    Page getPage(int pgno) throws Exception;    void close();    void release(Page page);    void truncateByBgno(int maxPgno);    int getPageNumber();    void flushPage(Page pg);&#125;</code></pre><p>页面缓存的具体实现类，需要继承抽象缓存框架，并且实现 <code>getForCache()</code> 和 <code>releaseForCache()</code> 两个抽象方法。由于数据源就是文件系统，<code>getForCache()</code> 直接从文件中读取，并包裹成 Page 即可：</p><pre><code class="java">@Overrideprotected Page getForCache(long key) throws Exception &#123;    int pgno = (int)key;    long offset = PageCacheImpl.pageOffset(pgno);    ByteBuffer buf = ByteBuffer.allocate(PAGE_SIZE);    fileLock.lock();    try &#123;        fc.position(offset);        fc.read(buf);    &#125; catch(IOException e) &#123;        CatchException.catchExc(e);    &#125;    fileLock.unlock();    return new PageImpl(pgno, buf.array(), this);&#125;private static long pageOffset(int pgno) &#123;    // 页号从 1 开始    return (pgno-1) * PAGE_SIZE;&#125;</code></pre><p>而 <code>releaseForCache()</code> 驱逐页面时，也只需要根据页面是否是脏页面，来决定是否需要写回文件系统：</p><pre><code class="java">@Overrideprotected void releaseForCache(Page pg) &#123;    if(pg.isDirty()) &#123;        flush(pg);        pg.setDirty(false);    &#125;&#125;private void flush(Page pg) &#123;    int pgno = pg.getPageNumber();    long offset = pageOffset(pgno);    fileLock.lock();    try &#123;        ByteBuffer buf = ByteBuffer.wrap(pg.getData());        fc.position(offset);        fc.write(buf);        fc.force(false);    &#125; catch(IOException e) &#123;        CatchException.catchExc(e);    &#125; finally &#123;        fileLock.unlock();    &#125;&#125;</code></pre><p>PageCache 还使用了一个 AtomicInteger，来记录了当前打开的数据库文件有多少页。这个数字在数据库文件被打开时就会被计算，并在新建页面时自增。</p><pre><code class="java">public int newPage(byte[] initData) &#123;    int pgno = pageNumbers.incrementAndGet();    Page pg = new PageImpl(pgno, initData, null);    flush(pg);  // 新建的页面需要立刻写回    return pgno;&#125;</code></pre><h2 id="数据页管理"><a href="#数据页管理" class="headerlink" title="数据页管理"></a>数据页管理</h2><h3 id="第一页"><a href="#第一页" class="headerlink" title="第一页"></a>第一页</h3><p>数据库文件的第一页，通常用作一些特殊用途，比如存储一些元数据，用来启动检查什么的。DylanDB的第一页，只是用来做启动检查。具体的原理是，在每次数据库启动时，会生成一串随机字节，存储在 100 ~ 107 字节。在数据库正常关闭时，会将这串字节，拷贝到第一页的 108 ~ 115 字节。</p><p>这样数据库在每次启动时，就会检查第一页两处的字节是否相同，以此来判断上一次是否正常关闭。如果是异常关闭，就需要执行数据的恢复流程。</p><p>启动时设置初始字节：</p><pre><code class="java">public static void setVcOpen(Page pg) &#123;    pg.setDirty(true);    setVcOpen(pg.getData());&#125;private static void setVcOpen(byte[] raw) &#123;    System.arraycopy(RandomUtil.randomBytes(LEN_VC), 0, raw, OF_VC, LEN_VC);&#125;</code></pre><p>关闭时拷贝字节：</p><pre><code class="java">public static void setVcClose(Page pg) &#123;    pg.setDirty(true);    setVcClose(pg.getData());&#125;private static void setVcClose(byte[] raw) &#123;    System.arraycopy(raw, OF_VC, raw, OF_VC+LEN_VC, LEN_VC);&#125;</code></pre><p>校验字节：</p><pre><code class="java">public static boolean checkVc(Page pg) &#123;    return checkVc(pg.getData());&#125;private static boolean checkVc(byte[] raw) &#123;    return Arrays.equals(Arrays.copyOfRange(raw, OF_VC, OF_VC+LEN_VC), Arrays.copyOfRange(raw, OF_VC+LEN_VC, OF_VC+2*LEN_VC));&#125;</code></pre><p>似乎就是这个 <code>Arrays.compare()</code> 方法不兼容 JDK8，可以使用其他等价的方法替换。</p><h3 id="普通页"><a href="#普通页" class="headerlink" title="普通页"></a>普通页</h3><p>DylanDB 对于普通数据页的管理就比较简单了。一个普通页面以一个 <strong>2 字节无符号数起始</strong>，表示这一页的空闲位置的偏移。剩下的部分都是实际存储的数据。</p><p>所以对普通页的管理，基本都是围绕着对 FSO（Free Space Offset）进行的。例如向页面插入数据：</p><pre><code class="java">// 将raw插入pg中，返回插入位置public static short insert(Page pg, byte[] raw) &#123;    pg.setDirty(true);    short offset = getFSO(pg.getData());    System.arraycopy(raw, 0, pg.getData(), offset, raw.length);    setFSO(pg.getData(), (short)(offset + raw.length));    return offset;&#125;</code></pre><p>在写入之前获取 FSO，来确定写入的位置，并在写入之后更新 FSO。FSO 的操作如下：</p><pre><code class="java">private static void setFSO(byte[] raw, short ofData) &#123;    System.arraycopy(Parser.short2Byte(ofData), 0, raw, OF_FREE, OF_DATA);&#125;// 获取pg的FSOpublic static short getFSO(Page pg) &#123;    return getFSO(pg.getData());&#125;private static short getFSO(byte[] raw) &#123;    return Parser.parseShort(Arrays.copyOfRange(raw, 0, 2));&#125;// 获取页面的空闲空间大小public static int getFreeSpace(Page pg) &#123;    return PageCache.PAGE_SIZE - (int)getFSO(pg.getData());&#125;</code></pre><p>剩余两个函数 <code>recoverInsert()</code> 和 <code>recoverUpdate()</code> 用于在数据库崩溃后重新打开时，恢复例程直接插入数据以及修改数据使用。</p><pre><code class="java">// 将raw插入pg中的offset位置，并将pg的offset设置为较大的offsetpublic static void recoverInsert(Page pg, byte[] raw, short offset) &#123;    pg.setDirty(true);    System.arraycopy(raw, 0, pg.getData(), offset, raw.length);    short rawFSO = getFSO(pg.getData());    if(rawFSO &lt; offset + raw.length) &#123;        setFSO(pg.getData(), (short)(offset+raw.length));    &#125;&#125;// 将raw插入pg中的offset位置，不更新updatepublic static void recoverUpdate(Page pg, byte[] raw, short offset) &#123;    pg.setDirty(true);    System.arraycopy(raw, 0, pg.getData(), offset, raw.length);&#125;</code></pre><h1 id="五-日志文件与恢复策略"><a href="#五-日志文件与恢复策略" class="headerlink" title="五.日志文件与恢复策略"></a>五.日志文件与恢复策略</h1><p>DylanDB提供了崩溃后的数据恢复功能。DM 层在每次对底层数据操作时，都会记录一条日志到磁盘上。在数据库奔溃之后，再次启动时，可以根据日志的内容，恢复数据文件，保证其一致性。</p><h2 id="日志读写"><a href="#日志读写" class="headerlink" title="日志读写"></a>日志读写</h2><p>日志的二进制文件，按照如下的格式进行排布：</p><pre><code>[XChecksum][Log1][Log2][Log3]...[LogN][BadTail]</code></pre><p>其中 <strong>XChecksum</strong> 是一个四字节的整数，是对后续所有日志计算的校验和。Log1 ~ LogN 是常规的日志数据，BadTail 是在数据库崩溃时，没有来得及写完的日志数据，这个 BadTail 不一定存在。</p><p>每条日志的格式如下：</p><pre><code>[Size][Checksum][Data]</code></pre><p>其中，Size 是一个四字节整数，标识了 Data 段的字节数。<strong>Checksum 则是该条日志的校验和。</strong></p><p>单条日志的校验和，其实就是通过一个指定的种子实现的：</p><pre><code class="java">private int calChecksum(int xCheck, byte[] log) &#123;    for (byte b : log) &#123;        xCheck = xCheck * SEED + b;    &#125;    return xCheck;&#125;</code></pre><p>这样，对所有日志求出校验和，求和就能得到日志文件的校验和了。</p><p>Logger 被实现成迭代器模式，通过 <code>next()</code> 方法，不断地从文件中读取下一条日志，并将其中的 Data 解析出来并返回。<code>next()</code> 方法的实现主要依靠 <code>internNext()</code>，大致如下，其中 position 是当前日志文件读到的位置偏移：</p><pre><code class="java">//log: sum+checksum+data(其中sum是4字节标识data长度,checksum是4字节代表当前日志的校验和)private byte[] internNext() &#123;    if(position + OF_DATA &gt;= fileSize) &#123;        return null;    &#125;    //读取size    ByteBuffer tmp = ByteBuffer.allocate(4);    try &#123;        fc.position(position);        fc.read(tmp);    &#125; catch(IOException e) &#123;        CatchException.catchExc(e);    &#125;    int size = Parser.parseInt(tmp.array());    if(position + size + OF_DATA &gt; fileSize) &#123;        return null;    &#125;    //读取checksum+data    ByteBuffer buf = ByteBuffer.allocate(OF_DATA + size);    try &#123;        fc.position(position);        fc.read(buf);    &#125; catch(IOException e) &#123;      CatchException.catchExc(e);    &#125;    //将读取的数据转换为byte数组    byte[] log = buf.array();    //校验checksum    int checkSum1 = calChecksum(0, Arrays.copyOfRange(log, OF_DATA, log.length));    //拿到checksum    int checkSum2 = Parser.parseInt(Arrays.copyOfRange(log, OF_CHECKSUM, OF_DATA));    if(checkSum1 != checkSum2) &#123;        return null;    &#125;    position += log.length;    return log;&#125;</code></pre><p>在打开一个日志文件时，需要首先校验日志文件的 XChecksum，并移除文件尾部可能存在的 BadTail，由于 BadTail 该条日志尚未写入完成，文件的校验和也就不会包含该日志的校验和，去掉 BadTail 即可保证日志文件的一致性。</p><pre><code class="java"> //指针指向xChecksum字段之后        rewind();        int xCheck=0;        while (true)&#123;            byte[] log = internNext();            if(log==null)&#123;                break;            &#125;            xCheck = calChecksum(xCheck, log);        &#125;        if(xCheck!=xChecksum)&#123;            CatchException.catchExc(Error.BadLogFileException);        &#125;        try &#123;            //截断文件到正常日志的末尾            truncate(position);        &#125;catch (Exception e)&#123;            CatchException.catchExc(e);        &#125;        try &#123;            //将文件指针指向该位置            file.seek(position);        &#125;catch (IOException e)&#123;            CatchException.catchExc(e);        &#125;        rewind();</code></pre><p>向日志文件写入日志时，也是首先将数据包裹成日志格式，写入文件后，再更新文件的校验和，更新校验和时，会刷新缓冲区，保证内容写入磁盘。</p><pre><code class="java">@Overridepublic void log(byte[] data) &#123;    //对checksum和size封装    byte[] log = wrapLog(data);    ByteBuffer buf = ByteBuffer.wrap(log);    lock.lock();    try &#123;        fc.position(fc.size());        //将新日志记录追加写入到fileChannel        fc.write(buf);    &#125; catch (IOException e) &#123;        CatchException.catchExc(e);    &#125;finally &#123;        lock.unlock();    &#125;    //更新XCheckSum    updateXChecksum(log);&#125;</code></pre><h2 id="恢复策略"><a href="#恢复策略" class="headerlink" title="恢复策略"></a>恢复策略</h2><p>恢复策略来自于 NYADB2 的恢复策略</p><p>DM 为上层模块，提供了两种操作，分别是插入新数据（I）和更新现有数据（U）。至于为啥没有删除数据，这个会在 VM 一节叙述。</p><p>DM 的日志策略很简单，一句话就是：</p><p>在进行 I 和 U 操作之前，必须先进行对应的日志操作，在保证日志写入磁盘后，才进行数据操作。</p><p>这个日志策略，使得 DM 对于数据操作的磁盘同步，可以更加随意。日志在数据操作之前，保证到达了磁盘，那么即使该数据操作最后没有来得及同步到磁盘，数据库就发生了崩溃，后续也可以通过磁盘上的日志恢复该数据。</p><p>对于两种数据操作，DM 记录的日志如下：</p><ul><li>(Ti, I, A, x)，表示事务 Ti 在 A 位置插入了一条数据 x</li><li>(Ti, U, A, oldx, newx)，表示事务 Ti 将 A 位置的数据，从 oldx 更新成 newx</li></ul><p>我们首先不考虑并发的情况，那么在某一时刻，只可能有一个事务在操作数据库。日志会看起来像下面那样：</p><pre><code>(Ti, x, x), ..., (Ti, x, x), (Tj, x, x), ..., (Tj, x, x), (Tk, x, x), ..., (Tk, x, x)</code></pre><h3 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h3><p>由于单线程，Ti、Tj 和 Tk 的日志永远不会相交。这种情况下利用日志恢复很简单，假设日志中最后一个事务是 Ti：</p><ol><li>对 Ti 之前所有的事务的日志，进行重做（redo）</li><li>接着检查 Ti 的状态（XID 文件），如果 Ti 的状态是已完成（包括 committed 和 aborted），就将 Ti 重做，否则进行撤销（undo）</li></ol><p>接着，是如何对事务 T 进行 <strong>redo</strong>：</p><ol><li>正序扫描事务 T 的所有日志</li><li>如果日志是插入操作 (Ti, I, A, x)，就将 x 重新插入 A 位置</li><li>如果日志是更新操作 (Ti, U, A, oldx, newx)，就将 A 位置的值设置为 newx</li></ol><p><strong>undo</strong> 也很好理解：</p><ol><li>倒序扫描事务 T 的所有日志</li><li>如果日志是插入操作 (Ti, I, A, x)，就将 A 位置的数据删除</li><li>如果日志是更新操作 (Ti, U, A, oldx, newx)，就将 A 位置的值设置为 oldx</li></ol><p>注意，DylanDB 中其实没有真正的删除操作，对于插入操作的 undo，只是将其中的标志位设置为 invalid。对于删除的探讨将在 VM 一节中进行。</p><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>经过以上的操作，就能保证了 DylanDB在单线程下的恢复性。对于多线程的情况下呢？我们来考虑下面的两种情况。</p><p>第一种：</p><pre><code class="java">T1 beginT2 beginT2 U(x)T1 R(x)...T1 commitDylanDB break down</code></pre><p>在系统崩溃时，T2 仍然是活跃状态。那么当数据库重新启动，执行恢复例程时，会撤销 T2，它对数据库的影响会被消除。但是由于 T1 读取了 T2 更新的值，既然 T2 被撤销，那么 T1 也应当被撤销。这种情况，就是级联回滚。但是，T1 已经 commit 了，所有 commit 的事务的影响，应当被持久化。这里就造成了矛盾。所以这里需要保证：</p><p><strong>规定1：正在进行的事务，不会读取其他任何未提交的事务产生的数据。</strong>(读已提交)</p><p>第二种情况，假设 x 的初值是 0</p><pre><code class="java">T1 beginT2 beginT1 set x = x+1 // 产生的日志为(T1, U, A, 0, 1)T2 set x = x+1 // 产生的日志为(T1, U, A, 1, 2)T2 commitDylanDB break down</code></pre><p>在系统崩溃时，T1 仍然是活跃状态。那么当数据库重新启动，执行恢复例程时，会对 T1 进行撤销，对 T2 进行重做，但是，无论撤销和重做的先后顺序如何，x 最后的结果，要么是 0，要么是 2，这都是错误的。</p><blockquote><p>出现这种问题的原因, 归根结底是因为我们的日志太过简单, 仅仅记录了”前相”和”后相”. 并单纯的依靠”前相”undo, 依靠”后相”redo. 这种简单的日志方式和恢复方式, 并不能涵盖住所有数据库操作形成的语义</p></blockquote><p>解决方法有两种：</p><ol><li>增加日志种类</li><li>限制数据库操作</li></ol><p>采用限制策略,需要保证：</p><p><strong>规定2：正在进行的事务，不会修改其他任何未提交的事务修改或产生的数据。</strong></p><p>在 DylanDB中，由于 VM 的存在，传递到 DM 层，真正执行的操作序列，都可以保证规定 1 和规定 2。VM 如何保证这两条规定，会在 VM 层一节中说明（VM 的坑还挺大）。有了这两条规定，并发情况下日志的恢复也就很简单了：</p><ol><li>重做所有崩溃时已完成（committed 或 aborted）的事务</li><li>撤销所有崩溃时未完成（active）的事务</li></ol><p>在恢复后，数据库就会恢复到所有已完成事务结束，所有未完成事务尚未开始的状态。</p><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><p>首先规定两种日志的格式：</p><pre><code class="java">private static final byte LOG_TYPE_INSERT = 0;private static final byte LOG_TYPE_UPDATE = 1;// updateLog:// [LogType] [XID] [UID] [OldRaw] [NewRaw]// insertLog:// [LogType] [XID] [Pgno] [Offset] [Raw]</code></pre><p>和原理中描述的类似，recover 例程主要也是两步：重做所有已完成事务，撤销所有未完成事务：</p><pre><code class="java">private static void redoTranscations(TransactionManager tm, Logger log, PageCache cache)&#123;    log.rewind();    while (true)&#123;        byte[] lg = log.next();        if(lg==null)&#123;            break;        &#125;        if(isInsertLog(lg))&#123;            InsertLogInfo li=parseInsertLog(lg);            long xid = li.xid;            if(!tm.isActive(xid))&#123;                doInsertLog(cache,lg,REDO);            &#125;        &#125;else&#123;            UpdateLogInfo xi=parseUpdateLog(lg);            long xid = xi.xid;            if(!tm.isActive(xid))&#123;                doUpdateLog(cache,lg,REDO);            &#125;        &#125;    &#125;&#125;//undo恢复private static void undoTranscations(TransactionManager tm, Logger lg, PageCache pc) &#123;    Map&lt;Long, List&lt;byte[]&gt;&gt; logCache = new HashMap&lt;&gt;();    //恢复整个log    //todo:待优化    lg.rewind();    while(true) &#123;        byte[] log = lg.next();        if(log == null) break;        if(isInsertLog(log)) &#123;            InsertLogInfo li = parseInsertLog(log);            long xid = li.xid;            if(tm.isActive(xid)) &#123;                if(!logCache.containsKey(xid)) &#123;                    logCache.put(xid, new ArrayList&lt;&gt;());                &#125;                logCache.get(xid).add(log);            &#125;        &#125; else &#123;            UpdateLogInfo xi = parseUpdateLog(log);            long xid = xi.xid;            if(tm.isActive(xid)) &#123;                if(!logCache.containsKey(xid)) &#123;                    logCache.put(xid, new ArrayList&lt;&gt;());                &#125;                logCache.get(xid).add(log);            &#125;        &#125;    &#125;    // 对所有active log进行倒序undo    for(Map.Entry&lt;Long, List&lt;byte[]&gt;&gt; entry : logCache.entrySet()) &#123;        List&lt;byte[]&gt; logs = entry.getValue();        for (int i = logs.size()-1; i &gt;= 0; i --) &#123;            byte[] log = logs.get(i);            if(isInsertLog(log)) &#123;                doInsertLog(pc, log, UNDO);            &#125; else &#123;                doUpdateLog(pc, log, UNDO);            &#125;        &#125;        tm.abort(entry.getKey());    &#125;&#125;</code></pre><p>updateLog 和 insertLog 的重做和撤销处理，分别合并成一个方法来实现：</p><pre><code class="java">private static void doInsertLog(PageCache pc,byte[]log,int flag)&#123;    InsertLogInfo li=parseInsertLog(log);    Page pg=null;    try &#123;        pg=pc.getPage(li.pgNo);    &#125; catch (Exception e) &#123;        CatchException.catchExc(e);    &#125;    try &#123;        if(flag==UNDO)&#123;            DataItem.setDataItemRawInvalid(li.raw);        &#125;        PageX.recoverInsert(pg,li.raw,li.offset);    &#125;finally &#123;        pg.release();    &#125;&#125;</code></pre><pre><code class="java">private static void doUpdateLog(PageCache pc, byte[] log, int flag) &#123;    int pgno;    short offset;    byte[] raw;    if(flag == REDO) &#123;        UpdateLogInfo xi = parseUpdateLog(log);        pgno = xi.pgNo;        offset = xi.offset;        raw = xi.newRaw;    &#125; else &#123;        UpdateLogInfo xi = parseUpdateLog(log);        pgno = xi.pgNo;        offset = xi.offset;        raw = xi.oldRaw;    &#125;    Page pg = null;    try &#123;        pg = pc.getPage(pgno);    &#125; catch (Exception e) &#123;        CatchException.catchExc(e);    &#125;    try &#123;        PageX.recoverUpdate(pg, raw, offset);    &#125; finally &#123;        pg.release();    &#125;&#125;</code></pre><h1 id="六-页面索引"><a href="#六-页面索引" class="headerlink" title="六.页面索引"></a>六.页面索引</h1><h2 id="页面索引"><a href="#页面索引" class="headerlink" title="页面索引"></a>页面索引</h2><p><strong>缓存了每一页的空闲空间。用于在上层模块进行插入操作时，能够快速找到一个合适空间的页面，而无需从磁盘或者缓存中检查每一个页面的信息。</strong></p><p>DylanDB 用一个比较粗略的算法实现了页面索引，<strong>将一页的空间划分成了 40 个区间</strong>。在启动时，就会遍历所有的页面信息，获取页面的空闲空间，安排到这 40 个区间中。insert 在请求一个页时，会首先将所需的空间向上取整，映射到某一个区间，随后取出这个区间的任何一页，都可以满足需求。</p><p>PageIndex 的实现也很简单，一个 List 类型的数组。</p><pre><code class="java">public class PageIndex &#123;    // 将一页划成40个区间    private static final int INTERVALS_NO = 40;    private static final int THRESHOLD = PageCache.PAGE_SIZE / INTERVALS_NO;    private List[] lists;&#125;</code></pre><p>从 PageIndex 中获取页面也很简单，算出区间号，直接取即可：</p><pre><code class="java">public PageInfo select(int spaceSize) &#123;    int number = spaceSize / THRESHOLD;    if(number &lt; INTERVALS_NO) number ++;    while(number &lt;= INTERVALS_NO) &#123;        if(lists[number].size() == 0) &#123;            number ++;            continue;        &#125;        return lists[number].remove(0);    &#125;    return null;&#125;</code></pre><p>返回的 PageInfo 中包含页号和空闲空间大小的信息。</p><p>可以注意到，被选择的页，会直接从 PageIndex 中移除，这意味着，同一个页面是不允许并发写的。在上层模块使用完这个页面后，需要将其重新插入 PageIndex：</p><p>在 DataManager 被创建时，需要获取所有页面并填充 PageIndex：</p><pre><code class="java">// 初始化pageIndexvoid fillPageIndex() &#123;    int pageNumber = pc.getPageNumber();    for(int i = 2; i &lt;= pageNumber; i ++) &#123;        Page pg = null;        try &#123;            pg = pc.getPage(i);        &#125; catch (Exception e) &#123;            CatchException.catchExc(e);        &#125;        pIndex.add(pg.getPageNumber(), PageX.getFreeSpace(pg));        pg.release();    &#125;&#125;</code></pre><p>注意在使用完 Page 后需要及时 release，否则可能会撑爆缓存。</p><h2 id="DataItem"><a href="#DataItem" class="headerlink" title="DataItem"></a>DataItem</h2><p>DataItem 是 DM 层向上层提供的数据抽象。上层模块通过地址，向 DM 请求到对应的 DataItem，再获取到其中的数据。</p><p>DataItem 的实现很简单：</p><pre><code class="java">private SubArray raw;private byte[] oldRaw;private Lock rLock;private Lock wLock;private DataManagerImpl dm;private long uid;private Page pg;</code></pre><p>保存一个 dm 的引用是因为其释放依赖 dm 的释放（dm 同时实现了缓存接口，用于缓存 DataItem），以及修改数据时落日志。</p><p>DataItem 中保存的数据，结构如下：</p><pre><code class="java">[ValidFlag] [DataSize] [Data]</code></pre><p>其中 ValidFlag 占用 1 字节，标识了该 DataItem 是否有效。删除一个 DataItem，只需要简单地将其有效位设置为 0。DataSize 占用 2 字节，标识了后面 Data 的长度。</p><p>上层模块在获取到 DataItem 后，可以通过 <code>data()</code> 方法，该方法返回的数组是数据共享的，而不是拷贝实现的，所以使用了 SubArray。</p><pre><code class="java">@Overridepublic SubArray data() &#123;    return new SubArray(raw.raw, raw.start+OF_DATA, raw.end);&#125;</code></pre><p>在上层模块试图对 DataItem 进行修改时，需要遵循一定的流程：<strong>在修改之前需要调用 <code>before()</code> 方法</strong>，想要撤销修改时，<strong>调用 <code>unBefore()</code> 方法</strong>，在修改完成后，<strong>调用 <code>after()</code> 方法</strong>。整个流程，主要是为了保存前相数据，并及时落日志。DM 会保证对 DataItem 的修改是原子性的。</p><pre><code class="java">@Overridepublic void before() &#123;    wLock.lock();    pg.setDirty(true);    System.arraycopy(raw.raw, raw.start, oldRaw, 0, oldRaw.length);&#125;@Overridepublic void unBefore() &#123;    System.arraycopy(oldRaw, 0, raw.raw, raw.start, oldRaw.length);    wLock.unlock();&#125;@Overridepublic void after(long xid) &#123;    dm.logDataItem(xid, this);    wLock.unlock();&#125;</code></pre><p><code>after()</code> 方法，主要就是调用 dm 中的一个方法，对修改操作落日志，不赘述。</p><p>在使用完 DataItem 后，也应当及时调用 release() 方法，释放掉 DataItem 的缓存（由 DM 缓存 DataItem）。</p><pre><code class="java">@Overridepublic void release() &#123;    dm.releaseDataItem(this);&#125;</code></pre><h2 id="DM-的实现"><a href="#DM-的实现" class="headerlink" title="DM 的实现"></a>DM 的实现</h2><p>DataManager 是 DM 层直接对外提供方法的类，同时，也实现成 DataItem 对象的缓存。DataItem 存储的 key，是由页号和页内偏移组成的一个 8 字节无符号整数，页号和偏移各占 4 字节。</p><p>DataItem 缓存，<code>getForCache()</code>，只需要从 key 中解析出页号，从 pageCache 中获取到页面，再根据偏移，解析出 DataItem 即可：</p><pre><code class="java">@Overrideprotected DataItem getForCache(long uid) throws Exception &#123;    short offset = (short)(uid &amp; ((1L &lt;&lt; 16) - 1));    uid &gt;&gt;&gt;= 32;    int pgno = (int)(uid &amp; ((1L &lt;&lt; 32) - 1));    Page pg = pc.getPage(pgno);    return DataItem.parseDataItem(pg, offset, this);&#125;</code></pre><p>DataItem 缓存释放，需要将 DataItem 写回数据源，由于对文件的读写是以页为单位进行的，只需要将 DataItem 所在的页 release 即可：</p><pre><code class="java">@Overrideprotected void releaseForCache(DataItem di) &#123;    di.page().release();&#125;</code></pre><p>从已有文件创建 DataManager 和从空文件创建 DataManager 的流程稍有不同，除了 PageCache 和 Logger 的创建方式有所不同以外，从空文件创建首先需要对第一页进行初始化，而从已有文件创建，则是需要对第一页进行校验，来判断是否需要执行恢复流程。并重新对第一页生成随机字节。</p><pre><code class="java"> public static DataManager create(String path, long mem, TransactionManager tm) &#123;        PageCache pc = PageCache.create(path, mem);        Logger lg = Logger.create(path);        DataManagerImpl dm = new DataManagerImpl(pc, lg, tm);        dm.initPageOne();        return dm;    &#125;    public static DataManager open(String path, long mem, TransactionManager tm) &#123;        PageCache pc = PageCache.open(path, mem);        Logger lg = Logger.open(path);        DataManagerImpl dm = new DataManagerImpl(pc, lg, tm);        if(!dm.loadCheckPageOne()) &#123;            Recover.recover(tm, lg, pc);        &#125;        dm.fillPageIndex();        FirstPage.setVcOpen(dm.pageOne);        dm.pc.flushPage(dm.pageOne);        return dm;    &#125;</code></pre><p>其中，初始化第一页，和校验第一页，基本都是调用 FirstPage类中的方法实现的：</p><pre><code class="java">// 在创建文件时初始化PageOne    void initPageOne() &#123;        int pgno = pc.newPage(FirstPage.InitRaw());        assert pgno == 1;        try &#123;            pageOne = pc.getPage(pgno);        &#125; catch (Exception e) &#123;            CatchException.catchExc(e);        &#125;        pc.flushPage(pageOne);    &#125;    // 在打开已有文件时时读入PageOne，并验证正确性    boolean loadCheckPageOne() &#123;        try &#123;            pageOne = pc.getPage(1);        &#125; catch (Exception e) &#123;            CatchException.catchExc(e);        &#125;        return FirstPage.checkVc(pageOne);    &#125;</code></pre><p>DM 层提供了三个功能供上层使用，分别是读、插入和修改。修改是通过读出的 DataItem 实现的，于是 DataManager 只需要提供 <code>read()</code> 和 <code>insert()</code> 方法。</p><p><code>read()</code> 根据 UID 从缓存中获取 DataItem，并校验有效位：</p><pre><code class="java">@Overridepublic DataItem read(long uid) throws Exception &#123;    DataItemImpl di = (DataItemImpl)super.get(uid);    if(!di.isValid()) &#123;        di.release();        return null;    &#125;    return di;&#125;</code></pre><p><code>insert()</code> 方法，在 pageIndex 中获取一个足以存储插入内容的页面的页号，获取页面后，首先需要写入插入日志，接着才可以通过 pageX 插入数据，并返回插入位置的偏移。最后需要将页面信息重新插入 pageIndex。</p><pre><code class="java">@Overridepublic long insert(long xid, byte[] data) throws Exception &#123;    byte[] raw = DataItem.wrapDataItemRaw(data);    if(raw.length &gt; PageX.MAX_FREE_SPACE) &#123;        throw Error.DataTooLargeException;    &#125;    // 尝试获取可用页    PageInfo pi = null;    for(int i = 0; i &lt; 5; i ++) &#123;        pi = pIndex.select(raw.length);        if (pi != null) &#123;            break;        &#125; else &#123;            int newPgno = pc.newPage(PageX.initRaw());            pIndex.add(newPgno, PageX.MAX_FREE_SPACE);        &#125;    &#125;    if(pi == null) &#123;        throw Error.DatabaseBusyException;    &#125;    Page pg = null;    int freeSpace = 0;    try &#123;        pg = pc.getPage(pi.pgno);        // 首先做日志        byte[] log = Recover.insertLog(xid, pg, raw);        logger.log(log);        // 再执行插入操作        short offset = PageX.insert(pg, raw);        pg.release();        return Types.addressToUid(pi.pgno, offset);    &#125; finally &#123;        // 将取出的pg重新插入pIndex        if(pg != null) &#123;            pIndex.add(pi.pgno, PageX.getFreeSpace(pg));        &#125; else &#123;            pIndex.add(pi.pgno, freeSpace);        &#125;    &#125;&#125;</code></pre><p>DataManager 正常关闭时，需要执行缓存和日志的关闭流程，不要忘了设置第一页的字节校验：</p><pre><code class="java">@Overridepublic void close() &#123;    super.close();    logger.close();    PageOne.setVcClose(pageOne);    pageOne.release();    pc.close();&#125;</code></pre><h1 id="七-MVCC和事务隔离"><a href="#七-MVCC和事务隔离" class="headerlink" title="七.MVCC和事务隔离"></a>七.MVCC和事务隔离</h1><p>从这一章开始，我们开始讨论 Version Manager。</p><blockquote><p>VM 基于两段锁协议实现了调度序列的可串行化，并实现了 MVCC 以消除读写阻塞。同时实现了两种隔离级别。</p></blockquote><p>类似于 Data Manager 是 DylanDB的数据管理核心，Version Manager 是 DylanDB的事务和数据版本的管理核心。</p><h2 id="2PL-与-MVCC"><a href="#2PL-与-MVCC" class="headerlink" title="2PL 与 MVCC"></a>2PL 与 MVCC</h2><h3 id="冲突与-2PL"><a href="#冲突与-2PL" class="headerlink" title="冲突与 2PL"></a>冲突与 2PL</h3><p>首先来定义数据库的冲突，暂时不考虑插入操作，只看更新操作（U）和读操作（R），两个操作只要满足下面三个条件，就可以说这两个操作相互冲突：</p><ol><li><strong>这两个操作是由不同的事务执行的</strong></li><li><strong>这两个操作操作的是同一个数据项</strong></li><li><strong>这两个操作至少有一个是更新操作</strong></li></ol><p>那么这样，对同一个数据操作的冲突，其实就只有下面这两种情况：</p><ol><li>两个不同事务的 U 操作冲突</li><li>两个不同事务的 U、R 操作冲突</li></ol><p>那么冲突或者不冲突，意义何在？作用在于，<strong>交换两个互不冲突的操作的顺序，不会对最终的结果造成影响</strong>，而交换两个冲突操作的顺序，则是会有影响的。</p><p>现在我们先抛开冲突不谈，记得在第四章举的例子吗，在并发情况下，两个事务同时操作 x。假设 x 的初值是 0：</p><pre><code class="java">T1 beginT2 beginR1(x) // T1读到0R2(x) // T2读到0U1(0+1) // T1尝试把x+1U2(0+1) // T2尝试把x+1T1 commitT2 commit</code></pre><p>最后 x 的结果是 1，这个结果显然与期望的不符。</p><p>VM 的一个很重要的职责，就是实现了调度序列的可串行化。DylanDB 采用两段锁协议（2PL）来实现。当采用 2PL 时，如果某个事务 i 已经对 x 加锁，且另一个事务 j 也想操作 x，但是这个操作与事务 i 之前的操作相互冲突的话，事务 j 就会被阻塞。譬如，T1 已经因为 U1(x) 锁定了 x，那么 T2 对 x 的读或者写操作都会被阻塞，T2 必须等待 T1 释放掉对 x 的锁。</p><p>由此来看，2PL 确实保证了调度序列的可串行话，但是不可避免地导致了事务间的相互阻塞，甚至可能导致死锁。DylanDB 为了提高事务处理的效率，降低阻塞概率，实现了 MVCC</p><h3 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h3><p>在介绍 MVCC 之前，首先明确记录和版本的概念。</p><p>DM 层向上层提供了数据项（Data Item）的概念，VM 通过管理所有的数据项，向上层提供了记录（Entry）的概念。上层模块通过 VM 操作数据的最小单位，就是记录。VM 则在其内部，为每个记录，维护了多个版本（Version）。每当上层模块对某个记录进行修改时，VM 就会为这个记录创建一个新的版本。</p><p><strong>DylanDB 通过 MVCC，降低了事务的阻塞概率。</strong></p><p>譬如，T1 想要更新记录 X 的值，于是 T1 需要首先获取 X 的锁，接着更新，也就是创建了一个新的 X 的版本，假设为 x3。假设 T1 还没有释放 X 的锁时，T2 想要读取 X 的值，这时候就不会阻塞，DylanDB 会返回一个较老版本的 X，例如 x2。这样最后执行的结果，就等价于，T2 先执行，T1 后执行，调度序列依然是可串行化的。如果 X 没有一个更老的版本，那只能等待 T1 释放锁了。所以只是降低了概率。</p><p>还记得我们在第四章中，为了保证数据的可恢复，VM 层传递到 DM 的操作序列需要满足以下两个规则：</p><blockquote><p>规定1：正在进行的事务，不会读取其他任何未提交的事务产生的数据。<br>规定2：正在进行的事务，不会修改其他任何未提交的事务修改或产生的数据。</p></blockquote><p>由于 2PL 和 MVCC，我们可以看到，这两个条件都被很轻易地满足了。</p><p>其实每次有对数据进行修改的操作都会隐式地开启一个事务!</p><h2 id="记录的实现"><a href="#记录的实现" class="headerlink" title="记录的实现"></a>记录的实现</h2><p>对于一条记录来说，DylanDB 使用 Entry 类维护了其结构。虽然理论上，MVCC 实现了多版本，但是在实现中，VM 并没有提供 Update 操作，对于字段的更新操作由后面的表和字段管理（TBM）实现。所以在 VM 的实现中，一条记录只有一个版本。</p><p>一条记录存储在一条 Data Item 中，所以 Entry 中保存一个 DataItem 的引用即可：</p><pre><code class="java">public class Entry &#123;    private static final int OF_XMIN = 0;    private static final int OF_XMAX = OF_XMIN+8;    private static final int OF_DATA = OF_XMAX+8;    private long uid;    private DataItem dataItem;    private VersionManager vm;    public static Entry loadEntry(VersionManager vm, long uid) throws Exception &#123;        DataItem di = ((VersionManagerImpl)vm).dm.read(uid);        return newEntry(vm, di, uid);    &#125;    public void remove() &#123;        dataItem.release();    &#125;&#125;</code></pre><p>我们规定，一条 Entry 中存储的数据格式如下：</p><pre><code>[XMIN] [XMAX] [DATA]</code></pre><p>XMIN 是创建该条记录（版本）的事务编号，而 XMAX 则是删除该条记录（版本）的事务编号。它们的作用将在下一节中说明。DATA 就是这条记录持有的数据。根据这个结构，在创建记录时调用的 <code>wrapEntryRaw()</code> 方法如下：</p><pre><code class="java">public static byte[] wrapEntryRaw(long xid, byte[] data) &#123;    byte[] xmin = Parser.long2Byte(xid);    byte[] xmax = new byte[8];    return Bytes.concat(xmin, xmax, data);&#125;</code></pre><p>同样，如果要获取记录中持有的数据，也就需要按照这个结构来解析：</p><pre><code class="java">// 以拷贝的形式返回内容public byte[] data() &#123;    dataItem.rLock();    try &#123;        SubArray sa = dataItem.data();        byte[] data = new byte[sa.end - sa.start - OF_DATA];        System.arraycopy(sa.raw, sa.start+OF_DATA, data, 0, data.length);        return data;    &#125; finally &#123;        dataItem.rUnLock();    &#125;&#125;</code></pre><p>这里以拷贝的形式返回数据，如果需要修改的话，需要对 DataItem 执行 <code>before()</code> 方法，这个在设置 XMAX 的值中体现了：</p><pre><code class="java">public void setXmax(long xid) &#123;    dataItem.before();    try &#123;        SubArray sa = dataItem.data();        System.arraycopy(Parser.long2Byte(xid), 0, sa.raw, sa.start+OF_XMAX, 8);    &#125; finally &#123;        dataItem.after(xid);    &#125;&#125;</code></pre><p><code>before()</code> 和 <code>after()</code> 是在 DataItem 一节中就已经确定的数据项修改规则。</p><h2 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h2><h3 id="读提交"><a href="#读提交" class="headerlink" title="读提交"></a>读提交</h3><p>上面提到，如果一个记录的最新版本被加锁，当另一个事务想要修改或读取这条记录时，DylanDB 就会返回一个较旧的版本的数据。这时就可以认为，最新的被加锁的版本，对于另一个事务来说，是不可见的。于是版本可见性的概念就诞生了。</p><p>版本的可见性与事务的隔离度是相关的。DylanDB支持的最低的事务隔离程度，是“读提交”（Read Committed），即事务在读取数据时, 只能读取已经提交事务产生的数据。保证最低的读提交的好处，第四章中已经说明（防止级联回滚与 commit 语义冲突）。</p><p>DylanDB实现读提交，为每个版本维护了两个变量，就是上面提到的 XMIN 和 XMAX：</p><ul><li>XMIN：创建该版本的事务编号</li><li>XMAX：删除该版本的事务编号</li></ul><p><strong>XMIN 应当在版本创建时填写，而 XMAX 则在版本被删除，或者有新版本出现时填写。</strong></p><p>XMAX 这个变量，也就解释了为什么 DM 层不提供删除操作，当想删除一个版本时，只需要设置其 XMAX，这样，这个版本对每一个 XMAX 之后的事务都是不可见的，也就等价于删除了。</p><p>如此，在读提交下，版本对事务的可见性逻辑如下：</p><pre><code class="java">(XMIN == Ti and                             // 由Ti创建且    XMAX == NULL                            // 还未被删除)or                                          // 或(XMIN is commited and                       // 由一个已提交的事务创建且    (XMAX == NULL or                        // 尚未删除或    (XMAX != Ti and XMAX is not commited)   // 由一个未提交的事务删除))</code></pre><p>若条件为 true，则版本对 Ti 可见。那么获取 Ti 适合的版本，只需要从最新版本开始，依次向前检查可见性，如果为 true，就可以直接返回。</p><p>以下方法判断某个记录对事务 t 是否可见：</p><pre><code class="java">private static boolean readCommitted(TransactionManager tm, Transaction t, Entry e) &#123;    long xid = t.xid;    long xmin = e.getXmin();    long xmax = e.getXmax();    if(xmin == xid &amp;&amp; xmax == 0) return true;    if(tm.isCommitted(xmin)) &#123;        if(xmax == 0) return true;        if(xmax != xid) &#123;            if(!tm.isCommitted(xmax)) &#123;                return true;            &#125;        &#125;    &#125;    return false;&#125;</code></pre><p>这里的 Transaction 结构只提供了一个 XID。</p><h4 id="可重复读"><a href="#可重复读" class="headerlink" title="可重复读"></a>可重复读</h4><p>读提交会导致的问题大家也都很清楚，八股也背了不少。那就是不可重复读和幻读。这里我们来解决不可重复读的问题。</p><p>不可重复度，会导致一个事务在执行期间对同一个数据项的读取得到不同结果。如下面的结果，加入 X 初始值为 0：</p><pre><code class="java">T1 beginR1(X) // T1 读得 0T2 beginU2(X) // 将 X 修改为 1T2 commitR1(X) // T1 读的 1</code></pre><p>可以看到，T1 两次读 X，读到的结果不一样。如果想要避免这个情况，就需要引入更严格的隔离级别，即可重复读（repeatable read）。</p><p>T1 在第二次读取的时候，读到了已经提交的 T2 修改的值，导致了这个问题。于是我们可以规定：</p><p>事务只能读取它开始时, 就已经结束的那些事务产生的数据版本</p><p>这条规定，增加于，事务需要忽略：</p><ol><li>在本事务后开始的事务的数据;</li><li>本事务开始时还是 active 状态的事务的数据</li></ol><p>对于第一条，只需要比较事务 ID，即可确定。而对于第二条，则需要在事务 Ti 开始时，记录下当前活跃的所有事务 SP(Ti)，如果记录的某个版本，XMIN 在 SP(Ti) 中，也应当对 Ti 不可见。</p><p>于是，可重复读的判断逻辑如下：</p><pre><code class="java">(XMIN == Ti and                 // 由Ti创建且 (XMAX == NULL or               // 尚未被删除))or                              // 或(XMIN is commited and           // 由一个已提交的事务创建且 XMIN &lt; XID and                 // 这个事务小于Ti且 XMIN is not in SP(Ti) and      // 这个事务在Ti开始前提交且 (XMAX == NULL or               // 尚未被删除或  (XMAX != Ti and               // 由其他事务删除但是   (XMAX is not commited or     // 这个事务尚未提交或XMAX &gt; Ti or                    // 这个事务在Ti开始之后才开始或XMAX is in SP(Ti)               // 这个事务在Ti开始前还未提交))))</code></pre><p>于是，需要提供一个结构，来抽象一个事务，以保存快照数据：</p><pre><code class="java">public class Transaction &#123;    public long xid;    public int level;    public Map&lt;Long, Boolean&gt; snapshot;    public Exception err;    public boolean autoAborted;    public static Transaction newTransaction(long xid, int level, Map&lt;Long, Transaction&gt; active) &#123;        Transaction t = new Transaction();        t.xid = xid;        t.level = level;        if(level != 0) &#123;            t.snapshot = new HashMap&lt;&gt;();            for(Long x : active.keySet()) &#123;                t.snapshot.put(x, true);            &#125;        &#125;        return t;    &#125;    public boolean isInSnapshot(long xid) &#123;        if(xid == TransactionManagerImpl.SUPER_XID) &#123;            return false;        &#125;        return snapshot.containsKey(xid);    &#125;&#125;</code></pre><p>构造方法中的 active，保存着当前所有 active 的事务。于是，可重复读的隔离级别下，一个版本是否对事务可见的判断如下：</p><pre><code class="java">private static boolean repeatableRead(TransactionManager tm, Transaction t, Entry e) &#123;    long xid = t.xid;    long xmin = e.getXmin();    long xmax = e.getXmax();    if(xmin == xid &amp;&amp; xmax == 0) return true;    if(tm.isCommitted(xmin) &amp;&amp; xmin &lt; xid &amp;&amp; !t.isInSnapshot(xmin)) &#123;        if(xmax == 0) return true;        if(xmax != xid) &#123;            if(!tm.isCommitted(xmax)  xmax &gt; xid  t.isInSnapshot(xmax)) &#123;                return true;            &#125;        &#125;    &#125;    return false;&#125;</code></pre><h1 id="八-死锁的检测与VM的实现"><a href="#八-死锁的检测与VM的实现" class="headerlink" title="八.死锁的检测与VM的实现"></a>八.死锁的检测与VM的实现</h1><h2 id="版本跳跃问题"><a href="#版本跳跃问题" class="headerlink" title="版本跳跃问题"></a>版本跳跃问题</h2><p>说到版本跳跃之前，顺便提一嘴，MVCC 的实现，使得 DylanDB 在撤销或是回滚事务很简单：只需要将这个事务标记为 aborted 即可。根据前一章提到的可见性，每个事务都只能看到其他 committed 的事务所产生的数据，一个 aborted 事务产生的数据，就不会对其他事务产生任何影响了，也就相当于，这个事务不曾存在过。</p><p>版本跳跃问题，考虑如下的情况，假设 X 最初只有 x0 版本，T1 和 T2 都是可重复读的隔离级别：</p><pre><code class="java">T1 beginT2 beginR1(X) // T1读取x0R2(X) // T2读取x0U1(X) // T1将X更新到x1T1 commitU2(X) // T2将X更新到x2T2 commit</code></pre><p>这种情况实际运行起来是没问题的，但是逻辑上不太正确。T1 将 X 从 x0 更新为了 x1，这是没错的。但是 T2 则是将 X 从 x0 更新成了 x2，跳过了 x1 版本。</p><p>读提交是允许版本跳跃的，而可重复读则是不允许版本跳跃的。解决版本跳跃的思路也很简单：如果 Ti 需要修改 X，而 X 已经被 Ti 不可见的事务 Tj 修改了，那么要求 Ti 回滚。</p><p>上一节中就总结了，Ti 不可见的 Tj，有两种情况：</p><ol><li>XID(Tj) &gt; XID(Ti)</li><li>Tj in SP(Ti)</li></ol><p>于是版本跳跃的检查也就很简单了，取出要修改的数据 X 的最新提交版本，并检查该最新版本的创建者对当前事务是否可见：</p><pre><code class="java">public static boolean isVersionSkip(TransactionManager tm, Transaction t, Entry e) &#123;    long xmax = e.getXmax();    if(t.level == 0) &#123;        return false;    &#125; else &#123;        return tm.isCommitted(xmax) &amp;&amp; (xmax &gt; t.xid  t.isInSnapshot(xmax));  &#125;&#125;</code></pre><h2 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h2><p>上一节提到了 2PL 会阻塞事务，直至持有锁的线程释放锁。可以将这种等待关系抽象成有向边，例如 Tj 在等待 Ti，就可以表示为 Tj –&gt; Ti。这样，无数有向边就可以形成一个图（不一定是连通图）。检测死锁也就简单了，只需要查看这个图中是否有环即可。</p><p>DylanDB 使用一个 LockTable 对象，在内存中维护这张图。维护结构如下：</p><pre><code class="java">public class LockTable &#123;    private Map&lt;Long, List&lt;Long&gt;&gt; x2u;  // 某个XID已经获得的资源的UID列表    private Map&lt;Long, Long&gt; u2x;        // UID被某个XID持有    private Map&lt;Long, List&lt;Long&gt;&gt; wait; // 正在等待UID的XID列表    private Map&lt;Long, Lock&gt; waitLock;   // 正在等待资源的XID的锁    private Map&lt;Long, Long&gt; waitU;      // XID正在等待的UID    private Lock lock;    ...&#125;</code></pre><p>在每次出现等待的情况时，就尝试向图中增加一条边，并进行死锁检测。如果检测到死锁，就撤销这条边，不允许添加，并撤销该事务。</p><pre><code class="java">// 不需要等待则返回null，否则返回锁对象// 会造成死锁则抛出异常public Lock add(long xid, long uid) throws Exception &#123;    lock.lock();    try &#123;        if(isInList(x2u, xid, uid)) &#123;            return null;        &#125;        if(!u2x.containsKey(uid)) &#123;            u2x.put(uid, xid);            putIntoList(x2u, xid, uid);            return null;        &#125;        waitU.put(xid, uid);        putIntoList(wait, xid, uid);        if(hasDeadLock()) &#123;            waitU.remove(xid);            removeFromList(wait, uid, xid);            throw Error.DeadlockException;        &#125;        Lock l = new ReentrantLock();        l.lock();        waitLock.put(xid, l);        return l;    &#125; finally &#123;        lock.unlock();    &#125;&#125;</code></pre><p>调用 add，如果需要等待的话，会返回一个上了锁的 Lock 对象。调用方在获取到该对象时，需要尝试获取该对象的锁，由此实现阻塞线程的目的，例如：</p><pre><code class="java">Lock l = lt.add(xid, uid);if(l != null) &#123;    l.lock();   // 阻塞在这一步    l.unlock();&#125;</code></pre><p>查找图中是否有环的算法也非常简单，就是一个深搜，只是需要注意这个图不一定是连通图。思路就是为每个节点设置一个访问戳，都初始化为 -1，随后遍历所有节点，以每个非 -1 的节点作为根进行深搜，并将深搜该连通图中遇到的所有节点都设置为同一个数字，不同的连通图数字不同。这样，如果在遍历某个图时，遇到了之前遍历过的节点，说明出现了环。</p><pre><code class="java">private boolean hasDeadLock() &#123;    xidStamp = new HashMap&lt;&gt;();    stamp = 1;    for(long xid : x2u.keySet()) &#123;        Integer s = xidStamp.get(xid);        if(s != null &amp;&amp; s &gt; 0) &#123;            continue;        &#125;        stamp ++;        if(dfs(xid)) &#123;            return true;        &#125;    &#125;    return false;&#125;private boolean dfs(long xid) &#123;    Integer stp = xidStamp.get(xid);    if(stp != null &amp;&amp; stp == stamp) &#123;        return true;    &#125;    if(stp != null &amp;&amp; stp &lt; stamp) &#123;        return false;    &#125;    xidStamp.put(xid, stamp);    Long uid = waitU.get(xid);    if(uid == null) return false;    Long x = u2x.get(uid);    assert x != null;    return dfs(x);&#125;</code></pre><p>在一个事务 commit 或者 abort 时，就可以释放所有它持有的锁，并将自身从等待图中删除。</p><pre><code class="java">public void remove(long xid) &#123;    lock.lock();    try &#123;        List&lt;Long&gt; l = x2u.get(xid);        if(l != null) &#123;            while(l.size() &gt; 0) &#123;                Long uid = l.remove(0);                selectNewXID(uid);            &#125;        &#125;        waitU.remove(xid);        x2u.remove(xid);        waitLock.remove(xid);    &#125; finally &#123;        lock.unlock();    &#125;&#125;</code></pre><p>while 循环释放掉了这个线程所有持有的资源的锁，这些资源可以被等待的线程所获取：</p><pre><code class="java">// 从等待队列中选择一个xid来占用uidprivate void selectNewXID(long uid) &#123;    u2x.remove(uid);    List&lt;Long&gt; l = wait.get(uid);    if(l == null) return;    assert l.size() &gt; 0;    while(l.size() &gt; 0) &#123;        long xid = l.remove(0);        if(!waitLock.containsKey(xid)) &#123;            continue;        &#125; else &#123;            u2x.put(uid, xid);            Lock lo = waitLock.remove(xid);            waitU.remove(xid);            lo.unlock();            break;        &#125;    &#125;    if(l.size() == 0) wait.remove(uid);&#125;</code></pre><p>从 List 开头开始尝试解锁，还是个公平锁。解锁时，将该 Lock 对象 unlock 即可，这样业务线程就获取到了锁，就可以继续执行了。</p><h2 id="VM-的实现"><a href="#VM-的实现" class="headerlink" title="VM 的实现"></a>VM 的实现</h2><p>VM 层通过 VersionManager 接口，向上层提供功能，如下：</p><pre><code class="java">public interface VersionManager &#123;    byte[] read(long xid, long uid) throws Exception;    long insert(long xid, byte[] data) throws Exception;    boolean delete(long xid, long uid) throws Exception;    long begin(int level);    void commit(long xid) throws Exception;    void abort(long xid);&#125;</code></pre><p>同时，VM 的实现类还被设计为 Entry 的缓存，需要继承 <code>AbstractCache&lt;Entry&gt;</code>。需要实现的获取到缓存和从缓存释放的方法很简单：</p><pre><code class="java">@Overrideprotected Entry getForCache(long uid) throws Exception &#123;    Entry entry = Entry.loadEntry(this, uid);    if(entry == null) &#123;        throw Error.NullEntryException;    &#125;    return entry;&#125;@Overrideprotected void releaseForCache(Entry entry) &#123;    entry.remove();&#125;</code></pre><p><code>begin()</code> 开启一个事务，并初始化事务的结构，将其存放在 activeTransaction 中，用于检查和快照使用：</p><pre><code class="java">@Overridepublic long begin(int level) &#123;    lock.lock();    try &#123;        long xid = tm.begin();        Transaction t = Transaction.newTransaction(xid, level, activeTransaction);        activeTransaction.put(xid, t);        return xid;    &#125; finally &#123;        lock.unlock();    &#125;&#125;</code></pre><p><code>commit()</code> 方法提交一个事务，主要就是 free 掉相关的结构，并且释放持有的锁，并修改 TM 状态：</p><pre><code class="java">@Overridepublic void commit(long xid) throws Exception &#123;    lock.lock();    Transaction t = activeTransaction.get(xid);    lock.unlock();    try &#123;        if(t.err != null) &#123;            throw t.err;        &#125;    &#125; catch(NullPointerException n) &#123;        System.out.println(xid);        System.out.println(activeTransaction.keySet());        Panic.panic(n);    &#125;    lock.lock();    activeTransaction.remove(xid);    lock.unlock();    lt.remove(xid);    tm.commit(xid);&#125;</code></pre><p>abort 事务的方法则有两种，手动和自动。手动指的是调用 abort() 方法，而自动，则是在事务被检测出出现死锁时，会自动撤销回滚事务；或者出现版本跳跃时，也会自动回滚：</p><pre><code class="java">private void internAbort(long xid, boolean autoAborted) &#123;    lock.lock();    Transaction t = activeTransaction.get(xid);    if(!autoAborted) &#123;        activeTransaction.remove(xid);    &#125;    lock.unlock();    if(t.autoAborted) return;    lt.remove(xid);    tm.abort(xid);&#125;</code></pre><p><code>read()</code> 方法读取一个 entry，注意判断下可见性即可：</p><pre><code class="java">@Overridepublic byte[] read(long xid, long uid) throws Exception &#123;    lock.lock();    Transaction t = activeTransaction.get(xid);    lock.unlock();    if(t.err != null) &#123;        throw t.err;    &#125;    Entry entry = super.get(uid);    try &#123;        if(Visibility.isVisible(tm, t, entry)) &#123;            return entry.data();        &#125; else &#123;            return null;        &#125;    &#125; finally &#123;        entry.release();    &#125;&#125;</code></pre><p><code>insert()</code> 则是将数据包裹成 Entry，无脑交给 DM 插入即可：</p><pre><code class="java">@Overridepublic long insert(long xid, byte[] data) throws Exception &#123;    lock.lock();    Transaction t = activeTransaction.get(xid);    lock.unlock();    if(t.err != null) &#123;        throw t.err;    &#125;    byte[] raw = Entry.wrapEntryRaw(xid, data);    return dm.insert(xid, raw);&#125;</code></pre><p><code>delete()</code> 方法看起来略为复杂：</p><pre><code class="java">@Overridepublic boolean delete(long xid, long uid) throws Exception &#123;    lock.lock();    Transaction t = activeTransaction.get(xid);    lock.unlock();    if(t.err != null) &#123;        throw t.err;    &#125;    Entry entry = super.get(uid);    try &#123;        if(!Visibility.isVisible(tm, t, entry)) &#123;            return false;        &#125;        Lock l = null;        try &#123;            l = lt.add(xid, uid);        &#125; catch(Exception e) &#123;            t.err = Error.ConcurrentUpdateException;            internAbort(xid, true);            t.autoAborted = true;            throw t.err;        &#125;        if(l != null) &#123;            l.lock();            l.unlock();        &#125;        if(entry.getXmax() == xid) &#123;            return false;        &#125;        if(Visibility.isVersionSkip(tm, t, entry)) &#123;            t.err = Error.ConcurrentUpdateException;            internAbort(xid, true);            t.autoAborted = true;            throw t.err;        &#125;        entry.setXmax(xid);        return true;    &#125; finally &#123;        entry.release();    &#125;&#125;</code></pre><p>实际上主要是前置的三件事：一是可见性判断，二是获取资源的锁，三是版本跳跃判断。删除的操作只有一个设置 XMAX。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis实战</title>
      <link href="/2022/12/21/redis-shi-zhan-pian/"/>
      <url>/2022/12/21/redis-shi-zhan-pian/</url>
      
        <content type="html"><![CDATA[<h1 id="实战篇Redis"><a href="#实战篇Redis" class="headerlink" title="实战篇Redis"></a>实战篇Redis</h1><ul><li>短信登录</li></ul><p>这一块我们会使用redis共享session来实现</p><ul><li>商户查询缓存</li></ul><p>通过本章节，我们会理解缓存击穿，缓存穿透，缓存雪崩等问题，让小伙伴的对于这些概念的理解不仅仅是停留在概念上，更是能在代码中看到对应的内容</p><ul><li>优惠卷秒杀</li></ul><p>通过本章节，我们可以学会Redis的计数器功能， 结合Lua完成高性能的redis操作，同时学会Redis分布式锁的原理，包括Redis的三种消息队列</p><ul><li>附近的商户</li></ul><p>我们利用Redis的GEOHash来完成对于地理坐标的操作</p><ul><li>UV统计</li></ul><p>主要是使用Redis来完成统计功能</p><ul><li>用户签到</li></ul><p>使用Redis的BitMap数据统计功能</p><ul><li>好友关注</li></ul><p>基于Set集合的关注、取消关注，共同关注等等功能，这一块知识咱们之前就讲过，这次我们在项目中来使用一下</p><ul><li>打人探店</li></ul><p>基于List来完成点赞列表的操作，同时基于SortedSet来完成点赞的排行榜功能</p><p>以上这些内容咱们统统都会给小伙伴们讲解清楚，让大家充分理解如何使用Redis</p><h2 id="1、短信登录"><a href="#1、短信登录" class="headerlink" title="1、短信登录"></a>1、短信登录</h2><h3 id="1-1、导入点评项目"><a href="#1-1、导入点评项目" class="headerlink" title="1.1、导入点评项目"></a>1.1、导入点评项目</h3><h3 id="1-2-、基于Session实现登录流程"><a href="#1-2-、基于Session实现登录流程" class="headerlink" title="1.2 、基于Session实现登录流程"></a>1.2 、基于Session实现登录流程</h3><p><strong>发送验证码：</strong></p><p>用户在提交手机号后，会校验手机号是否合法，如果不合法，则要求用户重新输入手机号</p><p>如果手机号合法，后台此时生成对应的验证码，同时将验证码进行保存，然后再通过短信的方式将验证码发送给用户</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images4/image-20221026231014643.png"></p><p><strong>短信验证码登录、注册：</strong></p><p>用户将验证码和手机号进行输入，后台从session中拿到当前验证码，然后和用户输入的验证码进行校验，如果不一致，则无法通过校验，如果一致，则后台根据手机号查询用户，如果用户不存在，则为用户创建账号信息，保存到数据库，无论是否存在，都会将用户信息保存到session中，方便后续获得当前登录信息</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images4/image-20221026231046532.png"></p><p><strong>校验登录状态:</strong></p><p>用户在请求时候，会从cookie中携带者JsessionId到后台，后台通过JsessionId从session中拿到用户信息，如果没有session信息，则进行拦截，如果有session信息，则将用户信息保存到threadLocal中，并且放行</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images4/image-20221026231105898.png" alt="image-20221026231105898"></p><h3 id="1-3-、实现发送短信验证码功能"><a href="#1-3-、实现发送短信验证码功能" class="headerlink" title="1.3 、实现发送短信验证码功能"></a>1.3 、实现发送短信验证码功能</h3><p><strong>页面流程</strong></p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images4/image-20221026215632526.png" alt="image-20221026215632526"></p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images4/image-20221026223209644.png" alt="image-20221026223209644"></p><p><strong>具体代码如下</strong></p><p><strong>贴心小提示：</strong></p><p>具体逻辑上文已经分析，我们仅仅只需要按照提示的逻辑写出代码即可。</p><ul><li>发送验证码</li></ul><pre><code class="java">    @Override    public Result sendCode(String phone, HttpSession session) &#123;        // 1.校验手机号        if (RegexUtils.isPhoneInvalid(phone)) &#123;            // 2.如果不符合，返回错误信息            return Result.fail(&quot;手机号格式错误！&quot;);        &#125;        // 3.符合，生成验证码        String code = RandomUtil.randomNumbers(6);        // 4.保存验证码到 session        session.setAttribute(&quot;code&quot;,code);        // 5.发送验证码        log.debug(&quot;发送短信验证码成功，验证码：&#123;&#125;&quot;, code);        // 返回ok        return Result.ok();    &#125;</code></pre><ul><li>登录</li></ul><pre><code class="java">    @Override    public Result login(LoginFormDTO loginForm, HttpSession session) &#123;        // 1.校验手机号        String phone = loginForm.getPhone();        if (RegexUtils.isPhoneInvalid(phone)) &#123;            // 2.如果不符合，返回错误信息            return Result.fail(&quot;手机号格式错误！&quot;);        &#125;        // 3.校验验证码        Object cacheCode = session.getAttribute(&quot;code&quot;);        String code = loginForm.getCode();        if(cacheCode == null || !cacheCode.toString().equals(code))&#123;             //3.不一致，报错            return Result.fail(&quot;验证码错误&quot;);        &#125;        //一致，根据手机号查询用户        User user = query().eq(&quot;phone&quot;, phone).one();        //5.判断用户是否存在        if(user == null)&#123;            //不存在，则创建            user =  createUserWithPhone(phone);        &#125;        //7.保存用户信息到session中        session.setAttribute(&quot;user&quot;,user);        return Result.ok();    &#125;</code></pre><h3 id="1-4、实现登录拦截功能"><a href="#1-4、实现登录拦截功能" class="headerlink" title="1.4、实现登录拦截功能"></a>1.4、实现登录拦截功能</h3><p><strong>温馨小贴士：tomcat的运行原理</strong></p><p>当用户发起请求时，会访问我们像tomcat注册的端口，任何程序想要运行，都需要有一个线程对当前端口号进行监听，tomcat也不例外，当监听线程知道用户想要和tomcat连接连接时，那会由监听线程创建socket连接，socket都是成对出现的，用户通过socket像互相传递数据，当tomcat端的socket接受到数据后，此时监听线程会从tomcat的线程池中取出一个线程执行用户请求，在我们的服务部署到tomcat后，线程会找到用户想要访问的工程，然后用这个线程转发到工程中的controller，service，dao中，并且访问对应的DB，在用户执行完请求后，再统一返回，再找到tomcat端的socket，再将数据写回到用户端的socket，完成请求和响应</p><p>通过以上讲解，我们可以得知 每个用户其实对应都是去找tomcat线程池中的一个线程来完成工作的， 使用完成后再进行回收，既然每个请求都是独立的，所以在每个用户去访问我们的工程时，我们可以使用threadlocal来做到线程隔离，每个线程操作自己的一份数据</p><p><strong>温馨小贴士：关于threadlocal</strong></p><p>如果小伙伴们看过threadLocal的源码，你会发现在threadLocal中，无论是他的put方法和他的get方法， 都是先从获得当前用户的线程，然后从线程中取出线程的成员变量map，只要线程不一样，map就不一样，所以可以通过这种方式来做到<strong>线程隔离</strong></p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images4/image-20221027124554781.png" alt="image-20221027124554781"></p><p>拦截器代码</p><pre><code class="Java">public class LoginInterceptor implements HandlerInterceptor &#123;    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;       //1.获取session        HttpSession session = request.getSession();        //2.获取session中的用户        Object user = session.getAttribute(&quot;user&quot;);        //3.判断用户是否存在        if(user == null)&#123;              //4.不存在，拦截，返回401状态码              response.setStatus(401);              return false;        &#125;        //5.存在，保存用户信息到Threadlocal        UserHolder.saveUser((User)user);        //6.放行        return true;    &#125;&#125;</code></pre><p>让拦截器生效</p><pre><code class="java">@Configurationpublic class MvcConfig implements WebMvcConfigurer &#123;    @Resource    private StringRedisTemplate stringRedisTemplate;    @Override    public void addInterceptors(InterceptorRegistry registry) &#123;        // 登录拦截器        registry.addInterceptor(new LoginInterceptor())                .excludePathPatterns(                        &quot;/shop/**&quot;,                        &quot;/voucher/**&quot;,                        &quot;/shop-type/**&quot;,                        &quot;/upload/**&quot;,                        &quot;/blog/hot&quot;,                        &quot;/user/code&quot;,                        &quot;/user/login&quot;                ).order(1);        // token刷新的拦截器        registry.addInterceptor(new RefreshTokenInterceptor(stringRedisTemplate)).addPathPatterns(&quot;/**&quot;).order(0);    &#125;&#125;</code></pre><h3 id="1-5、隐藏用户敏感信息"><a href="#1-5、隐藏用户敏感信息" class="headerlink" title="1.5、隐藏用户敏感信息"></a>1.5、隐藏用户敏感信息</h3><p>我们通过浏览器观察到此时用户的全部信息都在，这样极为不靠谱，所以我们应当在返回用户信息之前，将用户的敏感信息进行隐藏，采用的核心思路就是书写一个UserDto对象，这个UserDto对象就没有敏感信息了，我们在返回前，将有用户敏感信息的User对象转化成没有敏感信息的UserDto对象，那么就能够避免这个尴尬的问题了</p><p><strong>在登录方法处修改</strong></p><pre><code class="java">//7.保存用户信息到session中session.setAttribute(&quot;user&quot;, BeanUtils.copyProperties(user,UserDTO.class));</code></pre><p><strong>在拦截器处：</strong></p><pre><code class="java">//5.存在，保存用户信息到ThreadlocalUserHolder.saveUser((UserDTO) user);</code></pre><p><strong>在UserHolder处：将user对象换成UserDTO</strong></p><pre><code class="java">public class UserHolder &#123;    private static final ThreadLocal&lt;UserDTO&gt; tl = new ThreadLocal&lt;&gt;();    public static void saveUser(UserDTO user)&#123;        tl.set(user);    &#125;    public static UserDTO getUser()&#123;        return tl.get();    &#125;    public static void removeUser()&#123;        tl.remove();    &#125;&#125;</code></pre><h3 id="1-6、session共享问题"><a href="#1-6、session共享问题" class="headerlink" title="1.6、session共享问题"></a>1.6、session共享问题</h3><p><strong>核心思路分析：</strong></p><p>每个tomcat中都有一份属于自己的session,假设用户第一次访问第一台tomcat，并且把自己的信息存放到第一台服务器的session中，但是第二次这个用户访问到了第二台tomcat，那么在第二台服务器上，肯定没有第一台服务器存放的session，所以此时 整个登录拦截功能就会出现问题，我们能如何解决这个问题呢？早期的方案是session拷贝，就是说虽然每个tomcat上都有不同的session，但是每当任意一台服务器的session修改时，都会同步给其他的Tomcat服务器的session，这样的话，就可以实现session的共享了</p><p>但是这种方案具有两个大问题</p><p>1、每台服务器中都有完整的一份session数据，服务器压力过大。</p><p>2、session拷贝数据时，可能会出现延迟</p><p>所以咱们后来采用的方案都是基于redis来完成，我们把session换成redis，redis数据本身就是共享的，就可以避免session共享的问题了</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images4/image-20221027125401134.png" alt="image-20221027125401134"></p><h3 id="1-7-Redis代替session的业务流程"><a href="#1-7-Redis代替session的业务流程" class="headerlink" title="1.7 Redis代替session的业务流程"></a>1.7 Redis代替session的业务流程</h3><p>![](C:\Users\Dylan\AppData\Roaming\Typora\typora-user-images\image-20221027125438382.png</p><h4 id="1-7-1、设计key的结构"><a href="#1-7-1、设计key的结构" class="headerlink" title="1.7.1、设计key的结构"></a>1.7.1、设计key的结构</h4><p>首先我们要思考一下利用redis来存储数据，那么到底使用哪种结构呢？由于存入的数据比较简单，我们可以考虑使用String，或者是使用哈希，如下图，如果使用String，同学们注意他的value，用多占用一点空间，如果使用哈希，则他的value中只会存储他数据本身，如果不是特别在意内存，其实使用String就可以啦。</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images4/image-20221027125943902.png" alt="image-20221027125943902"></p><h4 id="1-7-2、设计key的具体细节"><a href="#1-7-2、设计key的具体细节" class="headerlink" title="1.7.2、设计key的具体细节"></a>1.7.2、设计key的具体细节</h4><p>所以我们可以使用String结构，就是一个简单的key，value键值对的方式，但是关于key的处理，session他是每个用户都有自己的session，但是redis的key是共享的，咱们就不能使用code了</p><p>在设计这个key的时候，我们之前讲过需要满足两点</p><p>1、key要具有唯一性</p><p>2、key要方便携带</p><p>如果我们采用phone：手机号这个的数据来存储当然是可以的，但是如果把这样的敏感数据存储到redis中并且从页面中带过来毕竟不太合适，所以我们在后台生成一个随机串token，然后让前端带来这个token就能完成我们的整体逻辑了</p><h4 id="1-7-3、整体访问流程"><a href="#1-7-3、整体访问流程" class="headerlink" title="1.7.3、整体访问流程"></a>1.7.3、整体访问流程</h4><p>当注册完成后，用户去登录会去校验用户提交的手机号和验证码，是否一致，如果一致，则根据手机号查询用户信息，不存在则新建，最后将用户数据保存到redis，并且生成token作为redis的key，当我们校验用户是否登录时，会去携带着token进行访问，从redis中取出token对应的value，判断是否存在这个数据，如果没有则拦截，如果存在则将其保存到threadLocal中，并且放行。</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images4/image-20221027152821064.png" alt="image-20221027152821064"></p><h3 id="1-8-基于Redis实现短信登录"><a href="#1-8-基于Redis实现短信登录" class="headerlink" title="1.8 基于Redis实现短信登录"></a>1.8 基于Redis实现短信登录</h3><p>这里具体逻辑就不分析了，之前咱们已经重点分析过这个逻辑啦。</p><p><strong>UserServiceImpl代码</strong></p><pre><code class="java">@Overridepublic Result login(LoginFormDTO loginForm, HttpSession session) &#123;    // 1.校验手机号    String phone = loginForm.getPhone();    if (RegexUtils.isPhoneInvalid(phone)) &#123;        // 2.如果不符合，返回错误信息        return Result.fail(&quot;手机号格式错误！&quot;);    &#125;    // 3.从redis获取验证码并校验    String cacheCode = stringRedisTemplate.opsForValue().get(LOGIN_CODE_KEY + phone);    String code = loginForm.getCode();    if (cacheCode == null || !cacheCode.equals(code)) &#123;        // 不一致，报错        return Result.fail(&quot;验证码错误&quot;);    &#125;    // 4.一致，根据手机号查询用户 select * from tb_user where phone = ?    User user = query().eq(&quot;phone&quot;, phone).one();    // 5.判断用户是否存在    if (user == null) &#123;        // 6.不存在，创建新用户并保存        user = createUserWithPhone(phone);    &#125;    // 7.保存用户信息到 redis中    // 7.1.随机生成token，作为登录令牌    String token = UUID.randomUUID().toString(true);    // 7.2.将User对象转为HashMap存储    UserDTO userDTO = BeanUtil.copyProperties(user, UserDTO.class);    Map&lt;String, Object&gt; userMap = BeanUtil.beanToMap(userDTO, new HashMap&lt;&gt;(),            CopyOptions.create()                    .setIgnoreNullValue(true)                    .setFieldValueEditor((fieldName, fieldValue) -&gt; fieldValue.toString()));    // 7.3.存储    String tokenKey = LOGIN_USER_KEY + token;    stringRedisTemplate.opsForHash().putAll(tokenKey, userMap);    // 7.4.设置token有效期    stringRedisTemplate.expire(tokenKey, LOGIN_USER_TTL, TimeUnit.MINUTES);    // 8.返回token    return Result.ok(token);&#125;</code></pre><h3 id="1-9-解决状态登录刷新问题"><a href="#1-9-解决状态登录刷新问题" class="headerlink" title="1.9 解决状态登录刷新问题"></a>1.9 解决状态登录刷新问题</h3><h4 id="1-9-1-初始方案思路总结："><a href="#1-9-1-初始方案思路总结：" class="headerlink" title="1.9.1 初始方案思路总结："></a>1.9.1 初始方案思路总结：</h4><p>在这个方案中，他确实可以使用对应路径的拦截，同时刷新登录token令牌的存活时间，但是现在这个拦截器他只是拦截需要被拦截的路径，假设当前用户访问了一些不需要拦截的路径，那么这个拦截器就不会生效，所以此时令牌刷新的动作实际上就不会执行，所以这个方案他是存在问题的</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images4/image-20221029133647181.png" alt="image-20221029133647181"></p><h4 id="1-9-2-优化方案"><a href="#1-9-2-优化方案" class="headerlink" title="1.9.2 优化方案"></a>1.9.2 优化方案</h4><p>既然之前的拦截器无法对不需要拦截的路径生效，那么我们可以添加一个拦截器，在第一个拦截器中拦截所有的路径，把第二个拦截器做的事情放入到第一个拦截器中，同时刷新令牌，因为第一个拦截器有了threadLocal的数据，所以此时第二个拦截器只需要判断拦截器中的user对象是否存在即可，完成整体刷新功能。</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images4/image-20221029133723365.png" alt="image-20221029133723365"></p><h4 id="1-9-3-代码"><a href="#1-9-3-代码" class="headerlink" title="1.9.3 代码"></a>1.9.3 代码</h4><p><strong>RefreshTokenInterceptor</strong></p><pre><code class="java">public class RefreshTokenInterceptor implements HandlerInterceptor &#123;    private StringRedisTemplate stringRedisTemplate;    public RefreshTokenInterceptor(StringRedisTemplate stringRedisTemplate) &#123;        this.stringRedisTemplate = stringRedisTemplate;    &#125;    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;        // 1.获取请求头中的token        String token = request.getHeader(&quot;authorization&quot;);        if (StrUtil.isBlank(token)) &#123;            return true;        &#125;        // 2.基于TOKEN获取redis中的用户        String key  = LOGIN_USER_KEY + token;        Map&lt;Object, Object&gt; userMap = stringRedisTemplate.opsForHash().entries(key);        // 3.判断用户是否存在        if (userMap.isEmpty()) &#123;            return true;        &#125;        // 5.将查询到的hash数据转为UserDTO        UserDTO userDTO = BeanUtil.fillBeanWithMap(userMap, new UserDTO(), false);        // 6.存在，保存用户信息到 ThreadLocal        UserHolder.saveUser(userDTO);        // 7.刷新token有效期        stringRedisTemplate.expire(key, LOGIN_USER_TTL, TimeUnit.MINUTES);        // 8.放行        return true;    &#125;    @Override    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;        // 移除用户        UserHolder.removeUser();    &#125;&#125;    </code></pre><p><strong>LoginInterceptor</strong></p><pre><code class="java">public class LoginInterceptor implements HandlerInterceptor &#123;    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;        // 1.判断是否需要拦截（ThreadLocal中是否有用户）        if (UserHolder.getUser() == null) &#123;            // 没有，需要拦截，设置状态码            response.setStatus(401);            // 拦截            return false;        &#125;        // 有用户，则放行        return true;    &#125;&#125;</code></pre><h2 id="2、商户查询缓存"><a href="#2、商户查询缓存" class="headerlink" title="2、商户查询缓存"></a>2、商户查询缓存</h2><h3 id="2-1-什么是缓存"><a href="#2-1-什么是缓存" class="headerlink" title="2.1 什么是缓存?"></a>2.1 什么是缓存?</h3><p><strong>前言</strong>:<strong>什么是缓存?</strong></p><p>就像自行车,越野车的避震器</p><p>举个例子:越野车,山地自行车,都拥有”避震器”,<strong>防止</strong>车体加速后因惯性,在酷似”U”字母的地形上飞跃,硬着陆导致的<strong>损害</strong>,像个弹簧一样;</p><p>同样,实际开发中,系统也需要”避震器”,防止过高的数据访问猛冲系统,导致其操作线程无法及时处理信息而瘫痪;</p><p>这在实际开发中对企业讲,对产品口碑,用户评价都是致命的;所以企业非常重视缓存技术;</p><p><strong>缓存(<strong>Cache),就是数据交换的</strong>缓冲区</strong>,俗称的缓存就是<strong>缓冲区内的数据</strong>,一般从数据库中获取,存储于本地代码(例如:</p><pre><code class="java">例1:Static final ConcurrentHashMap&lt;K,V&gt; map = new ConcurrentHashMap&lt;&gt;(); 本地用于高并发例2:static final Cache&lt;K,V&gt; USER_CACHE = CacheBuilder.newBuilder().build(); 用于redis等缓存例3:Static final Map&lt;K,V&gt; map =  new HashMap(); 本地缓存</code></pre><p>由于其被<strong>Static</strong>修饰,所以随着类的加载而被加载到<strong>内存之中</strong>,作为本地缓存,由于其又被<strong>final</strong>修饰,所以其引用(例3:map)和对象(例3:new HashMap())之间的关系是固定的,不能改变,因此不用担心赋值(&#x3D;)导致缓存失效;</p><h4 id="2-1-1-为什么要使用缓存"><a href="#2-1-1-为什么要使用缓存" class="headerlink" title="2.1.1 为什么要使用缓存"></a>2.1.1 为什么要使用缓存</h4><p>一句话:因为<strong>速度快,好用</strong></p><p>缓存数据存储于代码中,而代码运行在内存中,内存的读写性能远高于磁盘,缓存可以大大降低<strong>用户访问并发量带来的</strong>服务器读写压力</p><p>实际开发过程中,企业的数据量,少则几十万,多则几千万,这么大数据量,如果没有缓存来作为”避震器”,系统是几乎撑不住的,所以企业会大量运用到缓存技术;</p><p>但是缓存也会增加代码复杂度和运营的成本:</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images4/image-20221027154722836.png" alt="image-20221027154722836"></p><h4 id="2-1-2-如何使用缓存"><a href="#2-1-2-如何使用缓存" class="headerlink" title="2.1.2 如何使用缓存"></a>2.1.2 如何使用缓存</h4><p>实际开发中,会构筑多级缓存来使系统运行速度进一步提升,例如:本地缓存与redis中的缓存并发使用</p><p><strong>浏览器缓存</strong>：主要是存在于浏览器端的缓存</p><p><strong>应用层缓存：</strong>可以分为tomcat本地缓存，比如之前提到的map，或者是使用redis作为缓存</p><p><strong>数据库缓存：</strong>在数据库中有一片空间是 buffer pool，增改查数据都会先加载到mysql的缓存中</p><p><strong>CPU缓存：</strong>当代计算机最大的问题是 cpu性能提升了，但内存读写速度没有跟上，所以为了适应当下的情况，增加了cpu的L1，L2，L3级的缓存</p><h3 id="2-2-添加商户缓存"><a href="#2-2-添加商户缓存" class="headerlink" title="2.2 添加商户缓存"></a>2.2 添加商户缓存</h3><p>在我们查询商户信息时，我们是直接操作从数据库中去进行查询的，大致逻辑是这样，直接查询数据库那肯定慢咯，所以我们需要增加缓存</p><pre><code class="java">@GetMapping(&quot;/&#123;id&#125;&quot;)public Result queryShopById(@PathVariable(&quot;id&quot;) Long id) &#123;    //这里是直接查询数据库    return shopService.queryById(id);&#125;</code></pre><h4 id="2-2-1-、缓存模型和思路"><a href="#2-2-1-、缓存模型和思路" class="headerlink" title="2.2.1 、缓存模型和思路"></a>2.2.1 、缓存模型和思路</h4><p>标准的操作方式就是查询数据库之前先查询缓存，如果缓存数据存在，则直接从缓存中返回，如果缓存数据不存在，再查询数据库，然后将数据存入redis。</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images4/image-20221027155221277.png" alt="image-20221027155221277"></p><h4 id="2-1-2、代码如下"><a href="#2-1-2、代码如下" class="headerlink" title="2.1.2、代码如下"></a>2.1.2、代码如下</h4><p>代码思路：如果缓存有，则直接返回，如果缓存不存在，则查询数据库，然后存入redis。</p><pre><code class="java">@Servicepublic class ShopServiceImpl extends ServiceImpl&lt;ShopMapper, Shop&gt; implements IShopService &#123;    @Resource    private StringRedisTemplate stringRedisTemplate;    @Override    public Result queryById(Long id) &#123;        //1.从redis查询商铺缓存        String shopJson = stringRedisTemplate.opsForValue().get(CACHE_SHOP_KEY + id);        //2.判断是否存在        if(StrUtil.isNotBlank(shopJson))&#123;            //3.存在,直接返回            Shop shop = JSONUtil.toBean(shopJson, Shop.class);            return Result.ok(shop);        &#125;        //4.不存在,根据id查询数据库        Shop shop = getById(id);        //5.若数据库中也不存在就返回错误信息        if (shop == null) &#123;            return Result.fail(&quot;店铺不存在!&quot;);        &#125;        //6.若数据库中存在,先写入redis中缓存        stringRedisTemplate.opsForValue().set(CACHE_SHOP_KEY + id,JSONUtil.toJsonStr(shop));        //7.返回给客户端        return Result.ok(shop);    &#125;&#125;</code></pre><h3 id="2-3-缓存更新策略"><a href="#2-3-缓存更新策略" class="headerlink" title="2.3 缓存更新策略"></a>2.3 缓存更新策略</h3><p>缓存更新是redis为了节约内存而设计出来的一个东西，主要是因为内存数据宝贵，当我们向redis插入太多数据，此时就可能会导致缓存中的数据过多，所以redis会对部分数据进行更新，或者把他叫为淘汰更合适。</p><p><strong>内存淘汰：</strong>redis自动进行，当redis内存达到咱们设定的max-memery的时候，会自动触发淘汰机制，淘汰掉一些不重要的数据(可以自己设置策略方式)</p><p><strong>超时剔除：</strong>当我们给redis设置了过期时间ttl之后，redis会将超时的数据进行删除，方便咱们继续使用缓存</p><p><strong>主动更新：</strong>我们可以手动调用方法把缓存删掉，通常用于解决缓存和数据库不一致问题</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images4/image-20221028155733221.png" alt="image-20221028155733221"></p><h4 id="2-3-1-、数据库缓存不一致解决方案："><a href="#2-3-1-、数据库缓存不一致解决方案：" class="headerlink" title="2.3.1 、数据库缓存不一致解决方案："></a>2.3.1 、数据库缓存不一致解决方案：</h4><p>由于我们的<strong>缓存的数据源来自于数据库</strong>,而数据库的<strong>数据是会发生变化的</strong>,因此,如果当数据库中<strong>数据发生变化,而缓存却没有同步</strong>,此时就会有<strong>一致性问题存在</strong>,其后果是:</p><p>用户使用缓存中的过时数据,就会产生类似多线程数据安全问题,从而影响业务,产品口碑等;怎么解决呢？有如下几种方案</p><p><strong>Cache Aside Pattern</strong> 人工编码方式：缓存调用者在更新完数据库后再去更新缓存，也称之为双写方案</p><p><strong>Read&#x2F;Write Through Pattern</strong> : 由系统本身完成，数据库与缓存的问题交由系统本身去处理</p><p><strong>Write Behind Caching Pattern</strong> ：调用者只操作缓存，其他线程去异步处理数据库，实现最终一致</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images4/image-20221028160636817.png" alt="image-20221028160636817"></p><h4 id="2-3-2-、数据库和缓存不一致采用什么方案"><a href="#2-3-2-、数据库和缓存不一致采用什么方案" class="headerlink" title="2.3.2 、数据库和缓存不一致采用什么方案"></a>2.3.2 、数据库和缓存不一致采用什么方案</h4><p>综合考虑使用方案一，但是方案一调用者如何处理呢？这里有几个问题</p><p>操作缓存和数据库时有三个问题需要考虑：</p><p>如果采用第一个方案，那么假设我们每次操作数据库后，都操作缓存，但是中间如果没有人查询，那么这个更新动作实际上只有最后一次生效，中间的更新动作意义并不大，我们可以把缓存删除，等待再次查询时，将缓存中的数据加载出来</p><ul><li><p>删除缓存还是更新缓存？</p><ul><li>更新缓存：每次更新数据库都更新缓存，无效写操作较多</li><li>删除缓存：更新数据库时让缓存失效，查询时再更新缓存</li></ul></li><li><p>如何保证缓存与数据库的操作的同时成功或失败？</p><ul><li>单体系统，将缓存与数据库操作放在一个事务</li><li>分布式系统，利用TCC等分布式事务方案</li></ul></li></ul><p>应该具体操作缓存还是操作数据库，我们应当是先操作数据库，再删除缓存，原因在于，如果你选择第一种方案，在两个线程并发来访问时，假设线程1先来，他先把缓存删了，此时线程2过来，他查询缓存数据并不存在，此时他写入缓存，当他写入缓存后，线程1再执行更新动作时，实际上写入的就是旧的数据，新的数据被旧数据覆盖了。</p><ul><li>先操作缓存还是先操作数据库？<ul><li>先删除缓存，再操作数据库</li><li>先操作数据库，再删除缓存</li></ul></li></ul><p><img src="https://gitee.com/DylanToT99/images/raw/master/images4/image-20221028162042169.png" alt="image-20221028162042169"></p><h3 id="2-4-实现商铺和缓存与数据库双写一致"><a href="#2-4-实现商铺和缓存与数据库双写一致" class="headerlink" title="2.4 实现商铺和缓存与数据库双写一致"></a>2.4 实现商铺和缓存与数据库双写一致</h3><p>核心思路如下：</p><p>修改ShopController中的业务逻辑，满足下面的需求：</p><p>根据id查询店铺时，如果缓存未命中，则查询数据库，将数据库结果写入缓存，并设置超时时间</p><p>根据id修改店铺时，先修改数据库，再删除缓存</p><p><strong>修改重点代码1</strong>：修改<strong>ShopServiceImpl</strong>的queryById方法</p><p><strong>设置redis缓存时添加过期时间</strong></p><pre><code class="java">//6.若数据库中存在,先写入redis中缓存stringRedisTemplate.opsForValue().set(CACHE_SHOP_KEY + id,JSONUtil.toJsonStr(shop),CACHE_SHOP_TTL, TimeUnit.MINUTES);</code></pre><p><strong>修改重点代码2</strong></p><p>代码分析：通过之前的淘汰，我们确定了采用删除策略，来解决双写问题，当我们修改了数据之后，然后把缓存中的数据进行删除，查询时发现缓存中没有数据，则会从mysql中加载最新的数据，从而避免数据库和缓存不一致的问题</p><pre><code class="java">@Override//添加事务支持@Transactionalpublic Result update(Shop shop) &#123;    Long id = shop.getId();    if (id==null)&#123;        return Result.fail(&quot;商铺id不能为空&quot;);    &#125;    //1.更新数据库    updateById(shop);    //2.删除缓存    stringRedisTemplate.delete(CACHE_SHOP_KEY + shop.getId());    return Result.ok();&#125;</code></pre><h3 id="2-5-缓存穿透问题的解决思路"><a href="#2-5-缓存穿透问题的解决思路" class="headerlink" title="2.5 缓存穿透问题的解决思路"></a>2.5 缓存穿透问题的解决思路</h3><p><strong>缓存穿透</strong> ：缓存穿透是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会打到数据库。</p><p>常见的解决方案有两种：</p><ul><li>缓存空对象<ul><li>优点：实现简单，维护方便</li><li>缺点：<ul><li>额外的内存消耗</li><li>可能造成短期的不一致</li></ul></li></ul></li><li>布隆过滤<ul><li>优点：内存占用较少，没有多余key</li><li>缺点：<ul><li>实现复杂</li><li>存在误判可能</li></ul></li></ul></li></ul><p><strong>缓存空对象思路分析：</strong>当我们客户端访问不存在的数据时，先请求redis，但是此时redis中没有数据，此时会访问到数据库，但是数据库中也没有数据，这个数据穿透了缓存，直击数据库，我们都知道数据库能够承载的并发不如redis这么高，如果大量的请求同时过来访问这种不存在的数据，这些请求就都会访问到数据库，简单的解决方案就是哪怕这个数据在数据库中也不存在，我们也把这个数据存入到redis中去，这样，下次用户过来访问这个不存在的数据，那么在redis中也能找到这个数据就不会进入到缓存了</p><p><strong>布隆过滤：</strong>布隆过滤器其实采用的是哈希思想来解决这个问题，通过一个庞大的二进制数组，走哈希思想去判断当前这个要查询的这个数据是否存在，如果布隆过滤器判断存在，则放行，这个请求会去访问redis，哪怕此时redis中的数据过期了，但是数据库中一定存在这个数据，在数据库中查询出来这个数据后，再将其放入到redis中，</p><p>假设布隆过滤器判断这个数据不存在，则直接返回</p><p>这种方式优点在于节约内存空间，存在误判，误判原因在于：布隆过滤器走的是哈希思想，只要哈希思想，就可能存在哈希冲突</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images4/image-20221028172524112.png" alt="image-20221028172524112"></p><h3 id="2-6-编码解决商品查询的缓存穿透问题："><a href="#2-6-编码解决商品查询的缓存穿透问题：" class="headerlink" title="2.6 编码解决商品查询的缓存穿透问题："></a>2.6 编码解决商品查询的缓存穿透问题：</h3><p>核心思路如下：</p><p>在原来的逻辑中，我们如果发现这个数据在mysql中不存在，直接就返回404了，这样是会存在缓存穿透问题的</p><p>现在的逻辑中：如果这个数据不存在，我们不会返回404 ，还是会把这个数据写入到Redis中，并且将value设置为空，欧当再次发起查询时，我们如果发现命中之后，判断这个value是否是null，如果是null，则是之前写入的数据，证明是缓存穿透数据，如果不是，则直接返回数据。</p><pre><code class="java">if(StrUtil.isNotBlank(shopJson))&#123;    //3.存在,直接返回    Shop shop = JSONUtil.toBean(shopJson, Shop.class);    return Result.ok(shop);&#125;//判断命中的是否是空值:if(shopJson!=null)&#123;    //返回一个错误信息    return Result.fail(&quot;店铺不存在&quot;);&#125;</code></pre><p><strong>小总结：</strong></p><p>缓存穿透产生的原因是什么？</p><ul><li>用户请求的数据在缓存中和数据库中都不存在，不断发起这样的请求，给数据库带来巨大压力</li></ul><p>缓存穿透的解决方案有哪些？</p><ul><li>缓存null值</li><li>布隆过滤</li><li>增强id的复杂度，避免被猜测id规律</li><li>做好数据的基础格式校验</li><li>加强用户权限校验</li><li>做好热点参数的限流</li></ul><h3 id="2-7-缓存雪崩问题及解决思路"><a href="#2-7-缓存雪崩问题及解决思路" class="headerlink" title="2.7 缓存雪崩问题及解决思路"></a>2.7 缓存雪崩问题及解决思路</h3><p>缓存雪崩是指在同一时段大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力。</p><p>解决方案：</p><ul><li>给不同的Key的TTL添加随机值</li><li>利用Redis集群提高服务的可用性</li><li>给缓存业务添加降级限流策略</li><li>给业务添加多级缓存</li></ul><p><img src="https://gitee.com/DylanToT99/images/raw/master/images4/image-20221028174829798.png" alt="image-20221028174829798"></p><h3 id="2-8-缓存击穿问题及解决思路"><a href="#2-8-缓存击穿问题及解决思路" class="headerlink" title="2.8 缓存击穿问题及解决思路"></a>2.8 缓存击穿问题及解决思路</h3><p><strong>缓存击穿问题</strong>也叫<strong>热点Key</strong>问题，就是一个被高并发访问并且缓存重建业务较复杂的key突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击。</p><p>常见的解决方案有两种：</p><ul><li>互斥锁</li><li>逻辑过期</li></ul><p>逻辑分析：假设线程1在查询缓存之后，本来应该去查询数据库，然后把这个数据重新加载到缓存的，此时只要线程1走完这个逻辑，其他线程就都能从缓存中加载这些数据了，但是假设在线程1没有走完的时候，后续的线程2，线程3，线程4同时过来访问当前这个方法， 那么这些线程都不能从缓存中查询到数据，那么他们就会同一时刻来访问查询缓存，都没查到，接着同一时间去访问数据库，同时的去执行数据库代码，对数据库访问压力过大</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images4/image-20221028180007416.png" alt="image-20221028180007416"></p><p>解决方案一、使用锁来解决：</p><p>因为锁能实现互斥性。假设线程过来，只能一个人一个人的来访问数据库，从而避免对于数据库访问压力过大，但这也会影响查询的性能，因为此时会让查询的性能从并行变成了串行，我们可以采用tryLock方法 + double check来解决这样的问题。</p><p>假设现在线程1过来访问，他查询缓存没有命中，但是此时他获得到了锁的资源，那么线程1就会一个人去执行逻辑，假设现在线程2过来，线程2在执行过程中，并没有获得到锁，那么线程2就可以进行到休眠，直到线程1把锁释放后，线程2获得到锁，然后再来执行逻辑，此时就能够从缓存中拿到数据了。</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images4/image-20221028180048945.png" alt="image-20221028180048945"></p><p>解决方案二、逻辑过期方案</p><p>方案分析：我们之所以会出现这个缓存击穿问题，主要原因是在于我们对key设置了过期时间，假设我们不设置过期时间，其实就不会有缓存击穿的问题，但是不设置过期时间，这样数据不就一直占用我们内存了吗，我们可以采用逻辑过期方案。</p><p>我们把过期时间设置在 redis的value中，注意：这个过期时间并不会直接作用于redis，而是我们后续通过逻辑去处理。假设线程1去查询缓存，然后从value中判断出来当前的数据已经过期了，此时线程1去获得互斥锁，那么其他线程会进行阻塞，获得了锁的线程他会开启一个 线程去进行 以前的重构数据的逻辑，直到新开的线程完成这个逻辑后，才释放锁， 而线程1直接进行返回，假设现在线程3过来访问，由于线程线程2持有着锁，所以线程3无法获得锁，线程3也直接返回数据，只有等到新开的线程2把重建数据构建完后，其他线程才能走返回正确的数据。</p><p>这种方案巧妙在于，异步的构建缓存，缺点在于在构建完缓存之前，返回的都是脏数据。</p><p><img src="C:\Users\Dylan\AppData\Roaming\Typora\typora-user-images\image-20221028183531965.png"></p><p>进行对比</p><p><strong>互斥锁方案：</strong>由于保证了互斥性，所以数据一致，且实现简单，因为仅仅只需要加一把锁而已，也没其他的事情需要操心，所以没有额外的内存消耗，缺点在于有锁就有死锁问题的发生，且只能串行执行性能肯定受到影响</p><p><strong>逻辑过期方案：</strong> 线程读取过程中不需要等待，性能好，有一个额外的线程持有锁去进行重构数据，但是在重构数据完成前，其他的线程只能返回之前的数据，且实现起来麻烦</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images4/image-20221028180119985.png" alt="image-20221028180119985"></p><h3 id="2-9-利用互斥锁解决缓存击穿问题"><a href="#2-9-利用互斥锁解决缓存击穿问题" class="headerlink" title="2.9 利用互斥锁解决缓存击穿问题"></a>2.9 利用互斥锁解决缓存击穿问题</h3><p>核心思路：相较于原来从缓存中查询不到数据后直接查询数据库而言，现在的方案是 进行查询之后，如果从缓存没有查询到数据，则进行互斥锁的获取，获取互斥锁后，判断是否获得到了锁，如果没有获得到，则休眠，过一会再进行尝试，直到获取到锁为止，才能进行查询</p><p>如果获取到了锁的线程，再去进行查询，查询后将数据写入redis，再释放锁，返回数据，利用互斥锁就能保证只有一个线程去执行操作数据库的逻辑，防止缓存击穿</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images4/image-20221029135708108.png" alt="image-20221029135708108"></p><p><strong>操作锁的代码：</strong></p><p>核心思路就是利用redis的setnx方法来表示获取锁，该方法含义是redis中如果没有这个key，则插入成功，返回1，在stringRedisTemplate中返回true，  如果有这个key则插入失败，则返回0，在stringRedisTemplate返回false，我们可以通过true，或者是false，来表示是否有线程成功插入key，成功插入的key的线程我们认为他就是获得到锁的线程。</p><pre><code class="java">private boolean tryLock(String key) &#123;    Boolean flag = stringRedisTemplate.opsForValue().setIfAbsent(key, &quot;1&quot;, 10, TimeUnit.SECONDS);    return BooleanUtil.isTrue(flag);&#125;private void unlock(String key) &#123;    stringRedisTemplate.delete(key);&#125;</code></pre><p><strong>操作代码：</strong></p><pre><code class="java"> public Shop queryWithMutex(Long id)  &#123;        String key = CACHE_SHOP_KEY + id;        // 1、从redis中查询商铺缓存        String shopJson = stringRedisTemplate.opsForValue().get(&quot;key&quot;);        // 2、判断是否存在        if (StrUtil.isNotBlank(shopJson)) &#123;            // 存在,直接返回            return JSONUtil.toBean(shopJson, Shop.class);        &#125;        //判断命中的值是否是空值        if (shopJson != null) &#123;            //返回一个错误信息            return null;        &#125;        // 4.实现缓存重构        //4.1 获取互斥锁        String lockKey = &quot;lock:shop:&quot; + id;        Shop shop = null;        try &#123;            boolean isLock = tryLock(lockKey);            // 4.2 判断否获取成功            if(!isLock)&#123;                //4.3 失败，则休眠重试                Thread.sleep(50);                return queryWithMutex(id);            &#125;            //4.4 成功，根据id查询数据库             shop = getById(id);            // 5.不存在，返回错误            if(shop == null)&#123;                 //将空值写入redis                stringRedisTemplate.opsForValue().set(key,&quot;&quot;,CACHE_NULL_TTL,TimeUnit.MINUTES);                //返回错误信息                return null;            &#125;            //6.写入redis            stringRedisTemplate.opsForValue().set(key,JSONUtil.toJsonStr(shop),CACHE_NULL_TTL,TimeUnit.MINUTES);        &#125;catch (Exception e)&#123;            throw new RuntimeException(e);        &#125;        finally &#123;            //7.释放互斥锁            unlock(lockKey);        &#125;        return shop;    &#125;</code></pre><h3 id="3-0-、利用逻辑过期解决缓存击穿问题"><a href="#3-0-、利用逻辑过期解决缓存击穿问题" class="headerlink" title="3.0 、利用逻辑过期解决缓存击穿问题"></a>3.0 、利用逻辑过期解决缓存击穿问题</h3><p><strong>需求：修改根据id查询商铺的业务，基于逻辑过期方式来解决缓存击穿问题</strong></p><p>思路分析：当用户开始查询redis时，判断是否命中，如果没有命中则直接返回空数据，不查询数据库，而一旦命中后，将value取出，判断value中的过期时间是否满足，如果没有过期，则直接返回redis中的数据，如果过期，则在开启独立线程后直接返回之前的数据，独立线程去重构数据，重构完成后释放互斥锁。</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images4/image-20221029154130077.png" alt="image-20221029154130077"></p><p>如果封装数据：因为现在redis中存储的数据的value需要带上过期时间，此时要么你去修改原来的实体类，要么你</p><p><strong>步骤一、</strong></p><p>新建一个实体类，我们采用第二个方案，这个方案，对原来代码没有侵入性。</p><pre><code class="java">@Datapublic class RedisData &#123;    private LocalDateTime expireTime;    private Object data;&#125;</code></pre><p><strong>步骤二、</strong></p><p>在<strong>ShopServiceImpl</strong> 新增此方法，利用单元测试进行缓存预热</p><pre><code class="java">public void saveShopToRedis(Long id,Long expireSeconds) throws InterruptedException &#123;    //1.查询店铺数据    Shop shop = getById(id);    //Thread.sleep(200);    //2.封装逻辑过期时间    RedisData redisData = new RedisData();    redisData.setData(shop);    redisData.setExpireTime(LocalDateTime.now().plusSeconds(expireSeconds));    //3.写入redis    stringRedisTemplate.opsForValue().set(CACHE_SHOP_KEY+id,JSONUtil.toJsonStr(redisData));&#125;</code></pre><p><strong>在测试类中</strong></p><pre><code class="java">@Testvoid testSaveShop() throws InterruptedException &#123;    shopService.saveShopToRedis(1L,20L);&#125;</code></pre><p>步骤三：正式代码</p><p><strong>ShopServiceImpl</strong></p><pre><code class="java">  private static final ExecutorService CACHE_REBUILD_EXECUTOR= Executors.newFixedThreadPool(10);    public Shop queryWithLogicalExpire(Long id)&#123;        //1.从redis查询商铺缓存        String shopJson = stringRedisTemplate.opsForValue().get(CACHE_SHOP_KEY + id);        //2.判断是否存在        if(StrUtil.isBlank(shopJson))&#123;            //3.不存在,直接返回            return null;        &#125;        //命中将json反序列化为对象        RedisData redisData = JSONUtil.toBean(shopJson, RedisData.class);        JSONObject data = (JSONObject) redisData.getData();        Shop shop = JSONUtil.toBean(data, Shop.class);        LocalDateTime expireTime = redisData.getExpireTime();        //判断是否过期        if(expireTime.isAfter(LocalDateTime.now()))&#123;            //未过期,直接返回店铺信息            return shop;        &#125;        //过期,尝试缓存重建        //获取互斥锁        String lockKey=LOCK_SHOP_KEY+id;        boolean b = tryLock(lockKey);        if (b)&#123;            /**             * 再次检查是否过期,因为可能在上一条语句执行之前刚好有线程完成了对缓存的重建             */            String shopJson1 = stringRedisTemplate.opsForValue().get(CACHE_SHOP_KEY + id);            RedisData redisData1 = JSONUtil.toBean(shopJson1, RedisData.class);            JSONObject data1 = (JSONObject) redisData1.getData();            Shop shop1 = JSONUtil.toBean(data1, Shop.class);            LocalDateTime expireTime1 = redisData.getExpireTime();            //判断是否过期            if(expireTime1.isAfter(LocalDateTime.now()))&#123;                //未过期,直接返回店铺信息                return shop1;            &#125;            //TODO 获取到了锁:开启独立线程,实现缓存重建            CACHE_REBUILD_EXECUTOR.submit(()-&gt;&#123;                try &#123;                    this.saveShopToRedis(id,20L);                &#125; catch (Exception e) &#123;                    throw new RuntimeException(e);                &#125; finally &#123;                    unLock(lockKey);                &#125;            &#125;);        &#125;        //(未获取到锁:)        // 返回过期的商铺信息        return shop;    &#125;</code></pre><h3 id="3-1、封装Redis工具类"><a href="#3-1、封装Redis工具类" class="headerlink" title="3.1、封装Redis工具类"></a>3.1、封装Redis工具类</h3><p>基于StringRedisTemplate封装一个缓存工具类，满足下列需求：</p><ul><li>方法1：将任意Java对象序列化为json并存储在string类型的key中，并且可以设置TTL过期时间</li><li>方法2：将任意Java对象序列化为json并存储在string类型的key中，并且可以设置逻辑过期时间，用于处理缓</li></ul><p>存击穿问题</p><ul><li>方法3：根据指定的key查询缓存，并反序列化为指定类型，利用缓存空值的方式解决缓存穿透问题</li><li>方法4：根据指定的key查询缓存，并反序列化为指定类型，需要利用逻辑过期解决缓存击穿问题</li></ul><p>将逻辑进行封装</p><pre><code class="java">@Component@Slf4jpublic class CacheClient &#123;    private final StringRedisTemplate stringRedisTemplate;    public CacheClient(StringRedisTemplate stringRedisTemplate) &#123;        this.stringRedisTemplate = stringRedisTemplate;    &#125;    public void set(String key, Object value, Long time, TimeUnit unit)&#123;        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(value),time,unit);    &#125;    public void setWithLogicalExpire(String key, Object value, Long time, TimeUnit unit)&#123;        //设置逻辑过期        //利用RedisData这个类专门封装 &quot;类+逻辑过期时间&quot; 的需求        RedisData redisData = new RedisData();        redisData.setData(value);        redisData.setExpireTime(LocalDateTime.now().plusSeconds(unit.toSeconds(time)));        //写入redis        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(redisData));    &#125;    //解决缓存穿透    public &lt;R,ID&gt;R queryWithPassThrough(String prefix, ID id, Class&lt;R&gt;type, Function&lt;ID,R&gt;dbFallback,Long time,TimeUnit unit)&#123;        String key=prefix+id;        //1.从redis查询商铺缓存        String shopJson = stringRedisTemplate.opsForValue().get(key);        //2.判断是否存在        if(StrUtil.isNotBlank(shopJson))&#123;            //3.存在,直接返回            return JSONUtil.toBean(shopJson, type);        &#125;        //判断命中的是否是空值:        if(shopJson!=null)&#123;            //返回一个错误信息            return null;        &#125;        //4.不存在,根据id查询数据库        R r =dbFallback.apply(id);        //5.若数据库中也不存在就返回错误信息,且将空值写入到Redis中,防止缓存穿透        if (r == null) &#123;            stringRedisTemplate.opsForValue().set(key,&quot;&quot;,CACHE_NULL_TTL,TimeUnit.MINUTES);            return null;        &#125;        //6.若数据库中存在,先写入redis中缓存        this.set(key,r,time,unit);        //7.返回给客户端        return r;    &#125;    private static final ExecutorService CACHE_REBUILD_EXECUTOR= Executors.newFixedThreadPool(10);    //解决缓存击穿    public &lt;R,ID&gt;R queryWithLogicalExpire(ID id,String prefix,Class&lt;R&gt;type,String shopLockKey,Function&lt;ID,R&gt;dbFallBack,Long time,TimeUnit unit)&#123;        String key=prefix+id;        //1.从redis查询商铺缓存        String Json = stringRedisTemplate.opsForValue().get(key);        //2.判断是否存在        if(StrUtil.isBlank(Json))&#123;            //3.不存在,直接返回            return null;        &#125;        //命中将json反序列化为对象        RedisData redisData = JSONUtil.toBean(Json, RedisData.class);        JSONObject data = (JSONObject) redisData.getData();        R r = JSONUtil.toBean(data, type);        LocalDateTime expireTime = redisData.getExpireTime();        //判断是否过期        if(expireTime.isAfter(LocalDateTime.now()))&#123;            //未过期,直接返回信息            return r;        &#125;        //过期,尝试缓存重建        //获取互斥锁        String lockKey=shopLockKey+id;        boolean b = tryLock(lockKey);        if (b)&#123;            /**             * 再次检查是否过期,因为可能在上一条语句执行之前刚好有线程完成了对缓存的重建             */            String Json1 = stringRedisTemplate.opsForValue().get(key);            RedisData redisData1 = JSONUtil.toBean(Json1, RedisData.class);            JSONObject data1 = (JSONObject) redisData1.getData();            R r1 = JSONUtil.toBean(data1, type);            LocalDateTime expireTime1 = redisData.getExpireTime();            //判断是否过期            if(expireTime1.isAfter(LocalDateTime.now()))&#123;                //未过期,直接返回店铺信息                return r1;            &#125;            //TODO 获取到了锁:开启独立线程,实现缓存重建            CACHE_REBUILD_EXECUTOR.submit(()-&gt;&#123;                try &#123;                    //this.saveShopToRedis(id,20L);                    R apply = dbFallBack.apply(id);                    this.setWithLogicalExpire(key,apply,time,unit);                &#125; catch (Exception e) &#123;                    throw new RuntimeException(e);                &#125; finally &#123;                    unLock(lockKey);                &#125;            &#125;);        &#125;        //(未获取到锁:)        // 返回过期的商铺信息        return r;    &#125;    private boolean tryLock(String key)&#123;        Boolean aBoolean = stringRedisTemplate.opsForValue().setIfAbsent(key, &quot;1&quot;, 10, TimeUnit.SECONDS);        return BooleanUtil.isTrue(aBoolean);    &#125;    private  void unLock(String key)&#123;        stringRedisTemplate.delete(key);    &#125;&#125;</code></pre><p>在ShopServiceImpl 中</p><pre><code class="java">@Resourceprivate CacheClient cacheClient; @Override    public Result queryById(Long id) &#123;        // 解决缓存穿透        Shop shop = cacheClient                .queryWithPassThrough(CACHE_SHOP_KEY, id, Shop.class, this::getById, CACHE_SHOP_TTL, TimeUnit.MINUTES);        // 互斥锁解决缓存击穿        // Shop shop = cacheClient        //         .queryWithMutex(CACHE_SHOP_KEY, id, Shop.class, this::getById, CACHE_SHOP_TTL, TimeUnit.MINUTES);        // 逻辑过期解决缓存击穿        // Shop shop = cacheClient        //         .queryWithLogicalExpire(CACHE_SHOP_KEY, id, Shop.class, this::getById, 20L, TimeUnit.SECONDS);        if (shop == null) &#123;            return Result.fail(&quot;店铺不存在！&quot;);        &#125;        // 7.返回        return Result.ok(shop);    &#125;</code></pre><h2 id="3、优惠卷秒杀"><a href="#3、优惠卷秒杀" class="headerlink" title="3、优惠卷秒杀"></a>3、优惠卷秒杀</h2><h3 id="3-1-全局唯一ID"><a href="#3-1-全局唯一ID" class="headerlink" title="3.1 -全局唯一ID"></a>3.1 -全局唯一ID</h3><p>每个店铺都可以发布优惠券：</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images4/image-20221029174534582.png" alt="image-20221029174534582"></p><p>当用户抢购时，就会生成订单并保存到tb_voucher_order这张表中，而订单表如果使用数据库自增ID就存在一些问题：</p><ul><li>id的规律性太明显</li><li>受单表数据量的限制</li></ul><p>场景分析：如果我们的id具有太明显的规则，用户或者说商业对手很容易猜测出来我们的一些敏感信息，比如商城在一天时间内，卖出了多少单，这明显不合适。</p><p>场景分析二：随着我们商城规模越来越大，mysql的单表的容量不宜超过500W，数据量过大之后，我们要进行拆库拆表，但拆分表了之后，他们从逻辑上讲他们是同一张表，所以他们的id是不能一样的， 于是乎我们需要保证id的唯一性。</p><p><strong>全局ID生成器</strong>，是一种在分布式系统下用来生成全局唯一ID的工具，一般要满足下列特性：</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images4/image-20221029174608994.png" alt="image-20221029174608994"></p><p>为了增加ID的安全性，我们可以不直接使用Redis自增的数值，而是拼接一些其它信息：</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images4/image-20221029174635445.png" alt="image-20221029174635445"></p><p>ID的组成部分：符号位：1bit，永远为0</p><p>时间戳：31bit，以秒为单位，可以使用69年</p><p>序列号：32bit，秒内的计数器，支持每秒产生2^32个不同ID</p><h3 id="3-2-Redis实现全局唯一Id"><a href="#3-2-Redis实现全局唯一Id" class="headerlink" title="3.2 -Redis实现全局唯一Id"></a>3.2 -Redis实现全局唯一Id</h3><pre><code class="java">@Componentpublic class RedisIdWorker &#123;    /**     * 开始时间戳     */    private static final long BEGIN_TIMESTAMP = 1640995200L;    /**     * 序列号的位数     */    private static final int COUNT_BITS = 32;    private StringRedisTemplate stringRedisTemplate;    public RedisIdWorker(StringRedisTemplate stringRedisTemplate) &#123;        this.stringRedisTemplate = stringRedisTemplate;    &#125;    public long nextId(String keyPrefix) &#123;        // 1.生成时间戳        LocalDateTime now = LocalDateTime.now();        long nowSecond = now.toEpochSecond(ZoneOffset.UTC);        long timestamp = nowSecond - BEGIN_TIMESTAMP;        // 2.生成序列号        // 2.1.获取当前日期，精确到天        String date = now.format(DateTimeFormatter.ofPattern(&quot;yyyy:MM:dd&quot;));        // 2.2.自增长        long count = stringRedisTemplate.opsForValue().increment(&quot;icr:&quot; + keyPrefix + &quot;:&quot; + date);        // 3.拼接并返回        return timestamp &lt;&lt; COUNT_BITS | count;    &#125;&#125;</code></pre><p>测试类</p><p>知识小贴士：关于countdownlatch</p><p>countdownlatch名为信号枪：主要的作用是同步协调在多线程的等待于唤醒问题</p><p>我们如果没有CountDownLatch ，那么由于程序是异步的，当异步程序没有执行完时，主线程就已经执行完了，然后我们期望的是分线程全部走完之后，主线程再走，所以我们此时需要使用到CountDownLatch</p><p>CountDownLatch 中有两个最重要的方法</p><p>1、countDown</p><p>2、await</p><p>await 方法 是阻塞方法，我们担心分线程没有执行完时，main线程就先执行，所以使用await可以让main线程阻塞，那么什么时候main线程不再阻塞呢？当CountDownLatch  内部维护的 变量变为0时，就不再阻塞，直接放行，那么什么时候CountDownLatch   维护的变量变为0 呢，我们只需要调用一次countDown ，内部变量就减少1，我们让分线程和变量绑定， 执行完一个分线程就减少一个变量，当分线程全部走完，CountDownLatch 维护的变量就是0，此时await就不再阻塞，统计出来的时间也就是所有分线程执行完后的时间。</p><pre><code class="java">@Testvoid testIdWorker() throws InterruptedException &#123;    CountDownLatch latch = new CountDownLatch(300);    Runnable task = () -&gt; &#123;        for (int i = 0; i &lt; 100; i++) &#123;            long id = redisIdWorker.nextId(&quot;order&quot;);            System.out.println(&quot;id = &quot; + id);        &#125;        latch.countDown();    &#125;;    long begin = System.currentTimeMillis();    for (int i = 0; i &lt; 300; i++) &#123;        es.submit(task);    &#125;    latch.await();    long end = System.currentTimeMillis();    System.out.println(&quot;time = &quot; + (end - begin));&#125;</code></pre><h3 id="3-3-添加优惠卷"><a href="#3-3-添加优惠卷" class="headerlink" title="3.3 添加优惠卷"></a>3.3 添加优惠卷</h3><p>每个店铺都可以发布优惠券，分为平价券和特价券。平价券可以任意购买，而特价券需要秒杀抢购：</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images4/image-20221029185518816.png" alt="image-20221029185518816"></p><p>tb_voucher：优惠券的基本信息，优惠金额、使用规则等<br>tb_seckill_voucher：优惠券的库存、开始抢购时间，结束抢购时间。特价优惠券才需要填写这些信息</p><p>平价卷由于优惠力度并不是很大，所以是可以任意领取</p><p>而代金券由于优惠力度大，所以像第二种卷，就得限制数量，从表结构上也能看出，特价卷除了具有优惠卷的基本信息以外，还具有库存，抢购时间，结束时间等等字段</p><p>**新增普通卷代码：  **VoucherController</p><pre><code class="java">@PostMappingpublic Result addVoucher(@RequestBody Voucher voucher) &#123;    voucherService.save(voucher);    return Result.ok(voucher.getId());&#125;</code></pre><p><strong>新增秒杀卷代码：</strong></p><p><strong>VoucherController</strong></p><pre><code class="java">@PostMapping(&quot;seckill&quot;)public Result addSeckillVoucher(@RequestBody Voucher voucher) &#123;    voucherService.addSeckillVoucher(voucher);    return Result.ok(voucher.getId());&#125;</code></pre><p><strong>VoucherServiceImpl</strong></p><pre><code class="java">@Override@Transactionalpublic void addSeckillVoucher(Voucher voucher) &#123;    // 保存优惠券    save(voucher);    // 保存秒杀信息    SeckillVoucher seckillVoucher = new SeckillVoucher();    seckillVoucher.setVoucherId(voucher.getId());    seckillVoucher.setStock(voucher.getStock());    seckillVoucher.setBeginTime(voucher.getBeginTime());    seckillVoucher.setEndTime(voucher.getEndTime());    seckillVoucherService.save(seckillVoucher);    // 保存秒杀库存到Redis中    stringRedisTemplate.opsForValue().set(SECKILL_STOCK_KEY + voucher.getId(), voucher.getStock().toString());&#125;</code></pre><h3 id="3-4-实现秒杀下单"><a href="#3-4-实现秒杀下单" class="headerlink" title="3.4 实现秒杀下单"></a>3.4 实现秒杀下单</h3><p>下单核心思路：当我们点击抢购时，会触发右侧的请求，我们只需要编写对应的controller即可</p><p>!</p><p>秒杀下单应该思考的内容：</p><p>下单时需要判断两点：</p><ul><li>秒杀是否开始或结束，如果尚未开始或已经结束则无法下单</li><li>库存是否充足，不足则无法下单</li></ul><p>下单核心逻辑分析：</p><p>当用户开始进行下单，我们应当去查询优惠卷信息，查询到优惠卷信息，判断是否满足秒杀条件</p><p>比如时间是否充足，如果时间充足，则进一步判断库存是否足够，如果两者都满足，则扣减库存，创建订单，然后返回订单id，如果有一个条件不满足则直接结束。</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653366238564.png" alt="1653366238564"></p><p>VoucherOrderServiceImpl</p><pre><code class="java">@Overridepublic Result seckillVoucher(Long voucherId) &#123;    // 1.查询优惠券    SeckillVoucher voucher = seckillVoucherService.getById(voucherId);    // 2.判断秒杀是否开始    if (voucher.getBeginTime().isAfter(LocalDateTime.now())) &#123;        // 尚未开始        return Result.fail(&quot;秒杀尚未开始！&quot;);    &#125;    // 3.判断秒杀是否已经结束    if (voucher.getEndTime().isBefore(LocalDateTime.now())) &#123;        // 尚未开始        return Result.fail(&quot;秒杀已经结束！&quot;);    &#125;    // 4.判断库存是否充足    if (voucher.getStock() &lt; 1) &#123;        // 库存不足        return Result.fail(&quot;库存不足！&quot;);    &#125;    //5，扣减库存    boolean success = seckillVoucherService.update()            .setSql(&quot;stock= stock -1&quot;)            .eq(&quot;voucher_id&quot;, voucherId).update();    if (!success) &#123;        //扣减库存        return Result.fail(&quot;库存不足！&quot;);    &#125;    //6.创建订单    VoucherOrder voucherOrder = new VoucherOrder();    // 6.1.订单id    long orderId = redisIdWorker.nextId(&quot;order&quot;);    voucherOrder.setId(orderId);    // 6.2.用户id    Long userId = UserHolder.getUser().getId();    voucherOrder.setUserId(userId);    // 6.3.代金券id    voucherOrder.setVoucherId(voucherId);    save(voucherOrder);    return Result.ok(orderId);&#125;</code></pre><h3 id="3-5-库存超卖问题分析"><a href="#3-5-库存超卖问题分析" class="headerlink" title="3.5 库存超卖问题分析"></a>3.5 库存超卖问题分析</h3><p>有关超卖问题分析：在我们原有代码中是这么写的</p><pre><code class="java"> if (voucher.getStock() &lt; 1) &#123;        // 库存不足        return Result.fail(&quot;库存不足！&quot;);    &#125;    //5，扣减库存    boolean success = seckillVoucherService.update()            .setSql(&quot;stock= stock -1&quot;)            .eq(&quot;voucher_id&quot;, voucherId).update();    if (!success) &#123;        //扣减库存        return Result.fail(&quot;库存不足！&quot;);    &#125;</code></pre><p>假设线程1过来查询库存，判断出来库存大于1，正准备去扣减库存，但是还没有来得及去扣减，此时线程2过来，线程2也去查询库存，发现这个数量一定也大于1，那么这两个线程都会去扣减库存，最终多个线程相当于一起去扣减库存，此时就会出现库存的超卖问题。</p><p>超卖问题是典型的多线程安全问题，针对这一问题的常见解决方案就是加锁：而对于加锁，我们通常有两种解决方案：</p><p><strong>悲观锁：</strong></p><p> 悲观锁可以实现对于数据的串行化执行，比如syn，和lock都是悲观锁的代表，同时，悲观锁中又可以再细分为公平锁，非公平锁，可重入锁，等等</p><p><strong>乐观锁：</strong></p><p>  乐观锁：会有一个版本号，每次操作数据会对版本号+1，再提交回数据时，会去校验是否比之前的版本大1 ，如果大1 ，则进行操作成功，这套机制的核心逻辑在于，如果在操作过程中，版本号只比原来大1 ，那么就意味着操作过程中没有人对他进行过修改，他的操作就是安全的，如果不大1，则数据被修改过，当然乐观锁还有一些变种的处理方式比如cas</p><p>  乐观锁的典型代表：就是cas，利用cas进行无锁化机制加锁，var5 是操作前读取的内存值，while中的var1+var2 是预估值，如果预估值 &#x3D;&#x3D; 内存值，则代表中间没有被人修改过，此时就将新值去替换 内存值</p><p>  其中do while 是为了在操作失败时，再次进行自旋操作，即把之前的逻辑再操作一次。</p><pre><code class="java">int var5;do &#123;    var5 = this.getIntVolatile(var1, var2);&#125; while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));return var5;</code></pre><p><strong>课程中的使用方式：</strong></p><p>课程中的使用方式是没有像cas一样带自旋的操作，也没有对version的版本号+1 ，他的操作逻辑是在操作时，对版本号进行+1 操作，然后要求version 如果是1 的情况下，才能操作，那么第一个线程在操作后，数据库中的version变成了2，但是他自己满足version&#x3D;1 ，所以没有问题，此时线程2执行，线程2 最后也需要加上条件version &#x3D;1 ，但是现在由于线程1已经操作过了，所以线程2，操作时就不满足version&#x3D;1 的条件了，所以线程2无法执行成功</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653369268550.png" alt="1653369268550"></p><h3 id="3-6-乐观锁解决超卖问题"><a href="#3-6-乐观锁解决超卖问题" class="headerlink" title="3.6 乐观锁解决超卖问题"></a>3.6 乐观锁解决超卖问题</h3><p><strong>修改代码方案一、</strong></p><p>VoucherOrderServiceImpl 在扣减库存时，改为：</p><pre><code class="java">boolean success = seckillVoucherService.update()            .setSql(&quot;stock= stock -1&quot;) //set stock = stock -1            .eq(&quot;voucher_id&quot;, voucherId).eq(&quot;stock&quot;,voucher.getStock()).update(); //where id = ？ and stock = ?</code></pre><p>以上逻辑的核心含义是：只要我扣减库存时的库存和之前我查询到的库存是一样的，就意味着没有人在中间修改过库存，那么此时就是安全的，但是以上这种方式通过测试发现会有很多失败的情况，失败的原因在于：在使用乐观锁过程中假设100个线程同时都拿到了100的库存，然后大家一起去进行扣减，但是100个人中只有1个人能扣减成功，其他的人在处理时，他们在扣减时，库存已经被修改过了，所以此时其他线程都会失败</p><p><strong>修改代码方案二、</strong></p><p>之前的方式要修改前后都保持一致，但是这样我们分析过，成功的概率太低，所以我们的乐观锁需要变一下，改成stock大于0 即可</p><pre><code class="java">boolean success = seckillVoucherService.update()            .setSql(&quot;stock= stock -1&quot;)            .eq(&quot;voucher_id&quot;, voucherId).update().gt(&quot;stock&quot;,0); //where id = ? and stock &gt; 0</code></pre><p><strong>知识小扩展：</strong></p><p>针对cas中的自旋压力过大，我们可以使用Longaddr这个类去解决</p><p>Java8 提供的一个对AtomicLong改进后的一个类，LongAdder</p><p>大量线程并发更新一个原子性的时候，天然的问题就是自旋，会导致并发性问题，当然这也比我们直接使用syn来的好</p><p>所以利用这么一个类，LongAdder来进行优化</p><p>如果获取某个值，则会对cell和base的值进行递增，最后返回一个完整的值</p><h3 id="3-6-优惠券秒杀-一人一单"><a href="#3-6-优惠券秒杀-一人一单" class="headerlink" title="3.6 优惠券秒杀-一人一单"></a>3.6 优惠券秒杀-一人一单</h3><p>需求：修改秒杀业务，要求同一个优惠券，一个用户只能下一单</p><p><strong>现在的问题在于：</strong></p><p>优惠卷是为了引流，但是目前的情况是，一个人可以无限制的抢这个优惠卷，所以我们应当增加一层逻辑，让一个用户只能下一个单，而不是让一个用户下多个单</p><p>具体操作逻辑如下：比如时间是否充足，如果时间充足，则进一步判断库存是否足够，然后再根据优惠卷id和用户id查询是否已经下过这个订单，如果下过这个订单，则不再下单，否则进行下单</p><p>VoucherOrderServiceImpl  </p><p><strong>初步代码：增加一人一单逻辑</strong></p><pre><code class="java">@Overridepublic Result seckillVoucher(Long voucherId) &#123;    // 1.查询优惠券    SeckillVoucher voucher = seckillVoucherService.getById(voucherId);    // 2.判断秒杀是否开始    if (voucher.getBeginTime().isAfter(LocalDateTime.now())) &#123;        // 尚未开始        return Result.fail(&quot;秒杀尚未开始！&quot;);    &#125;    // 3.判断秒杀是否已经结束    if (voucher.getEndTime().isBefore(LocalDateTime.now())) &#123;        // 尚未开始        return Result.fail(&quot;秒杀已经结束！&quot;);    &#125;    // 4.判断库存是否充足    if (voucher.getStock() &lt; 1) &#123;        // 库存不足        return Result.fail(&quot;库存不足！&quot;);    &#125;    // 5.一人一单逻辑    // 5.1.用户id    Long userId = UserHolder.getUser().getId();    int count = query().eq(&quot;user_id&quot;, userId).eq(&quot;voucher_id&quot;, voucherId).count();    // 5.2.判断是否存在    if (count &gt; 0) &#123;        // 用户已经购买过了        return Result.fail(&quot;用户已经购买过一次！&quot;);    &#125;    //6，扣减库存    boolean success = seckillVoucherService.update()            .setSql(&quot;stock= stock -1&quot;)            .eq(&quot;voucher_id&quot;, voucherId).update();    if (!success) &#123;        //扣减库存        return Result.fail(&quot;库存不足！&quot;);    &#125;    //7.创建订单    VoucherOrder voucherOrder = new VoucherOrder();    // 7.1.订单id    long orderId = redisIdWorker.nextId(&quot;order&quot;);    voucherOrder.setId(orderId);    voucherOrder.setUserId(userId);    // 7.3.代金券id    voucherOrder.setVoucherId(voucherId);    save(voucherOrder);    return Result.ok(orderId);&#125;</code></pre><p><strong>存在问题：</strong>现在的问题还是和之前一样，并发过来，查询数据库，都不存在订单，所以我们还是需要加锁，但是乐观锁比较适合更新数据，而现在是插入数据，所以我们需要使用悲观锁操作</p><p><strong>注意：</strong>在这里提到了非常多的问题，我们需要慢慢的来思考，首先我们的初始方案是封装了一个createVoucherOrder方法，同时为了确保他线程安全，在方法上添加了一把synchronized 锁</p><pre><code class="java">@Transactionalpublic synchronized Result createVoucherOrder(Long voucherId) &#123;    Long userId = UserHolder.getUser().getId();         // 5.1.查询订单        int count = query().eq(&quot;user_id&quot;, userId).eq(&quot;voucher_id&quot;, voucherId).count();        // 5.2.判断是否存在        if (count &gt; 0) &#123;            // 用户已经购买过了            return Result.fail(&quot;用户已经购买过一次！&quot;);        &#125;        // 6.扣减库存        boolean success = seckillVoucherService.update()                .setSql(&quot;stock = stock - 1&quot;) // set stock = stock - 1                .eq(&quot;voucher_id&quot;, voucherId).gt(&quot;stock&quot;, 0) // where id = ? and stock &gt; 0                .update();        if (!success) &#123;            // 扣减失败            return Result.fail(&quot;库存不足！&quot;);        &#125;        // 7.创建订单        VoucherOrder voucherOrder = new VoucherOrder();        // 7.1.订单id        long orderId = redisIdWorker.nextId(&quot;order&quot;);        voucherOrder.setId(orderId);        // 7.2.用户id        voucherOrder.setUserId(userId);        // 7.3.代金券id        voucherOrder.setVoucherId(voucherId);        save(voucherOrder);        // 7.返回订单id        return Result.ok(orderId);&#125;</code></pre><p>，但是这样添加锁，锁的粒度太粗了，在使用锁过程中，控制<strong>锁粒度</strong> 是一个非常重要的事情，因为如果锁的粒度太大，会导致每个线程进来都会锁住，所以我们需要去控制锁的粒度，以下这段代码需要修改为：<br>intern() 这个方法是从常量池中拿到数据，如果我们直接使用userId.toString() 他拿到的对象实际上是不同的对象，new出来的对象，我们使用锁必须保证锁必须是同一把，所以我们需要使用intern()方法</p><pre><code class="java">@Transactionalpublic  Result createVoucherOrder(Long voucherId) &#123;    Long userId = UserHolder.getUser().getId();    synchronized(userId.toString().intern())&#123;         // 5.1.查询订单        int count = query().eq(&quot;user_id&quot;, userId).eq(&quot;voucher_id&quot;, voucherId).count();        // 5.2.判断是否存在        if (count &gt; 0) &#123;            // 用户已经购买过了            return Result.fail(&quot;用户已经购买过一次！&quot;);        &#125;        // 6.扣减库存        boolean success = seckillVoucherService.update()                .setSql(&quot;stock = stock - 1&quot;) // set stock = stock - 1                .eq(&quot;voucher_id&quot;, voucherId).gt(&quot;stock&quot;, 0) // where id = ? and stock &gt; 0                .update();        if (!success) &#123;            // 扣减失败            return Result.fail(&quot;库存不足！&quot;);        &#125;        // 7.创建订单        VoucherOrder voucherOrder = new VoucherOrder();        // 7.1.订单id        long orderId = redisIdWorker.nextId(&quot;order&quot;);        voucherOrder.setId(orderId);        // 7.2.用户id        voucherOrder.setUserId(userId);        // 7.3.代金券id        voucherOrder.setVoucherId(voucherId);        save(voucherOrder);        // 7.返回订单id        return Result.ok(orderId);    &#125;&#125;</code></pre><p>但是以上代码还是存在问题，问题的原因在于当前方法被spring的事务控制，如果你在方法内部加锁，可能会导致当前方法事务还没有提交，但是锁已经释放也会导致问题，所以我们选择将当前方法整体包裹起来，确保事务不会出现问题：如下：</p><p>在seckillVoucher 方法中，添加以下逻辑，这样就能保证事务的特性，同时也控制了锁的粒度</p><pre><code class="java">//获取代理对象synchronized (userId.toString().intern()) &#123;    IVoucherOrderService proxy = (IVoucherOrderService) AopContext.currentProxy();    return proxy.createVoucherOrder(voucherId);&#125;</code></pre><p>但是以上做法依然有问题，因为你调用的方法，其实是this.的方式调用的，事务想要生效，还得利用代理来生效，所以这个地方，我们需要获得原始的事务对象， 来操作事务.</p><p>complete code:</p><pre><code class="java">  @Override    //乐观锁解决超卖    public  Result secKillVoucher(Long voucherId) &#123;        //1.查询优惠券信息        SeckillVoucher voucher = seckillVoucherService.getById(voucherId);        //获取优惠券余量        Integer stock = voucher.getStock();        //2.判断秒杀是否开始        if (voucher.getBeginTime().isAfter(LocalDateTime.now())) &#123;            //尚未开始            return Result.fail(&quot;秒杀尚未开始!&quot;);        &#125;        //3.判断秒杀是否结束        if(voucher.getEndTime().isBefore(LocalDateTime.now()))&#123;            //秒杀已经结束            return Result.fail(&quot;秒杀已经结束!&quot;);        &#125;        //在秒杀活动的时间        //4.判断库存是否充足        if (voucher.getStock()&lt;1) &#123;            return Result.fail(&quot;库存不足!&quot;);        &#125;        Long userId = UserHolder.getUser().getId();        //获取代理对象        synchronized (userId.toString().intern()) &#123;            IVoucherOrderService proxy = (IVoucherOrderService) AopContext.currentProxy();            return proxy.createVoucherOrder(voucherId);        &#125;    &#125;    @Transactional    public  Result createVoucherOrder(Long voucherId) &#123;        //5.一人一单        //查询订单        //根据用户id和优惠券id查询        Long userId = UserHolder.getUser().getId();            //判断是否存在            int count = query().eq(&quot;user_id&quot;, userId).eq(&quot;voucher_id&quot;, voucherId).count().intValue();            if (count &gt; 0) &#123;                //用户购买过了                return Result.fail(&quot;用户已经购买过了&quot;);            &#125;            //6.扣减库存            boolean success = seckillVoucherService.update().setSql(&quot;stock=stock-1&quot;).eq(&quot;voucher_id&quot;, voucherId).gt(&quot;stock&quot;, 0).update();            if (!success) &#123;                //扣减失败                return Result.fail(&quot;库存不足!&quot;);            &#125;            //7.创建订单            VoucherOrder voucherOrder = new VoucherOrder();            //7.1订单id            long orderId = redisIdWorker.nextId(&quot;order&quot;);            voucherOrder.setId(orderId);            //7.2用户id            Long UserId = UserHolder.getUser().getId();            voucherOrder.setUserId(UserId);            //7.3代金券id            voucherOrder.setVoucherId(voucherId);            //8.返回订单信息            save(voucherOrder);            return Result.ok(orderId);    &#125;</code></pre><h3 id="3-7-集群环境下的并发问题"><a href="#3-7-集群环境下的并发问题" class="headerlink" title="3.7 集群环境下的并发问题"></a>3.7 集群环境下的并发问题</h3><p>通过加锁可以解决在单机情况下的一人一单安全问题，但是在集群模式下就不行了。</p><p>1、我们将服务启动两份，端口分别为8081和8082：</p><p>2、然后修改nginx的conf目录下的nginx.conf文件，配置反向代理和负载均衡：</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images4/image-20221101104926613.png" alt="image-20221101104926613"></p><p><strong>具体操作(略)</strong></p><p><strong>有关锁失效原因分析</strong></p><p>由于现在我们部署了多个tomcat，每个tomcat都有一个属于自己的jvm，那么假设在服务器A的tomcat内部，有两个线程，这两个线程由于使用的是同一份代码，那么他们的锁对象是同一个，是可以实现互斥的，但是如果现在是服务器B的tomcat内部，又有两个线程，但是他们的锁对象写的虽然和服务器A一样，但是锁对象却不是同一个，所以线程3和线程4可以实现互斥，但是却无法和线程1和线程2实现互斥，这就是 集群环境下，syn锁失效的原因，在这种情况下，我们就需要使用分布式锁来解决这个问题。</p><h2 id="4、分布式锁"><a href="#4、分布式锁" class="headerlink" title="4、分布式锁"></a>4、分布式锁</h2><h3 id="4-1-、基本原理和实现方式对比"><a href="#4-1-、基本原理和实现方式对比" class="headerlink" title="4.1 、基本原理和实现方式对比"></a>4.1 、基本原理和实现方式对比</h3><p>分布式锁：满足分布式系统或集群模式下多进程可见并且互斥的锁。</p><p>分布式锁的核心思想就是让大家都使用同一把锁，只要大家使用的是同一把锁，那么我们就能锁住线程，不让线程进行，让程序串行执行，这就是分布式锁的核心思路</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images4/image-20221101105103430.png" alt="image-20221101105103430"></p><p>那么分布式锁他应该满足一些什么样的条件呢？</p><p>可见性：多个线程都能看到相同的结果，注意：这个地方说的可见性并不是并发编程中指的内存可见性，只是说多个进程之间都能感知到变化的意思</p><p>互斥：互斥是分布式锁的最基本的条件，使得程序串行执行</p><p>高可用：程序不易崩溃，时时刻刻都保证较高的可用性</p><p>高性能：由于加锁本身就让性能降低，所有对于分布式锁本身需要他就较高的加锁性能和释放锁性能</p><p>安全性：安全也是程序中必不可少的一环</p><p><img src="C:/Users/Dylan/AppData/Roaming/Typora/typora-user-images/image-20221101105114564.png" alt="image-20221101105114564"></p><p>常见的分布式锁有三种</p><p>Mysql：mysql本身就带有锁机制，但是由于mysql性能本身一般，所以采用分布式锁的情况下，其实使用mysql作为分布式锁比较少见</p><p>Redis：redis作为分布式锁是非常常见的一种使用方式，现在企业级开发中基本都使用redis或者zookeeper作为分布式锁，利用setnx这个方法，如果插入key成功，则表示获得到了锁，如果有人插入成功，其他人插入失败则表示无法获得到锁，利用这套逻辑来实现分布式锁</p><p>Zookeeper：zookeeper也是企业级开发中较好的一个实现分布式锁的方案，由于本套视频并不讲解zookeeper的原理和分布式锁的实现，所以不过多阐述</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images4/image-20221101105129072.png" alt="image-20221101105129072"></p><h3 id="4-2-、Redis分布式锁的实现核心思路"><a href="#4-2-、Redis分布式锁的实现核心思路" class="headerlink" title="4.2 、Redis分布式锁的实现核心思路"></a>4.2 、Redis分布式锁的实现核心思路</h3><p>实现分布式锁时需要实现的两个基本方法：</p><ul><li><p>获取锁：</p><ul><li>互斥：确保只能有一个线程获取锁</li><li>非阻塞：尝试一次，成功返回true，失败返回false</li></ul></li><li><p>释放锁：</p><ul><li>手动释放</li><li>超时释放：获取锁时添加一个超时时间</li></ul><p><img src="https://gitee.com/DylanToT99/images/raw/master/images4/image-20221101105204689.png" alt="image-20221101105204689"></p></li></ul><p>核心思路：</p><p>我们利用redis 的setNx 方法，当有多个线程进入时，我们就利用该方法，第一个线程进入时，redis 中就有这个key 了，返回了1，如果结果是1，则表示他抢到了锁，那么他去执行业务，然后再删除锁，退出锁逻辑，没有抢到锁的哥们，等待一定时间后重试即可</p><p> <img src="https://gitee.com/DylanToT99/images/raw/master/images4/image-20221101105216494.png" alt="image-20221101105216494"></p><h3 id="4-3-实现分布式锁版本一"><a href="#4-3-实现分布式锁版本一" class="headerlink" title="4.3 实现分布式锁版本一"></a>4.3 实现分布式锁版本一</h3><ul><li>加锁逻辑</li></ul><p><strong>锁的基本接口</strong></p><pre><code class="java">public interface ILock &#123;    public boolean tryLock(long timeOut);    public void unLock();&#125;</code></pre><p><strong>SimpleRedisLock</strong></p><p>利用setnx方法进行加锁，同时增加过期时间，防止死锁，此方法可以保证加锁和增加过期时间具有原子性</p><pre><code class="java">private static final String KEY_PREFIX=&quot;lock:&quot;@Overridepublic boolean tryLock(long timeoutSec) &#123;    // 获取线程标示    String threadId = Thread.currentThread().getId()    // 获取锁    Boolean success = stringRedisTemplate.opsForValue()            .setIfAbsent(KEY_PREFIX + name, threadId + &quot;&quot;, timeoutSec, TimeUnit.SECONDS);    return Boolean.TRUE.equals(success);&#125;</code></pre><ul><li>释放锁逻辑</li></ul><p>SimpleRedisLock</p><p>释放锁，防止删除别人的锁</p><pre><code class="java">public void unlock() &#123;    //通过del删除锁    stringRedisTemplate.delete(KEY_PREFIX + name);&#125;</code></pre><ul><li>修改业务代码</li></ul><pre><code class="java">  @Override    public Result seckillVoucher(Long voucherId) &#123;        // 1.查询优惠券        SeckillVoucher voucher = seckillVoucherService.getById(voucherId);        // 2.判断秒杀是否开始        if (voucher.getBeginTime().isAfter(LocalDateTime.now())) &#123;            // 尚未开始            return Result.fail(&quot;秒杀尚未开始！&quot;);        &#125;        // 3.判断秒杀是否已经结束        if (voucher.getEndTime().isBefore(LocalDateTime.now())) &#123;            // 尚未开始            return Result.fail(&quot;秒杀已经结束！&quot;);        &#125;        // 4.判断库存是否充足        if (voucher.getStock() &lt; 1) &#123;            // 库存不足            return Result.fail(&quot;库存不足！&quot;);        &#125;        Long userId = UserHolder.getUser().getId();        //创建锁对象(新增代码)        SimpleRedisLock lock = new SimpleRedisLock(&quot;order:&quot; + userId, stringRedisTemplate);        //获取锁对象        boolean isLock = lock.tryLock(1200);        //加锁失败        if (!isLock) &#123;            return Result.fail(&quot;不允许重复下单&quot;);        &#125;        try &#123;            //获取代理对象(事务)            IVoucherOrderService proxy = (IVoucherOrderService) AopContext.currentProxy();            return proxy.createVoucherOrder(voucherId);        &#125; finally &#123;            //释放锁            lock.unlock();        &#125;    &#125;</code></pre><h3 id="4-4-Redis分布式锁误删情况说明"><a href="#4-4-Redis分布式锁误删情况说明" class="headerlink" title="4.4 Redis分布式锁误删情况说明"></a>4.4 Redis分布式锁误删情况说明</h3><p>逻辑说明：</p><p>持有锁的线程在锁的内部出现了阻塞，导致他的锁自动释放，这时其他线程，线程2来尝试获得锁，就拿到了这把锁，然后线程2在持有锁执行过程中，线程1反应过来，继续执行，而线程1执行过程中，走到了删除锁逻辑，此时就会把本应该属于线程2的锁进行删除，这就是误删别人锁的情况说明</p><p>解决方案：解决方案就是在每个线程释放锁的时候，去判断一下当前这把锁是否属于自己，如果属于自己，则不进行锁的删除，假设还是上边的情况，线程1卡顿，锁自动释放，线程2进入到锁的内部执行逻辑，此时线程1反应过来，然后删除锁，但是线程1，一看当前这把锁不是属于自己，于是不进行删除锁逻辑，当线程2走到删除锁逻辑时，如果没有卡过自动释放锁的时间点，则判断当前这把锁是属于自己的，于是删除这把锁。</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images4/image-20221101110808283.png" alt="image-20221101110808283"></p><h3 id="4-5-解决Redis分布式锁误删问题"><a href="#4-5-解决Redis分布式锁误删问题" class="headerlink" title="4.5 解决Redis分布式锁误删问题"></a>4.5 解决Redis分布式锁误删问题</h3><p>需求：修改之前的分布式锁实现，满足：在获取锁时存入线程标示（可以用UUID表示）<br>在释放锁时先获取锁中的线程标示，判断是否与当前线程标示一致</p><ul><li>如果一致则释放锁</li><li>如果不一致则不释放锁</li></ul><p>核心逻辑：在存入锁时，放入自己线程的标识，在删除锁时，判断当前这把锁的标识是不是自己存入的，如果是，则进行删除，如果不是，则不进行删除。</p><p>具体代码如下：加锁</p><pre><code class="java">private static final String ID_PREFIX = UUID.randomUUID().toString(true) + &quot;-&quot;;@Overridepublic boolean tryLock(long timeoutSec) &#123;   // 获取线程标示   String threadId = ID_PREFIX + Thread.currentThread().getId();   // 获取锁   Boolean success = stringRedisTemplate.opsForValue()                .setIfAbsent(KEY_PREFIX + name, threadId, timeoutSec, TimeUnit.SECONDS);   return Boolean.TRUE.equals(success);&#125;</code></pre><p>释放锁</p><pre><code class="java">public void unlock() &#123;    // 获取线程标示    String threadId = ID_PREFIX + Thread.currentThread().getId();    // 获取锁中的标示    String id = stringRedisTemplate.opsForValue().get(KEY_PREFIX + name);    // 判断标示是否一致    if(threadId.equals(id)) &#123;        // 释放锁        stringRedisTemplate.delete(KEY_PREFIX + name);    &#125;&#125;</code></pre><p><strong>有关代码实操说明：</strong></p><p>在我们修改完此处代码后，我们重启工程，然后启动两个线程，第一个线程持有锁后，手动释放锁，第二个线程 此时进入到锁内部，再放行第一个线程，此时第一个线程由于锁的value值并非是自己，所以不能释放锁，也就无法删除别人的锁，此时第二个线程能够正确释放锁，通过这个案例初步说明我们解决了锁误删的问题。</p><h3 id="4-6-分布式锁的原子性问题"><a href="#4-6-分布式锁的原子性问题" class="headerlink" title="4.6 分布式锁的原子性问题"></a>4.6 分布式锁的原子性问题</h3><p>更为极端的误删逻辑说明：</p><p>线程1现在持有锁之后，在执行业务逻辑过程中，他正准备删除锁，而且已经走到了条件判断的过程中，比如他已经拿到了当前这把锁确实是属于他自己的，正准备删除锁，但是此时他的锁到期了，那么此时线程2进来，但是线程1他会接着往后执行，当他卡顿结束后，他直接就会执行删除锁那行代码，相当于条件判断并没有起到作用，这就是删锁时的原子性问题，之所以有这个问题，是因为线程1的拿锁，比锁，删锁，实际上并不是原子性的，我们要防止刚才的情况发生，</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images4/image-20221101191913944.png" alt="image-20221101191913944"></p><h3 id="4-7-Lua脚本解决多条命令原子性问题"><a href="#4-7-Lua脚本解决多条命令原子性问题" class="headerlink" title="4.7 Lua脚本解决多条命令原子性问题"></a>4.7 Lua脚本解决多条命令原子性问题</h3><p>Redis提供了Lua脚本功能，在一个脚本中编写多条Redis命令，确保多条命令执行时的原子性。Lua是一种编程语言，它的基本语法大家可以参考网站：<a href="https://www.runoob.com/lua/lua-tutorial.html%EF%BC%8C%E8%BF%99%E9%87%8C%E9%87%8D%E7%82%B9%E4%BB%8B%E7%BB%8DRedis%E6%8F%90%E4%BE%9B%E7%9A%84%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0%EF%BC%8C%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8lua%E5%8E%BB%E6%93%8D%E4%BD%9Credis%EF%BC%8C%E5%8F%88%E8%83%BD%E4%BF%9D%E8%AF%81%E4%BB%96%E7%9A%84%E5%8E%9F%E5%AD%90%E6%80%A7%EF%BC%8C%E8%BF%99%E6%A0%B7%E5%B0%B1%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%E6%8B%BF%E9%94%81%E6%AF%94%E9%94%81%E5%88%A0%E9%94%81%E6%98%AF%E4%B8%80%E4%B8%AA%E5%8E%9F%E5%AD%90%E6%80%A7%E5%8A%A8%E4%BD%9C%E4%BA%86%EF%BC%8C%E4%BD%9C%E4%B8%BAJava%E7%A8%8B%E5%BA%8F%E5%91%98%E8%BF%99%E4%B8%80%E5%9D%97%E5%B9%B6%E4%B8%8D%E4%BD%9C%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E8%A6%81%E6%B1%82%EF%BC%8C%E5%B9%B6%E4%B8%8D%E9%9C%80%E8%A6%81%E5%A4%A7%E5%AE%B6%E8%BF%87%E4%BA%8E%E7%B2%BE%E9%80%9A%EF%BC%8C%E5%8F%AA%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E4%BB%96%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%E5%8D%B3%E5%8F%AF%E3%80%82">https://www.runoob.com/lua/lua-tutorial.html，这里重点介绍Redis提供的调用函数，我们可以使用lua去操作redis，又能保证他的原子性，这样就可以实现拿锁比锁删锁是一个原子性动作了，作为Java程序员这一块并不作一个简单要求，并不需要大家过于精通，只需要知道他有什么作用即可。</a></p><p>这里重点介绍Redis提供的调用函数，语法如下：</p><pre><code class="lua">redis.call(&#39;命令名称&#39;, &#39;key&#39;, &#39;其它参数&#39;, ...)</code></pre><p>例如，我们要执行set name jack，则脚本是这样：</p><pre><code class="lua"># 执行 set name jackredis.call(&#39;set&#39;, &#39;name&#39;, &#39;jack&#39;)</code></pre><p>例如，我们要先执行set name Rose，再执行get name，则脚本如下：</p><pre><code class="lua"># 先执行 set name jackredis.call(&#39;set&#39;, &#39;name&#39;, &#39;Rose&#39;)# 再执行 get namelocal name = redis.call(&#39;get&#39;, &#39;name&#39;)# 返回return name</code></pre><p>写好脚本以后，需要用Redis命令来调用脚本，调用脚本的常见命令如下：</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images4/image-20221101192046364.png" alt="image-20221101192046364"></p><p>例如，我们要执行 redis.call(‘set’, ‘name’, ‘jack’) 这个脚本，语法如下：</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images4/image-20221101192104397.png" alt="image-20221101192104397"></p><p>如果脚本中的key、value不想写死，可以作为参数传递。key类型参数会放入KEYS数组，其它参数会放入ARGV数组，在脚本中可以从KEYS和ARGV数组获取这些参数：</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images4/image-20221101192122861.png" alt="image-20221101192122861"></p><p>接下来我们来回一下我们释放锁的逻辑：</p><p>释放锁的业务流程是这样的</p><p>​1、获取锁中的线程标示</p><p>​2、判断是否与指定的标示（当前线程标示）一致</p><p>​3、如果一致则释放锁（删除）</p><p>​4、如果不一致则什么都不做</p><p>如果用Lua脚本来表示则是这样的：</p><p>最终我们操作redis的拿锁比锁删锁的lua脚本就会变成这样</p><pre><code class="lua">-- 这里的 KEYS[1] 就是锁的key，这里的ARGV[1] 就是当前线程标示-- 获取锁中的标示，判断是否与当前线程标示一致if (redis.call(&#39;GET&#39;, KEYS[1]) == ARGV[1]) then  -- 一致，则删除锁  return redis.call(&#39;DEL&#39;, KEYS[1])end-- 不一致，则直接返回return 0</code></pre><h3 id="4-8-利用Java代码调用Lua脚本改造分布式锁"><a href="#4-8-利用Java代码调用Lua脚本改造分布式锁" class="headerlink" title="4.8 利用Java代码调用Lua脚本改造分布式锁"></a>4.8 利用Java代码调用Lua脚本改造分布式锁</h3><p>lua脚本本身并不需要大家花费太多时间去研究，只需要知道如何调用，大致是什么意思即可，所以在笔记中并不会详细的去解释这些lua表达式的含义。</p><p>我们的RedisTemplate中，可以利用execute方法去执行lua脚本，参数对应关系就如下图股</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images4/image-20221101192236158.png" alt="image-20221101192236158"></p><p><strong>Java代码</strong></p><pre><code class="java">private static final DefaultRedisScript&lt;Long&gt; UNLOCK_SCRIPT;    static &#123;        UNLOCK_SCRIPT = new DefaultRedisScript&lt;&gt;();        UNLOCK_SCRIPT.setLocation(new ClassPathResource(&quot;unlock.lua&quot;));        UNLOCK_SCRIPT.setResultType(Long.class);    &#125;public void unlock() &#123;    // 调用lua脚本    stringRedisTemplate.execute(            UNLOCK_SCRIPT,            Collections.singletonList(KEY_PREFIX + name),            ID_PREFIX + Thread.currentThread().getId());&#125;经过以上代码改造后，我们就能够实现 拿锁比锁删锁的原子性动作了~</code></pre><p>小总结：</p><p>基于Redis的分布式锁实现思路：</p><ul><li>利用set nx ex获取锁，并设置过期时间，保存线程标示</li><li>释放锁时先判断线程标示是否与自己一致，一致则删除锁<ul><li>特性：<ul><li>利用set nx满足互斥性</li><li>利用set ex保证故障时锁依然能释放，避免死锁，提高安全性</li><li>利用Redis集群保证高可用和高并发特性</li></ul></li></ul></li></ul><p>笔者总结：我们一路走来，利用添加过期时间，防止死锁问题的发生，但是有了过期时间之后，可能出现误删别人锁的问题，这个问题我们开始是利用删之前 通过拿锁，比锁，删锁这个逻辑来解决的，也就是删之前判断一下当前这把锁是否是属于自己的，但是现在还有原子性问题，也就是我们没法保证拿锁比锁删锁是一个原子性的动作，最后通过lua表达式来解决这个问题</p><p>但是目前还剩下一个问题锁不住，什么是锁不住呢，你想一想，如果当过期时间到了之后，我们可以给他续期一下，比如续个30s，就好像是网吧上网， 网费到了之后，然后说，来，网管，再给我来10块的，是不是后边的问题都不会发生了，那么续期问题怎么解决呢，可以依赖于我们接下来要学习redission啦</p><p><strong>测试逻辑：</strong></p><p>第一个线程进来，得到了锁，手动删除锁，模拟锁超时了，其他线程会执行lua来抢锁，当第一天线程利用lua删除锁时，lua能保证他不能删除他的锁，第二个线程删除锁时，利用lua同样可以保证不会删除别人的锁，同时还能保证原子性。</p><h2 id="5、分布式锁-redission"><a href="#5、分布式锁-redission" class="headerlink" title="5、分布式锁-redission"></a>5、分布式锁-redission</h2><h3 id="5-1-分布式锁-redission功能介绍"><a href="#5-1-分布式锁-redission功能介绍" class="headerlink" title="5.1 分布式锁-redission功能介绍"></a>5.1 分布式锁-redission功能介绍</h3><p>基于setnx实现的分布式锁存在下面的问题：</p><p><strong>重入问题</strong>：重入问题是指 获得锁的线程可以再次进入到相同的锁的代码块中，可重入锁的意义在于防止死锁，比如HashTable这样的代码中，他的方法都是使用synchronized修饰的，假如他在一个方法内，调用另一个方法，那么此时如果是不可重入的，不就死锁了吗？所以可重入锁他的主要意义是防止死锁，我们的synchronized和Lock锁都是可重入的。</p><p><strong>不可重试</strong>：是指目前的分布式只能尝试一次，我们认为合理的情况是：当线程在获得锁失败后，他应该能再次尝试获得锁。</p><p><strong>超时释放：</strong>我们在加锁时增加了过期时间，这样的我们可以防止死锁，但是如果卡顿的时间超长，虽然我们采用了lua表达式防止删锁的时候，误删别人的锁，但是毕竟没有锁住，有安全隐患</p><p><strong>主从一致性：</strong> 如果Redis提供了主从集群，当我们向集群写数据时，主机需要异步的将数据同步给从机，而万一在同步过去之前，主机宕机了，就会出现死锁问题。</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images4/image-20221101210351034.png" alt="image-20221101210351034"></p><p>那么什么是Redission呢</p><p>Redisson是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式的Java常用对象，还提供了许多分布式服务，其中就包含了各种分布式锁的实现。</p><p>Redission提供了分布式锁的多种多样的功能</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images4/image-20221101210423509.png" alt="image-20221101210423509"></p><h3 id="5-2-分布式锁-Redission快速入门"><a href="#5-2-分布式锁-Redission快速入门" class="headerlink" title="5.2 分布式锁-Redission快速入门"></a>5.2 分布式锁-Redission快速入门</h3><p>引入依赖：</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.redisson&lt;/groupId&gt;    &lt;artifactId&gt;redisson&lt;/artifactId&gt;    &lt;version&gt;3.13.6&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>配置Redisson客户端：</p><pre><code class="java">@Configurationpublic class RedissonConfig &#123;    @Bean    public RedissonClient redissonClient()&#123;        // 配置        Config config = new Config();        config.useSingleServer().setAddress(&quot;redis://192.168.150.101:6379&quot;)            .setPassword(&quot;123321&quot;);        // 创建RedissonClient对象        return Redisson.create(config);    &#125;&#125;</code></pre><p>如何使用Redission的分布式锁</p><pre><code class="java">@Resourceprivate RedissionClient redissonClient;@Testvoid testRedisson() throws Exception&#123;    //获取锁(可重入)，指定锁的名称    RLock lock = redissonClient.getLock(&quot;anyLock&quot;);    //尝试获取锁，参数分别是：获取锁的最大等待时间(期间会重试)，锁自动释放时间，时间单位    boolean isLock = lock.tryLock(1,10,TimeUnit.SECONDS);    //判断获取锁成功    if(isLock)&#123;        try&#123;            System.out.println(&quot;执行业务&quot;);                  &#125;finally&#123;            //释放锁            lock.unlock();        &#125;            &#125;    &#125;</code></pre><p>在 VoucherOrderServiceImpl</p><p>注入RedissonClient</p><pre><code class="java">@Resourceprivate RedissonClient redissonClient;@Overridepublic Result seckillVoucher(Long voucherId) &#123;        // 1.查询优惠券        SeckillVoucher voucher = seckillVoucherService.getById(voucherId);        // 2.判断秒杀是否开始        if (voucher.getBeginTime().isAfter(LocalDateTime.now())) &#123;            // 尚未开始            return Result.fail(&quot;秒杀尚未开始！&quot;);        &#125;        // 3.判断秒杀是否已经结束        if (voucher.getEndTime().isBefore(LocalDateTime.now())) &#123;            // 尚未开始            return Result.fail(&quot;秒杀已经结束！&quot;);        &#125;        // 4.判断库存是否充足        if (voucher.getStock() &lt; 1) &#123;            // 库存不足            return Result.fail(&quot;库存不足！&quot;);        &#125;        Long userId = UserHolder.getUser().getId();        //创建锁对象 这个代码不用了，因为我们现在要使用分布式锁        //SimpleRedisLock lock = new SimpleRedisLock(&quot;order:&quot; + userId, stringRedisTemplate);        RLock lock = redissonClient.getLock(&quot;lock:order:&quot; + userId);        //获取锁对象        boolean isLock = lock.tryLock();               //加锁失败        if (!isLock) &#123;            return Result.fail(&quot;不允许重复下单&quot;);        &#125;        try &#123;            //获取代理对象(事务)            IVoucherOrderService proxy = (IVoucherOrderService) AopContext.currentProxy();            return proxy.createVoucherOrder(voucherId);        &#125; finally &#123;            //释放锁            lock.unlock();        &#125; &#125;</code></pre><h3 id="5-3-分布式锁-redission可重入锁原理"><a href="#5-3-分布式锁-redission可重入锁原理" class="headerlink" title="5.3 分布式锁-redission可重入锁原理"></a>5.3 分布式锁-redission可重入锁原理</h3><p>在Lock锁中，他是借助于底层的一个voaltile的一个state变量来记录重入的状态的，比如当前没有人持有这把锁，那么state&#x3D;0，假如有人持有这把锁，那么state&#x3D;1，如果持有这把锁的人再次持有这把锁，那么state就会+1 ，如果是对于synchronized而言，他在c语言代码中会有一个count，原理和state类似，也是重入一次就加一，释放一次就-1 ，直到减少成0 时，表示当前这把锁没有被人持有。  </p><p>在redission中，我们的也支持支持可重入锁</p><p>在分布式锁中，他采用hash结构用来存储锁，其中大key表示表示这把锁是否存在，用小key表示当前这把锁被哪个线程持有，所以接下来我们一起分析一下当前的这个lua表达式</p><p>这个地方一共有3个参数</p><p><strong>KEYS[1] ： 锁名称</strong></p><p><strong>ARGV[1]：  锁失效时间</strong></p><p><strong>ARGV[2]：  id + “:” + threadId; 锁的小key</strong></p><p>exists: 判断数据是否存在  name：是lock是否存在,如果&#x3D;&#x3D;0，就表示当前这把锁不存在</p><p>redis.call(‘hset’, KEYS[1], ARGV[2], 1);此时他就开始往redis里边去写数据 ，写成一个hash结构</p><p>Lock{</p><p>​    id + <strong>“:”</strong> + threadId :  1</p><p>}</p><p>如果当前这把锁存在，则第一个条件不满足，再判断</p><p>redis.call(‘hexists’, KEYS[1], ARGV[2]) &#x3D;&#x3D; 1</p><p>此时需要通过大key+小key判断当前这把锁是否是属于自己的，如果是自己的，则进行</p><p>redis.call(‘hincrby’, KEYS[1], ARGV[2], 1)</p><p>将当前这个锁的value进行+1 ，redis.call(‘pexpire’, KEYS[1], ARGV[1]); 然后再对其设置过期时间，如果以上两个条件都不满足，则表示当前这把锁抢锁失败，最后返回pttl，即为当前这把锁的失效时间</p><p>如果小伙帮们看了前边的源码， 你会发现他会去判断当前这个方法的返回值是否为null，如果是null，则对应则前两个if对应的条件，退出抢锁逻辑，如果返回的不是null，即走了第三个分支，在源码处会进行while(true)的自旋抢锁。</p><pre><code class="lua">&quot;if (redis.call(&#39;exists&#39;, KEYS[1]) == 0) then &quot; +                  &quot;redis.call(&#39;hset&#39;, KEYS[1], ARGV[2], 1); &quot; +                  &quot;redis.call(&#39;pexpire&#39;, KEYS[1], ARGV[1]); &quot; +                  &quot;return nil; &quot; +              &quot;end; &quot; +              &quot;if (redis.call(&#39;hexists&#39;, KEYS[1], ARGV[2]) == 1) then &quot; +                  &quot;redis.call(&#39;hincrby&#39;, KEYS[1], ARGV[2], 1); &quot; +                  &quot;redis.call(&#39;pexpire&#39;, KEYS[1], ARGV[1]); &quot; +                  &quot;return nil; &quot; +              &quot;end; &quot; +              &quot;return redis.call(&#39;pttl&#39;, KEYS[1]);&quot;</code></pre><p><img src="https://gitee.com/DylanToT99/images/raw/master/images4/image-20221101210734067.png" alt="image-20221101210734067"></p><p><img src="C:\Users\Dylan\AppData\Roaming\Typora\typora-user-images\image-20221101210757298.png" alt="image-20221101210757298"></p><p>流程图:</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images4/image-20221101210809535.png" alt="image-20221101210809535"></p><h3 id="5-4-分布式锁-redission锁重试和WatchDog机制"><a href="#5-4-分布式锁-redission锁重试和WatchDog机制" class="headerlink" title="5.4 分布式锁-redission锁重试和WatchDog机制"></a>5.4 分布式锁-redission锁重试和WatchDog机制</h3><p><strong>说明</strong>：由于课程中已经说明了有关tryLock的源码解析以及其看门狗原理，所以笔者在这里给大家分析lock()方法的源码解析，希望大家在学习过程中，能够掌握更多的知识</p><p>抢锁过程中，获得当前线程，通过tryAcquire进行抢锁，该抢锁逻辑和之前逻辑相同</p><p>1、先判断当前这把锁是否存在，如果不存在，插入一把锁，返回null</p><p>2、判断当前这把锁是否是属于当前线程，如果是，则返回null</p><p>所以如果返回是null，则代表着当前这哥们已经抢锁完毕，或者可重入完毕，但是如果以上两个条件都不满足，则进入到第三个条件，返回的是锁的失效时间，同学们可以自行往下翻一点点，你能发现有个while( true) 再次进行tryAcquire进行抢锁</p><pre><code class="java">long threadId = Thread.currentThread().getId();Long ttl = tryAcquire(-1, leaseTime, unit, threadId);// lock acquiredif (ttl == null) &#123;    return;&#125;</code></pre><p>接下来会有一个条件分支，因为lock方法有重载方法，一个是带参数，一个是不带参数，如果带带参数传入的值是-1，如果传入参数，则leaseTime是他本身，所以如果传入了参数，此时leaseTime !&#x3D; -1 则会进去抢锁，抢锁的逻辑就是之前说的那三个逻辑</p><pre><code class="java">if (leaseTime != -1) &#123;    return tryLockInnerAsync(waitTime, leaseTime, unit, threadId, RedisCommands.EVAL_LONG);&#125;</code></pre><p>如果是没有传入时间，则此时也会进行抢锁， 而且抢锁时间是默认看门狗时间 commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout()</p><p>ttlRemainingFuture.onComplete((ttlRemaining, e) 这句话相当于对以上抢锁进行了监听，也就是说当上边抢锁完毕后，此方法会被调用，具体调用的逻辑就是去后台开启一个线程，进行续约逻辑，也就是看门狗线程</p><pre><code class="java">RFuture&lt;Long&gt; ttlRemainingFuture = tryLockInnerAsync(waitTime,                                        commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout(),                                        TimeUnit.MILLISECONDS, threadId, RedisCommands.EVAL_LONG);ttlRemainingFuture.onComplete((ttlRemaining, e) -&gt; &#123;    if (e != null) &#123;        return;    &#125;    // lock acquired    if (ttlRemaining == null) &#123;        scheduleExpirationRenewal(threadId);    &#125;&#125;);return ttlRemainingFuture;</code></pre><p>此逻辑就是续约逻辑，注意看commandExecutor.getConnectionManager().newTimeout（） 此方法</p><p>Method(  <strong>new</strong> TimerTask() {},参数2 ，参数3  )</p><p>指的是：通过参数2，参数3 去描述什么时候去做参数1的事情，现在的情况是：10s之后去做参数一的事情</p><p>因为锁的失效时间是30s，当10s之后，此时这个timeTask 就触发了，他就去进行续约，把当前这把锁续约成30s，如果操作成功，那么此时就会递归调用自己，再重新设置一个timeTask()，于是再过10s后又再设置一个timerTask，完成不停的续约</p><p>那么大家可以想一想，假设我们的线程出现了宕机他还会续约吗？当然不会，因为没有人再去调用renewExpiration这个方法，所以等到时间之后自然就释放了。</p><pre><code class="java">private void renewExpiration() &#123;    ExpirationEntry ee = EXPIRATION_RENEWAL_MAP.get(getEntryName());    if (ee == null) &#123;        return;    &#125;        Timeout task = commandExecutor.getConnectionManager().newTimeout(new TimerTask() &#123;        @Override        public void run(Timeout timeout) throws Exception &#123;            ExpirationEntry ent = EXPIRATION_RENEWAL_MAP.get(getEntryName());            if (ent == null) &#123;                return;            &#125;            Long threadId = ent.getFirstThreadId();            if (threadId == null) &#123;                return;            &#125;                        RFuture&lt;Boolean&gt; future = renewExpirationAsync(threadId);            future.onComplete((res, e) -&gt; &#123;                if (e != null) &#123;                    log.error(&quot;Can&#39;t update lock &quot; + getName() + &quot; expiration&quot;, e);                    return;                &#125;                                if (res) &#123;                    // reschedule itself                    renewExpiration();                &#125;            &#125;);        &#125;    &#125;, internalLockLeaseTime / 3, TimeUnit.MILLISECONDS);        ee.setTimeout(task);&#125;</code></pre><p><img src="https://gitee.com/DylanToT99/images/raw/master/images4/image-20221101214722169.png" alt="image-20221101214722169"></p><h3 id="5-5-分布式锁-redission锁的MutiLock原理"><a href="#5-5-分布式锁-redission锁的MutiLock原理" class="headerlink" title="5.5 分布式锁-redission锁的MutiLock原理"></a>5.5 分布式锁-redission锁的MutiLock原理</h3><p>为了提高redis的可用性，我们会搭建集群或者主从，现在以主从为例(注意修改配置文件和开放linux防火墙的对应端口)</p><p>此时我们去写命令，写在主机上， 主机会将数据同步给从机，但是假设在主机还没有来得及把数据写入到从机去的时候，此时主机宕机，哨兵会发现主机宕机，并且选举一个slave变成master，而此时新的master中实际上并没有锁信息，此时锁信息就已经丢掉了。</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images4/image-20221101231401815.png" alt="image-20221101231401815"></p><p>为了解决这个问题，redission提出来了MutiLock锁，使用这把锁咱们就不使用主从了，每个节点的地位都是一样的， 这把锁加锁的逻辑需要写入到每一个主丛节点上，只有所有的服务器都写入成功，此时才是加锁成功，假设现在某个节点挂了，那么他去获得锁的时候，只要有一个节点拿不到，都不能算是加锁成功，就保证了加锁的可靠性。</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images4/image-20221101231425166.png" alt="image-20221101231425166"></p><p>那么MutiLock 加锁原理是什么呢？笔者画了一幅图来说明</p><p>当我们去设置了多个锁时，redission会将多个锁添加到一个集合中，然后用while循环去不停去尝试拿锁，但是会有一个总共的加锁时间，这个时间是用需要加锁的个数 * 1500ms ，假设有3个锁，那么时间就是4500ms，假设在这4500ms内，所有的锁都加锁成功， 那么此时才算是加锁成功，如果在4500ms有线程加锁失败，则会再次去进行重试.</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images4/image-20221101231538839.png" alt="image-20221101231538839"></p><h3 id="5-6分布式锁总结"><a href="#5-6分布式锁总结" class="headerlink" title="5.6分布式锁总结:"></a>5.6分布式锁总结:</h3><p><img src="https://gitee.com/DylanToT99/images/raw/master/images4/image-20221101231623040.png" alt="image-20221101231623040"></p><h2 id="6、秒杀优化"><a href="#6、秒杀优化" class="headerlink" title="6、秒杀优化"></a>6、秒杀优化</h2><h3 id="6-1-秒杀优化-异步秒杀思路"><a href="#6-1-秒杀优化-异步秒杀思路" class="headerlink" title="6.1 秒杀优化-异步秒杀思路"></a>6.1 秒杀优化-异步秒杀思路</h3><p>我们来回顾一下下单流程</p><p>当用户发起请求，此时会请求nginx，nginx会访问到tomcat，而tomcat中的程序，会进行串行操作，分成如下几个步骤</p><p>1、查询优惠卷</p><p>2、判断秒杀库存是否足够</p><p>3、查询订单</p><p>4、校验是否是一人一单</p><p>5、扣减库存</p><p>6、创建订单</p><p>在这六步操作中，又有很多操作是要去操作数据库的，而且还是一个线程串行执行， 这样就会导致我们的程序执行的很慢，所以我们需要异步程序执行，那么如何加速呢？</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images4/image-20221102131626092.png" alt="image-20221102131626092"></p><p>在这里笔者想给大家分享一下课程内没有的思路，看看有没有小伙伴这么想，比如，我们可以不可以使用异步编排来做，或者说我开启N多线程，N多个线程，一个线程执行查询优惠卷，一个执行判断扣减库存，一个去创建订单等等，然后再统一做返回，这种做法和课程中有哪种好呢？答案是课程中的好，因为如果你采用我刚说的方式，如果访问的人很多，那么线程池中的线程可能一下子就被消耗完了，而且你使用上述方案，最大的特点在于，你觉得时效性会非常重要，但是你想想是吗？并不是，比如我只要确定他能做这件事，然后我后边慢慢做就可以了，我并不需要他一口气做完这件事，所以我们应当采用的是课程中，类似消息队列的方式来完成我们的需求，而不是使用线程池或者是异步编排的方式来完成这个需求</p><p>优化方案：我们将耗时比较短的逻辑判断放入到redis中，比如是否库存足够，比如是否一人一单，这样的操作，只要这种逻辑可以完成，就意味着我们是一定可以下单完成的，我们只需要进行快速的逻辑判断，根本就不用等下单逻辑走完，我们直接给用户返回成功， 再在后台开一个线程，后台线程慢慢的去执行queue里边的消息，这样程序不就超级快了吗？而且也不用担心线程池消耗殆尽的问题，因为这里我们的程序中并没有手动使用任何线程池，当然这里边有两个难点</p><p>第一个难点是我们怎么在redis中去快速校验一人一单，还有库存判断</p><p>第二个难点是由于我们校验和tomct下单是两个线程，那么我们如何知道到底哪个单他最后是否成功，或者是下单完成，为了完成这件事我们在redis操作完之后，我们会将一些信息返回给前端，同时也会把这些信息丢到异步queue中去，后续操作中，可以通过这个id来查询我们tomcat中的下单逻辑是否完成了。</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images4/image-20221102131742553.png" alt="image-20221102131742553"></p><p>我们现在来看看整体思路：当用户下单之后，判断库存是否充足只需要导redis中去根据key找对应的value是否大于0即可，如果不充足，则直接结束，如果充足，继续在redis中判断用户是否可以下单，如果set集合中没有这条数据，说明他可以下单，如果set集合中没有这条记录，则将userId和优惠卷存入到redis中，并且返回0，整个过程需要保证是原子性的，我们可以使用lua来操作</p><p>当以上判断逻辑走完之后，我们可以判断当前redis中返回的结果是否是0 ，如果是0，则表示可以下单，则将之前说的信息存入到到queue中去，然后返回，然后再来个线程异步的下单，前端可以通过返回的订单id来判断是否下单成功。</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images4/image-20221102131804737.png" alt="image-20221102131804737"></p><h3 id="6-2-秒杀优化-Redis完成秒杀资格判断"><a href="#6-2-秒杀优化-Redis完成秒杀资格判断" class="headerlink" title="6.2 秒杀优化-Redis完成秒杀资格判断"></a>6.2 秒杀优化-Redis完成秒杀资格判断</h3><p>需求：</p><ul><li><p>新增秒杀优惠券的同时，将优惠券信息保存到Redis中</p></li><li><p>基于Lua脚本，判断秒杀库存、一人一单，决定用户是否抢购成功</p></li><li><p>如果抢购成功，将优惠券id和用户id封装后存入阻塞队列</p></li><li><p>开启线程任务，不断从阻塞队列中获取信息，实现异步下单功能</p></li></ul><p>VoucherServiceImpl</p><pre><code class="java">@Override@Transactionalpublic void addSeckillVoucher(Voucher voucher) &#123;    // 保存优惠券    save(voucher);    // 保存秒杀信息    SeckillVoucher seckillVoucher = new SeckillVoucher();    seckillVoucher.setVoucherId(voucher.getId());    seckillVoucher.setStock(voucher.getStock());    seckillVoucher.setBeginTime(voucher.getBeginTime());    seckillVoucher.setEndTime(voucher.getEndTime());    seckillVoucherService.save(seckillVoucher);    // 保存秒杀库存到Redis中    //SECKILL_STOCK_KEY 这个变量定义在RedisConstans中    //private static final String SECKILL_STOCK_KEY =&quot;seckill:stock:&quot;    stringRedisTemplate.opsForValue().set(SECKILL_STOCK_KEY + voucher.getId(), voucher.getStock().toString());&#125;</code></pre><p>完整lua表达式</p><pre><code class="lua">-- 1.参数列表-- 1.1.优惠券idlocal voucherId = ARGV[1]-- 1.2.用户idlocal userId = ARGV[2]-- 1.3.订单idlocal orderId = ARGV[3]-- 2.数据key-- 2.1.库存keylocal stockKey = &#39;seckill:stock:&#39; .. voucherId-- 2.2.订单keylocal orderKey = &#39;seckill:order:&#39; .. voucherId-- 3.脚本业务-- 3.1.判断库存是否充足 get stockKeyif(tonumber(redis.call(&#39;get&#39;, stockKey)) &lt;= 0) then    -- 3.2.库存不足，返回1    return 1end-- 3.2.判断用户是否下单 SISMEMBER orderKey userIdif(redis.call(&#39;sismember&#39;, orderKey, userId) == 1) then    -- 3.3.存在，说明是重复下单，返回2    return 2end-- 3.4.扣库存 incrby stockKey -1redis.call(&#39;incrby&#39;, stockKey, -1)-- 3.5.下单（保存用户）sadd orderKey userIdredis.call(&#39;sadd&#39;, orderKey, userId)-- 3.6.发送消息到队列中， XADD stream.orders * k1 v1 k2 v2 ...redis.call(&#39;xadd&#39;, &#39;stream.orders&#39;, &#39;*&#39;, &#39;userId&#39;, userId, &#39;voucherId&#39;, voucherId, &#39;id&#39;, orderId)return 0</code></pre><p>当以上lua表达式执行完毕后，剩下的就是根据步骤3,4来执行我们接下来的任务了</p><p>VoucherOrderServiceImpl</p><pre><code class="java">@Overridepublic Result seckillVoucher(Long voucherId) &#123;    //获取用户    Long userId = UserHolder.getUser().getId();    long orderId = redisIdWorker.nextId(&quot;order&quot;);    // 1.执行lua脚本    Long result = stringRedisTemplate.execute(            SECKILL_SCRIPT,            Collections.emptyList(),            voucherId.toString(), userId.toString(), String.valueOf(orderId)    );    int r = result.intValue();    // 2.判断结果是否为0    if (r != 0) &#123;        // 2.1.不为0 ，代表没有购买资格        return Result.fail(r == 1 ? &quot;库存不足&quot; : &quot;不能重复下单&quot;);    &#125;    //TODO 保存阻塞队列    // 3.返回订单id    return Result.ok(orderId);&#125;</code></pre><h3 id="6-3-秒杀优化-基于阻塞队列实现秒杀优化"><a href="#6-3-秒杀优化-基于阻塞队列实现秒杀优化" class="headerlink" title="6.3 秒杀优化-基于阻塞队列实现秒杀优化"></a>6.3 秒杀优化-基于阻塞队列实现秒杀优化</h3><p>VoucherOrderServiceImpl</p><p>修改下单动作，现在我们去下单时，是通过lua表达式去原子执行判断逻辑，如果判断我出来不为0 ，则要么是库存不足，要么是重复下单，返回错误信息，如果是0，则把下单的逻辑保存到队列中去，然后异步执行</p><pre><code class="java">//异步处理线程池private static final ExecutorService SECKILL_ORDER_EXECUTOR = Executors.newSingleThreadExecutor();//在类初始化之后执行，因为当这个类初始化好了之后，随时都是有可能要执行的@PostConstructprivate void init() &#123;   SECKILL_ORDER_EXECUTOR.submit(new VoucherOrderHandler());&#125;// 用于线程池处理的任务// 当初始化完毕后，就会去从对列中去拿信息 private class VoucherOrderHandler implements Runnable&#123;        @Override        public void run() &#123;            while (true)&#123;                try &#123;                    // 1.获取队列中的订单信息                    VoucherOrder voucherOrder = orderTasks.take();                    // 2.创建订单                    handleVoucherOrder(voucherOrder);                &#125; catch (Exception e) &#123;                    log.error(&quot;处理订单异常&quot;, e);                &#125;               &#125;        &#125;        private void handleVoucherOrder(VoucherOrder voucherOrder) &#123;            //1.获取用户            Long userId = voucherOrder.getUserId();            // 2.创建锁对象            RLock redisLock = redissonClient.getLock(&quot;lock:order:&quot; + userId);            // 3.尝试获取锁            boolean isLock = redisLock.lock();            // 4.判断是否获得锁成功            if (!isLock) &#123;                // 获取锁失败，直接返回失败或者重试                log.error(&quot;不允许重复下单！&quot;);                return;            &#125;            try &#123;                //注意：由于是spring的事务是放在threadLocal中，此时的是多线程，事务会失效                proxy.createVoucherOrder(voucherOrder);            &#125; finally &#123;                // 释放锁                redisLock.unlock();            &#125;    &#125;     //a    private BlockingQueue&lt;VoucherOrder&gt; orderTasks =new  ArrayBlockingQueue&lt;&gt;(1024 * 1024);    @Override    public Result seckillVoucher(Long voucherId) &#123;        Long userId = UserHolder.getUser().getId();        long orderId = redisIdWorker.nextId(&quot;order&quot;);        // 1.执行lua脚本        Long result = stringRedisTemplate.execute(                SECKILL_SCRIPT,                Collections.emptyList(),                voucherId.toString(), userId.toString(), String.valueOf(orderId)        );        int r = result.intValue();        // 2.判断结果是否为0        if (r != 0) &#123;            // 2.1.不为0 ，代表没有购买资格            return Result.fail(r == 1 ? &quot;库存不足&quot; : &quot;不能重复下单&quot;);        &#125;        VoucherOrder voucherOrder = new VoucherOrder();        // 2.3.订单id        long orderId = redisIdWorker.nextId(&quot;order&quot;);        voucherOrder.setId(orderId);        // 2.4.用户id        voucherOrder.setUserId(userId);        // 2.5.代金券id        voucherOrder.setVoucherId(voucherId);        // 2.6.放入阻塞队列        orderTasks.add(voucherOrder);        //3.获取代理对象         proxy = (IVoucherOrderService)AopContext.currentProxy();        //4.返回订单id        return Result.ok(orderId);    &#125;         @Transactional    public  void createVoucherOrder(VoucherOrder voucherOrder) &#123;        Long userId = voucherOrder.getUserId();        // 5.1.查询订单        int count = query().eq(&quot;user_id&quot;, userId).eq(&quot;voucher_id&quot;, voucherOrder.getVoucherId()).count();        // 5.2.判断是否存在        if (count &gt; 0) &#123;            // 用户已经购买过了           log.error(&quot;用户已经购买过了&quot;);           return ;        &#125;        // 6.扣减库存        boolean success = seckillVoucherService.update()                .setSql(&quot;stock = stock - 1&quot;) // set stock = stock - 1                .eq(&quot;voucher_id&quot;, voucherOrder.getVoucherId()).gt(&quot;stock&quot;, 0) // where id = ? and stock &gt; 0                .update();        if (!success) &#123;            // 扣减失败            log.error(&quot;库存不足&quot;);            return ;        &#125;        save(voucherOrder);     &#125;</code></pre><p><strong>小总结：</strong></p><p>秒杀业务的优化思路是什么？</p><ul><li>先利用Redis完成库存余量、一人一单判断，完成抢单业务</li><li>再将下单业务放入阻塞队列，利用独立线程异步下单</li><li>基于阻塞队列的异步秒杀存在哪些问题？<ul><li>内存限制问题</li><li>数据安全问题</li></ul></li></ul><h2 id="7、Redis消息队列"><a href="#7、Redis消息队列" class="headerlink" title="7、Redis消息队列"></a>7、Redis消息队列</h2><h3 id="7-1-Redis消息队列-认识消息队列"><a href="#7-1-Redis消息队列-认识消息队列" class="headerlink" title="7.1 Redis消息队列-认识消息队列"></a>7.1 Redis消息队列-认识消息队列</h3><p>什么是消息队列：字面意思就是存放消息的队列。最简单的消息队列模型包括3个角色：</p><ul><li>消息队列：存储和管理消息，也被称为消息代理（Message Broker）</li><li>生产者：发送消息到消息队列</li><li>消费者：从消息队列获取消息并处理消息</li></ul><p><img src="https://gitee.com/DylanToT99/images/raw/master/images4/image-20221102161901724.png" alt="image-20221102161901724"></p><p>使用队列的好处在于 <strong>解耦：</strong>所谓解耦，举一个生活中的例子就是：快递员(生产者)把快递放到快递柜里边(Message Queue)去，我们(消费者)从快递柜里边去拿东西，这就是一个异步，如果耦合，那么这个快递员相当于直接把快递交给你，这事固然好，但是万一你不在家，那么快递员就会一直等你，这就浪费了快递员的时间，所以这种思想在我们日常开发中，是非常有必要的。</p><p>这种场景在我们秒杀中就变成了：我们下单之后，利用redis去进行校验下单条件，再通过队列把消息发送出去，然后再启动一个线程去消费这个消息，完成解耦，同时也加快我们的响应速度。</p><p>这里我们可以使用一些现成的mq，比如kafka，rabbitmq等等，但是呢，如果没有安装mq，我们也可以直接使用redis提供的mq方案，降低我们的部署和学习成本。</p><h3 id="7-2-Redis消息队列-基于List实现消息队列"><a href="#7-2-Redis消息队列-基于List实现消息队列" class="headerlink" title="7.2 Redis消息队列-基于List实现消息队列"></a>7.2 Redis消息队列-基于List实现消息队列</h3><p><strong>基于List结构模拟消息队列</strong></p><p>消息队列（Message Queue），字面意思就是存放消息的队列。而Redis的list数据结构是一个双向链表，很容易模拟出队列效果。</p><p>队列是入口和出口不在一边，因此我们可以利用：LPUSH 结合 RPOP、或者 RPUSH 结合 LPOP来实现。<br>不过要注意的是，当队列中没有消息时RPOP或LPOP操作会返回null，并不像JVM的阻塞队列那样会阻塞并等待消息。因此这里应该使用BRPOP或者BLPOP来实现阻塞效果。</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images4/image-20221102161952400.png" alt="image-20221102161952400"></p><p>基于List的消息队列有哪些优缺点？<br>优点：</p><ul><li>利用Redis存储，不受限于JVM内存上限</li><li>基于Redis的持久化机制，数据安全性有保证</li><li>可以满足消息有序性</li></ul><p>缺点：</p><ul><li>无法避免消息丢失</li><li>只支持单消费者</li></ul><h3 id="7-3-Redis消息队列-基于PubSub的消息队列"><a href="#7-3-Redis消息队列-基于PubSub的消息队列" class="headerlink" title="7.3 Redis消息队列-基于PubSub的消息队列"></a>7.3 Redis消息队列-基于PubSub的消息队列</h3><p>PubSub（发布订阅）是Redis2.0版本引入的消息传递模型。顾名思义，消费者可以订阅一个或多个channel，生产者向对应channel发送消息后，所有订阅者都能收到相关消息。</p><p> SUBSCRIBE channel [channel] ：订阅一个或多个频道<br> PUBLISH channel msg ：向一个频道发送消息<br> PSUBSCRIBE pattern[pattern] ：订阅与pattern格式匹配的所有频道</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images4/image-20221102162030411.png" alt="image-20221102162030411"></p><p>基于PubSub的消息队列有哪些优缺点？<br>优点：</p><ul><li>采用发布订阅模型，支持多生产、多消费</li></ul><p>缺点：</p><ul><li>不支持数据持久化</li><li>无法避免消息丢失</li><li>消息堆积有上限，超出时数据丢失</li></ul><h3 id="7-4-Redis消息队列-基于Stream的消息队列"><a href="#7-4-Redis消息队列-基于Stream的消息队列" class="headerlink" title="7.4 Redis消息队列-基于Stream的消息队列"></a>7.4 Redis消息队列-基于Stream的消息队列</h3><p>Stream 是 Redis 5.0 引入的一种新数据类型，可以实现一个功能非常完善的消息队列。</p><p>发送消息的命令：</p><p><img src="C:/Users/Dylan/AppData/Roaming/Typora/typora-user-images/image-20221102162113991.png" alt="image-20221102162113991"></p><p>例如：</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images4/image-20221102162135337.png" alt="image-20221102162135337"></p><p>读取消息的方式之一：XREAD</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images4/image-20221102162147957.png" alt="image-20221102162147957"></p><p>例如，使用XREAD读取第一个消息：</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images4/image-20221102162202695.png" alt="image-20221102162202695"></p><p>XREAD阻塞方式，读取最新的消息：</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images4/image-20221102162216967.png" alt="image-20221102162216967"></p><p>在业务开发中，我们可以循环的调用XREAD阻塞方式来查询最新消息，从而实现持续监听队列的效果，伪代码如下</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images4/image-20221102162233387.png" alt="image-20221102162233387"></p><p>注意：当我们指定起始ID为$时，代表读取最新的消息，如果我们处理一条消息的过程中，又有超过1条以上的消息到达队列，则下次获取时也只能获取到最新的一条，会出现漏读消息的问题</p><p>STREAM类型消息队列的XREAD命令特点：</p><ul><li>消息可回溯</li><li>一个消息可以被多个消费者读取</li><li>可以阻塞读取</li><li>有消息漏读的风险</li></ul><h3 id="7-5-Redis消息队列-基于Stream的消息队列-消费者组"><a href="#7-5-Redis消息队列-基于Stream的消息队列-消费者组" class="headerlink" title="7.5 Redis消息队列-基于Stream的消息队列-消费者组"></a>7.5 Redis消息队列-基于Stream的消息队列-消费者组</h3><p>消费者组（Consumer Group）：将多个消费者划分到一个组中，监听同一个队列。具备下列特点：</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images4/image-20221102162317290.png" alt="image-20221102162317290"></p><p>创建消费者组：<br><img src="C:/Users/Dylan/AppData/Roaming/Typora/typora-user-images/image-20221102162331949.png" alt="image-20221102162331949"><br>key：队列名称<br>groupName：消费者组名称<br>ID：起始ID标示，$代表队列中最后一个消息，0则代表队列中第一个消息<br>MKSTREAM：队列不存在时自动创建队列<br>其它常见命令：</p><p> <strong>删除指定的消费者组</strong></p><pre><code class="java">XGROUP DESTORY key groupName</code></pre><p> <strong>给指定的消费者组添加消费者</strong></p><pre><code class="java">XGROUP CREATECONSUMER key groupname consumername</code></pre><p> <strong>删除消费者组中的指定消费者</strong></p><pre><code class="java">XGROUP DELCONSUMER key groupname consumername</code></pre><p>从消费者组读取消息：</p><pre><code class="java">XREADGROUP GROUP group consumer [COUNT count] [BLOCK milliseconds] [NOACK] STREAMS key [key ...] ID [ID ...]</code></pre><ul><li>group：消费组名称</li><li>consumer：消费者名称，如果消费者不存在，会自动创建一个消费者</li><li>count：本次查询的最大数量</li><li>BLOCK milliseconds：当没有消息时最长等待时间</li><li>NOACK：无需手动ACK，获取到消息后自动确认</li><li>STREAMS key：指定队列名称</li><li>ID：获取消息的起始ID：</li></ul><p><strong>“&gt;”<strong>：从下一个未消费的消息开始<br>其它：根据指定id从pending-list中获取已消费但未确认的消息，例如</strong>0</strong>，是从pending-list中的第一个消息开始</p><p>消费者监听消息的基本思路：</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images4/image-20221102162726969.png" alt="image-20221102162726969"></p><p>STREAM类型消息队列的XREADGROUP命令特点：</p><ul><li>消息可回溯</li><li>可以多消费者争抢消息，加快消费速度</li><li>可以阻塞读取</li><li>没有消息漏读的风险</li><li>有消息确认机制，保证消息至少被消费一次</li></ul><p>最后我们来个小对比</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images4/image-20221102162830338.png" alt="image-20221102162830338"></p><h3 id="7-6-基于Redis的Stream结构作为消息队列，实现异步秒杀下单"><a href="#7-6-基于Redis的Stream结构作为消息队列，实现异步秒杀下单" class="headerlink" title="7.6 基于Redis的Stream结构作为消息队列，实现异步秒杀下单"></a>7.6 基于Redis的Stream结构作为消息队列，实现异步秒杀下单</h3><p>需求：</p><ul><li>创建一个Stream类型的消息队列，名为stream.orders</li><li>修改之前的秒杀下单Lua脚本，在认定有抢购资格后，直接向stream.orders中添加消息，内容包含voucherId、userId、orderId</li><li>项目启动时，开启一个线程任务，尝试获取stream.orders中的消息，完成下单\</li></ul><p>修改lua表达式,新增3.6 </p><pre><code class="lua">local voucherId=ARGV[1]---用户IDlocal userId=ARGV[2]---订单IDlocal orderId=ARGV[3]---2.数据key---库存keylocal stockKey=&#39;seckill:stock:&#39;..voucherId---订单keylocal orderKey=&#39;seckill:order:&#39;..voucherId---脚本业务---判断库存是否充足if(tonumber(redis.call(&#39;get&#39;,stockKey),10)&lt;=0)then    ---库存不足    return 1end---判断用户是否下单if(redis.call(&#39;SISMEMBER&#39;,orderKey,userId)==1)then    ---已经存在, 不允许重复下单    return 2end---扣库存, incrby stockKey -1redis.call(&#39;incrby&#39;,stockKey,-1)---保存用户 SADD orderKey userIdredis.call(&#39;SADD&#39;,orderKey,userId)---发送消息到队列当中 XADD stream.orders * k1 v1 k2 v2redis.call(&#39;xadd&#39;,&#39;stream.orders&#39;,&#39;*&#39;,&#39;userId&#39;,userId,&#39;voucherId&#39;,voucherId,&#39;id&#39;,orderId)return 0</code></pre><p>VoucherOrderServiceImpl</p><pre><code class="java">private class VoucherOrderHandler implements Runnable &#123;    @Override    public void run() &#123;        while (true) &#123;            try &#123;                // 1.获取消息队列中的订单信息 XREADGROUP GROUP g1 c1 COUNT 1 BLOCK 2000 STREAMS s1 &gt;                List&lt;MapRecord&lt;String, Object, Object&gt;&gt; list = stringRedisTemplate.opsForStream().read(                    Consumer.from(&quot;g1&quot;, &quot;c1&quot;),                    StreamReadOptions.empty().count(1).block(Duration.ofSeconds(2)),                    StreamOffset.create(&quot;stream.orders&quot;, ReadOffset.lastConsumed())                );                // 2.判断订单信息是否为空                if (list == null || list.isEmpty()) &#123;                    // 如果为null，说明没有消息，继续下一次循环                    continue;                &#125;                // 解析数据                MapRecord&lt;String, Object, Object&gt; record = list.get(0);                Map&lt;Object, Object&gt; value = record.getValue();                VoucherOrder voucherOrder = BeanUtil.fillBeanWithMap(value, new VoucherOrder(), true);                // 3.创建订单                createVoucherOrder(voucherOrder);                // 4.确认消息 XACK                stringRedisTemplate.opsForStream().acknowledge(&quot;s1&quot;, &quot;g1&quot;, record.getId());            &#125; catch (Exception e) &#123;                log.error(&quot;处理订单异常&quot;, e);                //处理异常消息                handlePendingList();            &#125;        &#125;    &#125;    private void handlePendingList() &#123;        while (true) &#123;            try &#123;                // 1.获取pending-list中的订单信息 XREADGROUP GROUP g1 c1 COUNT 1 BLOCK 2000 STREAMS s1 0                List&lt;MapRecord&lt;String, Object, Object&gt;&gt; list = stringRedisTemplate.opsForStream().read(                    Consumer.from(&quot;g1&quot;, &quot;c1&quot;),                    StreamReadOptions.empty().count(1),                    StreamOffset.create(&quot;stream.orders&quot;, ReadOffset.from(&quot;0&quot;))                );                // 2.判断订单信息是否为空                if (list == null || list.isEmpty()) &#123;                    // 如果为null，说明没有异常消息，结束循环                    break;                &#125;                // 解析数据                MapRecord&lt;String, Object, Object&gt; record = list.get(0);                Map&lt;Object, Object&gt; value = record.getValue();                VoucherOrder voucherOrder = BeanUtil.fillBeanWithMap(value, new VoucherOrder(), true);                // 3.创建订单                createVoucherOrder(voucherOrder);                // 4.确认消息 XACK                stringRedisTemplate.opsForStream().acknowledge(&quot;s1&quot;, &quot;g1&quot;, record.getId());            &#125; catch (Exception e) &#123;                log.error(&quot;处理pendding订单异常&quot;, e);                try&#123;                    Thread.sleep(20);                &#125;catch(Exception e)&#123;                    e.printStackTrace();                &#125;            &#125;        &#125;    &#125;&#125;</code></pre><h2 id="8、达人探店"><a href="#8、达人探店" class="headerlink" title="8、达人探店"></a>8、达人探店</h2><h3 id="8-1、达人探店-发布探店笔记"><a href="#8-1、达人探店-发布探店笔记" class="headerlink" title="8.1、达人探店-发布探店笔记"></a>8.1、达人探店-发布探店笔记</h3><p>发布探店笔记</p><p>探店笔记类似点评网站的评价，往往是图文结合。对应的表有两个：<br>tb_blog：探店笔记表，包含笔记中的标题、文字、图片等<br>tb_blog_comments：其他用户对探店笔记的评价</p><p><strong>具体发布流程</strong></p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images4/image-20221104153058539.png" alt="image-20221104153058539"></p><p>上传接口</p><pre><code class="java">@Slf4j@RestController@RequestMapping(&quot;upload&quot;)public class UploadController &#123;    @PostMapping(&quot;blog&quot;)    public Result uploadImage(@RequestParam(&quot;file&quot;) MultipartFile image) &#123;        try &#123;            // 获取原始文件名称            String originalFilename = image.getOriginalFilename();            // 生成新文件名            String fileName = createNewFileName(originalFilename);            // 保存文件            image.transferTo(new File(SystemConstants.IMAGE_UPLOAD_DIR, fileName));            // 返回结果            log.debug(&quot;文件上传成功，&#123;&#125;&quot;, fileName);            return Result.ok(fileName);        &#125; catch (IOException e) &#123;            throw new RuntimeException(&quot;文件上传失败&quot;, e);        &#125;    &#125;&#125;</code></pre><p>注意：同学们在操作时，需要修改SystemConstants.IMAGE_UPLOAD_DIR 自己图片所在的地址，在实际开发中图片一般会放在nginx上或者是云存储上。</p><p>BlogController</p><pre><code class="java">@RestController@RequestMapping(&quot;/blog&quot;)public class BlogController &#123;    @Resource    private IBlogService blogService;    @PostMapping    public Result saveBlog(@RequestBody Blog blog) &#123;        //获取登录用户        UserDTO user = UserHolder.getUser();        blog.setUpdateTime(user.getId());        //保存探店博文        blogService.saveBlog(blog);        //返回id        return Result.ok(blog.getId());    &#125;&#125;</code></pre><h3 id="8-2-达人探店-查看探店笔记"><a href="#8-2-达人探店-查看探店笔记" class="headerlink" title="8.2 达人探店-查看探店笔记"></a>8.2 达人探店-查看探店笔记</h3><p>实现查看发布探店笔记的接口</p><p>![title: 小兔鲜<br>date: 2024-01-21 15:20:29<br>type: “vue”<br>categories:</p><ul><li>“前端”</li><li>“vue”](C:\Users\Dylan\AppData\Roaming\Typora\typora-user-images\image-20221104153129089.png)</li></ul><p>实现代码：</p><p>BlogServiceImpl</p><pre><code class="java">@Overridepublic Result queryBlogById(Long id) &#123;    // 1.查询blog    Blog blog = getById(id);    if (blog == null) &#123;        return Result.fail(&quot;笔记不存在！&quot;);    &#125;    // 2.查询blog有关的用户    queryBlogUser(blog);      return Result.ok(blog);&#125;</code></pre><h3 id="8-3-达人探店-点赞功能"><a href="#8-3-达人探店-点赞功能" class="headerlink" title="8.3 达人探店-点赞功能"></a>8.3 达人探店-点赞功能</h3><p>初始代码</p><pre><code class="java">@GetMapping(&quot;/likes/&#123;id&#125;&quot;)public Result queryBlogLikes(@PathVariable(&quot;id&quot;) Long id) &#123;    //修改点赞数量    blogService.update().setSql(&quot;liked = liked +1 &quot;).eq(&quot;id&quot;,id).update();    return Result.ok();&#125;</code></pre><p>问题分析：这种方式会导致一个用户无限点赞，明显是不合理的</p><p>造成这个问题的原因是，我们现在的逻辑，发起请求只是给数据库+1，所以才会出现这个问题</p><p>完善点赞功能</p><p>需求：</p><ul><li>同一个用户只能点赞一次，再次点击则取消点赞</li><li>如果当前用户已经点赞，则点赞按钮高亮显示（前端已实现，判断字段Blog类的isLike属性）</li></ul><p>实现步骤：</p><ul><li>给Blog类中添加一个isLike字段，标示是否被当前用户点赞</li><li>修改点赞功能，利用Redis的set集合判断是否点赞过，未点赞过则点赞数+1，已点赞过则点赞数-1</li><li>修改根据id查询Blog的业务，判断当前登录用户是否点赞过，赋值给isLike字段</li><li>修改分页查询Blog业务，判断当前登录用户是否点赞过，赋值给isLike字段</li></ul><p>为什么采用set集合：</p><p>因为我们的数据是不能重复的，当用户操作过之后，无论他怎么操作，都是</p><p>具体步骤：</p><p>1、在Blog 添加一个字段</p><pre><code class="java">@TableField(exist = false)private Boolean isLike;</code></pre><p>2、修改代码</p><pre><code class="java"> @Override    public Result likeBlog(Long id)&#123;        // 1.获取登录用户        Long userId = UserHolder.getUser().getId();        // 2.判断当前登录用户是否已经点赞        String key = BLOG_LIKED_KEY + id;        Boolean isMember = stringRedisTemplate.opsForSet().isMember(key, userId.toString());        if(BooleanUtil.isFalse(isMember))&#123;             //3.如果未点赞，可以点赞            //3.1 数据库点赞数+1            boolean isSuccess = update().setSql(&quot;liked = liked + 1&quot;).eq(&quot;id&quot;, id).update();            //3.2 保存用户到Redis的set集合            if(isSuccess)&#123;                stringRedisTemplate.opsForSet().add(key,userId.toString());            &#125;        &#125;else&#123;             //4.如果已点赞，取消点赞            //4.1 数据库点赞数-1            boolean isSuccess = update().setSql(&quot;liked = liked - 1&quot;).eq(&quot;id&quot;, id).update();            //4.2 把用户从Redis的set集合移除            if(isSuccess)&#123;                stringRedisTemplate.opsForSet().remove(key,userId.toString());            &#125;        &#125;</code></pre><h3 id="8-4-达人探店-点赞排行榜"><a href="#8-4-达人探店-点赞排行榜" class="headerlink" title="8.4 达人探店-点赞排行榜"></a>8.4 达人探店-点赞排行榜</h3><p>在探店笔记的详情页面，应该把给该笔记点赞的人显示出来，比如最早点赞的TOP5，形成点赞排行榜：</p><p>之前的点赞是放到set集合，但是set集合是不能排序的，所以这个时候，咱们可以采用一个可以排序的set集合，就是咱们的sortedSet</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images4/image-20221104153916833.png" alt="image-20221104153916833"></p><p>我们接下来来对比一下这些集合的区别是什么</p><p>所有点赞的人，需要是唯一的，所以我们应当使用set或者是sortedSet</p><p>其次我们需要排序，就可以直接锁定使用sortedSet啦</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images4/image-20221104153940259.png" alt="image-20221104153940259"></p><p>修改代码</p><p>BlogServiceImpl</p><p>点赞逻辑代码</p><pre><code class="java">   @Override    public Result likeBlog(Long id) &#123;        // 1.获取登录用户        Long userId = UserHolder.getUser().getId();        // 2.判断当前登录用户是否已经点赞        String key = BLOG_LIKED_KEY + id;        Double score = stringRedisTemplate.opsForZSet().score(key, userId.toString());        if (score == null) &#123;            // 3.如果未点赞，可以点赞            // 3.1.数据库点赞数 + 1            boolean isSuccess = update().setSql(&quot;liked = liked + 1&quot;).eq(&quot;id&quot;, id).update();            // 3.2.保存用户到Redis的set集合  zadd key value score            if (isSuccess) &#123;                stringRedisTemplate.opsForZSet().add(key, userId.toString(), System.currentTimeMillis());            &#125;        &#125; else &#123;            // 4.如果已点赞，取消点赞            // 4.1.数据库点赞数 -1            boolean isSuccess = update().setSql(&quot;liked = liked - 1&quot;).eq(&quot;id&quot;, id).update();            // 4.2.把用户从Redis的set集合移除            if (isSuccess) &#123;                stringRedisTemplate.opsForZSet().remove(key, userId.toString());            &#125;        &#125;        return Result.ok();    &#125;    private void isBlogLiked(Blog blog) &#123;        // 1.获取登录用户        UserDTO user = UserHolder.getUser();        if (user == null) &#123;            // 用户未登录，无需查询是否点赞            return;        &#125;        Long userId = user.getId();        // 2.判断当前登录用户是否已经点赞        String key = &quot;blog:liked:&quot; + blog.getId();        Double score = stringRedisTemplate.opsForZSet().score(key, userId.toString());        blog.setIsLike(score != null);    &#125;</code></pre><p>点赞列表查询列表</p><p>BlogController</p><pre><code class="java">@GetMapping(&quot;/likes/&#123;id&#125;&quot;)public Result queryBlogLikes(@PathVariable(&quot;id&quot;) Long id) &#123;    return blogService.queryBlogLikes(id);&#125;</code></pre><p>BlogService</p><pre><code class="java">@Overridepublic Result queryBlogLikes(Long id) &#123;    String key = BLOG_LIKED_KEY + id;    // 1.查询top5的点赞用户 zrange key 0 4    Set&lt;String&gt; top5 = stringRedisTemplate.opsForZSet().range(key, 0, 4);    if (top5 == null || top5.isEmpty()) &#123;        return Result.ok(Collections.emptyList());    &#125;    // 2.解析出其中的用户id    List&lt;Long&gt; ids = top5.stream().map(Long::valueOf).collect(Collectors.toList());    String idStr = StrUtil.join(&quot;,&quot;, ids);    // 3.根据用户id查询用户 WHERE id IN ( 5 , 1 ) ORDER BY FIELD(id, 5, 1)    List&lt;UserDTO&gt; userDTOS = userService.query()            .in(&quot;id&quot;, ids).last(&quot;ORDER BY FIELD(id,&quot; + idStr + &quot;)&quot;).list()            .stream()            .map(user -&gt; BeanUtil.copyProperties(user, UserDTO.class))            .collect(Collectors.toList());    // 4.返回    return Result.ok(userDTOS);&#125;</code></pre><h2 id="9、好友关注"><a href="#9、好友关注" class="headerlink" title="9、好友关注"></a>9、好友关注</h2><h3 id="9-1-好友关注-关注和取消关注"><a href="#9-1-好友关注-关注和取消关注" class="headerlink" title="9.1 好友关注-关注和取消关注"></a>9.1 好友关注-关注和取消关注</h3><p>针对用户的操作：可以对用户进行关注和取消关注功能。</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images4/image-20221104193516535.png" alt="image-20221104193516535"></p><p>实现思路：</p><p>需求：基于该表数据结构，实现两个接口：</p><ul><li>关注和取关接口</li><li>判断是否关注的接口</li></ul><p>关注是User之间的关系，是博主与粉丝的关系，数据库中有一张tb_follow表来标示：</p><p><img src="C:/Users/Dylan/AppData/Roaming/Typora/typora-user-images/image-20221104193546510.png" alt="image-20221104193546510"></p><p>注意: 这里需要把主键修改为自增长，简化开发。</p><p>FollowController</p><pre><code class="java">//关注@PutMapping(&quot;/&#123;id&#125;/&#123;isFollow&#125;&quot;)public Result follow(@PathVariable(&quot;id&quot;) Long followUserId, @PathVariable(&quot;isFollow&quot;) Boolean isFollow) &#123;    return followService.follow(followUserId, isFollow);&#125;//取消关注@GetMapping(&quot;/or/not/&#123;id&#125;&quot;)public Result isFollow(@PathVariable(&quot;id&quot;) Long followUserId) &#123;      return followService.isFollow(followUserId);&#125;</code></pre><p>FollowService</p><pre><code class="java">取消关注service@Overridepublic Result isFollow(Long followUserId) &#123;        // 1.获取登录用户        Long userId = UserHolder.getUser().getId();        // 2.查询是否关注 select count(*) from tb_follow where user_id = ? and follow_user_id = ?        Integer count = query().eq(&quot;user_id&quot;, userId).eq(&quot;follow_user_id&quot;, followUserId).count();        // 3.判断        return Result.ok(count &gt; 0);    &#125; 关注service @Override    public Result follow(Long followUserId, Boolean isFollow) &#123;        // 1.获取登录用户        Long userId = UserHolder.getUser().getId();        String key = &quot;follows:&quot; + userId;        // 1.判断到底是关注还是取关        if (isFollow) &#123;            // 2.关注，新增数据            Follow follow = new Follow();            follow.setUserId(userId);            follow.setFollowUserId(followUserId);            boolean isSuccess = save(follow);        &#125; else &#123;            // 3.取关，删除 delete from tb_follow where user_id = ? and follow_user_id = ?            remove(new QueryWrapper&lt;Follow&gt;()                    .eq(&quot;user_id&quot;, userId).eq(&quot;follow_user_id&quot;, followUserId));        &#125;        return Result.ok();    &#125;</code></pre><h3 id="9-2-好友关注-共同关注"><a href="#9-2-好友关注-共同关注" class="headerlink" title="9.2 好友关注-共同关注"></a>9.2 好友关注-共同关注</h3><p>想要去看共同关注的好友，需要首先进入到这个页面，这个页面会发起两个请求</p><p>1、去查询用户的详情</p><p>2、去查询用户的笔记</p><p>以上两个功能和共同关注没有什么关系，大家可以自行将笔记中的代码拷贝到idea中就可以实现这两个功能了，我们的重点在于共同关注功能。</p><pre><code class="java">// UserController 根据id查询用户@GetMapping(&quot;/&#123;id&#125;&quot;)public Result queryUserById(@PathVariable(&quot;id&quot;) Long userId)&#123;    // 查询详情    User user = userService.getById(userId);    if (user == null) &#123;        return Result.ok();    &#125;    UserDTO userDTO = BeanUtil.copyProperties(user, UserDTO.class);    // 返回    return Result.ok(userDTO);&#125;// BlogController  根据id查询博主的探店笔记@GetMapping(&quot;/of/user&quot;)public Result queryBlogByUserId(        @RequestParam(value = &quot;current&quot;, defaultValue = &quot;1&quot;) Integer current,        @RequestParam(&quot;id&quot;) Long id) &#123;    // 根据用户查询    Page&lt;Blog&gt; page = blogService.query()            .eq(&quot;user_id&quot;, id).page(new Page&lt;&gt;(current, SystemConstants.MAX_PAGE_SIZE));    // 获取当前页数据    List&lt;Blog&gt; records = page.getRecords();    return Result.ok(records);&#125;</code></pre><p>接下来我们来看看共同关注如何实现：</p><p>需求：利用Redis中恰当的数据结构，实现共同关注功能。在博主个人页面展示出当前用户与博主的共同关注呢。</p><p>当然是使用我们之前学习过的set集合咯，在set集合中，有交集并集补集的api，我们可以把两人的关注的人分别放入到一个set集合中，然后再通过api去查看这两个set集合中的交集数据。</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images4/image-20221104193759033.png" alt="image-20221104193759033"></p><p>我们先来改造当前的关注列表</p><p>改造原因是因为我们需要在用户关注了某位用户后，需要将数据放入到set集合中，方便后续进行共同关注，同时当取消关注时，也需要从set集合中进行删除</p><p>FollowServiceImpl</p><pre><code class="java">@Overridepublic Result follow(Long followUserId, Boolean isFollow) &#123;    // 1.获取登录用户    Long userId = UserHolder.getUser().getId();    String key = &quot;follows:&quot; + userId;    // 1.判断到底是关注还是取关    if (isFollow) &#123;        // 2.关注，新增数据        Follow follow = new Follow();        follow.setUserId(userId);        follow.setFollowUserId(followUserId);        boolean isSuccess = save(follow);        if (isSuccess) &#123;            // 把关注用户的id，放入redis的set集合 sadd userId followerUserId            stringRedisTemplate.opsForSet().add(key, followUserId.toString());        &#125;    &#125; else &#123;        // 3.取关，删除 delete from tb_follow where user_id = ? and follow_user_id = ?        boolean isSuccess = remove(new QueryWrapper&lt;Follow&gt;()                .eq(&quot;user_id&quot;, userId).eq(&quot;follow_user_id&quot;, followUserId));        if (isSuccess) &#123;            // 把关注用户的id从Redis集合中移除            stringRedisTemplate.opsForSet().remove(key, followUserId.toString());        &#125;    &#125;    return Result.ok();&#125;</code></pre><p><strong>具体的关注代码：</strong></p><p>FollowServiceImpl</p><pre><code class="java">@Overridepublic Result followCommons(Long id) &#123;    // 1.获取当前用户    Long userId = UserHolder.getUser().getId();    String key = &quot;follows:&quot; + userId;    // 2.求交集    String key2 = &quot;follows:&quot; + id;    Set&lt;String&gt; intersect = stringRedisTemplate.opsForSet().intersect(key, key2);    if (intersect == null || intersect.isEmpty()) &#123;        // 无交集        return Result.ok(Collections.emptyList());    &#125;    // 3.解析id集合    List&lt;Long&gt; ids = intersect.stream().map(Long::valueOf).collect(Collectors.toList());    // 4.查询用户    List&lt;UserDTO&gt; users = userService.listByIds(ids)            .stream()            .map(user -&gt; BeanUtil.copyProperties(user, UserDTO.class))            .collect(Collectors.toList());    return Result.ok(users);&#125;</code></pre><h3 id="9-3-好友关注-Feed流实现方案"><a href="#9-3-好友关注-Feed流实现方案" class="headerlink" title="9.3 好友关注-Feed流实现方案"></a>9.3 好友关注-Feed流实现方案</h3><p>当我们关注了用户后，这个用户发了动态，那么我们应该把这些数据推送给用户，这个需求，其实我们又把他叫做Feed流，关注推送也叫做Feed流，直译为投喂。为用户持续的提供“沉浸式”的体验，通过无限下拉刷新获取新的信息。</p><p>对于传统的模式的内容解锁：我们是需要用户去通过搜索引擎或者是其他的方式去解锁想要看的内容</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images4/image-20221104193836330.png" alt="image-20221104193836330"></p><p>对于新型的Feed流的的效果：不需要我们用户再去推送信息，而是系统分析用户到底想要什么，然后直接把内容推送给用户，从而使用户能够更加的节约时间，不用主动去寻找。</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images4/image-20221104193849752.png" alt="image-20221104193849752"></p><p>Feed流的实现有两种模式：</p><p>Feed流产品有两种常见模式：<br>Timeline：不做内容筛选，简单的按照内容发布时间排序，常用于好友或关注。例如朋友圈</p><ul><li>优点：信息全面，不会有缺失。并且实现也相对简单</li><li>缺点：信息噪音较多，用户不一定感兴趣，内容获取效率低</li></ul><p>智能排序：利用智能算法屏蔽掉违规的、用户不感兴趣的内容。推送用户感兴趣信息来吸引用户</p><ul><li>优点：投喂用户感兴趣信息，用户粘度很高，容易沉迷</li><li>缺点：如果算法不精准，可能起到反作用<br>本例中的个人页面，是基于关注的好友来做Feed流，因此采用Timeline的模式。该模式的实现方案有三种：</li></ul><p>我们本次针对好友的操作，采用的就是Timeline的方式，只需要拿到我们关注用户的信息，然后按照时间排序即可</p><p>，因此采用Timeline的模式。该模式的实现方案有三种：</p><ul><li>拉模式</li><li>推模式</li><li>推拉结合</li></ul><p><strong>拉模式</strong>：也叫做读扩散</p><p>该模式的核心含义就是：当张三和李四和王五发了消息后，都会保存在自己的邮箱中，假设赵六要读取信息，那么他会从读取他自己的收件箱，此时系统会从他关注的人群中，把他关注人的信息全部都进行拉取，然后在进行排序</p><p>优点：比较节约空间，因为赵六在读信息时，并没有重复读取，而且读取完之后可以把他的收件箱进行清楚。</p><p>缺点：比较延迟，当用户读取数据时才去关注的人里边去读取数据，假设用户关注了大量的用户，那么此时就会拉取海量的内容，对服务器压力巨大。</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images4/image-20221104193925727.png" alt="image-20221104193925727"></p><p><strong>推模式</strong>：也叫做写扩散。</p><p>推模式是没有写邮箱的，当张三写了一个内容，此时会主动的把张三写的内容发送到他的粉丝收件箱中去，假设此时李四再来读取，就不用再去临时拉取了</p><p>优点：时效快，不用临时拉取</p><p>缺点：内存压力大，假设一个大V写信息，很多人关注他， 就会写很多分数据到粉丝那边去</p><p><img src="C:/Users/Dylan/AppData/Roaming/Typora/typora-user-images/image-20221104193957938.png" alt="image-20221104193957938"></p><p><strong>推拉结合模式</strong>：也叫做读写混合，兼具推和拉两种模式的优点。</p><p>推拉模式是一个折中的方案，站在发件人这一段，如果是个普通的人，那么我们采用写扩散的方式，直接把数据写入到他的粉丝中去，因为普通的人他的粉丝关注量比较小，所以这样做没有压力，如果是大V，那么他是直接将数据先写入到一份到发件箱里边去，然后再直接写一份到活跃粉丝收件箱里边去，现在站在收件人这端来看，如果是活跃粉丝，那么大V和普通的人发的都会直接写入到自己收件箱里边来，而如果是普通的粉丝，由于他们上线不是很频繁，所以等他们上线时，再从发件箱里边去拉信息。</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images4/image-20221104194030549.png" alt="image-20221104194030549"></p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images4/image-20221104194056939.png" alt="image-20221104194056939"></p><h3 id="9-4-好友关注-推送到粉丝收件箱"><a href="#9-4-好友关注-推送到粉丝收件箱" class="headerlink" title="9.4 好友关注-推送到粉丝收件箱"></a>9.4 好友关注-推送到粉丝收件箱</h3><p>需求：</p><ul><li>修改新增探店笔记的业务，在保存blog到数据库的同时，推送到粉丝的收件箱</li><li>收件箱满足可以根据时间戳排序，必须用Redis的数据结构实现</li><li>查询收件箱数据时，可以实现分页查询</li></ul><p>Feed流中的数据会不断更新，所以数据的角标也在变化，因此不能采用传统的分页模式。</p><p>传统了分页在feed流是不适用的，因为我们的数据会随时发生变化</p><p>假设在t1 时刻，我们去读取第一页，此时page &#x3D; 1 ，size &#x3D; 5 ，那么我们拿到的就是10<del>6 这几条记录，假设现在t2时候又发布了一条记录，此时t3 时刻，我们来读取第二页，读取第二页传入的参数是page&#x3D;2 ，size&#x3D;5 ，那么此时读取到的第二页实际上是从6 开始，然后是6</del>2 ，那么我们就读取到了重复的数据，所以feed流的分页，不能采用原始方案来做。</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images4/image-20221104194117548.png" alt="image-20221104194117548"></p><p>Feed流的滚动分页</p><p>我们需要记录每次操作的最后一条，然后从这个位置开始去读取数据</p><p>举个例子：我们从t1时刻开始，拿第一页数据，拿到了10~6，然后记录下当前最后一次拿取的记录，就是6，t2时刻发布了新的记录，此时这个11放到最顶上，但是不会影响我们之前记录的6，此时t3时刻来拿第二页，第二页这个时候拿数据，还是从6后一点的5去拿，就拿到了5-1的记录。我们这个地方可以采用sortedSet来做，可以进行范围查询，并且还可以记录当前获取数据时间戳最小值，就可以实现滚动分页了</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images4/image-20221104194149681.png" alt="image-20221104194149681"></p><p>核心的意思：就是我们在保存完探店笔记后，获得到当前笔记的粉丝，然后把数据推送到粉丝的redis中去。</p><pre><code class="java">@Overridepublic Result saveBlog(Blog blog) &#123;    // 1.获取登录用户    UserDTO user = UserHolder.getUser();    blog.setUserId(user.getId());    // 2.保存探店笔记    boolean isSuccess = save(blog);    if(!isSuccess)&#123;        return Result.fail(&quot;新增笔记失败!&quot;);    &#125;    // 3.查询笔记作者的所有粉丝 select * from tb_follow where follow_user_id = ?    List&lt;Follow&gt; follows = followService.query().eq(&quot;follow_user_id&quot;, user.getId()).list();    // 4.推送笔记id给所有粉丝    for (Follow follow : follows) &#123;        // 4.1.获取粉丝id        Long userId = follow.getUserId();        // 4.2.推送        String key = FEED_KEY + userId;        stringRedisTemplate.opsForZSet().add(key, blog.getId().toString(), System.currentTimeMillis());    &#125;    // 5.返回id    return Result.ok(blog.getId());&#125;</code></pre><h3 id="9-5好友关注-实现分页查询收邮箱"><a href="#9-5好友关注-实现分页查询收邮箱" class="headerlink" title="9.5好友关注-实现分页查询收邮箱"></a>9.5好友关注-实现分页查询收邮箱</h3><p>需求：在个人主页的“关注”卡片中，查询并展示推送的Blog信息：</p><p>具体操作如下：</p><p>1、每次查询完成后，我们要分析出查询出数据的最小时间戳，这个值会作为下一次查询的条件</p><p>2、我们需要找到与上一次查询相同的查询个数作为偏移量，下次查询时，跳过这些查询过的数据，拿到我们需要的数据</p><p>综上：我们的请求参数中就需要携带 lastId：上一次查询的最小时间戳 和偏移量这两个参数。</p><p>这两个参数第一次会由前端来指定，以后的查询就根据后台结果作为条件，再次传递到后台。</p><p>一、定义出来具体的返回值实体类</p><pre><code class="java">@Datapublic class ScrollResult &#123;    private List&lt;?&gt; list;    private Long minTime;    private Integer offset;&#125;</code></pre><p>BlogController</p><p>注意：RequestParam 表示接受url地址栏传参的注解，当方法上参数的名称和url地址栏不相同时，可以通过RequestParam 来进行指定</p><pre><code class="java">@GetMapping(&quot;/of/follow&quot;)public Result queryBlogOfFollow(    @RequestParam(&quot;lastId&quot;) Long max, @RequestParam(value = &quot;offset&quot;, defaultValue = &quot;0&quot;) Integer offset)&#123;    return blogService.queryBlogOfFollow(max, offset);&#125;</code></pre><p>BlogServiceImpl</p><pre><code class="java">@Overridepublic Result queryBlogOfFollow(Long max, Integer offset) &#123;    // 1.获取当前用户    Long userId = UserHolder.getUser().getId();    // 2.查询收件箱 ZREVRANGEBYSCORE key Max Min LIMIT offset count    String key = FEED_KEY + userId;    Set&lt;ZSetOperations.TypedTuple&lt;String&gt;&gt; typedTuples = stringRedisTemplate.opsForZSet()        .reverseRangeByScoreWithScores(key, 0, max, offset, 2);    // 3.非空判断    if (typedTuples == null || typedTuples.isEmpty()) &#123;        return Result.ok();    &#125;    // 4.解析数据：blogId、minTime（时间戳）、offset    List&lt;Long&gt; ids = new ArrayList&lt;&gt;(typedTuples.size());    long minTime = 0; // 2    int os = 1; // 2    for (ZSetOperations.TypedTuple&lt;String&gt; tuple : typedTuples) &#123; // 5 4 4 2 2        // 4.1.获取id        ids.add(Long.valueOf(tuple.getValue()));        // 4.2.获取分数(时间戳）        long time = tuple.getScore().longValue();        if(time == minTime)&#123;            os++;        &#125;else&#123;            minTime = time;            os = 1;        &#125;    &#125;    os = minTime == max ? os : os + offset;    // 5.根据id查询blog    String idStr = StrUtil.join(&quot;,&quot;, ids);    List&lt;Blog&gt; blogs = query().in(&quot;id&quot;, ids).last(&quot;ORDER BY FIELD(id,&quot; + idStr + &quot;)&quot;).list();    for (Blog blog : blogs) &#123;        // 5.1.查询blog有关的用户        queryBlogUser(blog);        // 5.2.查询blog是否被点赞        isBlogLiked(blog);    &#125;    // 6.封装并返回    ScrollResult r = new ScrollResult();    r.setList(blogs);    r.setOffset(os);    r.setMinTime(minTime);    return Result.ok(r);&#125;</code></pre><h2 id="10、附近商户"><a href="#10、附近商户" class="headerlink" title="10、附近商户"></a>10、附近商户</h2><h3 id="10-1、附近商户-GEO数据结构的基本用法"><a href="#10-1、附近商户-GEO数据结构的基本用法" class="headerlink" title="10.1、附近商户-GEO数据结构的基本用法"></a>10.1、附近商户-GEO数据结构的基本用法</h3><p>GEO就是Geolocation的简写形式，代表地理坐标。Redis在3.2版本中加入了对GEO的支持，允许存储地理坐标信息，帮助我们根据经纬度来检索数据。常见的命令有：</p><ul><li>GEOADD：添加一个地理空间信息，包含：经度（longitude）、纬度（latitude）、值（member）</li><li>GEODIST：计算指定的两个点之间的距离并返回</li><li>GEOHASH：将指定member的坐标转为hash字符串形式并返回</li><li>GEOPOS：返回指定member的坐标</li><li>GEORADIUS：指定圆心、半径，找到该圆内包含的所有member，并按照与圆心之间的距离排序后返回。6.以后已废弃</li><li>GEOSEARCH：在指定范围内搜索member，并按照与指定点之间的距离排序后返回。范围可以是圆形或矩形。6.2.新功能</li><li>GEOSEARCHSTORE：与GEOSEARCH功能一致，不过可以把结果存储到一个指定的key。 6.2.新功能</li></ul><h3 id="10-2、-附近商户-导入店铺数据到GEO"><a href="#10-2、-附近商户-导入店铺数据到GEO" class="headerlink" title="10.2、 附近商户-导入店铺数据到GEO"></a>10.2、 附近商户-导入店铺数据到GEO</h3><p>具体场景说明：</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images4/image-20221105162722421.png" alt="image-20221105162722421"></p><p>当我们点击美食之后，会出现一系列的商家，商家中可以按照多种排序方式，我们此时关注的是距离，这个地方就需要使用到我们的GEO，向后台传入当前app收集的地址(我们此处是写死的) ，以当前坐标作为圆心，同时绑定相同的店家类型type，以及分页信息，把这几个条件传入后台，后台查询出对应的数据再返回。</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images4/image-20221105162753604.png" alt="image-20221105162753604"></p><p>我们要做的事情是：将数据库表中的数据导入到redis中去，redis中的GEO，GEO在redis中就一个menber和一个经纬度，我们把x和y轴传入到redis做的经纬度位置去，但我们不能把所有的数据都放入到menber中去，毕竟作为redis是一个内存级数据库，如果存海量数据，redis还是力不从心，所以我们在这个地方存储他的id即可。</p><p>但是这个时候还有一个问题，就是在redis中并没有存储type，所以我们无法根据type来对数据进行筛选，所以我们可以按照商户类型做分组，类型相同的商户作为同一组，以typeId为key存入同一个GEO集合中即可</p><p>代码</p><p>HmDianPingApplicationTests</p><pre><code class="java">@Testvoid loadShopData() &#123;    // 1.查询店铺信息    List&lt;Shop&gt; list = shopService.list();    // 2.把店铺分组，按照typeId分组，typeId一致的放到一个集合    Map&lt;Long, List&lt;Shop&gt;&gt; map = list.stream().collect(Collectors.groupingBy(Shop::getTypeId));    // 3.分批完成写入Redis    for (Map.Entry&lt;Long, List&lt;Shop&gt;&gt; entry : map.entrySet()) &#123;        // 3.1.获取类型id        Long typeId = entry.getKey();        String key = SHOP_GEO_KEY + typeId;        // 3.2.获取同类型的店铺的集合        List&lt;Shop&gt; value = entry.getValue();        List&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt; locations = new ArrayList&lt;&gt;(value.size());        // 3.3.写入redis GEOADD key 经度 纬度 member        for (Shop shop : value) &#123;            // stringRedisTemplate.opsForGeo().add(key, new Point(shop.getX(), shop.getY()), shop.getId().toString());            locations.add(new RedisGeoCommands.GeoLocation&lt;&gt;(                    shop.getId().toString(),                    new Point(shop.getX(), shop.getY())            ));        &#125;        stringRedisTemplate.opsForGeo().add(key, locations);    &#125;&#125;</code></pre><h3 id="10-3-附近商户-实现附近商户功能"><a href="#10-3-附近商户-实现附近商户功能" class="headerlink" title="10.3 附近商户-实现附近商户功能"></a>10.3 附近商户-实现附近商户功能</h3><p>SpringDataRedis的2.3.9版本并不支持Redis 6.2提供的GEOSEARCH命令，因此我们需要提示其版本，修改自己的POM</p><p>第一步：导入pom</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;    &lt;exclusions&gt;        &lt;exclusion&gt;            &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt;            &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;        &lt;/exclusion&gt;        &lt;exclusion&gt;            &lt;artifactId&gt;lettuce-core&lt;/artifactId&gt;            &lt;groupId&gt;io.lettuce&lt;/groupId&gt;        &lt;/exclusion&gt;    &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;    &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt;    &lt;version&gt;2.6.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;io.lettuce&lt;/groupId&gt;    &lt;artifactId&gt;lettuce-core&lt;/artifactId&gt;    &lt;version&gt;6.1.6.RELEASE&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>第二步：</p><p>ShopController</p><pre><code class="java">@GetMapping(&quot;/of/type&quot;)public Result queryShopByType(        @RequestParam(&quot;typeId&quot;) Integer typeId,        @RequestParam(value = &quot;current&quot;, defaultValue = &quot;1&quot;) Integer current,        @RequestParam(value = &quot;x&quot;, required = false) Double x,        @RequestParam(value = &quot;y&quot;, required = false) Double y) &#123;   return shopService.queryShopByType(typeId, current, x, y);&#125;</code></pre><p>ShopServiceImpl</p><pre><code class="java">@Override    public Result queryShopByType(Integer typeId, Integer current, Double x, Double y) &#123;        // 1.判断是否需要根据坐标查询        if (x == null || y == null) &#123;            // 不需要坐标查询，按数据库查询            Page&lt;Shop&gt; page = query()                    .eq(&quot;type_id&quot;, typeId)                    .page(new Page&lt;&gt;(current, SystemConstants.DEFAULT_PAGE_SIZE));            // 返回数据            return Result.ok(page.getRecords());        &#125;        // 2.计算分页参数        int from = (current - 1) * SystemConstants.DEFAULT_PAGE_SIZE;        int end = current * SystemConstants.DEFAULT_PAGE_SIZE;        // 3.查询redis、按照距离排序、分页。结果：shopId、distance        String key = SHOP_GEO_KEY + typeId;        GeoResults&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt; results = stringRedisTemplate.opsForGeo() // GEOSEARCH key BYLONLAT x y BYRADIUS 10 WITHDISTANCE                .search(                        key,                        GeoReference.fromCoordinate(x, y),                        new Distance(5000),                        RedisGeoCommands.GeoSearchCommandArgs.newGeoSearchArgs().includeDistance().limit(end)                );        // 4.解析出id        if (results == null) &#123;            return Result.ok(Collections.emptyList());        &#125;        List&lt;GeoResult&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt;&gt; list = results.getContent();        if (list.size() &lt;= from) &#123;            // 没有下一页了，结束            return Result.ok(Collections.emptyList());        &#125;        // 4.1.截取 from ~ end的部分        List&lt;Long&gt; ids = new ArrayList&lt;&gt;(list.size());        Map&lt;String, Distance&gt; distanceMap = new HashMap&lt;&gt;(list.size());        list.stream().skip(from).forEach(result -&gt; &#123;            // 4.2.获取店铺id            String shopIdStr = result.getContent().getName();            ids.add(Long.valueOf(shopIdStr));            // 4.3.获取距离            Distance distance = result.getDistance();            distanceMap.put(shopIdStr, distance);        &#125;);        // 5.根据id查询Shop        String idStr = StrUtil.join(&quot;,&quot;, ids);        List&lt;Shop&gt; shops = query().in(&quot;id&quot;, ids).last(&quot;ORDER BY FIELD(id,&quot; + idStr + &quot;)&quot;).list();        for (Shop shop : shops) &#123;            shop.setDistance(distanceMap.get(shop.getId().toString()).getValue());        &#125;        // 6.返回        return Result.ok(shops);    &#125;</code></pre><h2 id="11、用户签到"><a href="#11、用户签到" class="headerlink" title="11、用户签到"></a>11、用户签到</h2><h4 id="11-1、用户签到-BitMap功能演示"><a href="#11-1、用户签到-BitMap功能演示" class="headerlink" title="11.1、用户签到-BitMap功能演示"></a>11.1、用户签到-BitMap功能演示</h4><p>我们针对签到功能完全可以通过mysql来完成，比如说以下这张表</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images4/image-20221105162828153.png" alt="image-20221105162828153"></p><p>用户一次签到，就是一条记录，假如有1000万用户，平均每人每年签到次数为10次，则这张表一年的数据量为 1亿条</p><p>每签到一次需要使用（8 + 8 + 1 + 1 + 3 + 1）共22 字节的内存，一个月则最多需要600多字节</p><p>我们如何能够简化一点呢？其实可以考虑小时候一个挺常见的方案，就是小时候，咱们准备一张小小的卡片，你只要签到就打上一个勾，我最后判断你是否签到，其实只需要到小卡片上看一看就知道了</p><p>我们可以采用类似这样的方案来实现我们的签到需求。</p><p>我们按月来统计用户签到信息，签到记录为1，未签到则记录为0.</p><p>把每一个bit位对应当月的每一天，形成了映射关系。用0和1标示业务状态，这种思路就称为位图（BitMap）。这样我们就用极小的空间，来实现了大量数据的表示</p><p>Redis中是利用string类型数据结构实现BitMap，因此最大上限是512M，转换为bit则是 2^32个bit位。</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images4/image-20221105162933699.png" alt="image-20221105162933699"></p><p>BitMap的操作命令有：</p><ul><li>SETBIT：向指定位置（offset）存入一个0或1</li><li>GETBIT ：获取指定位置（offset）的bit值</li><li>BITCOUNT ：统计BitMap中值为1的bit位的数量</li><li>BITFIELD ：操作（查询、修改、自增）BitMap中bit数组中的指定位置（offset）的值</li><li>BITFIELD_RO ：获取BitMap中bit数组，并以十进制形式返回</li><li>BITOP ：将多个BitMap的结果做位运算（与 、或、异或）</li><li>BITPOS ：查找bit数组中指定范围内第一个0或1出现的位置</li></ul><h4 id="11-2-、用户签到-实现签到功能"><a href="#11-2-、用户签到-实现签到功能" class="headerlink" title="11.2 、用户签到-实现签到功能"></a>11.2 、用户签到-实现签到功能</h4><p>需求：实现签到接口，将当前用户当天签到信息保存到Redis中</p><p>思路：我们可以把年和月作为bitMap的key，然后保存到一个bitMap中，每次签到就到对应的位上把数字从0变成1，只要对应是1，就表明说明这一天已经签到了，反之则没有签到。</p><p>我们通过接口文档发现，此接口并没有传递任何的参数，没有参数怎么确实是哪一天签到呢？这个很容易，可以通过后台代码直接获取即可，然后到对应的地址上去修改bitMap。</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images4/image-20221105164742197.png" alt="image-20221105164742197"></p><p><strong>代码</strong></p><p>UserController</p><pre><code class="java"> @PostMapping(&quot;/sign&quot;) public Result sign()&#123;    return userService.sign(); &#125;</code></pre><p>UserServiceImpl</p><pre><code class="java">@Overridepublic Result sign() &#123;    // 1.获取当前登录用户    Long userId = UserHolder.getUser().getId();    // 2.获取日期    LocalDateTime now = LocalDateTime.now();    // 3.拼接key    String keySuffix = now.format(DateTimeFormatter.ofPattern(&quot;:yyyyMM&quot;));    String key = USER_SIGN_KEY + userId + keySuffix;    // 4.获取今天是本月的第几天    int dayOfMonth = now.getDayOfMonth();    // 5.写入Redis SETBIT key offset 1    stringRedisTemplate.opsForValue().setBit(key, dayOfMonth - 1, true);    return Result.ok();&#125;</code></pre><h4 id="11-3-用户签到-签到统计"><a href="#11-3-用户签到-签到统计" class="headerlink" title="11.3 用户签到-签到统计"></a>11.3 用户签到-签到统计</h4><p><strong>问题1：</strong>什么叫做连续签到天数？<br>从最后一次签到开始向前统计，直到遇到第一次未签到为止，计算总的签到次数，就是连续签到天数。</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images4/image-20221105164815976.png" alt="image-20221105164815976"></p><p>Java逻辑代码：获得当前这个月的最后一次签到数据，定义一个计数器，然后不停的向前统计，直到获得第一个非0的数字即可，每得到一个非0的数字计数器+1，直到遍历完所有的数据，就可以获得当前月的签到总天数了</p><p><strong>问题2：</strong>如何得到本月到今天为止的所有签到数据？</p><p>  BITFIELD key GET u[dayOfMonth] 0</p><p>假设今天是10号，那么我们就可以从当前月的第一天开始，获得到当前这一天的位数，是10号，那么就是10位，去拿这段时间的数据，就能拿到所有的数据了，那么这10天里边签到了多少次呢？统计有多少个1即可。</p><p><strong>问题3：如何从后向前遍历每个bit位？</strong></p><p>注意：bitMap返回的数据是10进制，哪假如说返回一个数字8，那么我哪儿知道到底哪些是0，哪些是1呢？我们只需要让得到的10进制数字和1做与运算就可以了，因为1只有遇见1 才是1，其他数字都是0 ，我们把签到结果和1进行与操作，每与一次，就把签到结果向右移动一位，依次内推，我们就能完成逐个遍历的效果了。</p><p>需求：实现下面接口，统计当前用户截止当前时间在本月的连续签到天数</p><p>有用户有时间我们就可以组织出对应的key，此时就能找到这个用户截止这天的所有签到记录，再根据这套算法，就能统计出来他连续签到的次数了</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images4/image-20221105164857291.png" alt="image-20221105164857291"></p><p>代码</p><p><strong>UserController</strong></p><pre><code class="java">@GetMapping(&quot;/sign/count&quot;)public Result signCount()&#123;    return userService.signCount();&#125;</code></pre><p><strong>UserServiceImpl</strong></p><pre><code class="java">@Overridepublic Result signCount() &#123;    // 1.获取当前登录用户    Long userId = UserHolder.getUser().getId();    // 2.获取日期    LocalDateTime now = LocalDateTime.now();    // 3.拼接key    String keySuffix = now.format(DateTimeFormatter.ofPattern(&quot;:yyyyMM&quot;));    String key = USER_SIGN_KEY + userId + keySuffix;    // 4.获取今天是本月的第几天    int dayOfMonth = now.getDayOfMonth();    // 5.获取本月截止今天为止的所有的签到记录，返回的是一个十进制的数字 BITFIELD sign:5:202203 GET u14 0    List&lt;Long&gt; result = stringRedisTemplate.opsForValue().bitField(            key,            BitFieldSubCommands.create()                    .get(BitFieldSubCommands.BitFieldType.unsigned(dayOfMonth)).valueAt(0)    );    if (result == null || result.isEmpty()) &#123;        // 没有任何签到结果        return Result.ok(0);    &#125;    Long num = result.get(0);    if (num == null || num == 0) &#123;        return Result.ok(0);    &#125;    // 6.循环遍历    int count = 0;    while (true) &#123;        // 6.1.让这个数字与1做与运算，得到数字的最后一个bit位  // 判断这个bit位是否为0        if ((num &amp; 1) == 0) &#123;            // 如果为0，说明未签到，结束            break;        &#125;else &#123;            // 如果不为0，说明已签到，计数器+1            count++;        &#125;        // 把数字右移一位，抛弃最后一个bit位，继续下一个bit位        num &gt;&gt;&gt;= 1;    &#125;    return Result.ok(count);&#125;</code></pre><h4 id="11-4-额外加餐-关于使用bitmap来解决缓存穿透的方案"><a href="#11-4-额外加餐-关于使用bitmap来解决缓存穿透的方案" class="headerlink" title="11.4 额外加餐-关于使用bitmap来解决缓存穿透的方案"></a>11.4 额外加餐-关于使用bitmap来解决缓存穿透的方案</h4><p>回顾<strong>缓存穿透</strong>：</p><p>发起了一个数据库不存在的，redis里边也不存在的数据，通常你可以把他看成一个攻击</p><p>解决方案：</p><ul><li><p>判断id&lt;0</p></li><li><p>如果数据库是空，那么就可以直接往redis里边把这个空数据缓存起来</p></li></ul><p>第一种解决方案：遇到的问题是如果用户访问的是id不存在的数据，则此时就无法生效</p><p>第二种解决方案：遇到的问题是：如果是不同的id那就可以防止下次过来直击数据</p><p>所以我们如何解决呢？</p><p>我们可以将数据库的数据，所对应的id写入到一个list集合中，当用户过来访问的时候，我们直接去判断list中是否包含当前的要查询的数据，如果说用户要查询的id数据并不在list集合中，则直接返回，如果list中包含对应查询的id数据，则说明不是一次缓存穿透数据，则直接放行。</p><p><img src="/.%5CRedis%E5%AE%9E%E6%88%98%E7%AF%87.assets%5C1653836416586.png" alt="1653836416586"></p><p>现在的问题是这个主键其实并没有那么短，而是很长的一个 主键</p><p>哪怕你单独去提取这个主键，但是在11年左右，淘宝的商品总量就已经超过10亿个</p><p>所以如果采用以上方案，这个list也会很大，所以我们可以使用bitmap来减少list的存储空间</p><p>我们可以把list数据抽象成一个非常大的bitmap，我们不再使用list，而是将db中的id数据利用哈希思想，比如：</p><p>id % bitmap.size  &#x3D; 算出当前这个id对应应该落在bitmap的哪个索引上，然后将这个值从0变成1，然后当用户来查询数据时，此时已经没有了list，让用户用他查询的id去用相同的哈希算法， 算出来当前这个id应当落在bitmap的哪一位，然后判断这一位是0，还是1，如果是0则表明这一位上的数据一定不存在，  采用这种方式来处理，需要重点考虑一个事情，就是误差率，所谓的误差率就是指当发生哈希冲突的时候，产生的误差。</p><h2 id="12、UV统计"><a href="#12、UV统计" class="headerlink" title="12、UV统计"></a>12、UV统计</h2><h3 id="12-1-、UV统计-HyperLogLog"><a href="#12-1-、UV统计-HyperLogLog" class="headerlink" title="12.1 、UV统计-HyperLogLog"></a>12.1 、UV统计-HyperLogLog</h3><p>首先我们搞懂两个概念：</p><ul><li>UV：全称Unique Visitor，也叫独立访客量，是指通过互联网访问、浏览这个网页的自然人。1天内同一个用户多次访问该网站，只记录1次。</li><li>PV：全称Page View，也叫页面访问量或点击量，用户每访问网站的一个页面，记录1次PV，用户多次打开页面，则记录多次PV。往往用来衡量网站的流量。</li></ul><p>通常来说UV会比PV大很多，所以衡量同一个网站的访问量，我们需要综合考虑很多因素，所以我们只是单纯的把这两个值作为一个参考值</p><p>UV统计在服务端做会比较麻烦，因为要判断该用户是否已经统计过了，需要将统计过的用户信息保存。但是如果每个访问的用户都保存到Redis中，数据量会非常恐怖，那怎么处理呢？</p><p>Hyperloglog(HLL)是从Loglog算法派生的概率算法，用于确定非常大的集合的基数，而不需要存储其所有值。相关算法原理大家可以参考：<a href="https://juejin.cn/post/6844903785744056333#heading-0">https://juejin.cn/post/6844903785744056333#heading-0</a><br>Redis中的HLL是基于string结构实现的，单个HLL的内存<strong>永远小于16kb</strong>，<strong>内存占用低</strong>的令人发指！作为代价，其测量结果是概率性的，<strong>有小于0.81％的误差</strong>。不过对于UV统计来说，这完全可以忽略。</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images4/image-20221105164950162.png" alt="image-20221105164950162"></p><h3 id="12-2-UV统计-测试百万数据的统计"><a href="#12-2-UV统计-测试百万数据的统计" class="headerlink" title="12.2 UV统计-测试百万数据的统计"></a>12.2 UV统计-测试百万数据的统计</h3><p>测试思路：我们直接利用单元测试，向HyperLogLog中添加100万条数据，看看内存占用和统计效果如何</p><p><img src="C:\Users\Dylan\AppData\Roaming\Typora\typora-user-images\image-20221105165010132.png" alt="image-20221105165010132"></p><p>经过测试：我们会发生他的误差是在允许范围内，并且内存占用极小</p>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
          <category> redis </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>注解随笔</title>
      <link href="/2022/11/06/zhu-jie-sui-bi/"/>
      <url>/2022/11/06/zhu-jie-sui-bi/</url>
      
        <content type="html"><![CDATA[<h2 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h2><h3 id="1-responsebody"><a href="#1-responsebody" class="headerlink" title="1.@responsebody"></a>1.@responsebody</h3><p>作用是将controller方法返回的对象通过适当的转换器换为指定个事之后,写入到response对象的body区,通常用来返回JSON数据或是xml数据,在使用此注解之后不会再走视图处理器，而是直接将数据写入到输入流中，他的效果等同于通过response对象输出指定格式的数据。代码示例:</p><pre><code class="java">**@RequestMapping**(&quot;/login&quot;)　　@ResponseBody　　public User login(User user)&#123;　　　　return user;　　&#125;　　User字段：userName pwd　　那么在前台接收到的数据为：’&#123;“userName”:“xxx”,“pwd”:“xxx”&#125;’**效果等同于如下代码**：　　@RequestMapping(&quot;/login&quot;)　　public void login(User user, HttpServletResponse response)&#123;　　　　response.getWriter.write(JSONObject.fromObject(user).toString());　　&#125;</code></pre><h3 id="2-requestbody"><a href="#2-requestbody" class="headerlink" title="2.@requestbody"></a>2.@requestbody</h3><p>@RequestBody主要用来接收前端传递给后端的json字符串中的数据的(即请求体中的数据的)；</p><ul><li>使用@RequestBody的情况：</li></ul><p>参数是放在请求体中<br>当请求content_type为：application&#x2F;json类型的请求，数据类型为json时， json格式如下：{“aaa”:“111”,“bbb”:“222”}</p><ul><li>不使用@RequestBody的情况：</li></ul><p>接收URL中的数据并组装为对象<br>当请求content_type为：application&#x2F;x-www-form-urlencoded类型的或multipart&#x2F;form-data时，数据格式为aaa&#x3D;111&amp;bbb&#x3D;222</p><h3 id="3-requestparam"><a href="#3-requestparam" class="headerlink" title="3.@requestparam"></a>3.@requestparam</h3><p>主要用于将请求参数区域的数据映射到控制层方法的参数上.</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20220520162443070.png" alt="image-20220520162443070"></p><p>@RequestParam注解主要有哪些参数</p><ul><li><p><strong>value</strong>：请求中传入参数的名称，如果不设置后台接口的value值，则会默认为该变量名。比如上图中第一个参数如果不设置value&#x3D;“page”,则前端传入的参数名必须为pageNum,否则在后台接口中pageNum将接收不到对应的数据.</p></li><li><p><strong>required</strong>：该参数是否为必传项。默认是true，表示请求中一定要传入对应的参数，否则会报404错误，如果设置为false时，当请求中没有此参数，将会默认为null,而对于基本数据类型的变量，则必须有值，这时会抛出空指针异常。如果允许空值，则接口中变量需要使用包装类来声明。</p></li><li><p><strong>defaultValue</strong>：参数的默认值，如果请求中没有同名的参数时，该变量默认为此值。注意默认值可以使用SpEL表达式，如”#{systemProperties[‘java.vm.version’]}”</p></li></ul><h3 id="4-pathVariable"><a href="#4-pathVariable" class="headerlink" title="4.@pathVariable"></a>4.@pathVariable</h3><p>通过@pathVariable可以绑定占位符参数到方法参数中</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20220520163445580.png" alt="image-20220520163445580"></p><h3 id="5-requestHeader"><a href="#5-requestHeader" class="headerlink" title="5.@requestHeader"></a>5.@requestHeader</h3><p>相似的,@RequestHeader用于将请求的头信息区数据映射到功能处理方法的参数上。</p><pre><code class="java">@RequestMapping(value=&quot;/header&quot;)  public String test(         @RequestHeader(&quot;User-Agent&quot;) String userAgent,         @RequestHeader(value=&quot;Accept&quot;) String[] accepts)</code></pre><h3 id="6-ModelAttribute"><a href="#6-ModelAttribute" class="headerlink" title="6.@ModelAttribute"></a>6.@ModelAttribute</h3><h4 id="1-绑定请求参数到命令对象"><a href="#1-绑定请求参数到命令对象" class="headerlink" title="1. 绑定请求参数到命令对象:"></a>1. 绑定请求参数到命令对象:</h4><p>放在功能处理方法的入参上时，用于将多个请求参数绑定到一个命令对象，从而简化绑定流程，而且自动暴露为模型数据用于视图页面展示时使用；</p><p>如:public String test1(@ModelAttribute(“user”) UserModel user) ;</p><p>它的作用是将该绑定的命令对象以“user”为名称添加到模型对象中供视图页面展示使用。我们此时可以在视图页面使用${user.username}来获取绑定的命令对象的属性。</p><p>绑定请求参数到命令对象支持对象图导航式的绑定，如请求参数包含“?username&#x3D;zhang&amp;password&#x3D;123&amp;workInfo.city&#x3D;bj”自动绑定到user中的workInfo属性的city属性中。</p><pre><code class="java">@RequestMapping(value=&quot;/model2/&#123;username&#125;&quot;)  public String test2(@ModelAttribute(&quot;model&quot;) DataBinderTestModel model) &#123;   </code></pre><p>DataBinderTestModel相关模型请从第三章拷贝过来，URI模板变量也能自动绑定到命令对象中，当你请求的URL中包含“bool&#x3D;yes&amp;schooInfo.specialty&#x3D;computer&amp;hobbyList[0]&#x3D;program&amp;hobbyList[1]&#x3D;music&amp;map[key1]&#x3D;value1&amp;map[key2]&#x3D;value2&amp;state&#x3D;blocked”会自动绑定到命令对象上。</p><p>当URI模板变量和请求参数同名时，URI模板变量具有高优先权。</p><h4 id="2-暴露表单引用对象为模型数据："><a href="#2-暴露表单引用对象为模型数据：" class="headerlink" title="2.暴露表单引用对象为模型数据："></a>2.暴露表单引用对象为模型数据：</h4><p>放在处理器的一般方法（非功能处理方法）上时，是为表单准备要展示的表单引用对象，如注册时需要选择的所在城市等，而且在执行功能处理方法（@RequestMapping注解的方法）之前，自动添加到模型对象中，用于视图页面展示时使用；</p><pre><code class="java">@ModelAttribute(&quot;cityList&quot;)  public List&lt;String&gt; cityList() &#123;      return Arrays.asList(&quot;北京&quot;, &quot;山东&quot;);  &#125; </code></pre><p>如上代码会在执行功能处理方法之前执行，并将其自动添加到模型对象中，在功能处理方法中调用Model 入参的containsAttribute(“cityList”)将会返回true。</p><pre><code class="java">@ModelAttribute(&quot;user&quot;)  //①  public UserModel getUser(@RequestParam(value=&quot;username&quot;, defaultValue=&quot;&quot;) String username) &#123;  //TODO 去数据库根据用户名查找用户对象  UserModel user = new UserModel();  user.setRealname(&quot;zhang&quot;);       return user;  &#125;</code></pre><p>如你要修改用户资料时一般需要根据用户的编号&#x2F;用户名查找用户来进行编辑，此时可以通过如上代码查找要编辑的用户。</p><p>也可以进行一些默认值的处理.</p><pre><code class="java">@RequestMapping(value=&quot;/model1&quot;) //②  public String test1(@ModelAttribute(&quot;user&quot;) UserModel user, Model model)  </code></pre><p>此处我们看到①和②有同名的命令对象，那Spring Web MVC内部如何处理的呢：</p><p>(1、首先执行@ModelAttribute注解的方法，准备视图展示时所需要的模型数据；@ModelAttribute注解方法形式参数规则和@RequestMapping规则一样，如可以有@RequestParam等；</p><p>（2、执行@RequestMapping注解方法，进行模型绑定时首先查找模型数据中是否含有同名对象，如果有直接使用，如果没有通过反射创建一个，因此②处的user将使用①处返回的命令对象。即②处的user等于①处的user。</p><h4 id="3-暴露RequestMapping方法返回值为模型数据"><a href="#3-暴露RequestMapping方法返回值为模型数据" class="headerlink" title="3.暴露RequestMapping方法返回值为模型数据"></a>3.暴露RequestMapping方法返回值为模型数据</h4><pre><code class="java">public @ModelAttribute(&quot;user2&quot;) UserModel test3(@ModelAttribute(&quot;user2&quot;) UserModel user) </code></pre><p>大家可以看到返回值类型是命令对象类型，而且通过@ModelAttribute(“user2”)注解，此时会暴露返回值到模型数据（名字为user2）中供视图展示使用。那哪个视图应该展示呢？此时Spring Web MVC会根据RequestToViewNameTranslator进行逻辑视图名的翻译.</p><p>此时又有问题了，@RequestMapping注解方法的入参user暴露到模型数据中的名字也是user2，其实我们能猜到：</p><p>（3、@ModelAttribute注解的返回值会覆盖@RequestMapping注解方法中的@ModelAttribute注解的同名命令对象。</p><h4 id="4-绑定命令参数"><a href="#4-绑定命令参数" class="headerlink" title="4.绑定命令参数"></a>4.绑定命令参数</h4><pre><code class="java">public String test4(@ModelAttribute UserModel user, Model model)  //或  public String test5(UserModel user, Model model)   </code></pre><p>此时我们没有为命令对象提供暴露到模型数据中的名字，此时的名字是什么呢？Spring Web MVC自动将简单类名（首字母小写）作为名字暴露，如“cn.javass.chapter6.model.UserModel”暴露的名字为“userModel”。</p><pre><code class="java">public @ModelAttribute List&lt;String&gt; test6()  或  public @ModelAttribute List&lt;UserModel&gt; test7()   </code></pre><p>对于集合类型（Collection接口的实现者们，包括数组），生成的模型对象属性名为“简单类名（首字母小写）”+“List”，如List生成的模型对象属性名为“stringList”，List生成的模型对象属性名为“userModelList”。</p><p>其他情况一律都是使用简单类名（首字母小写）作为模型对象属性名，如Map&lt;String, UserModel&gt;类型的模型对象属性名为“map”。</p><h3 id="7-SessionAttributes"><a href="#7-SessionAttributes" class="headerlink" title="7.@SessionAttributes"></a>7.@SessionAttributes</h3><p>作用:绑定对象到session</p><p>有时候我们需要在多次请求之间保持数据，一般情况需要我们明确的调用HttpSession的API来存取会话数据，如多步骤提交的表单。Spring Web MVC提供了@SessionAttributes进行请求间透明的存取会话数据。</p><pre><code class="java">//1、在控制器类头上添加@SessionAttributes注解  @SessionAttributes(value = &#123;&quot;user&quot;&#125;)    //①  public class SessionAttributeController     //2、@ModelAttribute注解的方法进行表单引用对象的创建  @ModelAttribute(&quot;user&quot;)    //②  public UserModel initUser()     //3、@RequestMapping注解方法的@ModelAttribute注解的参数进行命令对象的绑定  @RequestMapping(&quot;/session1&quot;)   //③  public String session1(@ModelAttribute(&quot;user&quot;) UserModel user)    //4、通过SessionStatus的setComplete()方法清除@SessionAttributes指定的会话数据  @RequestMapping(&quot;/session2&quot;)   //③  public String session(@ModelAttribute(&quot;user&quot;) UserModel user, SessionStatus status) &#123;      if(true) &#123; //④          status.setComplete();      &#125;      return &quot;success&quot;;  &#125;</code></pre><p>@SessionAttributes(value &#x3D; {“user”})含义：</p><p>@SessionAttributes(value &#x3D; {“user”}) 标识将模型数据中的名字为“user” 的对象存储到会话中（默认HttpSession），此处value指定将模型数据中的哪些数据（名字进行匹配）存储到会话中，此外还有一个types属性表示模型数据中的哪些类型的对象存储到会话范围内，如果同时指定value和types属性则那些名字和类型都匹配的对象才能存储到会话范围内。</p><p>包含@SessionAttributes的执行流程如下所示：</p><p>① 首先根据@SessionAttributes注解信息查找会话内的对象放入到模型数据中；</p><p>② 执行@ModelAttribute注解的方法：如果模型数据中包含同名的数据，则不执行@ModelAttribute注解方法进行准备表单引用数据，而是使用①步骤中的会话数据；如果模型数据中不包含同名的数据，执行@ModelAttribute注解的方法并将返回值添加到模型数据中；</p><p>③ 执行@RequestMapping方法，绑定@ModelAttribute注解的参数：查找模型数据中是否有@ModelAttribute注解的同名对象，如果有直接使用，否则通过反射创建一个；并将请求参数绑定到该命令对象；</p><p>此处需要注意：如果使用@SessionAttributes注解控制器类之后，③步骤一定是从模型对象中取得同名的命令对象，如果模型数据中不存在将抛出HttpSessionRequiredException Expected session attribute ‘user’(Spring3.1)</p><p>或HttpSessionRequiredException Session attribute ‘user’ required - not found in session(Spring3.0)异常。</p><p>④ 如果会话可以销毁了，如多步骤提交表单的最后一步，此时可以调用SessionStatus对象的setComplete()标识当前会话的@SessionAttributes指定的数据可以清理了，此时当@RequestMapping功能处理方法执行完毕会进行清理会话数据。</p><h3 id="8-CookieValue"><a href="#8-CookieValue" class="headerlink" title="8.@CookieValue"></a>8.@CookieValue</h3><p>绑定Cookie数据值</p><p>@CookieValue用于将请求的Cookie数据映射到功能处理方法的参数上。</p><pre><code class="java">public String test(@CookieValue(value=&quot;JSESSIONID&quot;, defaultValue=&quot;&quot;) String sessionId) </code></pre><p>如上配置将自动将JSESSIONID值入参到sessionId参数上，defaultValue表示Cookie中没有JSESSIONID时默认为空。</p><pre><code class="java">public String test2(@CookieValue(value=&quot;JSESSIONID&quot;, defaultValue=&quot;&quot;) Cookie sessionId)   </code></pre><h3 id="9-Value"><a href="#9-Value" class="headerlink" title="9.@Value"></a>9.@Value</h3><p>绑定SpEL表示式</p><pre><code class="java">public String test(@Value(&quot;#&#123;systemProperties[&#39;java.vm.version&#39;]&#125;&quot;) String jvmVersion)  </code></pre><p>10.错误随笔</p><p>遇到一次接口调用两次请求的情况,多数是页面的超链接设置了空值或者仅仅是填充了一个占位符.此时需要将超链接的内容填上正确的值才能保证浏览器不会进行页面检查,发送两次值</p><h2 id="类上标注"><a href="#类上标注" class="headerlink" title="类上标注"></a>类上标注</h2><h3 id="10-RestController和-Controller的区别"><a href="#10-RestController和-Controller的区别" class="headerlink" title="10.@RestController和@Controller的区别"></a>10.@RestController和@Controller的区别</h3><p>@RestController注解相当于@ResponseBody ＋ @Controller合在一起的作用。</p><p>\1)  如果只是使用@RestController注解Controller，则Controller中的方法无法返回jsp页面，或者html，配置的视图解析器 InternalResourceViewResolver不起作用，返回的内容就是Return 里的内容。</p><p>\2) 如果需要返回到指定页面，则需要用 @Controller配合视图解析器InternalResourceViewResolver才行。<br>   如果需要返回JSON，XML或自定义mediaType内容到页面，则需要在对应的方法上加上@ResponseBody注解。</p><p>3)如果需要返回JSON，XML或自定义mediaType内容到页面，则需要在对应的方法上加上@ResponseBody注解。</p><h3 id="JsonIgnore"><a href="#JsonIgnore" class="headerlink" title="@JsonIgnore"></a>@JsonIgnore</h3><p>来自于com.fasterxml.jackson.annotation.JsonIgnore;</p><p>此作用是保证保证类的属性不被传入到前端数据,具体作用还未探知</p><h2 id="mybatisPlus"><a href="#mybatisPlus" class="headerlink" title="mybatisPlus"></a>mybatisPlus</h2><h3 id="TableName"><a href="#TableName" class="headerlink" title="@TableName"></a>@TableName</h3><p>标注在实体类上的注解,其值对应着数据库表的值</p><h3 id="TableId"><a href="#TableId" class="headerlink" title="@TableId"></a>@TableId</h3><p>标注在实体类属性的注解,用以对应表的主键</p><h3 id="MapperScan"><a href="#MapperScan" class="headerlink" title="@MapperScan"></a>@MapperScan</h3><p>标注在mybatisPlus配置类上的注解,用来将mapper注册到springboot中</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis底层原理</title>
      <link href="/2022/11/01/redis-di-ceng-yuan-li/"/>
      <url>/2022/11/01/redis-di-ceng-yuan-li/</url>
      
        <content type="html"><![CDATA[<h1 id="一-简单动态字符串"><a href="#一-简单动态字符串" class="headerlink" title="一. 简单动态字符串"></a>一. 简单动态字符串</h1><h2 id="1-SDS的字面定义"><a href="#1-SDS的字面定义" class="headerlink" title="1.SDS的字面定义"></a>1.SDS的字面定义</h2><p>Redis没有直接使用C语言传统的字符串表示, 而是自己构建了一种名为简单动态字符串的抽象类型(simple dynamic string,SDS)</p><p>在Redis里面，C字符串只会作为字符串字面量（string literal）用在一些无须对字符串值进行修改的地方，比如打印日志：</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221125124851185.png" alt="image-20221125124851185"></p><h2 id="2-SDS的作用"><a href="#2-SDS的作用" class="headerlink" title="2.SDS的作用"></a>2.SDS的作用</h2><h3 id="实现字符串"><a href="#实现字符串" class="headerlink" title="实现字符串"></a>实现字符串</h3><p>在redis数据库中,包含字符串的键值对在底层都是SDS实现的.</p><p>比如, 若客户端执行命令:</p><pre><code class="sh">redis&gt;set msg &quot;hello&quot;</code></pre><p>redis就会存储一条键值对, 底层实现为 键为字符串对象,底层保存的是值为:”msg”的SDS.</p><p>同理, 值也为字符串对象, 底层为”hello”的SDS</p><h3 id="用作缓冲区"><a href="#用作缓冲区" class="headerlink" title="用作缓冲区"></a>用作缓冲区</h3><p>除了用来保存数据库中的字符串值之外，SDS还被用作缓冲区（buffer）：AOF模块中的AOF缓冲区，以及客户端状态中的输入缓冲区，都是由SDS实现的，</p><h2 id="3-SDS的底层实现"><a href="#3-SDS的底层实现" class="headerlink" title="3.SDS的底层实现"></a>3.SDS的底层实现</h2><h3 id="3-1-实现原理"><a href="#3-1-实现原理" class="headerlink" title="3.1 实现原理:"></a>3.1 实现原理:</h3><p>每个sds.h代表一个sds值:</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221125125830193.png" alt="image-20221125125830193"></p><p>一个sds实例:</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221125125909049.png" alt="image-20221125125909049"></p><p>SDS遵循C字符串以空字符结尾的惯例，保存空字符的1字节空间不计算在SDS的len属性里面，并且为空字符分配额外的1字节空间，以及添加空字符到字符串末尾等操作，都是由SDS函数自动完成的，所以这个空字符对于SDS的使用者来说是完全透明的。遵循空字符结尾这一惯例的好处是，SDS可以直接重用一部分C字符串函数库里面的函数。</p><h3 id="3-2SDS与C字符串的区别"><a href="#3-2SDS与C字符串的区别" class="headerlink" title="3.2SDS与C字符串的区别:"></a>3.2SDS与C字符串的区别:</h3><h4 id="3-2-1常数复杂度获取字符串长度"><a href="#3-2-1常数复杂度获取字符串长度" class="headerlink" title="3.2.1常数复杂度获取字符串长度"></a>3.2.1常数复杂度获取字符串长度</h4><p>因为C字符串并不记录自身的长度信息，所以为了获取一个C字符串的长度，程序必须遍历整个字符串，对遇到的每个字符进行计数，直到遇到代表字符串结尾的空字符为止，这个操作的复杂度为O（N）。</p><p>但是sds在len属性中记录了sds本身的长度,因此获取len的时间复杂度仅为O(1).</p><blockquote><p>设置和更新SDS长度的工作是由SDS的API在执行时自动完成的，使用SDS无须进行任何手动修改长度的工作。</p></blockquote><h4 id="3-2-2杜绝缓冲区溢出"><a href="#3-2-2杜绝缓冲区溢出" class="headerlink" title="3.2.2杜绝缓冲区溢出"></a>3.2.2杜绝缓冲区溢出</h4><p>与C字符串不同，SDS的空间分配策略完全杜绝了发生缓冲区溢出的可能性：当SDS API需要对SDS进行修改时，API会先检查SDS的空间是否满足修改所需的要求，如果不满足的话，API会自动将SDS的空间扩展至执行修改所需的大小，然后才执行实际的修改操作，所以使用SDS既不需要手动修改SDS的空间大小，也不会出现前面所说的缓冲区溢出问题.</p><h4 id="3-2-3减少修改字符串时带来的内存重分配次数"><a href="#3-2-3减少修改字符串时带来的内存重分配次数" class="headerlink" title="3.2.3减少修改字符串时带来的内存重分配次数"></a>3.2.3减少修改字符串时带来的内存重分配次数</h4><p>C字符串不记录本身长度,C字符串的长度和底层数组的长度之间存在着关联性(包含了N个字符的字符串长度为N+1)，所以每次增长或者缩短一个C字符串，程序都总要对保存这个C字符串的数组进行一次内存重分配操作.</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221125134540651.png" alt="image-20221125134540651"></p><p>举个例子，如果我们持有一个值为”Redis”的C字符串s，那么为了将s的值改为”Redis Cluster”，在执行：</p><pre><code class="c++">strcat(s,&quot;cluster&quot;);</code></pre><p>之前，我们需要先使用内存重分配操作，扩展s的空间。</p><p>之后,我们又想在其末尾添加 Redisson,那么在执行</p><pre><code class="c++">strcat(s,&quot;Redisson&quot;);</code></pre><p>之前，我们需要先使用内存重分配操作，扩展s的空间。</p><p>因为内存重分配涉及复杂的算法，并且可能需要执行系统调用，所以它通常是一个比较耗时的操作.</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221125135203485.png" alt="image-20221125135203485"></p><p>而在SDS中,buf数组的长度为len与free相加, len的长度仅仅代表使用的长度,free则记录了未使用的字节数</p><p>通过未使用空间，SDS实现了<strong>空间预分配</strong>和<strong>惰性空间释放</strong>两种优化策略。</p><h5 id="1-空间预分配"><a href="#1-空间预分配" class="headerlink" title="1.空间预分配:"></a><strong>1.空间预分配:</strong></h5><p>空间预分配用于优化SDS的字符串增长操作:当SDS的api对一个sds进行修改时,并且需要对sds进行空间拓展的时候,程序不仅会为其分配所需要的空间,还会sds分配额外的未使用空间</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221125135832920.png" alt="image-20221125135832920"></p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221125135855500.png" alt="image-20221125135855500"></p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221125135917795.png" alt="image-20221125135917795"></p><p>因此采用这种方式,上面C字符串的空间分配操作次数是两次, 而redis只有一次</p><p>通过这种预分配策略，SDS将连续增长N次字符串所需的内存重分配次数从必定N次降低为最多N次。</p><h5 id="2-惰性空间释放"><a href="#2-惰性空间释放" class="headerlink" title="2.惰性空间释放"></a>2.惰性空间释放</h5><p>惰性空间释放用于优化SDS的字符串缩短操作：当SDS的API需要缩短SDS保存的字符串时，程序并不立即使用内存重分配来回收缩短后多出来的字节，而是使用free属性将这些字节的数量记录起来，并等待将来使用。</p><p>与此同时,SDS也提供了相应的API让我们在真正有需要时,来释放SDS的未使用空间所以不用担心惰性空间释放带来的空间浪费.</p><h4 id="3-2-4-二进制安全"><a href="#3-2-4-二进制安全" class="headerlink" title="3.2.4 二进制安全"></a>3.2.4 二进制安全</h4><p>C字符串因为默认空字符’\0’为结束标志,所以一些二进制数据其无法保存.</p><p>虽然数据库一般用于保存文本数据，但使用数据库来保存二进制数据的场景也不少见，因此，为了确保Redis可以适用于各种不同的使用场景，SDS的API都是二进制安全的（binary-safe），所有SDS API都会以处理二进制的方式来处理SDS存放在buf数组里的数据，程序不会对其中的数据做任何限制、过滤、或者假设，数据在写入时是什么样的，被读取时就是什么样,<strong>SDS使用len属性的值而不是空字符来判断字符串是否结束</strong>。这也是我们将SDS的<strong>buf属性称为字节数组</strong>的原因——Redis不是用这个数组来保存字符，而是用它来保存一系列二进制数据。</p><h4 id="3-2-5总结"><a href="#3-2-5总结" class="headerlink" title="3.2.5总结"></a>3.2.5总结</h4><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221125141442255.png" alt="image-20221125141442255"></p><h3 id="3-3-主要api"><a href="#3-3-主要api" class="headerlink" title="3.3 主要api"></a>3.3 主要api</h3><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221125141712141.png" alt="image-20221125141712141"></p><h1 id="二-链表"><a href="#二-链表" class="headerlink" title="二.链表"></a>二.链表</h1><p>链表在redis中应用非常广泛,比如<strong>list</strong>的底层实现之一就是链表.当一个列表键包含了数量比较多的元素，又或者列表中包含的元 素都是比较长的字符串时，Redis就会使用链表作为列表键的底层实现。</p><p>发布,订阅,慢查询和监视器也使用了链表.</p><h2 id="2-1-链表和链表节点的实现"><a href="#2-1-链表和链表节点的实现" class="headerlink" title="2.1 链表和链表节点的实现"></a>2.1 链表和链表节点的实现</h2><p>每个链表节点使用一个adlist.h&#x2F;listNode结构来表示：</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221126150848799.png" alt="image-20221126150848799"></p><p>虽然使用多个listNode结构就可以使用链表结构,但使用adlist.h&#x2F;list来持有链表的话,操作起来会更方便</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221126151041098.png" alt="image-20221126151041098"></p><p>list的结构例子如下:</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221126151337327.png" alt="image-20221126151337327"></p><p><strong>Redis的链表实现特性如下</strong>:</p><ul><li><strong>双向</strong>:带有pre和next指针</li><li><strong>无环</strong>,表头结点的pre指向null,尾结点的next也指向null</li><li>带表头指针和表尾指针</li><li>带链表长度计数器</li><li><strong>多态</strong>:链表节点使用void*指针来保存节点值，并且可以通过list 结构的dup、free、match三个属性为节点值设置类型特定函数，所以链 表可以用于保存各种不同类型的值。</li></ul><h2 id="2-2链表和链表节点的API"><a href="#2-2链表和链表节点的API" class="headerlink" title="2.2链表和链表节点的API"></a>2.2链表和链表节点的API</h2><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221126152026031.png" alt="image-20221126152026031"></p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221126152034479.png" alt="image-20221126152034479"></p><h2 id="2-3-总结"><a href="#2-3-总结" class="headerlink" title="2.3 总结"></a>2.3 总结</h2><ul><li><p>链表被广泛用于实现Redis的各种功能，比如列表键、发布与订 阅、慢查询、监视器等。</p></li><li><p>每个链表节点由一个listNode结构来表示，每个节点都有一个指 向前置节点和后置节点的指针，所以Redis的链表实现是双端链表。</p></li><li><p>每个链表使用一个list结构来表示，这个结构带有表头节点指针、 表尾节点指针，以及链表长度等信息。</p></li><li><p>因为链表表头节点的前置节点和表尾节点的后置节点都指向 NULL，所以Redis的链表实现是无环链表。 </p></li><li><p>通过为链表设置不同的类型特定函数，Redis的链表可以用于保存 各种不同类型的值。</p></li></ul><h1 id="三-字典"><a href="#三-字典" class="headerlink" title="三.字典"></a>三.字典</h1><p>​字典又称为符号表(symbol table),关联数组(associative array)或者映射(map).</p><p>​在字典中，一个键（key）可以和一个值（value）进行关联（或者 说将键映射为值），这些关联的键和值就称为键值对。</p><p>​字典中的每个<strong>键</strong>都是独一无二的，程序可以在字典中根据键查找与之关联的值，或者通过键来更新值，又或者根据键来删除整个键值对， 等等。</p><p>​字典在Redis中的应用相当广泛，比如<strong>Redis的数据库</strong>就是使用字典来作为底层实现的，对数据库的增、删、查、改操作也是构建在对字典 的操作之上的。</p><p>​在数据库中创建一个键为”msg”，值为”hello world”的键值对时，这个键值对就是保存在代表数据库的字典里面的。 除了用来表示数据库之外，<strong>字典还是哈希键的底层实现之一</strong>，当一个哈希键包含的键值对比较多，又或者键值对中的元素都是比较长的字符串时，Redis就会使用字典作为哈希键的底层实现。</p><p>​举个例子，website是一个包含10086个键值对的哈希键，这个哈希 键的键都是一些数据库的名字，而键的值就是数据库的主页网址：</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221126153510917.png" alt="image-20221126153510917"></p><h2 id="3-1-字典的实现"><a href="#3-1-字典的实现" class="headerlink" title="3.1 字典的实现"></a>3.1 字典的实现</h2><p>redis的字典使用哈希表作为底层实现,一个哈希表里面可以有多个哈希表节点,而每个hash表节点就保存了字典的一个键值对.</p><h3 id="3-11-哈希表"><a href="#3-11-哈希表" class="headerlink" title="3.11 哈希表"></a>3.11 哈希表</h3><p>Redis字典所使用的哈希表由dict.h&#x2F;dictht结构定义：</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221126160859329.png" alt="image-20221126160859329"></p><p>able属性是一个数组，数组中的每个元素都是一个指向 dict.h&#x2F;dictEntry结构的指针，每个dictEntry结构保存着一个键值对。size 属性记录了哈希表的大小，也即是table数组的大小，而used属性则记录 了哈希表目前已有节点（键值对）的数量。sizemask属性的值总是等于 size-1，这个属性和哈希值一起决定一个键应该被放到table数组的哪个 索引上面。</p><p>如下为一个大小为4的空hash表</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221126161317645.png" alt="image-20221126161317645"></p><h3 id="3-1-2-哈希表节点"><a href="#3-1-2-哈希表节点" class="headerlink" title="3.1.2 哈希表节点"></a>3.1.2 哈希表节点</h3><p>哈希表节点使用dictEntry结构表示，每个dictEntry结构都保存着一 个键值对：</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221126161432655.png" alt="image-20221126161432655"></p><p>key属性保存着键值对中的键，而v属性则保存着键值对中的值，其 中键值对的值可以是一个指针，或者是一个uint64_t整数，又或者是一 个int64_t整数。 next属性是指向另一个哈希表节点的指针，这个指针可以将多个哈 希值相同的键值对连接在一次，以此来解决<strong>键冲突（collision）</strong>的问 题。 举个例子，下图就展示了如何通过next指针，将两个索引值相同的 键k1和k0连接在一起。</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221126161937927.png" alt="image-20221126161937927"></p><h3 id="3-1-3-字典"><a href="#3-1-3-字典" class="headerlink" title="3.1.3 字典"></a>3.1.3 字典</h3><p>Redis中的字典由dict.h&#x2F;dict结构表示：</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221126162013473.png" alt="image-20221126162013473"></p><p>type属性和privdata属性是针对不同类型的键值对，为创建多态字典 而设置的：</p><ul><li>type属性是一个指向dictType结构的指针，每个dictType结构保存 了一簇用于操作特定类型键值对的函数，Redis会为用途不同的字典设置 不同的类型特定函数。</li><li>而privdata属性则保存了需要传给那些类型特定函数的可选参数。</li></ul><pre><code class="c">typedef struct dictType &#123;//计算哈希值的函数    unsigned int (*hashFunction)(const void *key);//复制键的函数    void *(*keyDup)(void *privdata, const void *key);//复制值的函数    void *(*valDup)(void *privdata, const void *obj);//对比键的函数    int (*keyCompare)(void *privdata, const void *key1, const void *key2);//销毁键的函数    void (*keyDestructor)(void *privdata, void *key);//销毁值的函数    void (*valDestructor)(void *privdata, void *obj);&#125; dictType;</code></pre><p>ht属性是一个包含两个项的数组，数组中的每个项都是一个dictht哈希表，一般情况下，字典只使用ht[0]哈希表，ht[1]哈希表只会在对ht[0] 哈希表进行rehash时使用。</p><p>除了ht[1]之外，另一个和rehash有关的属性就是rehashidx，它记录 了rehash目前的进度，如果目前没有在进行rehash，那么它的值为-1。</p><p>下图展示了一个普通状态下（没有进行rehash）的字典:</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221126162443189.png" alt="image-20221126162443189"></p><h2 id="3-2-哈希算法"><a href="#3-2-哈希算法" class="headerlink" title="3.2 哈希算法"></a>3.2 哈希算法</h2><p>当要将一个新的键值对添加到字典里面时，程序需要先根据键值对的<strong>键</strong>计算出<strong>哈希值和索引值</strong>，然后再根据索引值，将包含新键值对的哈希表节点放到哈希表数组的指定索引上面。</p><p>Redis计算哈希值和索引值的方法如下：</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221128143944340.png" alt="image-20221128143944340"></p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221128144302131.png" alt="image-20221128144302131"></p><p>举个例子，对于上图所示的字典来说，如果我们要将一个键值对 k0和v0添加到字典里面，那么程序会先使用语句：</p><pre><code class="c">hash = dict-&gt;type-&gt;hashFunction(k0);</code></pre><p>计算键k0的哈希值。 假设计算得出的哈希值为8，那么程序会继续使用语句：</p><pre><code class="c">index = hash&amp;dict-&gt;ht[0].sizemask = 8 &amp; 3 = 0;</code></pre><p>计算出键k0的索引值0，这表示包含键值对k0和v0的节点应该被放 置到哈希表数组的索引0位置上，如图所示:</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221128144601263.png" alt="image-20221128144601263"></p><h2 id="3-3-解决键冲突"><a href="#3-3-解决键冲突" class="headerlink" title="3.3 解决键冲突"></a>3.3 解决键冲突</h2><p>当有两个或以上数量的键被分配到了哈希表数组的同一个索引上面 时，我们称这些键发生了冲突（collision）。</p><p>Redis的哈希表使用<strong>链地址法（separate chaining）</strong>来解决键冲突， 每个哈希表节点都有一个next指针，多个哈希表节点可以用next指针构 成一个单向链表，被分配到同一个索引上的多个节点可以用这个单向链表连接起来，这就解决了键冲突的问题。</p><p>举个例子，假设程序要将键值对k2和v2添加到下图所示的哈希表 里面，并且计算得出k2的索引值为2，那么键k1和k2将产生冲突，而解 决冲突的办法就是使用next指针将键k2和k1所在的节点连接起来.</p><p> 因为dictEntry节点组成的链表没有指向链表表尾的指针，所以为了 速度考虑，程序总是将新节点添加到链表的表头位置（复杂度为 O（1）），排在其他已有节点的前面。</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221128144959193.png" alt="image-20221128144959193"></p><h2 id="3-4-rehash"><a href="#3-4-rehash" class="headerlink" title="3.4 rehash"></a>3.4 rehash</h2><p>随着操作的不断执行，哈希表保存的键值对会逐渐地增多或者减 少，为了让哈希表的负载因子（load factor）维持在一个合理的范围之 内，当哈希表保存的键值对数量太多或者太少时，程序需要对哈希表的 大小进行相应的扩展或者收缩。</p><p>扩展和收缩哈希表的工作可以通过执行rehash（重新散列）操作来 完成，Redis对字典的哈希表执行rehash的步骤如下：</p><p>1）为字典的ht[1]哈希表分配空间，这个哈希表的空间大小取决于 要执行的操作，以及ht[0]当前包含的键值对数量（也即是ht[0].used属性 的值）：</p><ul><li><p>如果执行的是扩展操作，那么ht[1]的大小为第一个大于等于 ht[0].used*2的2 n （2的n次方幂）；</p></li><li><p>如果执行的是收缩操作，那么ht[1]的大小为第一个大于等于 ht[0].used的2 n 。</p></li></ul><p>2）将保存在ht[0]中的所有键值对rehash到ht[1]上面：rehash指的是 重新计算键的哈希值和索引值，然后将键值对放置到ht[1]哈希表的指定 位置上。</p><p>3）当ht[0]包含的所有键值对都迁移到了ht[1]之后（ht[0]变为空 表），释放ht[0]，将ht[1]设置为ht[0]，并在ht[1]新创建一个空白哈希表，为下一次rehash做准备。</p><p>举个例子，假设程序要对图4-8所示字典的ht[0]进行扩展操作，那 么程序将执行以下步骤：</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221128145744248.png" alt="image-20221128145744248"></p><p>1）ht[0].used当前的值为4，4*2&#x3D;8，而8（2的3次方 ）恰好是第一个大于 等于4的2的n次方，所以程序会将ht[1]哈希表的大小设置为8。图4-9展 示了ht[1]在分配空间之后，字典的样子。</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221128145845678.png" alt="image-20221128145845678"></p><p>2）将ht[0]包含的四个键值对都rehash到ht[1]，如图4-10所示。</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221128145926852.png" alt="image-20221128145926852"></p><p>3）释放ht[0]，并将ht[1]设置为ht[0]，然后为ht[1]分配一个空白哈 希表，如图4-11所示。至此，对哈希表的扩展操作执行完毕，程序成功 将哈希表的大小从原来的4改为了现在的8。</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221128145941894.png" alt="image-20221128145941894"></p><blockquote><p>哈希表的扩展与收缩:</p><p>​当以下条件中的任意一个被满足时，程序会自动开始对哈希表执行 扩展操作：</p><p>1）服务器目前没有在执行BGSAVE命令或者BGREWRITEAOF命 令，并且哈希表的负载因子大于等于1。</p><p>2）服务器目前正在执行BGSAVE命令或者BGREWRITEAOF命 令，并且哈希表的负载因子大于等于5。</p><p>其中哈希表的负载因子可以通过公式：</p><p>负载因子&#x3D; 哈希表已保存节点数量&#x2F; 哈希表大小 load_factor &#x3D; ht[0].used &#x2F; ht[0].size</p><p>计算得出。 例如，对于一个大小为4，包含4个键值对的哈希表来说，这个哈希 表的负载因子为：</p><p>load_factor &#x3D; 4 &#x2F; 4 &#x3D; 1</p><p>根据BGSAVE命令或BGREWRITEAOF命令是否正在执行，服务器 执行扩展操作所需的负载因子并不相同，这是因为在执行BGSAVE命令 或BGREWRITEAOF命令的过程中，Redis需要创建当前服务器进程的子 进程，而大多数操作系统都采用写时复制（copy-on-write）技术来优化 子进程的使用效率，所以在子进程存在期间，服务器会提高执行扩展操 作所需的负载因子，从而尽可能地避免在子进程存在期间进行哈希表扩 展操作，这可以避免不必要的内存写入操作，最大限度地节约内存。 另一方面，当哈希表的负载因子小于0.1时，程序自动开始对哈希 表执行收缩操作。</p></blockquote><h2 id="3-5-渐进式rehash"><a href="#3-5-渐进式rehash" class="headerlink" title="3.5 渐进式rehash"></a>3.5 渐进式rehash</h2><p>上一节说过，扩展或收缩哈希表需要将ht[0]里面的所有键值对 rehash到ht[1]里面，但是，这个rehash动作并不是一次性、集中式地完成 的，而是分多次、渐进式地完成的。</p><p> 这样做的原因在于，如果ht[0]里只保存着四个键值对，那么服务器 可以在瞬间就将这些键值对全部rehash到ht[1]；但是，如果哈希表里保 存的键值对数量不是四个，而是四百万、四千万甚至四亿个键值对，那 么要一次性将这些键值对全部rehash到ht[1]的话，庞大的计算量可能会 导致服务器在一段时间内停止服务。</p><p> 因此，为了避免rehash对服务器性能造成影响，服务器不是一次性 将ht[0]里面的所有键值对全部rehash到ht[1]，而是分多次、渐进式地将 ht[0]里面的键值对慢慢地rehash到ht[1]。</p><p> 以下是哈希表渐进式rehash的详细步骤：</p><ul><li><p>为ht[1]分配空间，让字典同时持有ht[0]和ht[1]两个哈希表。 </p></li><li><p>在字典中维持一个索引计数器变量rehashidx，并将它的值设置 为0，表示rehash工作正式开始。 </p></li><li><p>在rehash进行期间，每次对字典执行添加、删除、查找或者更新 操作时，程序除了执行指定的操作以外，还会顺带将ht[0]哈希表在 rehashidx索引上的所有键值对rehash到ht[1]，当rehash工作完成之后，程序将rehashidx属性的值增一。 </p></li><li><p>随着字典操作的不断执行，最终在某个时间点上，ht[0]的所有 键值对都会被rehash至ht[1]，这时程序将rehashidx属性的值设为-1，表 示rehash操作已完成。</p></li></ul><p> 渐进式rehash的好处在于它采取分而治之的方式，将rehash键值对 所需的计算工作均摊到对字典的每个添加、删除、查找和更新操作上， 从而避免了集中式rehash而带来的庞大计算量。</p><p>渐进式rehash执行期间的哈希表操作 因为在进行渐进式rehash的过程中，字典会同时使用ht[0]和ht[1]两 个哈希表，所以在渐进式rehash进行期间，字典的删除（delete）、查找 （find）、更新（update）等操作会在两个哈希表上进行。例如，要在 字典里面查找一个键的话，程序会先在ht[0]里面进行查找，如果没找到 的话，就会继续到ht[1]里面进行查找，诸如此类。 <strong>另外，在渐进式rehash执行期间，新添加到字典的键值对一律会被 保存到ht[1]里面</strong>，而ht[0]则不再进行任何添加操作，这一措施保证了 ht[0]包含的键值对数量会只减不增，并随着rehash操作的执行而最终变成空表。</p><h2 id="3-6-字典API"><a href="#3-6-字典API" class="headerlink" title="3.6 字典API"></a>3.6 字典API</h2><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221128150903829.png" alt="image-20221128150903829"></p><h2 id="3-7-小结"><a href="#3-7-小结" class="headerlink" title="3.7 小结"></a>3.7 小结</h2><ul><li><p>字典被广泛用于实现Redis的各种功能，其中包括数据库和哈希 键。</p></li><li><p>Redis中的字典使用<strong>哈希表作为底层实现</strong>，每个字典带有两个哈希 表，一个平时使用，另一个仅在进行rehash时使用。</p></li><li><p>当字典被用作数据库的底层实现，或者哈希键的底层实现时， Redis使用MurmurHash2算法来计算键的哈希值。</p></li><li><p>哈希表使用<strong>链地址法</strong>来解决键冲突，被分配到同一个索引上的多 个键值对会连接成一个单向链表。</p></li><li><p>在对哈希表进行扩展或者收缩操作时，程序需要将现有哈希表包含的所有键值对rehash到新哈希表里面，并且这个rehash过程并不是一次 性地完成的，而是<strong>渐进式地完成的。</strong></p></li></ul><h1 id="四-跳跃表"><a href="#四-跳跃表" class="headerlink" title="四. 跳跃表"></a>四. 跳跃表</h1><p>​跳跃表（skiplist）是一种有序数据结构，它通过在每个节点中维持 多个指向其他节点的指针，从而达到快速访问节点的目的。跳跃表支持<strong>平均O（logN）</strong>、<strong>最坏O（N）</strong>复杂度的节点查找，还可 以通过顺序性操作来批量处理节点。</p><p>​Redis使用跳跃表作为有序集合键的底层实现之一，如果一个有序 集合包含的元素数量比较多，又或者有序集合中元素的成员 （member）是比较长的字符串时，Redis就会使用跳跃表来作为有序集 合键的底层实现。</p><p>​和链表、字典等数据结构被广泛地应用在Redis内部不同，Redis只 在两个地方用到了跳跃表，一个是<strong>实现有序集合键</strong>，另一个是<strong>在集群节点中用作内部数据结构</strong>，除此之外，跳跃表在Redis里面没有其他用途。</p><h2 id="4-1-跳跃表的实现"><a href="#4-1-跳跃表的实现" class="headerlink" title="4.1 跳跃表的实现"></a>4.1 跳跃表的实现</h2><p>​Redis的跳跃表由redis.h&#x2F;zskiplistNode和redis.h&#x2F;zskiplist两个结构定 义，其中zskiplistNode结构用于表示跳跃表节点，而zskiplist结构则用于保存跳跃表节点的相关信息，比如节点的数量，以及指向表头节点和表 尾节点的指针等等。</p><p>​<img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221202170247578.png" alt="image-20221202170247578"></p><p>上图展示了一个跳跃表的示例,最左边的是zskiplist结构,其包含了:</p><ul><li><p>header：指向跳跃表的表头节点。</p></li><li><p>tail：指向跳跃表的表尾节点。</p><ul><li>level：记录目前跳跃表内，层数最大的那个节点的层数（表头节 点的层数不计算在内）。</li></ul></li><li><p>length：记录跳跃表的长度，也即是，跳跃表目前包含节点的数 量（表头节点不计算在内）。</p></li></ul><p>位于zskiplist结构右方的是四个zskiplistNode结构，该结构包含以下属性：</p><blockquote><p>层（level）：节点中用L1、L2、L3等字样标记节点的各个层，L1 代表第一层，L2代表第二层，以此类推。每个层都带有两个属性：前进 指针和跨度。前进指针用于访问位于表尾方向的其他节点，而跨度则记 录了前进指针所指向节点和当前节点的距离。在上面的图片中，连线上 带有数字的箭头就代表前进指针，而那个数字就是跨度。当程序从表头 向表尾进行遍历时，访问会沿着层的前进指针进行。</p><p>后退（backward）指针：节点中用BW字样标记节点的后退指 针，它指向位于当前节点的前一个节点。后退指针在程序从表尾向表头 遍历时使用。</p><p>分值（score）：各个节点中的1.0、2.0和3.0是节点所保存的分值。在跳跃表中，节点按各自所保存的分值从小到大排列。</p><p>成员对象（obj）：各个节点中的o1、o2和o3是节点所保存的成员 对象。</p></blockquote><p>注意表头节点和其他节点的构造是一样的：表头节点也有后退指 针、分值和成员对象，不过表头节点的这些属性都不会被用到，所以图 中省略了这些部分，只显示了表头节点的各个层。</p><h3 id="4-1-1-跳跃表节点"><a href="#4-1-1-跳跃表节点" class="headerlink" title="4.1.1 跳跃表节点"></a>4.1.1 跳跃表节点</h3><p>跳跃表节点的实现由redis.h&#x2F;zskiplistNode结构定义：</p><pre><code class="c">typedef struct zskiplistNode &#123;    //    层    struct zskiplistLevel &#123;        //        前进指针        struct zskiplistNode *forward;        //        跨度        unsigned int span;    &#125; level[];    //    后退指针    struct zskiplistNode *backward;    //    分值    double score;    //    成员对象    robj *obj;&#125; zskiplistNode;</code></pre><h4 id="层"><a href="#层" class="headerlink" title="层"></a>层</h4><p>​跳跃表节点的level数组可以包含多个元素，每个元素都包含一个指 向其他节点的指针，程序可以通过这些层来加快访问其他节点的速度， 一般来说，层的数量越多，访问其他节点的速度就越快。 每次创建一个新跳跃表节点的时候，程序都根据<strong>幂次定律</strong>（power law，越大的数出现的概率越小）随机生成一个介于1和32之间的值作为 level数组的大小，这个大小就是层的“高度”。</p><p>如图,表示1,3,5层的节点:</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221202171716184.png" alt="image-20221202171716184"></p><h4 id="前进指针"><a href="#前进指针" class="headerlink" title="前进指针"></a>前进指针</h4><p>每个层都有一个指向表尾方向的前进指针（level[i].forward属 性），用于从表头向表尾方向访问节点。图5-3用虚线表示出了程序从 表头向表尾方向，遍历跳跃表中所有节点的路径：</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221202171809793.png" alt="image-20221202171809793"></p><h4 id="跨度"><a href="#跨度" class="headerlink" title="跨度"></a>跨度</h4><p>层的跨度（level[i].span属性）用于记录两个节点之间的距离：</p><ul><li><p>两个节点之间的跨度越大，它们相距得就越远。</p></li><li><p>指向NULL的所有前进指针的跨度都为0，因为它们没有连向任何节点。</p></li></ul><p>​初看上去，很容易以为跨度和遍历操作有关，但实际上并不是这样，遍历操作只使用前进指针就可以完成了，跨度实际上是用来计算排位（rank）的：在查找某个节点的过程中，将沿途访问过的所有层的跨度累计起来，得到的结果就是目标节点在跳跃表中的排位。</p><p>​举个例子，图5-4用虚线标记了在跳跃表中查找分值为3.0、成员对象为o3的节点时，沿途经历的层：查找的过程只经过了一个层，并且层 的跨度为3，所以目标节点在跳跃表中的排位为3。</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221202172453497.png" alt="image-20221202172453497"></p><p>​再举个例子，图5-5用虚线标记了在跳跃表中查找分值为2.0、成员 对象为o2的节点时，沿途经历的层：在查找节点的过程中，程序经过了 两个跨度为1的节点，因此可以计算出，目标节点在跳跃表中的排位为 2。</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221202172620260.png" alt="image-20221202172620260"></p><h4 id="后退指针"><a href="#后退指针" class="headerlink" title="后退指针"></a>后退指针</h4><p>​节点的后退指针（backward属性）用于从表尾向表头方向访问节 点：跟可以一次跳过多个节点的前进指针不同，因为每个节点只有一个 后退指针，所以每次只能后退至前一个节点。</p><p>​ 图5-6用虚线展示了如果从表尾向表头遍历跳跃表中的所有节点： 程序首先通过跳跃表的tail指针访问表尾节点，然后通过后退指针访问 倒数第二个节点，之后再沿着后退指针访问倒数第三个节点，再之后遇 到指向NULL的后退指针，于是访问结束。</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221202172734155.png" alt="image-20221202172734155"></p><h4 id="分值和成员"><a href="#分值和成员" class="headerlink" title="分值和成员"></a>分值和成员</h4><p>​节点的分值（score属性）是一个double类型的浮点数，跳跃表中的 所有节点都按分值从小到大来排序。 节点的成员对象（obj属性）是一个指针，它指向一个字符串对象，而字符串对象则保存着一个SDS值。</p><p>​在同一个跳跃表中，<strong>各个节点保存的成员对象必须是唯一的</strong>，但是 多个节点保存的分值却可以是相同的：分值相同的节点将按照<strong>成员对象在字典序中的大小来进行排序，</strong>成员对象较小的节点会排在前面（靠近表头的方向），而成员对象较大的节点则会排在后面（靠近表尾的方向）。</p><p>​举个例子，在图5-7所示的跳跃表中，三个跳跃表节点都保存了相 同的分值10086.0，但保存成员对象o1的节点却排在保存成员对象o2和 o3的节点之前，而保存成员对象o2的节点又排在保存成员对象o3的节点 之前，由此可见，o1、o2、o3三个成员对象在字典中的排序为 o1&lt;&#x3D;o2&lt;&#x3D;o3。</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221202173152283.png" alt="image-20221202173152283"></p><h3 id="4-1-2-跳跃表"><a href="#4-1-2-跳跃表" class="headerlink" title="4.1.2 跳跃表"></a>4.1.2 跳跃表</h3><p>​仅靠多个跳跃表节点就可以组成一个跳跃表，但通过使用一个zskiplist结构来持有这些节点，程序可以更方便地 对整个跳跃表进行处理，比如快速访问跳跃表的表头节点和表尾节点， 或者快速地获取跳跃表节点的数量（也即是跳跃表的长度）等信息.</p><p>zskiplist结构的定义如下：</p><pre><code class="c">typedef struct zskiplist &#123;    //    表头节点和表尾节点    structz skiplistNode *header, *tail;    //    表中节点的数量    unsigned long length;    //    表中层数最大的节点的层数    int level;&#125; zskiplist;</code></pre><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221202172734155.png" alt="image-20221202172734155"></p><ul><li><p>header和tail指针分别指向跳跃表的表头和表尾节点，通过这两个指针，程序定位表头节点和表尾节点的复杂度为O(1) </p></li><li><p>通过使用length属性来记录节点的数量，程序可以在O（1）复杂度 内返回跳跃表的长度.</p></li><li><p>level属性则用于在O(1)复杂度内获取跳跃表中层高最大的那个节点的层数量，注意表头节点的层高并不计算在内。</p></li></ul><h2 id="4-2-跳跃表API"><a href="#4-2-跳跃表API" class="headerlink" title="4.2 跳跃表API"></a>4.2 跳跃表API</h2><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221202173930062.png" alt="image-20221202173930062"></p><h2 id="4-3-总结"><a href="#4-3-总结" class="headerlink" title="4.3 总结"></a>4.3 总结</h2><ul><li>跳跃表是有序集合的底层实现之一。</li><li>Redis的跳跃表实现由zskiplist和zskiplistNode两个结构组成，其中 zskiplist用于保存跳跃表信息（比如表头节点、表尾节点、长度），而 zskiplistNode则用于表示跳跃表节点。</li><li>每个跳跃表节点的层高都是1至32之间的随机数。</li><li>在同一个跳跃表中，多个节点可以包含相同的分值，但每个节点 的成员对象必须是唯一的。 </li><li>跳跃表中的节点按照分值大小进行排序，当分值相同时，节点按照成员对象的大小进行排序。</li></ul><h1 id="五-整数集合"><a href="#五-整数集合" class="headerlink" title="五.整数集合"></a>五.整数集合</h1><p>整数集合（intset）是集合键的底层实现之一，当一个集合只包含整 数值元素，并且这个集合的元素数量不多时，Redis就会使用整数集合 作为集合键的底层实现。</p><h2 id="5-1-整数集合的实现"><a href="#5-1-整数集合的实现" class="headerlink" title="5.1 整数集合的实现"></a>5.1 整数集合的实现</h2><p>​数集合（intset）是Redis用于保存整数值的集合抽象数据结构， 它可以保存类型为int16_t、int32_t或者int64_t的整数值，并且保证集合中不会出现重复元素。</p><p>​每个intset.h&#x2F;intset结构表示一个整数集合：</p><pre><code class="c">typedef struct intset &#123;    //    编码方式    uint32_t encoding;    //    集合包含的元素数量    uint32_t length;    //    保存元素的数组    int8_t contents[];&#125;  intset;</code></pre><p>contents数组是整数集合的底层实现：整数集合的每个元素都是 contents数组的一个数组项（item），各个项在数组中按值的大小从<strong>小到大</strong>有序地排列，并且数组中不包含任何重复项。</p><p>虽然intset结构将contents属性声明为int8_t类型的数组，但实际上contents数组并不保存任何int8_t类型的值，contents数组的真正类型取决 于encoding属性的值：</p><blockquote><ul><li><p>如果encoding属性的值为INTSET_ENC_INT16，那么contents就是 一个int16_t类型的数组，数组里的每个项都是一个int16_t类型的整数值 （最小值为-32768，最大值为32767）。</p></li><li><p>如果encoding属性的值为INTSET_ENC_INT32，那么contents就是 一个int32_t类型的数组，数组里的每个项都是一个int32_t类型的整数值 （最小值为-2147483648，最大值为2147483647）。</p></li><li><p>如果encoding属性的值为INTSET_ENC_INT64，那么contents就是 一个int64_t类型的数组，数组里的每个项都是一个int64_t类型的整数值 （最小值为-9223372036854775808，最大值为9223372036854775807）。</p></li></ul></blockquote><h2 id="5-2-升级"><a href="#5-2-升级" class="headerlink" title="5.2 升级"></a>5.2 升级</h2><p>每当我们要将一个新元素添加到整数集合里面，并且新元素的类型 比整数集合现有所有元素的类型都要长时，整数集合需要<strong>先进行升级</strong> （upgrade），然后才能将新元素添加到整数集合里面。</p><p>升级整数集合并添加新元素共分为三步进行：</p><p>1）<strong>根据新元素的类型，扩展整数集合底层数组的空间大小，并为新元素分配空间。</strong></p><p> 2）将底层数组现有的所有元素都转换成与新元素相同的类型，并将类型转换后的元素放置到正确的位上，而且在放置元素的过程中，需要继续维持底层数组的有序性质不变。</p><p> 3）将新元素添加到底层数组里面。</p><p>例:</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221212223708045.png" alt="image-20221212223708045"></p><p>因为每个元素都占用16位空间，所以整数集合底层数组的大小为 3*16&#x3D;48位，图6-4展示了整数集合的三个元素在这48位里的位置。</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221212223729861.png" alt="image-20221212223729861"></p><p>现在，假设我们要将类型为int32_t的整数值65535添加到整数集合 里面，因为65535的类型int32_t比整数集合当前所有元素的类型都要长，所以在将65535添加到整数集合之前，程序需要先对整数集合进行升级。</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221212224052748.png" alt="image-20221212224052748"></p><p>然后每三十二位存一个元素</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221212224150933.png" alt="image-20221212224150933"></p><p>最后，程序将整数集合encoding属性的值从INTSET_ENC_INT16改 为INTSET_ENC_INT32，并将length属性的值从3改为4.<img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221212224213024.png" alt="image-20221212224213024"></p><h2 id="5-3-升级的益处"><a href="#5-3-升级的益处" class="headerlink" title="5.3 升级的益处"></a>5.3 升级的益处</h2><p>整数集合的升级策略有两个好处，一个是提升整数集合的灵活性， 另一个是尽可能地节约内存。</p><h3 id="5-3-1-提升灵活性"><a href="#5-3-1-提升灵活性" class="headerlink" title="5.3.1 提升灵活性"></a>5.3.1 提升灵活性</h3><p>因为C语言是静态类型语言，为了避免类型错误，我们通常不会将两种不同类型的值放在同一个数据结构里面。 </p><p>例如，我们一般只使用int16_t类型的数组来保存int16_t类型的值， 只使用int32_t类型的数组来保存int32_t类型的值，诸如此类。</p><p> 但是，因为整数集合可以通过自动升级底层数组来适应新元素，所 以我们可以随意地将int16_t、int32_t或者int64_t类型的整数添加到集合 中，而不必担心出现类型错误，这种做法非常灵活。</p><h3 id="5-3-2-节约内存"><a href="#5-3-2-节约内存" class="headerlink" title="5.3.2 节约内存"></a>5.3.2 节约内存</h3><p>要让一个数组可以同时保存int16_t、int32_t、int64_t三种类 型的值，最简单的做法就是直接使用int64_t类型的数组作为整数集合的 底层实现。不过这样一来，即使添加到整数集合里面的都是int16_t类型 或者int32_t类型的值，数组都需要使用int64_t类型的空间去保存它们， 从而出现浪费内存的情况。 </p><p>而整数集合现在的做法既可以让集合能同时保存三种不同类型的 值，又可以确保升级操作只会在有需要的时候进行，这可以尽量节省内 存。 例如，如果我们一直只向整数集合添加int16_t类型的值，那么整数 集合的底层实现就会一直是int16_t类型的数组，只有在我们要将int32_t 类型或者int64_t类型的值添加到集合时，程序才会对数组进行升级。</p><h2 id="5-4-降级"><a href="#5-4-降级" class="headerlink" title="5.4 降级"></a>5.4 降级</h2><p><strong>整数集合不支持降级操作，一旦对数组进行了升级，编码就会一直保持升级后的状态。</strong></p><h2 id="5-5-整数集合API"><a href="#5-5-整数集合API" class="headerlink" title="5.5 整数集合API"></a>5.5 整数集合API</h2><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221212224603351.png" alt="image-20221212224603351"></p><h2 id="5-6-总结"><a href="#5-6-总结" class="headerlink" title="5.6 总结"></a>5.6 总结</h2><ul><li>整数集合是集合键的底层实现之一。</li><li>整数集合的底层实现为数组，这个数组以有序、无重复的方式保 存集合元素，在有需要时，程序会根据新添加元素的类型，改变这个数 组的类型。</li><li>升级操作为整数集合带来了操作上的灵活性，并且尽可能地节约 了内存。</li><li>整数集合只支持升级操作，不支持降级操作</li></ul><h1 id="六-压缩列表"><a href="#六-压缩列表" class="headerlink" title="六.压缩列表"></a>六.压缩列表</h1><h2 id="6-1-压缩列表的组成"><a href="#6-1-压缩列表的组成" class="headerlink" title="6.1 压缩列表的组成"></a>6.1 压缩列表的组成</h2><p>压缩列表是Redis为了节约内存而开发的，是由一系列特殊编码的 连续内存块组成的顺序型（sequential）数据结构。一个压缩列表可以包 含任意多个节点（entry），每个节点可以保存一个字节数组或者一个整数值。</p><p>下图展示了压缩列表的各个组成部分，表则记录了各个组成部 分的类型、长度以及用途。</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221215210946269.png" alt="image-20221215210946269"></p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221215211014809.png" alt="image-20221215211014809"></p><ul><li>列表zlbytes属性的值为0x50（十进制80），表示压缩列表的总长为80字节。</li><li>列表zltail属性的值为0x3c（十进制60），这表示如果我们有一个指向压缩列表起始地址的指针p，那么只要用指针p加上偏移量60，就可 以计算出表尾节点entry3的地址。</li><li>列表zllen属性的值为0x3（十进制3），表示压缩列表包含三个节点。</li></ul><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221215211112370.png" alt="image-20221215211112370"></p><h2 id="6-2-压缩列表节点的构成"><a href="#6-2-压缩列表节点的构成" class="headerlink" title="6.2 压缩列表节点的构成"></a>6.2 压缩列表节点的构成</h2><p>每个压缩列表节点可以保存一个字节数组或者一个整数值，其中，字节数组可以是<strong>以下三种长度的其中一种</strong>：</p><ul><li>长度小于等于63（2^6 –1）字节的字节数组；</li><li>长度小于等于16383（2^14 –1）字节的字节数组；</li><li>长度小于等于4294967295（^ 32 –1）字节的字节数组；</li></ul><p>而整数值则可以是以下<strong>六种长度的其中一种</strong>：</p><ul><li>4位长，介于0至12之间的无符号整数；</li><li>1字节长的有符号整数；</li><li>3字节长的有符号整数；</li><li>int16_t类型整数；</li><li>int32_t类型整数；</li><li>int64_t类型整数。</li></ul><p>每个压缩列表节点都由previous_entry_length、encoding、content三个部分组成，如图7-4所示。</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221215212324238.png" alt="image-20221215212324238"></p><h3 id="6-2-1-previous-entry-length"><a href="#6-2-1-previous-entry-length" class="headerlink" title="6.2.1 previous_entry_length"></a>6.2.1 previous_entry_length</h3><p>节点的previous_entry_length属性以<strong>字节为单位</strong>，记录了压缩列表中<strong>前一个节点的长度</strong>。previous_entry_length属性的长度可以是1字节或者5 字节：</p><ul><li>如果前一节点的长度小于254字节，那么previous_entry_length属性 的长度为1字节：前一节点的长度就保存在这一个字节里面。</li><li>如果前一节点的长度大于等于254字节，那么previous_entry_length 属性的长度为5字节：其中属性的第一字节会被设置为0xFE（十进制值 254），而之后的四个字节则用于保存前一节点的长度。</li></ul><p>下图展示了一个包含五字节长previous_entry_length属性的压缩节点，属性的值为0xFE00002766，其中值的最高位字节0xFE表示这是一 个五字节长的previous_entry_length属性，而之后的四字节 0x00002766（十进制值10086）才是前一节点的实际长度。</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221215213506222.png" alt="image-20221215213506222"></p><p>压缩列表的从表尾向表头遍历操作就是使用这一原理实现的，只要 我们拥有了一个指向某个节点起始地址的指针，那么通过这个指针以及 这个节点的previous_entry_length属性，程序就可以一直向前一个节点回 溯，最终到达压缩列表的表头节点。</p><h3 id="6-2-2-encoding"><a href="#6-2-2-encoding" class="headerlink" title="6.2.2 encoding"></a>6.2.2 encoding</h3><p>节点的encoding属性记录了节点的content属性所保存数据的类型以 及长度：</p><ul><li><p>一字节、两字节或者五字节长，值的最高位为00、01或者10的是 字节数组编码：这种编码表示节点的content属性保存着字节数组，数组 的长度由编码除去最高两位之后的其他位记录；</p></li><li><p>一字节长，值的最高位以11开头的是整数编码：这种编码表示节 点的content属性保存着整数值，整数值的类型和长度由编码除去最高两位之后的其他位记录；</p></li></ul><p>字节数组编码:</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221215214419305.png" alt="image-20221215214419305"></p><p>整数编码:</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221215214431998.png" alt="image-20221215214431998"></p><h3 id="6-2-3-content"><a href="#6-2-3-content" class="headerlink" title="6.2.3 content"></a>6.2.3 content</h3><p>节点的content属性负责保存节点的值，节点值可以是一个字节数组 或者整数，值的类型和长度由节点的encoding属性决定。</p><p>实例:</p><ul><li><p>编码的最高两位00表示节点保存的是一个字节数组；</p></li><li><p>编码的后六位001011记录了字节数组的长度11；</p></li><li><p>content属性保存着节点的值”hello world”。</p></li></ul><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221215214753016.png" alt="image-20221215214753016"></p><p>下图展现了一个保存整数的节点:</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221215214829029.png" alt="image-20221215214829029"></p><ul><li><p>编码11000000表示节点保存的是一个int16_t类型的整数值；</p></li><li><p>content属性保存着节点的值10086。</p></li></ul><h2 id="6-3-连锁更新"><a href="#6-3-连锁更新" class="headerlink" title="6.3 连锁更新"></a>6.3 连锁更新</h2><p>前面说过，每个节点的previous_entry_length属性都记录了前一个节 点的长度：</p><ul><li>如果前一节点的长度小于254字节，那么previous_entry_length属性 需要用1字节长的空间来保存这个长度值。</li><li>如果前一节点的长度大于等于254字节，那么previous_entry_length 属性需要用5字节长的空间来保存这个长度值。</li></ul><p>现在，考虑这样一种情况：在一个压缩列表中，有多个连续的、长 度介于250字节到253字节之间的节点e1至eN，如图:</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221215215050095.png" alt="image-20221215215050095"></p><p>因为e1至eN的所有节点的长度都小于254字节，所以记录这些节点 的长度只需要1字节长的previous_entry_length属性，换句话说，e1至eN 的所有节点的previous_entry_length属性都是1字节长的。 这时，如果我们将一个长度大于等于254字节的新节点new设置为压 缩列表的表头节点，那么new将成为e1的前置节点,如图:</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221215215112736.png" alt="image-20221215215112736"></p><p>​因为e1的previous_entry_length属性仅长1字节，它没办法保存新节 点new的长度，所以程序将对压缩列表执行空间重分配操作，并将e1节 点的previous_entry_length属性从原来的1字节长扩展为5字节长。</p><p>​现在，麻烦的事情来了，e1原本的长度介于250字节至253字节之 间，在为previous_entry_length属性新增四个字节的空间之后，e1的长度 就变成了介于254字节至257字节之间，而这种长度使用1字节长的 previous_entry_length属性是没办法保存的。</p><p>​因此，为了让e2的previous_entry_length属性可以记录下e1的长度， 程序需要再次对压缩列表执行空间重分配操作，并将e2节点的 previous_entry_length属性从原来的1字节长扩展为5字节长。 正如扩展e1引发了对e2的扩展一样，扩展e2也会引发对e3的扩展， 而扩展e3又会引发对e4的扩展……为了让每个节点的 previous_entry_length属性都符合压缩列表对节点的要求，程序需要不断 地对压缩列表执行空间重分配操作，直到eN为止。</p><p>Redis将这种在特殊情况下产生的连续多次空间扩展操作称之为<strong>“连锁更新”</strong></p><p>除了添加新节点可能会引发连锁更新之外，删除节点也可能会引发 连锁更新。</p><p>考虑下图所示的压缩列表，如果e1至eN都是大小介于250字节至 253字节的节点，big节点的长度大于等于254字节（需要5字节的 previous_entry_length来保存），而small节点的长度小于254字节（只需 要1字节的previous_entry_length来保存），那么当我们将small节点从压 缩列表中删除之后，为了让e1的previous_entry_length属性可以记录big 节点的长度，程序将扩展e1的空间，并由此引发之后的连锁更新。</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221215220921298.png" alt="image-20221215220921298"></p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221215221106093.png" alt="image-20221215221106093"></p><p>因为连锁更新在最坏情况下需要对压缩列表执行N次空间重分配操 作，而每次空间重分配的最坏复杂度为O（N），所以连锁更新的最坏 复杂度为O（N 2 ）。 要注意的是，尽管连锁更新的复杂度较高，但它真正造成性能问题 的几率是很低的：</p><ul><li>首先，压缩列表里要恰好有多个连续的、长度介于250字节至253 字节之间的节点，连锁更新才有可能被引发，在实际中，这种情况并不 多见；</li><li>其次，即使出现连锁更新，但只要被更新的节点数量不多，就不 会对性能造成任何影响：比如说，对三五个节点进行连锁更新是绝对不 会影响性能的；</li></ul><p>因为以上原因，ziplistPush等命令的平均复杂度仅为O（N），在实 际中，我们可以放心地使用这些函数，而不必担心连锁更新会影响压缩 列表的性能。</p><h2 id="6-4-压缩列表api"><a href="#6-4-压缩列表api" class="headerlink" title="6.4 压缩列表api"></a>6.4 压缩列表api</h2><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221215221236106.png" alt="image-20221215221236106"></p><p>因为ziplistPush、ziplistInsert、ziplistDelete和ziplistDeleteRange四个 函数都有可能会引发连锁更新，所以它们的最坏复杂度都是O（N2）。</p><h2 id="6-5-总结"><a href="#6-5-总结" class="headerlink" title="6.5 总结"></a>6.5 总结</h2><ul><li>压缩列表是一种为节约内存而开发的顺序型数据结构。</li><li>压缩列表被用作列表键和哈希键的底层实现之一。</li><li>压缩列表可以包含多个节点，每个节点可以保存一个字节数组或 者整数值</li><li>添加新节点到压缩列表，或者从压缩列表中删除节点，可能会引 发连锁更新操作，但这种操作出现的几率并不高。</li></ul><h1 id="七-对象"><a href="#七-对象" class="headerlink" title="七.对象"></a>七.对象</h1><p>redis基于前面的简单动态字符串（SDS）、双端链表、字典、压缩列表、整数集合等创造了一个对象系统. 这个系统包含字符串对象、列表对象、哈希对象、集合对象和有序集合对象这五种类型的对象，每种对 象都用到了至少一种我们前面所介绍的数据结构。</p><h2 id="7-1-对象的类型与编码"><a href="#7-1-对象的类型与编码" class="headerlink" title="7.1 对象的类型与编码"></a>7.1 对象的类型与编码</h2><p>Redis使用对象来表示数据库中的键和值，每次当我们在Redis的数 据库中新创建一个键值对时，我们至少会创建两个对象，一个对象用作 键值对的键（键对象），另一个对象用作键值对的值（值对象）。</p><p>举个例子，以下SET命令在数据库中创建了一个新的键值对，其中 键值对的键是一个包含了字符串值”msg”的对象，而键值对的值则是一 个包含了字符串值”hello world”的对象：</p><pre><code class="shell">redis&gt; SET msg &quot;hello world&quot;OK</code></pre><p>Redis中的每个对象都由一个redisObject结构表示，该结构中和保存 数据有关的三个属性分别是<strong>type属性、encoding属性和ptr属性：</strong></p><pre><code class="c">typedef struct redisObject &#123;//类型unsigned type:4;//编码unsigned encoding:4;//指向底层实现数据结构的指针void *ptr;// ...&#125; robj;</code></pre><h3 id="7-1-1-类型"><a href="#7-1-1-类型" class="headerlink" title="7.1.1 类型"></a>7.1.1 类型</h3><p>对象的type属性记录了对象的类型:</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230102194622417.png" alt="image-20230102194622417"></p><p>对于Redis数据库保存的键值对来说，键总是一个字符串对象，而 值则可以是字符串对象、列表对象、哈希对象、集合对象或者有序集合 对象的其中一种，因此：</p><ul><li>当我们称呼一个数据库键为“字符串键”时，我们指的是“这个 数据库键所对应的值为字符串对象”；</li><li>当我们称呼一个键为“列表键”时，我们指的是“这个数据库键 所对应的值为列表对象”。</li></ul><p>TYPE命令的实现方式也与此类似，当我们对一个数据库键执行 TYPE命令时，命令返回的结果<strong>为数据库键对应的值对象的类型，</strong>而不是键对象的类型：</p><pre><code class="shell">#键为字符串对象，值为字符串对象redis&gt; SET msg &quot;hello world&quot;OKredis&gt; TYPE msgstring#键为字符串对象，值为列表对象redis&gt; RPUSH numbers 1 3 5(integer) 6redis&gt; TYPE numberslist#键为字符串对象，值为哈希对象redis&gt; HMSET profile name Tom age 25 career ProgrammerOKredis&gt; TYPE profilehash#键为字符串对象，值为集合对象redis&gt; SADD fruits apple banana cherry(integer) 3redis&gt; TYPE fruitsset#键为字符串对象，值为有序集合对象redis&gt; ZADD price 8.5 apple 5.0 banana 6.0 cherry(integer) 3redis&gt; TYPE pricezset</code></pre><p>下表列出了TYPE命令在面对不同类型的值对象时所产生的输出</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230102194900455.png" alt="image-20230102194900455"></p><h3 id="7-1-2-编码和底层实现"><a href="#7-1-2-编码和底层实现" class="headerlink" title="7.1.2 编码和底层实现"></a>7.1.2 编码和底层实现</h3><p>对象的ptr指针指向对象的底层实现数据结构，而这些数据结构由对 象的encoding属性决定。</p><p>encoding属性记录了对象所使用的编码，也即是说这个对象使用了 什么数据结构作为对象的底层实现，这个属性的值可以是下表列出的 常量的其中一个。</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230102194953231.png" alt="image-20230102194953231"></p><p>每种类型的对象都至少使用了两种不同的编码，下表列出了每种类型的对象可以使用的编码。</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230102195046913.png" alt="image-20230102195046913"></p><p>使用OBJECT ENCODING命令可以查看一个数据库键的值对象的编码：</p><pre><code class="shell">redis&gt; SET msg &quot;hello wrold&quot;OKredis&gt; OBJECT ENCODING msg&quot;embstr&quot;redis&gt; SET story &quot;long long long long long long ago ...&quot;OKredis&gt; OBJECT ENCODING story&quot;raw&quot;redis&gt; SADD numbers 1 3 5(integer) 3redis&gt; OBJECT ENCODING numbers&quot;intset&quot;redis&gt; SADD numbers &quot;seven&quot;(integer) 1redis&gt; OBJECT ENCODING numbers&quot;hashtable&quot;</code></pre><p>下表列出了不同编码的对象所对应的OBJECT ENCODING命令输出。</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230102201746354.png" alt="image-20230102201746354"></p><p>通过encoding属性来设定对象所使用的编码，而不是为特定类型的 对象关联一种固定的编码，极大地提升了Redis的灵活性和效率，因为 Redis可以根据不同的使用场景来为一个对象设置不同的编码，从而优 化对象在某一场景下的效率。</p><p>举个例子，在列表对象包含的元素比较少时，Redis使用压缩列表作为列表对象的底层实现：</p><ul><li><p>因为压缩列表比双端链表更节约内存，并且在元素数量较少时， 在内存中以连续块方式保存的压缩列表比起双端链表可以更快被载入到缓存中；</p></li><li><p>随着列表对象包含的元素越来越多，使用压缩列表来保存元素的 优势逐渐消失时，对象就会将底层实现从压缩列表转向功能更强、也更 适合保存大量元素的双端链表上面；</p></li></ul><h2 id="7-2-字符串对象"><a href="#7-2-字符串对象" class="headerlink" title="7.2 字符串对象"></a>7.2 字符串对象</h2><p>字符串对象的编码可以是int、raw或者embstr。</p><p>如果一个字符串对象保存的是整数值，并且这个整数值可以用long 类型来表示，那么字符串对象会将整数值保存在字符串对象结构的ptr属 性里面（将void*转换成long），并将字符串对象的编码设置为int。</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230102201944782.png" alt="image-20230102201944782"></p><p>举个例子，如果我们执行以下SET命令，那么服务器将创建一个如 图所示的int编码的字符串对象作为number键的值：</p><pre><code class="shell">redis&gt; SET number 10086OKredis&gt; OBJECT ENCODING number&quot;int&quot;</code></pre><p>如果字符串对象保存的是一个字符串值，并且这个字符串值的长度大于32字节，那么字符串对象将使用一个简单动态字符串（SDS）来保 存这个字符串值，并将对象的编码设置为raw。</p><p>举个例子，如果我们执行以下命令，那么服务器将创建一个如图8- 2所示的raw编码的字符串对象作为story键的值：</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230102202052133.png" alt="image-20230102202052133"></p><pre><code class="shell">redis&gt; SET story &quot;Long, long ago there lived a king ...&quot;OKredis&gt; STRLEN story(integer) 37redis&gt; OBJECT ENCODING story&quot;raw&quot;</code></pre><p>如果字符串对象保存的是一个字符串值，并且这个字符串值的长度 小于等于32字节，那么字符串对象将使用embstr编码的方式来保存这个字符串值。</p><p><strong>embstr</strong>编码是专门用于保存短字符串的一种优化编码方式，这种编码和raw编码一样，都使用redisObject结构和sdshdr结构来表示字符串对 象，但raw编码会调用两次内存分配函数来分别创建redisObject结构和 sdshdr结构，而embstr编码则通过调用一次内存分配函数来分配一块连 续的空间，空间中依次包含redisObject和sdshdr两个结构，如图所 示。</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230102202153286.png" alt="image-20230102202153286"></p><p>embstr编码的字符串对象在执行命令时，产生的效果和raw编码的 字符串对象执行命令时产生的效果是相同的，但使用embstr编码的字符 串对象来保存短字符串值有以下好处：</p><ul><li><p>embstr编码将创建字符串对象所需的内存分配次数从raw编码的两次降低为一次。</p></li><li><p>释放embstr编码的字符串对象只需要调用一次内存释放函数，而 释放raw编码的字符串对象需要调用两次内存释放函数。</p></li><li><p>因为embstr编码的字符串对象的所有数据都保存在一块连续的内存里面，所以这种编码的字符串对象比起raw编码的字符串对象能够更 好地利用缓存带来的优势。</p></li></ul><p>最后要说的是，可以用long double类型表示的浮点数在Redis中也是 作为字符串值来保存的。如果我们要保存一个浮点数到字符串对象里 面，那么程序会先将这个浮点数转换成字符串值，然后再保存转换所得 的字符串值。</p><p>举个例子，执行以下代码将创建一个包含3.14的字符串表</p><pre><code class="shell">redis&gt; SET pi 3.14OKredis&gt; OBJECT ENCODING pi&quot;embstr&quot;</code></pre><p>在有需要的时候，程序会将保存在字符串对象里面的字符串值转换 回浮点数值，执行某些操作，然后再将执行操作所得的浮点数值转换回 字符串值，并继续保存在字符串对象里面。</p><pre><code class="shell">redis&gt; INCRBYFLOAT pi 2.0&quot;5.14&quot;redis&gt; OBJECT ENCODING pi&quot;embstr&quot;</code></pre><p>那么程序首先会取出字符串对象里面保存的字符串值”3.14”，将它 转换回浮点数值3.14，然后把3.14和2.0相加得出的值5.14转换成字符 串”5.14”，并将这个”5.14”保存到字符串对象里面。</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230102202519692.png" alt="image-20230102202519692"></p><h3 id="7-2-1-编码的转换"><a href="#7-2-1-编码的转换" class="headerlink" title="7.2.1 编码的转换"></a>7.2.1 编码的转换</h3><p>int编码的字符串对象和embstr编码的字符串对象在条件满足的情况 下，会被转换为raw编码的字符串对象。</p><p>对于int编码的字符串对象来说，如果我们向对象执行了一些命令， 使得这个对象保存的不再是整数值，而是一个字符串值，那么字符串对 象的编码将从int变为raw。</p><p>我们通过APPEND命令，向一个保存整数值的字 符串对象追加了一个字符串值，因为追加操作只能对字符串值执行，所 以程序会先将之前保存的整数值10086转换为字符串值”10086”，然后再 执行追加操作，操作的执行结果就是一个raw编码的、保存了字符串值 的字符串对象.</p><p>另外，因为Redis没有为embstr编码的字符串对象编写任何相应的修改程序（只有int编码的字符串对象和raw编码的字符串对象有这些程序），所以embstr编码的字符串对象实际上是只读的。当我们对embstr 编码的字符串对象执行任何修改命令时，程序会先将对象的编码从 embstr转换成raw，然后再执行修改命令。因为这个原因，embstr编码的 字符串对象在执行修改命令之后，总会变成一个raw编码的字符串对 象。</p><h3 id="7-2-2-字符串命令的实现"><a href="#7-2-2-字符串命令的实现" class="headerlink" title="7.2.2 字符串命令的实现"></a>7.2.2 字符串命令的实现</h3><p>因为字符串键的值为字符串对象，所以用于字符串键的所有命令都 是针对字符串对象来构建的，表8-7列举了其中一部分字符串命令，以 及这些命令在不同编码的字符串对象下的实现方法。</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230102202751443.png" alt="image-20230102202751443"></p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230102202759063.png" alt="image-20230102202759063"></p><h2 id="7-3-列表对象"><a href="#7-3-列表对象" class="headerlink" title="7.3 列表对象"></a>7.3 列表对象</h2><p>列表对象的编码可以是ziplist或者linkedlist。</p><p>iplist编码的列表对象使用压缩列表作为底层实现，每个压缩列表 节点（entry）保存了一个列表元素。举个例子，如果我们执行以下 RPUSH命令，那么服务器将创建一个列表对象作为numbers键的值：</p><pre><code class="shell">redis&gt; RPUSH numbers 1 &quot;three&quot; 5(integer) 3</code></pre><p>如果numbers键的值对象使用的是ziplist编码，这个这个值对象将会 是图8-5所展示的样子。</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230102203123975.png" alt="image-20230102203123975"></p><p>另一方面，linkedlist编码的列表对象使用双端链表作为底层实现， 每个双端链表节点（node）都保存了一个字符串对象，而每个字符串对象都保存了一个列表元素。</p><p>个例子，如果前面所说的numbers键创建的列表对象使用的不是 ziplist编码，而是linkedlist编码，那么numbers键的值对象将是图8-6所示的样子。<img src="C:/Users/Dylan/AppData/Roaming/Typora/typora-user-images/image-20230102203153331.png" alt="image-20230102203153331"></p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230102203258150.png" alt="image-20230102203258150"></p><h3 id="7-3-1-编码转换"><a href="#7-3-1-编码转换" class="headerlink" title="7.3.1 编码转换"></a>7.3.1 编码转换</h3><p>当列表对象可以同时满足以下两个条件时，列表对象使用ziplist编码：</p><ul><li><p>列表对象保存的所有字符串元素的长度都小于64字节；</p></li><li><p>列表对象保存的元素数量小于512个；不能满足这两个条件的列表对象需要使用linkedlist编码。</p></li></ul><p>​对于使用ziplist编码的列表对象来说，当使用ziplist编码所需的两个 条件的任意一个不能被满足时，对象的编码转换操作就会被执行，原本 保存在压缩列表里的所有列表元素都会被转移并保存到双端链表里面， 对象的编码也会从ziplist变为linkedlist。</p><h3 id="7-3-2-列表命令的实现"><a href="#7-3-2-列表命令的实现" class="headerlink" title="7.3.2 列表命令的实现"></a>7.3.2 列表命令的实现</h3><p>因为列表键的值为列表对象，所以用于列表键的所有命令都是针对 列表对象来构建的，表8-8列出了其中一部分列表键命令，以及这些命 令在不同编码的列表对象下的实现方法。</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230102203459889.png" alt="image-20230102203459889"></p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230102203507167.png" alt="image-20230102203507167"></p><h2 id="7-4-哈希对象"><a href="#7-4-哈希对象" class="headerlink" title="7.4 哈希对象"></a>7.4 哈希对象</h2><p>哈希对象的编码可以是ziplist或者hashtable。</p><p>ziplist编码的哈希对象使用压缩列表作为底层实现，每当有新的键值对要加入到哈希对象时，程序会先将保存了键的压缩列表节点推入到压缩列表表尾，然后再将保存了值的压缩列表节点推入到压缩列表表尾，因此：</p><ul><li>保存了同一键值对的两个节点总是紧挨在一起，保存键的节点在前，保存值的节点在后；</li><li>先添加到哈希对象中的键值对会被放在压缩列表的表头方向，而后来添加到哈希对象中的键值对会被放在压缩列表的表尾方向。</li></ul><p>举个例子，如果我们执行以下HSET命令，那么服务器将创建一个列表对象作为profile键的值：</p><pre><code class="shell">redis&gt; HSET profile name &quot;Tom&quot;(integer) 1redis&gt; HSET profile age 25(integer) 1redis&gt; HSET profile career &quot;Programmer&quot;(integer) 1</code></pre><p>如果profile键的值对象使用的是ziplist编码，那么这个值对象将会是 图8-9所示的样子，其中对象所使用的压缩列表如图8-10所示。</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230102203840807.png" alt="image-20230102203840807"></p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230102203904604.png" alt="image-20230102203904604"></p><p>另一方面，hashtable编码的哈希对象使用字典作为底层实现，哈希对象中的每个键值对都使用一个字典键值对来保存：</p><ul><li><p>字典的每个键都是一个字符串对象，对象中保存了键值对的键；</p></li><li><p>字典的每个值都是一个字符串对象，对象中保存了键值对的值。</p></li></ul><p>个例子，如果前面profile键创建的不是ziplist编码的哈希对象，而 是hashtable编码的哈希对象，那么这个哈希对象应该会是图8-11所示的样子。</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230102203955461.png" alt="image-20230102203955461"></p><h3 id="7-4-1-编码转换"><a href="#7-4-1-编码转换" class="headerlink" title="7.4.1 编码转换"></a>7.4.1 编码转换</h3><p>当哈希对象可以同时满足以下两个条件时，哈希对象使用ziplist编码：</p><ul><li><p>哈希对象保存的所有键值对的键和值的字符串长度都小于64字 节；</p></li><li><p>哈希对象保存的键值对数量小于512个；不能满足这两个条件的 哈希对象需要使用hashtable编码。</p></li></ul><p>对于使用ziplist编码的列表对象来说，当使用ziplist编码所需的两个 条件的任意一个不能被满足时，对象的编码转换操作就会被执行，原本 保存在压缩列表里的所有键值对都会被转移并保存到字典里面，对象的 编码也会从ziplist变为hashtable。</p><h3 id="7-4-2-哈希命令的实现"><a href="#7-4-2-哈希命令的实现" class="headerlink" title="7.4.2 哈希命令的实现"></a>7.4.2 哈希命令的实现</h3><p>因为哈希键的值为哈希对象，所以用于哈希键的所有命令都是针对 哈希对象来构建的，表8-9列出了其中一部分哈希键命令，以及这些命 令在不同编码的哈希对象下的实现方法。</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230102204202582.png" alt="image-20230102204202582"></p><h2 id="7-5-集合对象"><a href="#7-5-集合对象" class="headerlink" title="7.5 集合对象"></a>7.5 集合对象</h2><p>集合对象的编码可以是intset或者hashtable。</p><p>intset编码的集合对象使用整数集合作为底层实现，集合对象包含的所有元素都被保存在整数集合里面</p><p>举个例子，以下代码将创建一个如图8-12所示的intset编码集合对象：</p><pre><code class="shell">redis&gt; SADD numbers 1 3 5(integer) 3</code></pre><p>另一方面，hashtable编码的集合对象使用字典作为底层实现，字典的每个键都是一个字符串对象，每个字符串对象包含了一个集合元素， 而字典的值则全部被设置为NULL。</p><p>举个例子，以下代码将创建一个如图8-13所示的hashtable编码集合对象：</p><pre><code class="shell">redis&gt; SAD Dfruits &quot;apple&quot; &quot;banana&quot; &quot;cherry&quot;(integer)3</code></pre><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230102204450815.png" alt="image-20230102204450815"></p><h3 id="7-5-1-编码的转换"><a href="#7-5-1-编码的转换" class="headerlink" title="7.5.1 编码的转换"></a>7.5.1 编码的转换</h3><p>当集合对象可以同时满足以下两个条件时，对象使用intset编码：</p><ul><li><p>集合对象保存的所有元素都是整数值；</p></li><li><p>集合对象保存的元素数量不超过512个。</p></li></ul><p>不能满足这两个条件的集合对象需要使用hashtable编码。</p><p>对于使用intset编码的集合对象来说，当使用intset编码所需的两个 条件的任意一个不能被满足时，就会执行对象的编码转换操作，原本保 存在整数集合中的所有元素都会被转移并保存到字典里面，并且对象的 编码也会从intset变为hashtable。</p><h3 id="7-5-2-集合命令的实现"><a href="#7-5-2-集合命令的实现" class="headerlink" title="7.5.2 集合命令的实现"></a>7.5.2 集合命令的实现</h3><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230102204631147.png" alt="image-20230102204631147"></p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230102204638771.png" alt="image-20230102204638771"></p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis底层原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解JVM</title>
      <link href="/2022/08/09/jvm-du-shu-bi-ji/"/>
      <url>/2022/08/09/jvm-du-shu-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="一-Java内存区域与内存溢出异常"><a href="#一-Java内存区域与内存溢出异常" class="headerlink" title="一. Java内存区域与内存溢出异常"></a>一. Java内存区域与内存溢出异常</h1><h2 id="1-运行时数据区域"><a href="#1-运行时数据区域" class="headerlink" title="1 运行时数据区域"></a>1 运行时数据区域</h2><p>运行时数据区域包括: 方法区(Method Area), 程序计数器(program counter register), 虚拟机栈(VM Stack),堆(Heap),本地方法栈(Native Method Stack)</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images1/image-20221211170814259.png" alt="img"></p><h3 id="1-1-程序计数器"><a href="#1-1-程序计数器" class="headerlink" title="1.1 程序计数器"></a>1.1 程序计数器</h3><p>程序计数器(program counter register), 是一块较小的内存空间;</p><p>可以看做是当前线程所执行的字节码的<strong>行号指示器.</strong></p><p>虚拟机的概念模型：字节码解释器，工作时通过改变这个计数器的值，选择下一条需执行的字节码指令，分支  循环  跳转  异常处理  线程恢复等基础功能，都需要依赖这个计数器来完成</p><p>JVM的多线程，通过线程轮流切换并分配CPU时间片的方式，来实现 单核如上，多核就是真正的并行.</p><p>程序计数器是<strong>线程私有的</strong>,每个线程都有自己的程序计数器,且互不影响.</p><p>线程执行Java方法，计数器记录正在执行的虚拟机字节码指令的地址 ,线程执行Native方法，计数器为空（Undefined）</p><hr><h3 id="1-2-Java虚拟机栈"><a href="#1-2-Java虚拟机栈" class="headerlink" title="1.2 Java虚拟机栈"></a>1.2 Java虚拟机栈</h3><p>同程序计数器，Java虚拟机栈<strong>也是线程私有</strong>，生命周期和线程相同;</p><p>虚拟机栈描述的是：<strong>Java方法执行的内存模型</strong>。每个方法执行时，会创建一个<strong>栈帧</strong>用于存储“<strong>局部变量表、操作数栈、动态链接、方法出口等信息</strong>”；方法从调用至完成，对应着一个栈帧从入栈到出栈;</p><p>局部变量表，存放了编译期可知的各种基本数据类型、对象引用类型、returnAddress类型(指向一条字节码指令的地址)。</p><p>64位的long和double类型数据，会占用2个局部变量空间（Slot），其余占用一个。 局部变量表所需内存空间，在编译期间完成分配，<strong>运行期不改变其大小</strong>。</p><p>JVM规范中，对这个区域规定了两种异常情况：栈溢出，内存溢出</p><hr><h3 id="1-3-本地方法栈"><a href="#1-3-本地方法栈" class="headerlink" title="1.3 本地方法栈"></a>1.3 本地方法栈</h3><p>类Java虚拟机栈（为Java方法，字节码服务），而本地方法栈为Native方法服务 ;</p><p>JVM规范中，对这个区域规定了两种异常情况：栈溢出，内存溢出;</p><hr><h3 id="1-4-堆"><a href="#1-4-堆" class="headerlink" title="1.4 堆"></a>1.4 堆</h3><p>堆，是JVM管理的内存中最大的一块。</p><p> 线程共享。在JVM启动时创建，<strong>唯一目的就是存放对象实例。</strong></p><p>JVM规范：所有对象实例及数组都要在堆上分配。 随着JIT编译期的发展以及逃逸分析技术逐渐成熟，栈上分配  标量替换优化技术导致“堆上分配对象”不再那么绝对</p><p>堆，是垃圾收集器管理的主要区域。 收集器基本采用分代收集算法，所以堆可细分为：新生代，老年代。 新生代可再分：Eden空间，From Survivor空间，To Survivor空间等</p><p>从内存分配角度，线程共享的堆可能划分出多个线程私有的分配缓冲区（TLAB）</p><p>JVM规范：<strong>堆可处于物理上不连续的内存空间，只要逻辑上连续即可。</strong></p><p>固定大小或可扩展（主流JVM，通过参数-Xmx和-Xms控制堆大小）</p><p>堆无法扩展时，将会抛出内存溢出异常.</p><hr><h3 id="1-5-方法区"><a href="#1-5-方法区" class="headerlink" title="1.5 方法区"></a>1.5 方法区</h3><p>方法区（method area）只是JVM规范中定义的一个概念，用于存储<strong>类信息、常量池、静态变量、JIT编译后的代码等数据，</strong>具体放在哪里，不同的实现可以放在不同的地方。</p><p>永久代是Hotspot虚拟机特有的概念，是方法区的一种实现，别的JVM都没有这个东西。</p><p>在Java 6中，方法区中包含的数据，除了JIT编译生成的代码存放在native memory的CodeCache区域，其他都存放在永久代。</p><p>在Java 7中，Symbol的存储从PermGen移动到了native memory，并且把静态变量从instanceKlass末尾（位于PermGen内）移动到了java.lang.Class对象的末尾（位于普通Java heap内）。</p><p>在Java 8中，永久代被彻底移除，取而代之的是另一块与堆不相连的本地内存——元空间（Metaspace）,‑XX:MaxPermSize 参数失去了意义，取而代之的是-XX:MaxMetaspaceSize。</p><hr><h3 id="1-6-运行时常量池"><a href="#1-6-运行时常量池" class="headerlink" title="1.6 运行时常量池"></a>1.6 运行时常量池</h3><p>属于方法区的一部分。</p><p>Class文件除了有“类版本、字段、方法、接口等描述信息外，还有一项信息为常量池”</p><p>常量池：存放编译期生成的各种字面量和符号引用;</p><p>类加载进入方法区，常量池内容（字面量，符号引用）存放到运行时常量池 </p><ul><li><p>符号引用翻译出来的直接引用，也存储在运行时常量池中</p></li><li><p>运行时进入常量池：如String类的intern()方法</p></li></ul><hr><h3 id="1-7-直接内存"><a href="#1-7-直接内存" class="headerlink" title="1.7 直接内存"></a>1.7 直接内存</h3><p>不是JVM运行时数据区的一部分。</p><p>JDK 1.4引用了NIO类，基于通道与缓冲区的IO方式，可使用Native函数库直接分配堆外内存<br>堆外内存，通过一个存储在Java堆中的DirectByteBuffer对象，作为堆外内存的引用进行操作。避免Java堆和Native堆来回复制数据.</p><p>服务器管理员配置虚拟机参数时，会根据实际内存去设置-Xmx等参数信息，但经常忽略掉直接内存，使得各个内存区域总和大于物理内存限制，从而导致动态扩展时出现OutOfMemoryError异常。</p><h2 id="2-HotSpot虚拟机对象"><a href="#2-HotSpot虚拟机对象" class="headerlink" title="2 HotSpot虚拟机对象"></a>2 HotSpot虚拟机对象</h2><p>对象的创建:</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images1/image-20221213123203832.png" alt="img"></p><p>当Java虚拟机遇到一条字节码new指令时，首先将去检查这个指令的参数是否能在<strong>常量池</strong>中定位到一个类的<strong>符号引用</strong>，并且检查这个符号引用代表的类是否被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</p><p>在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定，<strong>为对象分配空间的任务实际上便等同于把一块确定大小的内存块从Java堆中划分出来</strong>。</p><h3 id="分配内存的方式"><a href="#分配内存的方式" class="headerlink" title="分配内存的方式:"></a>分配内存的方式:</h3><blockquote><p>【1】<br>假设Java堆中内存是绝对规整的，<br>所有被使用过的内存都被放在一边，<br>空闲的内存被放在另一边，<br>中间放着一个指针作为分界点的指示器，<br>那分配内存就仅仅是把那个指针向空闲方向挪动一段与对象大小相等的距离，<br>这种分配方式称为<strong>指针碰撞 Bump The Pointer</strong></p><p>【2】<br>假设Java堆中的内存并不是规整的，<br>已使用的和未使用的交错在一起，<br>虚拟机要维护一个列表，<br>记录哪些内存块是可用的，<br>在分配的时候从列表中找到一块足够大的空间分配给实例，<br>并更新列表上的记录，<br>这种分配方式称为<strong>空闲列表 Free List</strong></p></blockquote><p>选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由<br>所采用的垃圾收集器是否带有**空间压缩整理(Compact)**的能力决定</p><h3 id="对象创建的线程安全"><a href="#对象创建的线程安全" class="headerlink" title="对象创建的线程安全"></a>对象创建的线程安全</h3><p>解决并发下的线程安全这个问题有两种可选方案：</p><ul><li>对分配内存的动作进行同步处理：<br>虚拟机是采用<strong>CAS</strong>配上<strong>失败重试</strong>的方式保证更新操作的原子性</li></ul><ul><li>把内存分配的动作按照线程划分在不同的空间之中进行：<br><strong>即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲</strong>(Thread Local Allocation Buffer，<strong>TLAB</strong>)，哪个线程要分配内存，就在哪个线程的本地缓冲区中分配，只有本地缓冲区用完了，分配新的缓冲区时才需要同步锁定。</li></ul><p>虚拟机是否使用TLAB，可以通过**-XX: +&#x2F;-UseTLAB**参数来设定。</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images1/735d456a7e5b6fa12f0ff45727b2b839.png"></p><p>内存分配完成之后，<strong>虚拟机必须将分配到的内存空间(但不包括对象头)都初始化为零值，</strong>如果使用了TLAB的话，这一项工作也可以提前至TLAB分配时顺便进行。</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images1/eae158b48452d37724340cf6e42ce7b0.png"></p><p>这步操作保证了对象的实例字段在Java代码中可以不赋值就直接使用，使程序能访问到这些字段的数据类型所对应的零值。</p><blockquote><p>Java虚拟机还要对对象进行必要的设置</p><p>例如这个对象是哪个类的实例、<br>如何才能找到类的元数据信息、<br>对象的哈希码(对象的哈希吗会延后到真正调用Object::hashCode())方法时才计算）、<br>对象的GC分代年龄等信息。<br><strong>这些信息存放在对象的对象头(Object Header)之中。</strong>根据虚拟机当运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</p></blockquote><p><img src="https://gitee.com/DylanToT99/images/raw/master/images1/image-20221213125031369.png" alt="img"></p><p>上面的工作都完成后，从虚拟机的视角看，新的对象已经产生了。<br><strong>但是从Java程序的时间看，对象创建才刚刚开始。</strong></p><p>构造函数，即Class文件中的**<init>**()方法还没执行，所有字段都为默认的零值，对象需要的其他资源和状态信息也还没有按照预定的意图构造好，一般来说(由字节码中new指令是否跟随invokespecial指令所决定，Java编译器会在遇到new关键字的地方同时生成这两条字节码指令，但如果直接通过其他方式产生的则不一定如此)，new指令之后会接着执行&lt; init&gt;()方法，按照代码对对象进行初始化，然后一个可用的对象才算被构造出来。<br>例如: 下面一个类:</p><pre><code class="java">public class objectTest &#123;    private int n;    public objectTest()&#123;    &#125;    public objectTest(int n)&#123;        this.n=n;    &#125;    public static void main(String[] args) &#123;        objectTest objectTest = new objectTest();    &#125;&#125;</code></pre><p>对应的字节码:</p><pre><code class="java">public class com/dylan/jvm/objectTest &#123;  // compiled from: objectTest.java  // access flags 0x2  private I n  // access flags 0x1  public &lt;init&gt;()V   L0    LINENUMBER 12 L0    ALOAD 0    INVOKESPECIAL java/lang/Object.&lt;init&gt; ()V   L1    LINENUMBER 14 L1    RETURN   L2    LOCALVARIABLE this Lcom/dylan/jvm/objectTest; L0 L2 0    MAXSTACK = 1    MAXLOCALS = 1  // access flags 0x1  public &lt;init&gt;(I)V   L0    LINENUMBER 15 L0    ALOAD 0    INVOKESPECIAL java/lang/Object.&lt;init&gt; ()V   L1    LINENUMBER 16 L1    ALOAD 0    ILOAD 1    PUTFIELD com/dylan/jvm/objectTest.n : I   L2    LINENUMBER 17 L2    RETURN   L3    LOCALVARIABLE this Lcom/dylan/jvm/objectTest; L0 L3 0    LOCALVARIABLE n I L0 L3 1    MAXSTACK = 2    MAXLOCALS = 2  // access flags 0x9  public static main([Ljava/lang/String;)V   L0    LINENUMBER 20 L0    NEW com/dylan/jvm/objectTest //分配内存    DUP//复制    INVOKESPECIAL com/dylan/jvm/objectTest.&lt;init&gt; ()V  //调用构造方法    ASTORE 1 //建立关联   L1    LINENUMBER 21 L1    RETURN   L2    LOCALVARIABLE args [Ljava/lang/String; L0 L2 0    LOCALVARIABLE objectTest Lcom/dylan/jvm/objectTest; L1 L2 1    MAXSTACK = 2    MAXLOCALS = 2&#125;</code></pre><h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><p>**对象头(Header)<strong>、</strong>实例数据(Instance Data)*<em>和*<em>对齐填充(Padding)</em></em></p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images1/image-20221213132312083.png" alt="img"></p><p>对象自身的运行时数据的长度在32位和64位的虚拟机(未开启压缩指针)中分别为32个比特和64个比特，官方称它为“Mark Word”。</p><ul><li>Mark Word：记录对象的运行时信息，如 hashCode，GC 分代年龄，尾部 2 bit 用于标记锁状态</li></ul><p><img src="https://gitee.com/DylanToT99/images/raw/master/images1/5379ed3e6a10d59d8b8cae3d2f16ec77.png"></p><p>对象需要存储的运行时数据很多，其实已经超过了32、64位Bitmap结构所能记录的最大限度，但对象头里的信息是与对象自身定义的数据无关的额外存储成本，考虑到虚拟机空间效率，Mark Word被设计成一个有着动态定义的数据结构，以便在极小的空间内存储尽量多的数据，根据对象的状态复用自己的存储空间。</p><p><strong>实例数据</strong>部分是对象真正存储的有效信息，就是我们在程序代码里面所定义的各种类型的字段内容，无论是从父类继承下来的，还是在子类中定义的字段都必须记录起来。<br>这部分的存储顺序会受到虚拟机分配策略参数(-XX: FieldsAllocationStyle参数)和字段在Java源码中定义顺序的影响。<br>HotSpot虚拟机默认的分配顺序为longs&#x2F;doubles、ints、shorts&#x2F;chars、bytes&#x2F;booleans、bytes&#x2F;booleans、oops(Ordinary Object Pointers)。相同宽度的字段总是被分配到一起存放。</p><p><strong>对齐填充</strong>不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。<strong>由于HotSpot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说就是任何对象的大小都必须是8字节的整数倍</strong>。对象头部分已经倍精心设计成正好是8字节的倍数(1倍或者2倍)，如果不够就对齐填充。</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images1/image-20221213133024970.png" alt="img"></p><h4 id="一个Object占多少字节？"><a href="#一个Object占多少字节？" class="headerlink" title="一个Object占多少字节？"></a>一个Object占多少字节？</h4><p>Object o &#x3D; new Object();</p><p>&#x2F;&#x2F;虚拟机参数:</p><pre><code class="java">java -XX:+PrintCommandLineFlags -version</code></pre><p>想把这两项关掉，+改成-就行。</p><p>-XX:-UseCompressedClassPointers -XX:-UseCompressedOops</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images1/image-20221213135845538.png" alt="img"></p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images1/image-20221213135904634.png" alt="img"></p><p>使用jol查看内存信息:</p><p>运行类:</p><pre><code class="java">public class ramTest &#123;    public static void main(String[] args) &#123;        int []a=new int[1];        Object o = new Object();        System.out.println(ClassLayout.parseInstance(a).toPrintable());        System.out.println(ClassLayout.parseInstance(o).toPrintable());    &#125;&#125;</code></pre><p>结果:</p><p>数组a:(大小为24byte,开启压缩的情况下)</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images1/image-20221213142642798.png" alt="img"></p><p>对象o:(16byte,开启了压缩)</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images1/image-20221213142728606.png" alt="img"></p><p>若去除jvm的压缩:</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images1/image-20221213142818925.png" alt="img"></p><p>数组a:(32byte)</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images1/image-20221213142842259.png" alt="img"></p><p>对象a:(仍然是16byte)</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images1/image-20221213142900914.png" alt="img"></p><h3 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h3><p>Java程序会通过<strong>栈上的reference数据</strong>来操作堆上的具体对象。主流的访问方式主要有使用<strong>句柄</strong>和<strong>直接指针</strong>两种。</p><ul><li>句柄<br>Java堆中将可能会划分出一块内存来作为句柄池，<strong>reference中存储的就是对象的句柄地址</strong>，而句柄中包含了对象实例数据与类型数据各自具体的地址信息。</li></ul><p><img src="https://gitee.com/DylanToT99/images/raw/master/images1/image-20221213143112321.png" alt="img"></p><ul><li>直接指针<br>Java堆中对象的内存布局就必须考虑如何放置访问类型数据的相关信息，reference中存储的直接就是对象地址，如果只是访问对象本身的话，就不需要多一次间接访问的开销。</li></ul><p><img src="https://gitee.com/DylanToT99/images/raw/master/images1/image-20221213143146227.png" alt="img"></p><p>使用句柄来访问reference中存储的是稳定句柄地址，在对象被移动(垃圾收集时移动对象是非常普遍的行为)时只会改变句柄中的实例数据指针，而reference本身不需要被修改。</p><p>使用直接指针来访问最大的好处就是速度快，节省了一次指针定位的时间开销，由于对象访问在Java中非常频繁，因此这类开销积少成多也是可观的执行成本。(HotSpot主要使用这种)</p><h2 id="3-OutOfMemoryError异常"><a href="#3-OutOfMemoryError异常" class="headerlink" title="3 OutOfMemoryError异常"></a>3 OutOfMemoryError异常</h2><h3 id="Java堆溢出"><a href="#Java堆溢出" class="headerlink" title="Java堆溢出"></a>Java堆溢出</h3><p>只要不断地创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，那么随着对象数量的增加，总容量触及最大堆的容量限制后就会产生内存溢出异常。</p><p>上面限制Java堆的大小为20MB，不可扩展(<strong>将堆的最小值-Xms参数与最大值-Xmx参数设置为一样即可避免堆自动扩展</strong>)，通过参数**<code>-XX：+HeapDumpOnOutOfMemoryError</code>可以让虚拟机在内存溢出异常的时候Dump出当前的内存堆转储快照以便进行事后分析。**</p><p>添加虚拟机参数:-Xms10M -Xmx10M -XX:SurvivorRatio&#x3D;8 -XX:+PrintGCDetails -XX:+HeapDumpOnOutOfMemoryError</p><pre><code class="java">public class MapTest &#123;    static class OOMObject&#123;    &#125;    public static void main(String[] args) &#123;        List&lt;OOMObject&gt; list = new ArrayList&lt;OOMObject&gt;();        while(true) &#123;            list.add(new OOMObject());        &#125;    &#125;&#125;</code></pre><p>快照文件:</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images1/image-20230327204941014.png" alt="image-20230327204941014"></p><p>文件内容:</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images1/image-20230327204954200.png" alt="image-20230327204954200"></p><p>解决内存区域的异常，常规的处理方法是首先通过内存映像分析工具(如Eclipse Memory Analyzer)对Dump出现的堆转储快照进行分析。第一步首先应确认内存中导致OOM的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏(Memory Leak)还是内存溢出(Memory Overflow)。</p><p>如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链，找到泄漏对象是通过怎样的引用路径，与哪些GC Roots相关联，才导致垃圾收集器无法回收它们，根据泄漏对象的类型信息以及它到GC Roots引用链的信息，一遍可以比较准确地定位到这些对象创建的位置，进而找到产生内存泄漏的代码的具体位置。</p><p>如果不是内存泄漏，换句话说就是内存中的对象确实都是必须存活的，那就应当检查Java虚拟机的堆参数设置(-Xmx与-Xms)设置，与机器的内存对比，看看是否还有向上调整的空间。再从代码上检查是否存在某些对象生命周期过长、存储结构设计不合理等情况，尽量减少程序运行期的内存消耗。</p><p><strong>栈内存</strong>：-Xss指定栈大小，当栈深度超阈值（比如未触发终止条件的递归调用）、本地方法变量表过大等，都可能导致内存溢出 StackOverflowError</p><p><strong>方法区</strong>：-XX:MetaspaceSize指定元空间初始大小，-XX:MaxMetaspaceSize指定最大大小，默认 -1 无限制，若在运行时动态生成大量的类，则可能触发 OOM</p><p><strong>运行时常量池：</strong>strObj.intern()动态地将首次出现的字符串对象放入字符串常量池并返回，JDK7 前会拷贝到永久代，之后则直接引用堆对象</p><h3 id="内存泄漏-内存溢出"><a href="#内存泄漏-内存溢出" class="headerlink" title="内存泄漏&amp;内存溢出"></a>内存泄漏&amp;内存溢出</h3><ul><li><strong>内存泄漏</strong> memory leak<br>–&gt;申请了内存用完不释放</li></ul><blockquote><p>泄漏的分类：<br>1 经常发生：发生泄漏的代码会被多次执行，每次执行，泄漏一块内存<br>2 偶然发生：在某些特定情况下才会发生<br>3 一次性：发生内存泄漏的方法只会执行一次<br>4 隐式泄漏：一直占着内存不释放，直到执行结束，但是执行时间特别长，严格来说不算泄漏</p></blockquote><blockquote><p>导致内存泄漏的常见原因：<br>1.循环过多或死循环，产生大量对象<br>——————————————————————————<br>2.静态集合类引起内存泄漏，因为静态集合的生命周期和JVM一致，索引静态集合引用的对象不能被释放。<br>static List list &#x3D; new ArrayList();<br>public void Test(){<br>Object obj &#x3D; new Object();<br>list.add(obj);<br>}<br>list是静态的，只要JVM不停，obj也一直不会释放。<br>——————————————————————————<br>3.单例模式，因为单例的静态特征，它的生命周期和JVM的生命周期一样长。如果单例对象持有外部对象的引用，那么这个外部对象也不会被回收，那么就会造成内存泄漏。<br>——————————————————————————<br>4.数据连接、IO、Socket连接等等，它们必须显式释放，close，否则不会被GC回收。<br>——————————————————————————<br>5.内部类的对象被长期持有，那么内部对象所属的外部类对象也不会被回收。<br>——————————————————————————<br>6.Hash值发生改变，当元素的hashCode发生改变后，找不到之前的那个元素了，我们想把自己定义的类保存到散列表时，要保证对象的hashCode不可变。<br>——————————————————————————<br>7.内存中加载数据量过大。</p></blockquote><ul><li><strong>内存溢出</strong> out of memory<br>–&gt;申请内存时，没有足够的内存可以使用</li></ul><h3 id="查看堆内存"><a href="#查看堆内存" class="headerlink" title="查看堆内存"></a>查看堆内存</h3><blockquote><p><strong>java -XX:+PrintCommandLineFlags -version</strong></p></blockquote><h1 id="二-垃圾收集器与内存分配策略"><a href="#二-垃圾收集器与内存分配策略" class="headerlink" title="二. 垃圾收集器与内存分配策略"></a>二. 垃圾收集器与内存分配策略</h1><h2 id="2-1-对象已死"><a href="#2-1-对象已死" class="headerlink" title="2.1 对象已死?"></a>2.1 对象已死?</h2><h3 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法:"></a>引用计数算法:</h3><p>在对象中添加一个引用计数器，<br>每当有一个地方引用它时，计数器值就加一;<br>当引用失效时，计数器就减一；<br>任何时刻计数器为零的对象就是不可能再被使用的。</p><p>虽然占用了一些额外的内存空间来进行计数，但是原理简单，判断效率高。不过主流Java虚拟机里都没有选用这种方法，比如循环引用的问题就很难解决。</p><h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p>当前主流的商用程序语言(Java、C#)的内存管理子系统，都是通过可达性分析(Reachability Analysis)算法来判定对象是否存活的。<br>这个算法的基本思路就是通过一系列称为”GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”，如果某个对象到GC Roots间没有任何引用链相连，或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的。<br>object 5\6\7都是垃圾。</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images1/image-20221217211616482.png" alt="img"></p><p>目前最新的几款垃圾收集器无一例外都具备了局部回收的特征，为了避免GC Root包含过多对象而过度膨胀，它们在实现上也做出了各种优化处理。</p><h3 id="GC-Root"><a href="#GC-Root" class="headerlink" title="GC Root"></a>GC Root</h3><p>在Java技术体系里<strong>，固定可作为GC Roots的对象包括以下几种：</strong></p><ul><li><p>在虚拟机栈(栈帧中的本地变量表)中引用的对象，譬如各个<strong>线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。</strong></p></li><li><p>在方法区中<strong>类静态属性引用的对象</strong>，譬如Java类的引用类型静态变量。</p></li><li><p>在方法区中<strong>常量引用的对象</strong>，譬如字符串常量池(String Table)里的引用。</p></li><li><p>在本地方法栈中<strong>JNI(即通常所说的Native方法)引用的对象。</strong></p></li><li><p>Java虚拟机内部的引用，<strong>如基本数据类型对应的Class对象，****一些常驻的异常对象</strong>(比如NullPointException、OutOfMemory Error)等，还有系统类加载器。</p><ul><li><strong>所有被同步锁(sychronized关键字)持有的对象。</strong></li></ul></li><li><p>反映Java虚拟机内部情况的JM XBean、JVM TI中注册的回调、本地代码缓存等。</p></li></ul><p>除了这些固定的GC Roots集合外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，<strong>还可以有其他对象临时性地加入</strong>，共同构成完整GC Roots集合。</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images1/image-20221217212114051.png" alt="img"></p><h2 id="2-2-引用"><a href="#2-2-引用" class="headerlink" title="2.2 引用"></a>2.2 引用</h2><p>无论是通过引用计数算法判断对象的引用数量还是通过可达性分析算法判断对象是否引用链可达，判定对象是否存活都和”<strong>引用</strong>“离不开关系。</p><p>在JDK 1.2版本之前，Java里面的引用是很传统的定义：如果reference类型的数据中存储的数值代表的是另一块内存的起始地址。</p><p>在JDK 1.2版本之后，Java对引用的概念进行了扩充，将引用分为**强引用(Strongly Reference)<strong>、</strong>软引用(Soft Reference)<strong>、</strong>弱引用(Weak Reference)<strong>和</strong>虚引用(Phantom Reference)**4种，这四种引用强度依次逐渐减弱。</p><ul><li><p>强引用是最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“Object obj&#x3D;new Object()”这种引用关系。无论任何情况下，只要强引用关系还在，垃圾收集器就永远不会回收掉被引用的对象。</p></li><li><p><strong>软引用是用来描述一些还有用，但非必须的对象。</strong>只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行二次回收，如果这次还没有足够的内存，才会抛出内存溢出异常。JDK 1.2+提供了SoftReference类来实现软引用。</p></li><li><p>弱引用也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，<strong>被弱引用关联的对象只能生存到下一次垃圾收集发生为止。</strong>当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。JDK 1.2+提供了<strong>WeakReference</strong>类来实现弱引用。</p></li><li><p><strong>虚引用</strong>也称为“幽灵引用”或者“幻影引用”，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的<strong>只是为了能在这个对象被收集器回收时收到一个系统通知。</strong></p></li></ul><p>示例：限制堆內存 50MB，其中新生代 30MB，老年代 20MB；依次分配 5 次 10MB 的byte[]对象，仅使用软引用来引用，观察 GC 过程</p><pre><code class="java">public class ReferenceTest &#123;    public static void main(String[] args) &#123;        // softRefList --&gt; SoftReference --&gt; 10MB byte[]        List&lt;SoftReference&lt;byte[]&gt;&gt; softRefList = new ArrayList&lt;&gt;();        ReferenceQueue&lt;byte[]&gt; softRefQueue = new ReferenceQueue&lt;&gt;(); // 无效引用队列        for (int i = 0; i &lt; 5; i++) &#123;            SoftReference&lt;byte[]&gt; softRef = new SoftReference&lt;&gt;(new byte[10*1024*1024], softRefQueue);            softRefList.add(softRef);            for (SoftReference&lt;byte[]&gt; ref : softRefList) // dump 所有软引用指向的对象，检查是否已被回收                System.out.print(ref.get() == null ? &quot;gced &quot; : &quot;ok &quot;);            System.out.println();        &#125;        Reference&lt;? extends byte[]&gt; ref = softRefQueue.poll();        while (ref != null) &#123;            softRefList.remove(ref); // 解除对软引用对象本身的引用            ref = softRefQueue.poll();        &#125;        System.out.println(&quot;effective soft ref: &quot; + softRefList.size()); // 2    &#125;&#125;</code></pre><p>结果:</p><pre><code>ok [GC (Allocation Failure) [PSYoungGen: 13542K-&gt;968K(27136K)] 13542K-&gt;11216K(47616K), 0.0050112 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [Full GC (Ergonomics) [PSYoungGen: 968K-&gt;0K(27136K)] [ParOldGen: 10248K-&gt;10956K(20480K)] 11216K-&gt;10956K(47616K), [Metaspace: 3107K-&gt;3107K(1056768K)], 0.0046552 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] ok ok ok ok ok [Full GC (Ergonomics) [PSYoungGen: 20918K-&gt;20480K(27136K)] [ParOldGen: 10956K-&gt;10953K(20480K)] 31875K-&gt;31433K(47616K), [Metaspace: 3107K-&gt;3107K(1056768K)], 0.0045133 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] [Full GC (Allocation Failure) [PSYoungGen: 20480K-&gt;0K(27136K)] [ParOldGen: 10953K-&gt;698K(20480K)] 31433K-&gt;698K(47616K), [Metaspace: 3107K-&gt;3107K(1056768K)], 0.0046123 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] gced gced gced ok gced gced gced ok ok effective soft ref: 2Heap PSYoungGen      total 27136K, used 21552K [0x00000000fe200000, 0x0000000100000000, 0x0000000100000000)  eden space 23552K, 91% used [0x00000000fe200000,0x00000000ff70c248,0x00000000ff900000)  from space 3584K, 0% used [0x00000000ff900000,0x00000000ff900000,0x00000000ffc80000)  to   space 3584K, 0% used [0x00000000ffc80000,0x00000000ffc80000,0x0000000100000000) ParOldGen       total 20480K, used 698K [0x00000000fce00000, 0x00000000fe200000, 0x00000000fe200000)  object space 20480K, 3% used [0x00000000fce00000,0x00000000fceaeac8,0x00000000fe200000) Metaspace       used 3116K, capacity 4486K, committed 4864K, reserved 1056768K  class space    used 323K, capacity 386K, committed 512K, reserved 1048576K</code></pre><h2 id="2-3-生存还是死亡"><a href="#2-3-生存还是死亡" class="headerlink" title="2.3 生存还是死亡"></a>2.3 生存还是死亡</h2><p>即时是在可达性分析算法中判定为不可达的对象，也不是“非死不可”的，要真正宣告一个对象死亡，至少要经历两次标记过程：</p><ul><li><p>如果对象在进行可达性分析后发现没有与GC Roots相链接的引用链，那它将会被第一次标记</p></li><li><p>随后进行一次筛选，筛选条件是此对象是否有必要执行finalize()方法。假如对象<strong>没有覆盖finalize()方法</strong>，或者<strong>finalize()方法已经被虚拟机调用过</strong>，那么虚拟机将这两种情况都视为”没必要执行”</p></li></ul><p>如果这个对象被判定为确有必要执行finalize()方法，那么对象将会被放置在一个名为<strong>F-Queue的队列之中</strong>，并在稍后由一条由虚拟机自动建立的、低调度优先级的Finalizer线程去执行它们的finalize()方法。<br>执行是说虚拟机会触发这个方法开始运行，但并不承诺一定会等待它运行结束。(如果某个对象的finalize()方法执行缓慢，或者更极端地发生了死循环，将很可能导致F-Queue队列中的其他对象永久处于等待)</p><p>如果某对象在finalize()中成功拯救了自己，只要重新与引用链上的任何一个对象建立关联即可(譬如把自己赋值给某个类变量或者对象的成员变量)。不过自救的机会只有一次，因为一个对象的finalize()方法最多只会被系统自动调用一次。</p><p>finalize()方法平时能不用就别用了，不划算，不推荐。</p><h2 id="2-4GC算法"><a href="#2-4GC算法" class="headerlink" title="2.4GC算法"></a>2.4GC算法</h2><h3 id="分代收集理论"><a href="#分代收集理论" class="headerlink" title="分代收集理论"></a><strong>分代收集理论</strong></h3><p>两个分代假说：符合大多数程序运行的实际情况</p><ul><li><p>弱分代假说：绝大多数对象是朝生夕灭，生存时间极短</p></li><li><p>强分代假说：熬过越多次 GC 的对象，越可能被继续使用，越难以回收</p></li></ul><p>对应地，JVM 堆被划分为 2 个不同区域，将对象按年龄分类，兼顾了 GC 耗时与内存利用率</p><ul><li><p>新生代：大量对象将被回收，只关注仍存活的对象，逐步晋升</p></li><li><p>老年代：大量对象不被回收，只关注要被回收的对象</p></li></ul><p>跨代引用</p><ul><li><p>问题：老年代会引用新生代，新生代 GC 时需遍历老年代中大量的存活对象，分析可达性，时间复杂度高</p></li><li><p>背景：相互引用的对象倾向于同时存亡，比如跨代引用关系中的新生代必然会逐步晋升，最终消除跨代关系</p></li><li><p>假说：跨代引用相比同代引用只占极少数，无需全量扫描老年代</p></li><li><p>实现：新生代维护全局数据结构：记忆集（Remembered Set），将老年代分为多个子块，标记存在跨代引用的子块，等待后续扫描；代价：为保证记忆集的正确性，需在跨代引用建立或断开时保持同步</p></li></ul><p><img src="https://gitee.com/DylanToT99/images/raw/master/images1/f824637aed807ac8a3336b09e1b13a26.png" alt="个人笔记，深入理解 JVM，很全！（终于有人把JVM说清楚了）"></p><h3 id="标记清除：Mark-Sweep"><a href="#标记清除：Mark-Sweep" class="headerlink" title="标记清除：Mark-Sweep"></a>标记清除：Mark-Sweep</h3><ul><li>原理：标记不可达对象，统一清理回收，反之亦可</li><li>缺点：执行效率不稳定，回收耗时取决于活跃对象的数量；内存碎片多，会出现内存充足但无法分配过大的连续内存（数组）</li></ul><p><img src="https://gitee.com/DylanToT99/images/raw/master/images1/264175b4ef23cfdc0b23267997c69f88.png" alt="个人笔记，深入理解 JVM，很全！（终于有人把JVM说清楚了）"></p><h3 id="标记-复制"><a href="#标记-复制" class="headerlink" title="标记-复制"></a>标记-复制</h3><ul><li><p>理论：将堆内存切为两等份 A, B，每次仅使用 A，用完后标记存活对象复制到 B，清空 A 后执行 swap</p></li><li><p>优点：直接针对半区回收，无内存碎片问题；分配内存只需移动堆顶指针，高效顺序分配</p></li><li><p>缺点：当 A 区有大量存活对象时，复制开销大；B 区长时间闲置，内存浪费严重</p></li><li><p>实践：对于存活对象少的新生代，无需按 1:1 分配，而是按 8:1:1 的内存布局，其中 Eden 和 From 区同时使用，只有 To 区会被闲置（担保机制：若 To 区不够容纳 Minor GC 后的存活对象，则晋升到老年区）<br><img src="https://gitee.com/DylanToT99/images/raw/master/images1/68ccc3fef57bcf2583c35c172036084d.png" alt="个人笔记，深入理解 JVM，很全！（终于有人把JVM说清楚了）"></p></li></ul><h3 id="标记整理：Mark-Compact"><a href="#标记整理：Mark-Compact" class="headerlink" title="标记整理：Mark-Compact"></a>标记整理：Mark-Compact</h3><ul><li>原理：标记存活对象后统一移动到内存空间一侧，再回收边界之外的内存</li><li>优点：内存模型简单，无内存碎片，降低内存分配和访问的时间成本，能提高吞吐</li><li>缺点：对象移动需 STW 同步更新引用关系，会增加延迟</li></ul><p><img src="https://gitee.com/DylanToT99/images/raw/master/images1/9deb5f608ca8eaa10da9293889fa5447.png" alt="个人笔记，深入理解 JVM，很全！（终于有人把JVM说清楚了）"></p><h2 id="2-5HotSpot-GC-算法细节"><a href="#2-5HotSpot-GC-算法细节" class="headerlink" title="2.5HotSpot GC 算法细节"></a>2.5HotSpot GC 算法细节</h2><h2 id="2-6发起GC-安全点与安全区域"><a href="#2-6发起GC-安全点与安全区域" class="headerlink" title="2.6发起GC:安全点与安全区域"></a>2.6发起GC:安全点与安全区域</h2><ul><li><p>问题：为保证可达性分析结果的准确性，需挂起用户线程（STW），再从各线程的执行上下文中收集 GC Root，如何通知线程挂起？</p></li><li><p>安全点：HotSpot 内部有线程中断标记；在各线程的方法调用、循环跳转、异常跳转等会长时间执行的指令处，额外插入检查该标记的test高效指令；若轮询发现标记为真，线程会主动在最近的 SafePoint 处挂起，此时其栈上对象的引用关系不再变化，可收集 GC Root 对象</p></li><li><p>安全区域：引用关系不会变化的指令区域，可安全地收集 GC Root；线程离开此区域时，若 GC Root 收集过程还未结束，则需等待<br><img src="https://gitee.com/DylanToT99/images/raw/master/images1/b8751622ef90c890f1ae53ebe1ca77c7.png" alt="个人笔记，深入理解 JVM，很全！（终于有人把JVM说清楚了）"></p></li></ul><h2 id="2-7加速GC-CardTable"><a href="#2-7加速GC-CardTable" class="headerlink" title="2.7加速GC:CardTable"></a>2.7加速GC:CardTable</h2><p>问题：非收集区域（老年代）会存在到收集区域（新生代）的跨代引用，如何避免对前者的全量扫描？</p><p>卡表：记忆集的字节数组实现；将老年代内存划分为 Card Page（512KB）大小的子内存块，若新建跨代引用，则将对应的 Card 标记为 dirty，GC 时只需扫描老年代中被标记为 dirty 的子内存块</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images1/a630a1aaced4e48a0806dd2ee9f29dae.png" alt="个人笔记，深入理解 JVM，很全！（终于有人把JVM说清楚了）"></p><p>写屏障：有别于volatile禁用指令重排的内存屏障，GC 中的写屏障是在对象引用更新时执行额外 hook 动作的机制。简单实现：</p><pre><code class="java">void oop_field_store(oop* field, oop new_val) &#123; // oop: ordinary object pointer// pre_write_barrier(field, new_val); // 写前屏障：更新前先执行，使用 oop 旧状态*field = new_val;post_write_barrier(field, new_val); // 写后屏障：更新完才执行&#125;</code></pre><p>使用写屏障保证 CardTable 的实时更新:</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images1/c164e31afff97c383555210346d1baca.png" alt="个人笔记，深入理解 JVM，很全！（终于有人把JVM说清楚了）"></p><h2 id="2-8正确GC-并发可达性分析"><a href="#2-8正确GC-并发可达性分析" class="headerlink" title="2.8正确GC:并发可达性分析"></a>2.8正确GC:并发可达性分析</h2><p><strong>问题：</strong>GC Roots 的对象源固定，故枚举时 STW 时间短暂且可控。但后续可达性分析的时间复杂度与堆中对象数量成正相关，即堆中对象越多，对象图越复杂，堆变大后 STW 时间不可接受</p><p><strong>解决：</strong>并发标记。引出新问题：用户线程动态建立、解除引用，标记过程中图结构发生变化，结果不可靠；证明：用三色法描述对象状态</p><ul><li><p>白色：未被回收器访问过的对象；分析开始都是白色，分析结束还是白色则不可达</p></li><li><p>灰色：被回收器访问过，但其上至少还有 1 个引用未被扫描（中间态）</p></li><li><p>黑色：被回收器访问过，其上引用全部都已被扫描，存在引用链，为存活对象；若其他对象引用了黑色对象，则不必再扫描，肯定也存活；黑色不可能直接引用白色</p></li></ul><p>STW 无并发的正确标记：顶部 3 个对象将被回收<br><img src="https://gitee.com/DylanToT99/images/raw/master/images1/cb7a0640fd155cb2154d0e3b7ec8b9e4.png" alt="个人笔记，深入理解 JVM，很全！（终于有人把JVM说清楚了）"></p><p>用户线程并发修改引用，会导致标记结果无效，分 2 种情况：</p><ul><li>少回收，对象标记为存活，但用户解除了引用：产生浮动垃圾，可接受，等待下次 GC</li></ul><p><img src="https://gitee.com/DylanToT99/images/raw/master/images1/4a657ee449f35e48a7ceb12e09d9907f.png" alt="个人笔记，深入理解 JVM，很全！（终于有人把JVM说清楚了）"></p><ul><li>误回收，对象标记为可回收，但用户新建了引用：实际存活对象被回收，内存错误</li></ul><p><img src="https://gitee.com/DylanToT99/images/raw/master/images1/c9cbc10691a56cb206cbcd62172348d3.png" alt="个人笔记，深入理解 JVM，很全！（终于有人把JVM说清楚了）"></p><p>论文《Uniprocessor Garbage Collection Techniques - Paul R. Wilson》§3.2 证明了「实际存活的对象被标记为可回收」必须同时满足两个条件（有时间序）</p><p>插入一条或多条从黑色到白色的新引用<br>删除所有灰色到该白色的直接、间接引用<br>为正确实现标记，打破其中一个条件即可（类比打破死锁四个条件之一的思想），分别对应两种方案：</p><p>增量更新 Increment Update：记录黑到白的引用关系，并发标记结束后，以黑为根，重新扫描；A 直接存活<br>原始快照 SATB（Snapshot At The Begining）：记录灰到白的解引用关系，并发标记结束后，以灰为根，重新扫描；B 为灰色，最后变为黑色，存活。需注意，若没有步骤 3，则 B,C 变为浮动垃圾</p><h2 id="2-9经典垃圾回收器"><a href="#2-9经典垃圾回收器" class="headerlink" title="2.9经典垃圾回收器"></a>2.9经典垃圾回收器</h2><p><img src="https://gitee.com/DylanToT99/images/raw/master/images1/42bc9220b8473e64ae8a4193af612e27.png" alt="个人笔记，深入理解 JVM，很全！（终于有人把JVM说清楚了）"></p><h3 id="Serial-SerialOld"><a href="#Serial-SerialOld" class="headerlink" title="Serial, SerialOld"></a>Serial, SerialOld</h3><p>原理：内存不足触发 GC 后会暂停所有用户线程，单线程地在新生代中标记复制，在老年代中标记整理，收集完毕后恢复用户线程</p><p>优点：全程 STW 简单高效</p><p>缺点：STW 时长与堆对象数量成正相关，且 GC 线程只能用到 1 core 无法加速</p><p>场景：单核 CPU 且可用内存少（如百兆级），JDK1.3 之前的唯一选择</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images1/a6f68c8cae6d31d822ec84aa9fd2759f.png" alt="个人笔记，深入理解 JVM，很全！（终于有人把JVM说清楚了）"></p><h3 id="ParNew"><a href="#ParNew" class="headerlink" title="ParNew"></a>ParNew</h3><p>原理：多线程并行版的 Serial 实现，能有效减少 STW 时长；线程数默认与核数相同，可配置</p><p>场景：JDK7 之前搭配老年代的 CMS 回收器使用</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images1/0a44b5b10359fc82efd13dffcb371bda.png" alt="个人笔记，深入理解 JVM，很全！（终于有人把JVM说清楚了）"></p><h3 id="Parallel-Parallel-Old"><a href="#Parallel-Parallel-Old" class="headerlink" title="Parallel, Parallel Old"></a>Parallel, Parallel Old</h3><p>垃圾回收有两个通常不可兼得的目标</p><p>低延迟：STW 时长短，响应快；允许高频、短暂 GC，比如调小新生代空间，加快收集延迟（吞吐下降）<br>高吞吐量：用户线程耗时 &#x2F;（用户线程耗时 + GC 线程耗时）高，GC 总时间低；允许低频、单次长时间 GC，（延迟增加）</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images1/987297111c48bb174dc1f677831a2b1b.png" alt="个人笔记，深入理解 JVM，很全！（终于有人把JVM说清楚了）"></p><p>原理：与 ParNew 类似都是并行回收，主要增加了 3 个选项（倾向于提高吞吐量）</p><ul><li><p>-XX:MaxGCPauseTime：控制最大延迟</p></li><li><p>-XX:GCTimeRatio：控制吞吐（默认 99%）</p></li><li><p>-XX:+UseAdaptiveSizePolicy ：启用自适应策略，自动调整 Eden 与 2 个 Survivor 区的内存占比-XX:SurvivorRatio，老年代晋升阈值 -XX:PretenureSizeThreshold</p></li></ul><p><img src="https://gitee.com/DylanToT99/images/raw/master/images1/b442db8316548a757de90088ade1428f.png" alt="个人笔记，深入理解 JVM，很全！（终于有人把JVM说清楚了）"></p><h3 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h3><p>CMS：Concurrent Mark Sweep，即并发标记清除，主要有 4 个阶段</p><ul><li><p>初始标记（initial mark）：STW 快速收集 GC Roots</p></li><li><p>并发标记（concurrent mark）：从 GC Roots 出发检测引用链，标记可回收对象；与用户线程并发执行，通过增量更新来</p></li><li><p>避免误回收</p></li><li><p>重新标记（remark）：STW 重新分析被增量更新所收集的 GC Roots</p></li><li><p>并发清除（concurrent sweep）：并发清除可回收对象</p></li></ul><p><img src="https://gitee.com/DylanToT99/images/raw/master/images1/fa33967452c3c6f61f69868ef81fab28.png" alt="个人笔记，深入理解 JVM，很全！（终于有人把JVM说清楚了）"></p><p>优点：两次 STW 时间相比并发标记耗时要短得多，相比前三种收集器，延迟大幅降低</p><p>缺点</p><ul><li><p><strong>CPU 敏感</strong>：若核数较少（&lt; 4core），并发标记将占用大量 CPU 时间，会导致吞吐突降</p></li><li><p>无法处理浮动垃圾：-XX:CMSInitiatingOccupancyFration（默认 92%）指定触发 CMS GC 的阈值；在并发标记、并发清理的同时，用户线程会产生浮动垃圾（引用可回收对象、产生新对象），若浮动垃圾占比超过-XX:CMSInitiatingOccupancyFration；若 GC 的同时产生过多的浮动垃圾，导致老年代内存不足，会出现 CMS 并发失败，退化为 Serial Old 执行 Full GC，会导致延迟突增</p></li><li><p>无法避免内存碎片：-XX:CMSFullGCsBeforeCompaction（默认 0）指定每次在 Full GC 前，先整理老年代的内存碎片</p></li></ul><h3 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h3><p>特点：基于 region 内存布局实现局部回收；GC 延迟目标可配置；无内存碎片问题</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images1/cbac949e04b082be00a910192cfe943c.png" alt="个人笔记，深入理解 JVM，很全！（终于有人把JVM说清楚了）"></p><p>首先我们要知道的是G1垃圾回收器的算法是标记-整理算法，通过回收一个个Region，来充分减少标记-整理算法上的内存浪费的缺点。</p><p>G1之前回收器堆内存划分方式多个<strong>等大的 region</strong>， 各 region 分代角色并不固定，按需在 Eden, Survivor, Old 间切换固定大小、固定数量的分代区域回收目标回收价值高的 region 动态组成的回收集合新生代、整个堆内存</p><p>跨代引用(<strong>RSet（Remember Set ：记忆集合）</strong>)：各 region 除了用卡表标记各卡页是否为 dirty 之外，还用哈希表记录了各卡页正在被哪些 region 引用，通过这种“双向指针”机制，能直接找到 Old 区，避免了全量扫描（G1 自身内存开销大头）</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images1/45fe8d9d8f4aebf542b4657e986c1fe5.png" alt="个人笔记，深入理解 JVM，很全！（终于有人把JVM说清楚了）"></p><p>G1 GC 有 3 个阶段（参考其 GC 日志）</p><ul><li><p>YoungGC 的工作流程<br>YGC 的工作流程很简单：APP线程跑，然后就进行青年代Region的回收，把需要回收的YoungRegion，放入YoungCSet中，在YGC阶段就进行对年轻代CSet中的Region进行回收。因为大部分都是垃圾，采用了复制回收算法，基本只需要较短时间的STW就能完全回收了。</p></li><li><p>MixGC 的工作流程<br>当老年代垃圾达到一个阀值的时候，就会触发MixGC。阈值-XX:InitiatingHeapOccupancyPercent(默认45%)时，G1就会启动一次混合垃圾收集周期。在经过第一次YGC的同时，进行Init Mark，然后在后面几次YGC的整个过程中进行进行ConcurrentMark，并把需要收集的Region放入CSet当中。然后进行一次STW的时候，ReMark（重新标记，主要是扫描堆栈上新的对象的索引），并且进行Clean（主要的任务是直接清理没有用的大对象Region，也叫做HumongousRegion），然后就开始分步清理CSet中的Region，根据ReSet中计算出垃圾比率较高的Region开始清理。这一系列循环收集的过程称为混合收集周期(Mixed Collection Cycle)。</p></li><li><p><strong>转移失败的担保机制 Full GC</strong><br>我们看到第一幅回收流程图的过程，进行MixGC的同时也在并发的进行APP线程，产生了新的垃圾，如果这个时候发生了新产生的对象进入老年代Region，而堆空间不够的时候就会发生转移失败(Evacuation Failure)，此时G1便会触发担保机制，执行一次STW式的、单线程的Full GC。Full GC会对整堆做<strong>标记清除和压缩</strong>，最后将只包含纯粹的存活对象。但是有一个参数-XX:G1ReservePercent(默认10%)可以保留空间，来应对晋升模式下的异常情况，最大占用整堆50%，但是太大了一般会浪费空间，也没有太大的意义。</p><p>G1在以下场景中会触发Full GC，同时会在日志中记录to-space-exhausted以及Evacuation Failure：</p><p>从年轻代分区拷贝存活对象时，无法找到可用的空闲分区<br>从老年代分区转移存活对象时，无法找到可用的空闲分区<br>分配巨型对象时在老年代无法找到足够的连续分区<br>由于G1的应用场合往往堆内存都比较大，所以Full GC的收集代价非常昂贵，应该避免Full GC的发生。</p></li></ul><p><strong>SATB(Snapshot At the Begging)</strong><br>SATB，也可以称为对象快照技术，在GC之前对整个堆进行一次对象索引关系，形成位图，相当于堆的逻辑快照。在并发回收过程中，通过增量的方式维护这个对象位图。</p><p>SATB解决了什么问题？<br>主要是为了解决并发标记过程中，出现的漏标，误标等问题。</p><p>什么是漏标，误标。<br>在并发标记过程中，APP线程跟GC线程同时进行，GC线程扫描的时候发现一个对象位垃圾对象，不对他进行标记，而APP线程马上就会操作索引指向这个对象。那么在垃圾回收的时候这样漏标的对象被回收就会产生灾难性的后果。也有的情况就是，在GC标记完一个对象不需要回收之后，APP线程之后就会把所有指向这个对象的索引完全去除，那么这就是一个垃圾对象，然而在回收过程之中并没有回收，造成了浮动垃圾，这种情况就是误标。</p><p>漏标、误标的解决方案。<br>解决漏标误标，就必须了解两个名词。第一个名词：三色标记法，第二个名词：writer barrier（写栅栏）<br>首先解释第一个名词：三色标记算法<br>首先我们知道无论是 g1还是CMS垃圾标记算法都叫做根可达（root searching），首先搜索比如 线程栈上的对象、静态变量、常量池中的对象以及jni指针，这个部分往往发生是G1的初始标记阶段，会进行STW。然后就进入了并发标记阶段。首先我们定义：扫描过当前对象以及其子索引对象的为不可回收的对象位黑色对象，有黑色父对象索引指向的，并且未扫描其子索引的对象为灰色对象，需要回收的对象：为白色对象。</p><p>参数控制（文档：HotSpot GC Tuning Guide）</p><p>参数及默认值描述‐XX:+UseG1GCJDK9 之前手动启用 G1-XX:MaxGCPauseMillis&#x3D;200预期的最大 GC 停顿时间；不宜过小，避免每次回收内存少而导致频繁 GC-XX:ParallelGCThreads&#x3D;NSTW 并行线程数，若可用核数 M &lt; 8 则 N&#x3D;1，否则默认 N&#x3D;M*5&#x2F;8-XX:ConcGCThreads&#x3D;N并发阶段并发线程数，默认是 ParallelGCThreads 的 1&#x2F;4</p><p>-XX:InitiatingHeapOccupancyPercent&#x3D;45老年代 region 占比超过 45% 则触发老年代 GC-XX:G1HeapRegionSize&#x3D;N单个 region 大小，1~32MB-XX:G1NewSizePercent&#x3D;5, -XX:G1MaxNewSizePercent&#x3D;60新生代 region 最小占整堆的 5%，最大 60%，超出则触发新生代 GC-XX:G1HeapWastePercent&#x3D;5允许浪费的堆内存占比，可回收内存低于 5% 则不进行混合回收-XX:G1MixedGCLiveThresholdPercent&#x3D;85老年代存活对象占比超 85%，回收价值低，暂不回收-XX:G1MixedGCCountTarget&#x3D;8单次收集中混合回收次数</p><hr><h2 id="2-10内存分配策略"><a href="#2-10内存分配策略" class="headerlink" title="2.10内存分配策略"></a>2.10内存分配策略</h2><ol><li>对象优先分配在 Eden 区</li></ol><p>新对象在 Eden 区分配，空间不足则触发 Minor GC，<strong>存活对象拷贝到 To Survivor</strong>，若还是内存不足则通过分配担保机制转移到老年区，依旧不足才 OOM</p><pre><code class="java">    private static final int int_1MB=1024*1024;    public static void main(String[] args) &#123;        byte[] allocation1,allocation2,allocation3,allocation4;        allocation1=new byte[2*int_1MB];        allocation2=new byte[2*int_1MB];        allocation3=new byte[2*int_1MB];        //发生GC        allocation4=new byte[4*int_1MB];    &#125;//GC参数:-Xmn10M是给新生代分10M,-XX:SurvivorRatio=8是Eden区和一个survivor区的大小比//-Xms20M -Xmx20M -Xmn10M -XX:SurvivorRatio=8 -XX:+PrintGCDetails</code></pre><p>结果:</p><pre><code class="java">[GC (Allocation Failure) [PSYoungGen: 6455K-&gt;936K(9216K)] 6455K-&gt;5040K(19456K), 0.0022870 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] Heap PSYoungGen      total 9216K, used 7290K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)  eden space 8192K, 77% used [0x00000000ff600000,0x00000000ffc349c8,0x00000000ffe00000)  from space 1024K, 91% used [0x00000000ffe00000,0x00000000ffeea020,0x00000000fff00000)  to   space 1024K, 0% used [0x00000000fff00000,0x00000000fff00000,0x0000000100000000) ParOldGen       total 10240K, used 4104K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000) //第四个byte数组由于minorGC一次之后也无法存放在新生代,所以只能放在老年代(object space)  object space 10240K, 40% used [0x00000000fec00000,0x00000000ff002020,0x00000000ff600000) Metaspace       used 3113K, capacity 4486K, committed 4864K, reserved 1056768K  class space    used 323K, capacity 386K, committed 512K, reserved 1048576K</code></pre><ol start="2"><li>大对象直接进入老年区</li></ol><p>对于 Serial, ParNew，可配置超过阈值 -XX:PretenureSizeThreshold 的大对象（连续内存），直接在老年代中分配，避免频繁触发 minor gc，导致 Eden 和 Survivor 产生大量的内存复制操作</p><pre><code class="java">byte[] buf1 = new byte[4 * MB];// java -verbose:gc -Xms20m -Xmx20m -Xmn10m -XX:+PrintGCDetails -XX:+UseSerialGC// -XX:PretenureSizeThreshold=3145728 com.ch03.Allocation // 3145728 即 3MBHeap def new generation   total 9216K, used 843K eden space 8192K,  10% used from space 1024K,   0% used to   space 1024K,   0% used  tenured generation   total 10240K, used 4096K  the space 10240K,  40% used // buf1</code></pre><ol start="3"><li><strong>长期存活的对象进入老年代</strong></li></ol><p><strong>对象头中 4bit 的 age 字段存储了对象当前 GC 分代年龄</strong>，当超过阈值-XX:MaxTenuringThreshold（默认 15，也即 age 字段最大值）后，将晋升到老年代，可搭配-XX:+PrintTenuringDistribution观察分代分布</p><pre><code class="java">byte[] buf1 = new byte[MB / 16];byte[] buf2 = new byte[4 * MB];byte[] buf3 = new byte[4 * MB]; // 触发 minor gcbuf3 = null;buf3 = new byte[4 * MB];// java -verbose:gc -Xms20m -Xmx20m -Xmn10m -XX:+PrintGCDetails -XX:+UseSerialGC // -XX:MaxTenuringThreshold=1 -XX:+PrintTenuringDistribution com.ch03.Allocation[GC (Allocation Failure) [DefNewDesired survivor size 524288 bytes, new threshold 1 (max 1)- age   1:     359280 bytes,     359280 total  : 4839K-&gt;350K(9216K)] 4839K-&gt;4446K(19456K), 0.0017247 secs]   // 至此，buf1 熬过了第一次收集，age=1  [GC (Allocation Failure) [DefNew  Desired survivor size 524288 bytes, new threshold 1 (max 1): 4446K-&gt;0K(9216K)] 8542K-&gt;4438K(19456K)]   Heap   def new generation   total 9216K, used 4178K   eden space 8192K,  51% used   from space 1024K,   0% used // buf1 在第二轮收集中被提前晋升  to   space 1024K,   0% used    tenured generation   total 10240K, used 4438K    the space 10240K,  43% used </code></pre><ol start="4"><li><strong>分代年龄动态判定</strong></li></ol><p>-XX:MaxTenuringThreshold并非晋升的最低硬性门槛，<strong>当 Survivor 中同龄对象超 50% 后，大于等于该年龄的对象会被自动晋升，哪怕还没到阈值</strong></p><ol start="5"><li><strong>空间分配担保</strong></li></ol><p>老年代作为 To Survivor 区的担保区域，当 Eden + From Survivor 中存活对象的总大小超出 To Survivor 时，将尝试存入老年代。JDK6 之后，只要老年代的连续空间大于新生代对象的总大小，或之前晋升的平均大小，则只会进行 Minor GC，否则进行 Full GC</p><h1 id="三-字节码指令"><a href="#三-字节码指令" class="headerlink" title="三.字节码指令"></a>三.字节码指令</h1><pre><code class="java">JVM 面向操作数栈（operand stack）设计了指令集，每个指令由 1 字节的操作码（opcode）表示，其后跟随 0 个或多个操作数（operand），指令集列表参考 Java bytecode instruction listings大部分与数据类型相关的指令，其操作码符号都会带类型前缀，如 i 前缀表示操作 int，剩余对应关系为 b:byte, c:char, s:short, f:float, d:double, l:long, a:reference由于指令集大小有限（256个），故 boolean, byte, char, short 会被转为int运算字节码可大致分为六类：加载和存储指令：将变量从局部变量表 slot 加载到操作数栈的栈顶，反向则是存储// 将 slot 0,1,2,3,N 加载到栈顶，T 表示类型简记前缀，可取 i,l,f,d,aTload_0, Tload_1, Tload_2, Tload_3, Tload n// 将栈顶数据写回指定的 slotTstore_0, Tstore_1, Tstore_2, Tstore_3, Tstore n// 将不同范围的常量值加载到栈顶，由于 0~5 常量过于常用，有单独对应的指令，ldc 则加载普通常量bipush, sipush, Tconst_[0,1,2,3,4,5], aconst_null, ldc-----------------------------------------运算指令Tadd, Tsub, Tmul, Tdiv, Trem     // 算术运算：加减乘除，取余Tneg, Tor, Tand, Txor            // 位运算：取反、或、与、异或dcmpg, dcmpl, fcmpg, fcmpl, lcmp // 比较运算：后缀 g 即 greater, l 即 less thaniinc                             // 局部自增运算，与 iload 搭配使用-------------------------------------------------------强制类型转换指令：窄化转换为 T 类型（长度为 N）时，会直接丢弃除了低 N 位外的其他位，可能会导致数据溢出、正负号不确定，浮点数转整型则会丢失精度i2b // int -&gt; bytei2c, i2s; l2i, f2i, d2i; d2l, f2l; d2f------------------------------------------------对象创建与访问指令：类实例、数组都是对象，存储结构不同，创建和访问指令有所区别new                                      // 创建类实例newarray, annewarray, multianewarry      // 创建基本类型数组、引用类型数组、多维引用类型数组getfield, putfield; getstatic, putstatic // 读写类实例字段；读写类静态字段Taload, Tastore; arraylength             // 读写数组元素；计算数组长度instanceof; checkcast                    // 校验对象是否为类实例；执行强制转换--------------------------------------------------操作数栈管理指令pop, pop2       // 弹出栈顶 1，2 元素dup, dup2; swap // 复制栈顶 1，2 个元素并重新入栈；交换栈顶两个元素控制转移指令：判断条件成立，则跳转到指定的指令行（修改 PC 指向）if_&lt;icmpeq,icmpne;icmplt,icmple;icmpgt,icmpge;acmpe,acmpne&gt; // 整型比较，引用相等性判断if&lt;eq,lt,le,gt,ge,null,nonnull&gt;                             // 搭配其他类型的比较运算指令使用-----------------------------------------------------------方法调用与返回指令invokevirtual   // 根据对象的实际类型进行分派，调用对应的方法（比如继承后方法重写） invokespecial   // 调用特殊方法，如 &lt;cint&gt;()V, &lt;init&gt;()V 等初始化方法、私有方法、父类方法invokestatic    // 调用类的静态方法invokeinterface // 调用接口方法（实现接口的类对象，但被声明为接口类型，调用方法）invokedynamic   // TODOTreturn, return // 返回指定类型，返回 void--------------------------------------------------异常处理指令：athrow 抛出异常，异常处理则由 exception_table 描述同步指令：synchronized 对象锁由 monitorenter, monitorexit 搭配对象的 monitor 锁共同实现</code></pre><h1 id="四-类加载过程"><a href="#四-类加载过程" class="headerlink" title="四.类加载过程"></a>四.类加载过程</h1><p><img src="https://gitee.com/DylanToT99/images/raw/master/images1/05970c54559776859098fd33d74d3f13.png" alt="个人笔记，深入理解 JVM，很全！（终于有人把JVM说清楚了）"></p><h2 id="1-加载"><a href="#1-加载" class="headerlink" title="1. 加载"></a><strong>1. 加载</strong></h2><p>原理：委托 ClassLoader 读取 Class 二进制字节流，载入到方法区内存，并在堆内存中生成对应的java.lang.Class对象相互引用</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images1/f45d23e2713ac8c96a5c88cffe9dc524.png" alt="个人笔记，深入理解 JVM，很全！（终于有人把JVM说清楚了）"></p><h2 id="2-验证"><a href="#2-验证" class="headerlink" title="2. 验证"></a><strong>2. 验证</strong></h2><p>校验字节流确保符合 Class 文件格式，执行语义分析确保符合 Java 语法，校验字节码指令合法性</p><h2 id="3-准备"><a href="#3-准备" class="headerlink" title="3.准备"></a><strong>3.准备</strong></h2><p>在堆中分配类变量（<strong>static</strong>）内存并初始化为零值，主义还没到执行 putstatic 指令赋值的初始化阶段，但静态常量属性除外：</p><pre><code class="java">public class ClassX &#123;final static int n = 2;          // 常量的值在编译期就已知，准备阶段完成赋值，值存储在 ConstantValuefinal static String str = &quot;str&quot;; // 字符串静态常量同理&#125;static final java.lang.String str;descriptor: Ljava/lang/String;flags: ACC_STATIC, ACC_FINALConstantValue: String str</code></pre><h2 id="4-解析"><a href="#4-解析" class="headerlink" title="4.解析"></a>4.解析</h2><p><strong>将常量池中的符号引用（Class_info, Fieldref_info, Methodref_info）替换为直接引用（内存地址）</strong></p><h2 id="5-初始化"><a href="#5-初始化" class="headerlink" title="5.初始化"></a>5.初始化</h2><p>javac 会从上到下合并类中 static 变量赋值、static 语句块，生成类构造器()V，在初始化阶段执行，此方法的执行由 JVM 保证线程安全；注意 JVM 规定有且仅有的，会立即触发对类初始化的六种 case</p><pre><code class="java">public class ClassX &#123;static &#123;  println(&quot;main class ClassX init&quot;); // 1. main() 所在的主类，总是先被初始化&#125; public static void main(String[] args) throws Exception &#123;  // 首次会触发类的初始化  // SubX b = new SubX();  // new 对象 // 2. new, getsatic, putstatic, invokestatic 指令  // println(SuperX.a);    // 读写类的 static 变量，或调用 static 方法   // println(SubX.c);      // 3. 子类初始化，会触发父类初始化  // println(SubX.a);      //    子类访问父类的静态变量，只会触发父类初始化    // 不会触发类的初始化  // println(SubX.b);      // 1. 访问类的静态常量（基本类型、字符串字面量）  // println(SubX.class);  // 2. 访问类对象  // println(new SubX[2]); // 3. 创建类的数组&#125;&#125; class SuperX &#123;static int a = 0;static &#123;  println(&quot;class SuperX initiated&quot;);&#125;&#125; class SubX extends SuperX &#123;final static double b = 0.1;static boolean c = false;static &#123;  println(&quot;class SubX initiated&quot;);&#125;&#125;</code></pre><h1 id="五-类加载器"><a href="#五-类加载器" class="headerlink" title="五.类加载器"></a>五.类加载器</h1><p><img src="https://gitee.com/DylanToT99/images/raw/master/images1/b71073a9cf3eacd71d7144b0f75371b5.png" alt="个人笔记，深入理解 JVM，很全！（终于有人把JVM说清楚了）"></p><p>双亲委派机制</p><p>原理：一个类加载器收到加载某个类的请求时，会先委派上层的父类加载器去加载，逐层向上，当父类加载器逐层向下反馈都无法加载此类后，该类加载器才会尝试自己加载；此模型保证了，诸如 rt.jar 中的java.lang.Object类，不论在底层哪种类加载器中都一定是被 Bootstrap 类加载器加载， JVM 中仅此一份，保证了一致性</p><pre><code class="java">// java/lang/ClassLoaderprotected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException &#123;    synchronized (getClassLoadingLock(name)) &#123;        // 1. 先检查自己的加载器是否已加载此类        Class&lt;?&gt; c = findLoadedClass(name);        if (c == null) &#123;            long t0 = System.nanoTime();            try &#123;                if (parent != null) &#123;                    // 2. 还有上层则委派给上层去加载                    c = parent.loadClass(name, false);                &#125; else &#123;                    // 3. 如果没有上级，则委派给 Bootstrap 加载                    c = findBootstrapClassOrNull(name);                &#125;            &#125; catch (ClassNotFoundException e) &#123;                // 类不存在            &#125;             if (c == null) &#123;                // 4. 到自己的 classpath 中查找类，用户自定义 ClassLoader 自定义了查找规则                long t1 = System.nanoTime();                c = findClass(name);            &#125;        &#125;        if (resolve) &#123;            resolveClass(c);        &#125;        return c;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
          <category> java虚拟机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql锁</title>
      <link href="/2022/08/09/mysql-suo/"/>
      <url>/2022/08/09/mysql-suo/</url>
      
        <content type="html"><![CDATA[<h1 id="Mysql锁"><a href="#Mysql锁" class="headerlink" title="Mysql锁"></a>Mysql锁</h1><h1 id="MySQL-有哪些锁"><a href="#MySQL-有哪些锁" class="headerlink" title="MySQL 有哪些锁"></a>MySQL 有哪些锁</h1><h2 id="1-全局锁"><a href="#1-全局锁" class="headerlink" title="1.全局锁"></a>1.全局锁</h2><blockquote><p>全局锁是怎么用的？</p></blockquote><p>要使用全局锁，则要执行这条命令：</p><pre><code class="sql">flush tables with read lock</code></pre><p>执行后，<strong>整个数据库就处于只读状态了</strong>，这时其他线程执行以下操作，都会被阻塞：</p><ul><li>对数据的增删改操作，比如 insert、delete、update 等语句；</li><li>对表结构的更改操作，比如 alter table、drop table 等语句。</li></ul><p>如果要释放全局锁，则要执行这条命令：</p><pre><code class="sql">unlock tables</code></pre><p>当然，当会话断开了，全局锁会被自动释放。</p><blockquote><p>全局锁的应用场景是什么</p></blockquote><p>全局锁主要应用于做<strong>全库逻辑备份</strong>，这样在备份数据库期间，不会因为数据或表结构的更新，而出现备份文件的数据与预期的不一样。</p><blockquote><p>既然备份数据库数据的时候，使用全局锁会影响业务，那有什么其他方式可以避免？</p></blockquote><p>有的，如果数据库的引擎支持的事务支持<strong>可重复读的隔离级别</strong>，那么在备份数据库之前先开启事务，会先创建 Read View，然后整个事务执行期间都在用这个 Read View，而且由于 MVCC 的支持，备份期间业务依然可以对数据进行更新操作。</p><p>InnoDB 存储引擎默认的事务隔离级别正是可重复读，因此可以采用这种方式来备份数据库。</p><p>但是，对于 MyISAM 这种不支持事务的引擎，在备份数据库时就要使用全局锁的方法。</p><h2 id="2-表级锁"><a href="#2-表级锁" class="headerlink" title="2.表级锁"></a>2.表级锁</h2><p>MySQL 里面表级别的锁有这几种：</p><ul><li>表锁；</li><li>元数据锁（MDL）;</li><li>意向锁；</li><li>AUTO-INC 锁；</li></ul><h3 id="2-1-表锁"><a href="#2-1-表锁" class="headerlink" title="2.1 表锁"></a>2.1 表锁</h3><p>先来说说<strong>表锁</strong>。</p><p>如果我们想对学生表（t_student）加表锁，可以使用下面的命令：</p><pre><code class="sql">//表级别的共享锁，也就是读锁；lock tables t_student read;//表级别的独占锁，也就是写锁；lock tables t_stuent write;</code></pre><p>需要注意的是，表锁除了会限制别的线程的读写外，也会限制本线程接下来的读写操作。</p><p>也就是说如果本线程对学生表加了「共享表锁」，那么本线程接下来如果要对学生表执行写操作的语句，是会被阻塞的，当然其他线程对学生表进行写操作时也会被阻塞，直到锁被释放。</p><p>要释放表锁，可以使用下面这条命令，会释放当前会话的所有表锁：</p><pre><code class="sql">unlock tables</code></pre><p>另外，当会话退出后，也会释放所有表锁。</p><p>不过尽量避免在使用 InnoDB 引擎的表使用表锁，因为表锁的颗粒度太大，会影响并发性能，<strong>InnoDB 牛逼的地方在于实现了颗粒度更细的行级锁</strong>。</p><h3 id="2-2-元数据锁"><a href="#2-2-元数据锁" class="headerlink" title="2.2 元数据锁"></a>2.2 元数据锁</h3><p>再来说说<strong>元数据锁</strong>（MDL）。</p><p>我们不需要显示的使用 MDL，因为当我们对数据库表进行操作时，会自动给这个表加上 MDL：</p><ul><li>对一张表进行 CRUD 操作时，加的是 <strong>MDL 读锁</strong>；</li><li>对一张表做结构变更操作的时候，加的是 <strong>MDL 写锁</strong>；</li></ul><p>MDL 是为了保证当用户对表执行 CRUD 操作时，防止其他线程对这个表结构做了变更。</p><p>当有线程在执行 select 语句（ 加 MDL 读锁）的期间，如果有其他线程要更改该表的结构（ 申请 MDL 写锁），那么将会被阻塞，直到执行完 select 语句（ 释放 MDL 读锁）。</p><p>反之，当有线程对表结构进行变更（ 加 MDL 写锁）的期间，如果有其他线程执行了 CRUD 操作（ 申请 MDL 读锁），那么就会被阻塞，直到表结构变更完成（ 释放 MDL 写锁）。</p><blockquote><p>MDL 不需要显示调用，那它是在什么时候释放的?</p></blockquote><p>MDL 是在事务提交后才会释放，这意味着<strong>事务执行期间，MDL 是一直持有的</strong>。</p><p>那如果数据库有一个长事务（所谓的长事务，就是开启了事务，但是一直还没提交），那在对表结构做变更操作的时候，可能会发生意想不到的事情，比如下面这个顺序的场景：</p><ol><li>首先，线程 A 先启用了事务（但是一直不提交），然后执行一条 select 语句，此时就先对该表加上 MDL 读锁；</li><li>然后，线程 B 也执行了同样的 select 语句，此时并不会阻塞，因为「读读」并不冲突；</li><li>接着，线程 C 修改了表字段，此时由于线程 A 的事务并没有提交，也就是 MDL 读锁还在占用着，这时线程 C 就无法申请到 MDL 写锁，就会被阻塞，</li></ol><p>那么在线程 C 阻塞后，后续有对该表的 select 语句，就都会被阻塞，如果此时有大量该表的 select 语句的请求到来，就会有大量的线程被阻塞住，这时数据库的线程很快就会爆满了。</p><hr><h3 id="2-3-意向锁"><a href="#2-3-意向锁" class="headerlink" title="2.3 意向锁"></a>2.3 意向锁</h3><ul><li>在使用 InnoDB 引擎的表里对某些记录加上「共享锁」之前，需要先在表级别加上一个「意向共享锁」；</li><li>在使用 InnoDB 引擎的表里对某些纪录加上「独占锁」之前，需要先在表级别加上一个「意向独占锁」；</li></ul><p>也就是，当执行插入、更新、删除操作，需要先对表加上「意向独占锁」，然后对该记录加独占锁。</p><p>而普通的 select 是不会加行级锁的，普通的 select 语句是利用 MVCC 实现一致性读，是无锁的。</p><p>不过，select 也是可以对记录加共享锁和独占锁的，具体方式如下：</p><pre><code class="sql">//先在表上加上意向共享锁，然后对读取的记录加共享锁select ... lock in share mode;//先表上加上意向独占锁，然后对读取的记录加独占锁select ... for update;</code></pre><p><strong>意向共享锁和意向独占锁是表级锁，不会和行级的共享锁和独占锁发生冲突，而且意向锁之间也不会发生冲突，只会和共享表锁（</strong>​<em><strong>lock tables … read</strong></em>​<strong>）和独占表锁（</strong>​<em><strong>lock tables … write</strong></em>​<strong>）发生冲突。</strong></p><p>如果没有「意向锁」，那么加「独占表锁」时，就需要遍历表里所有记录，查看是否有记录存在独占锁，这样效率会很慢。</p><p>那么有了「意向锁」，由于在对记录加独占锁前，先会加上表级别的意向独占锁，那么在加「独占表锁」时，直接查该表是否有意向独占锁，如果有就意味着表里已经有记录被加了独占锁，这样就不用去遍历表里的记录。</p><p>所以，<strong>意向锁的目的是为了快速判断表里是否有记录被加锁</strong>。</p><hr><h3 id="2-4AUTO-INC-锁"><a href="#2-4AUTO-INC-锁" class="headerlink" title="2.4AUTO-INC 锁"></a>2.4AUTO-INC 锁</h3><p>表里的主键通常都会设置成自增的，这是通过对主键字段声明 <code>AUTO_INCREMENT</code>​ 属性实现的。</p><p>之后可以在插入数据时，可以不指定主键的值，数据库会自动给主键赋值递增的值，这主要是通过 <strong>AUTO-INC 锁</strong>实现的。</p><p>AUTO-INC 锁是特殊的表锁机制，锁<strong>不是再一个事务提交后才释放，而是再执行完插入语句后就会立即释放</strong>。</p><p><strong>在插入数据时，会加一个表级别的 AUTO-INC 锁</strong>，然后为被 <code>AUTO_INCREMENT</code>​ 修饰的字段赋值递增的值，等插入语句执行完成后，才会把 AUTO-INC 锁释放掉,这也会影响性能.</p><p>因此， 在 MySQL 5.1.22 版本开始，InnoDB 存储引擎提供了一种<strong>轻量级的锁</strong>来实现自增。</p><p>一样也是在插入数据的时候，会为被 <code>AUTO_INCREMENT</code>​​ 修饰的字段加上轻量级锁，<strong>然后给该字段赋值一个自增的值，就把这个轻量级锁释放了，而不需要等待整个插入语句执行完后才释放锁</strong>。</p><h2 id="3-行级锁"><a href="#3-行级锁" class="headerlink" title="3.行级锁"></a>3.行级锁</h2><p>InnoDB 引擎是支持行级锁的，而 MyISAM 引擎并不支持行级锁。</p><p>前面也提到，普通的 select 语句是不会对记录加锁的，因为它属于快照读。如果要在查询时对记录加行锁，可以使用下面这两个方式，这种查询会加锁的语句称为<strong>锁定读</strong>。</p><pre><code class="sql">//对读取的记录加共享锁select ... lock in share mode;//对读取的记录加独占锁select ... for update;</code></pre><p>上面这两条语句必须在一个事务中，<strong>因为当事务提交了，锁就会被释放</strong>，所以在使用这两条语句的时候，要加上 begin、start transaction 或者 set autocommit &#x3D; 0。</p><p>共享锁（S 锁）满足读读共享，读写互斥。独占锁（X 锁）满足写写互斥、读写互斥。</p><p>行级锁的类型主要有三类：</p><ul><li>Record Lock，记录锁，也就是仅仅把一条记录锁上；</li><li>Gap Lock，间隙锁，锁定一个范围，但是不包含记录本身；</li><li>Next-Key Lock：Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。</li></ul><h3 id="3-1Record-Lock"><a href="#3-1Record-Lock" class="headerlink" title="3.1Record Lock"></a>3.1Record Lock</h3><p>Record Lock 称为记录锁，锁住的是一条记录。而且记录锁是有 S 锁和 X 锁之分的：</p><ul><li>当一个事务对一条记录加了 S 型记录锁后，其他事务也可以继续对该记录加 S 型记录锁（S 型与 S 锁兼容），但是不可以对该记录加 X 型记录锁（S 型与 X 锁不兼容）;</li><li>当一个事务对一条记录加了 X 型记录锁后，其他事务既不可以对该记录加 S 型记录锁（S 型与 X 锁不兼容），也不可以对该记录加 X 型记录锁（X 型与 X 锁不兼容）。</li></ul><h3 id="3-2Gap-Lock"><a href="#3-2Gap-Lock" class="headerlink" title="3.2Gap Lock"></a>3.2Gap Lock</h3><p>Gap Lock 称为间隙锁，只存在于可重复读隔离级别，目的是为了解决可重复读隔离级别下幻读的现象。</p><p>假设，表中有一个范围 id 为（3，5）间隙锁，那么其他事务就无法插入 id &#x3D; 4 这条记录了，这样就有效的防止幻读现象的发生。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/%E9%94%81/gap%E9%94%81.drawio.png" alt="51w5qew">​</p><p>间隙锁虽然存在 X 型间隙锁和 S 型间隙锁，但是并没有什么区别，<strong>间隙锁之间是兼容的，即两个事务可以同时持有包含共同间隙范围的间隙锁，并不存在互斥关系，因为间隙锁的目的是防止插入幻影记录而提出的</strong>。</p><hr><h3 id="3-3Next-Key-Lock"><a href="#3-3Next-Key-Lock" class="headerlink" title="3.3Next-Key Lock"></a>3.3Next-Key Lock</h3><p>Next-Key Lock 称为临键锁，是 Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。</p><p>假设，表中有一个范围 id 为（3，5] 的 next-key lock，那么其他事务即不能插入 id &#x3D; 4 记录，也不能修改 id &#x3D; 5 这条记录。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/%E9%94%81/%E4%B8%B4%E9%94%AE%E9%94%81.drawio.png" alt="dw65q151qew">​</p><p>所以，next-key lock 即能保护该记录，又能阻止其他事务将新纪录插入到被保护记录前面的间隙中。</p><p><strong>next-key lock 是包含间隙锁 + 记录锁的，如果一个事务获取了 X 型的 next-key lock，那么另外一个事务在获取相同范围的 X 型的 next-key lock 时，是会被阻塞的</strong>。</p><p>比如，一个事务持有了范围为 (1, 10] 的 X 型的 next-key lock，那么另外一个事务在获取相同范围的 X 型的 next-key lock 时，就会被阻塞。</p><p>虽然相同范围的间隙锁是多个事务相互兼容的，但对于记录锁，我们是要考虑 X 型与 S 型关系，X 型的记录锁与 X 型的记录锁是冲突的。</p><hr><h3 id="3-4-插入意向锁"><a href="#3-4-插入意向锁" class="headerlink" title="3.4 插入意向锁"></a>3.4 插入意向锁</h3><p>一个事务在插入一条记录的时候，需要判断插入位置是否已被其他事务加了间隙锁（next-key lock 也包含间隙锁）。</p><p>如果有的话，插入操作就会发生<strong>阻塞</strong>，直到拥有间隙锁的那个事务提交为止（释放间隙锁的时刻），在此期间会生成一个<strong>插入意向锁</strong>，表明有事务想在某个区间插入新记录，但是现在处于等待状态。</p><p>插入意向锁名字虽然有意向锁，但是它并<strong>不是意向锁，它是一种特殊的间隙锁，属于行级别锁</strong>。</p><p>如果说间隙锁锁住的是一个区间，那么「插入意向锁」锁住的就是一个点。因而从这个角度来说，插入意向锁确实是一种特殊的间隙锁。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL原理</title>
      <link href="/2022/08/07/mysql-yuan-li-xue-xi/"/>
      <url>/2022/08/07/mysql-yuan-li-xue-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="一-执行了一条select语句-中间发生了什么"><a href="#一-执行了一条select语句-中间发生了什么" class="headerlink" title="一.执行了一条select语句,中间发生了什么"></a>一.执行了一条select语句,中间发生了什么</h1><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230308103152867.png" alt="image-20230308103152867"></p><ul><li>连接器:建立连接,管理连接,检验用户身份</li><li>查询缓存：查询语句如果命中查询缓存则直接返回，否则继续往下执行。MySQL 8.0 已删除该模块；</li><li>解析 SQL，通过解析器对 SQL 查询语句进行词法分析、语法分析，然后构建语法树，方便后续模块读取表名、字段、语句类型；</li><li>执行 SQL：执行 SQL 共有三个阶段：<ul><li>预处理阶段：检查表或字段是否存在；将 <code>select *</code> 中的 <code>*</code> 符号扩展为表上的所有列。</li><li>优化阶段：基于查询成本的考虑， 选择查询成本最小的执行计划；</li><li>执行阶段：根据执行计划执行 SQL 查询语句，从存储引擎读取记录，返回给客户端；</li></ul></li></ul><h1 id="二-MySQL一行记录是怎么存储的"><a href="#二-MySQL一行记录是怎么存储的" class="headerlink" title="二.MySQL一行记录是怎么存储的"></a>二.MySQL一行记录是怎么存储的</h1><h2 id="1-表空间文件的结构"><a href="#1-表空间文件的结构" class="headerlink" title="1.表空间文件的结构:"></a>1.表空间文件的结构:</h2><p><strong>表空间由段（segment）、区（extent）、页（page）、行（row）组成</strong>，InnoDB存储引擎的逻辑存储结构大致如下图：</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230308103416566.png" alt="image-20230308103416566"></p><p>注意,记录是按照行来存储的，但是数据库的读取并不以「行」为单位，否则一次读取（也就是一次 I&#x2F;O 操作）只能处理一行数据，效率会非常低。</p><p>因此，<strong>InnoDB 的数据是按「页」为单位来读写的</strong>，也就是说，当需要读一条记录的时候，并不是将这个行记录从磁盘读出来，而是以页为单位，将其整体读入内存。</p><p><strong>默认每个页的大小为 16KB</strong>，也就是最多能保证 16KB 的连续存储空间。</p><p>页是 InnoDB 存储引擎磁盘管理的最小单元，意味着数据库每次读写都是以 16KB 为单位的，一次最少从磁盘中读取 16K 的内容到内存中，一次最少把内存中的 16K 内容刷新到磁盘中。</p><p><strong>在表中数据量大的时候，为某个索引分配空间的时候就不再按照页为单位分配了，而是按照区（extent）为单位分配。每个区的大小为 1MB，对于 16KB 的页来说，连续的 64 个页会被划为一个区，这样就使得链表中相邻的页的物理位置也相邻，就能使用顺序 I&#x2F;O 了</strong>。</p><h2 id="2-行格式"><a href="#2-行格式" class="headerlink" title="2.行格式"></a>2.行格式</h2><p>InnoDB 提供了 4 种行格式，分别是 Redundant、Compact、Dynamic和 Compressed 行格式。</p><ul><li>Redundant 是很古老的行格式了， MySQL 5.0 版本之前用的行格式，现在基本没人用了。</li><li>Dynamic 和 Compressed 两个都是紧凑的行格式，它们的行格式都和 Compact 差不多，因为都是基于 Compact 改进一点东西。从 MySQL5.7 版本之后，默认使用 Dynamic 行格式。</li></ul><h3 id="2-1COMPACT行格式"><a href="#2-1COMPACT行格式" class="headerlink" title="2.1COMPACT行格式"></a>2.1COMPACT行格式</h3><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230308103735117.png" alt="image-20230308103735117"></p><h3 id="2-2变长字段长度列表"><a href="#2-2变长字段长度列表" class="headerlink" title="2.2变长字段长度列表"></a>2.2变长字段长度列表</h3><p>varchar(n) 和 char(n) 的区别是什么，相信大家都非常清楚，char 是定长的，varchar 是变长的，变长字段实际存储的数据的长度（大小）不固定的。</p><p>所以，在存储数据的时候，也要把数据占用的大小存起来，存到「变长字段长度列表」里面，读取数据的时候才能根据这个「变长字段长度列表」去读取对应长度的数据。其他 TEXT、BLOB 等变长字段也是这么实现的。这些变长字段的真实数据占用的字节数会按照列的顺序<strong>逆序存放</strong></p><p>「变长字段长度列表」中的信息之所以要逆序存放，是因为这样可以<strong>使得位置靠前的记录的真实数据和数据对应的字段长度信息可以同时在一个 CPU Cache Line 中，这样就可以提高 CPU Cache 的命中率</strong>。</p><h3 id="2-3-null值列表"><a href="#2-3-null值列表" class="headerlink" title="2.3 null值列表"></a>2.3 null值列表</h3><p>表中的某些列可能会存储 NULL 值，如果把这些 NULL 值都放到记录的真实数据中会比较浪费空间，所以 Compact 行格式把这些值为 NULL 的列存储到 NULL值列表中。</p><p>如果存在允许 NULL 值的列，则每个列对应一个二进制位（bit），二进制位按照列的顺序逆序排列。</p><ul><li>二进制位的值为<code>1</code>时，代表该列的值为NULL。</li><li>二进制位的值为<code>0</code>时，代表该列的值不为NULL。</li></ul><p>另外，NULL 值列表必须用整数个字节的位表示（1字节8位），如果使用的二进制位个数不足整数个字节，则在字节的高位补 <code>0</code></p><blockquote><p>每个数据库表的行格式都有「NULL 值列表」吗？</p></blockquote><p>NULL 值列表也不是必须的。</p><p><strong>当数据表的字段都定义成 NOT NULL 的时候，这时候表里的行格式就不会有 NULL 值列表了</strong>。</p><p>所以在设计数据库表的时候，通常都是建议将字段设置为 NOT NULL，这样可以至少节省 1 字节的空间（NULL 值列表至少占用 1 字节空间）。</p><blockquote><p>「NULL 值列表」是固定 1 字节空间吗？如果这样的话，一条记录有 9 个字段值都是 NULL，这时候怎么表示？</p></blockquote><p>「NULL 值列表」的空间不是固定 1 字节的。</p><p>当一条记录有 9 个字段值都是 NULL，那么就会创建 2 字节空间的「NULL 值列表」，以此类推。</p><h3 id="2-4记录头信息"><a href="#2-4记录头信息" class="headerlink" title="2.4记录头信息"></a>2.4记录头信息</h3><p>记录头信息中包含的内容很多，这里说几个比较重要的：</p><ul><li>delete_mask ：标识此条数据是否被删除。从这里可以知道，我们执行 detele 删除记录的时候，并不会真正的删除记录，只是将这个记录的 delete_mask 标记为 1。</li><li>next_record：下一条记录的位置。从这里可以知道，记录与记录之间是通过链表组织的。在前面我也提到了，指向的是下一条记录的「记录头信息」和「真实数据」之间的位置，这样的好处是向左读就是记录头信息，向右读就是真实数据，比较方便。</li><li>record_type：表示当前记录的类型，0表示普通记录，1表示B+树非叶子节点记录，2表示最小记录，3表示最大记录</li></ul><h3 id="2-5记录的真实数据"><a href="#2-5记录的真实数据" class="headerlink" title="2.5记录的真实数据"></a>2.5记录的真实数据</h3><p>记录真实数据部分除了我们定义的字段，还有三个隐藏字段，分别为：row_id、trx_id、roll_pointer，我们来看下这三个字段是什么。</p><ul><li>row_id</li></ul><p>​如果我们建表的时候指定了主键或者唯一约束列，那么就没有 row_id 隐藏字段了。如果既没有指定主键，又没有唯一约束，那么 InnoDB 就会为记录添加 row_id 隐藏字段。<strong>row_id不是必需的，占用 6 个字节。</strong></p><ul><li>trx_id</li></ul><p>​事务id，表示这个数据是由哪个事务生成的。 <strong>trx_id是必需的，占用 6 个字节。</strong></p><ul><li>roll_pointer</li></ul><p>​这条记录上一个版本的指针。<strong>roll_pointer 是必需的，占用 7 个字节。</strong></p><h2 id="3-varchar-n-中-n-最大取值为多少？"><a href="#3-varchar-n-中-n-最大取值为多少？" class="headerlink" title="3.varchar(n) 中 n 最大取值为多少？"></a>3.varchar(n) 中 n 最大取值为多少？</h2><p>我们要清楚一点，<strong>MySQL 规定除了 TEXT、BLOBs 这种大对象类型之外，其他所有的列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过 65535 个字节</strong>。</p><p>也就是说，一行记录除了 TEXT、BLOBs 类型的列，限制最大为 65535 字节，注意是一行的总长度，不是一列。</p><p>要算 varchar(n) 最大能允许存储的字节数，还要看数据库表的字符集，因为字符集代表着，1个字符要占用多少字节，比如 ascii 字符集， 1 个字符占用 1 字节，那么 varchar(100) 意味着最大能允许存储 100 字节的数据。</p><h2 id="4-行溢出后-MySQL的处理方式"><a href="#4-行溢出后-MySQL的处理方式" class="headerlink" title="4.行溢出后,MySQL的处理方式"></a>4.行溢出后,MySQL的处理方式</h2><p>MySQL 中磁盘和内存交互的基本单位是页，一个页的大小一般是 <code>16KB</code>，也就是 <code>16384字节</code>，而一个 varchar(n) 类型的列最多可以存储 <code>65532字节</code>，一些大对象如 TEXT、BLOB 可能存储更多的数据，这时一个页可能就存不了一条记录。这个时候就会<strong>发生行溢出，多的数据就会存到另外的「溢出页」中</strong>。</p><p>如果一个数据页存不了一条记录，InnoDB 存储引擎会自动将溢出的数据存放到「溢出页」中。在一般情况下，InnoDB 的数据都是存放在 「数据页」中。但是当发生行溢出时，溢出的数据会存放到「溢出页」中。</p><p>当发生行溢出时，在记录的真实数据处只会保存该列的一部分数据，而把剩余的数据放在「溢出页」中，然后真实数据处用 20 字节存储指向溢出页的地址，从而可以找到剩余数据所在的页。大致如下图所示。</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230308104554936.png" alt="image-20230308104554936"></p><p>上面这个是 Compact 行格式在发生行溢出后的处理。</p><p>Compressed 和 Dynamic 这两个行格式和 Compact 非常类似，主要的区别在于处理行溢出数据时有些区别。</p><p>这两种格式采用完全的行溢出方式，记录的真实数据处不会存储该列的一部分数据，只存储 20 个字节的指针来指向溢出页。而实际的数据都存储在溢出页中，看起来就像下面这样：</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230308104606480.png" alt="image-20230308104606480"></p><h1 id="三-索引"><a href="#三-索引" class="headerlink" title="三.索引"></a>三.索引</h1><h2 id="3-1什么是索引？"><a href="#3-1什么是索引？" class="headerlink" title="3.1什么是索引？"></a>3.1什么是索引？</h2><p>那换到数据库中，索引的定义就是帮助存储引擎快速获取数据的一种数据结构，形象的说就是<strong>索引是数据的目录</strong>。</p><p>所以索引是以空间换时间的设计思想,帮助我们快速找到数据</p><h2 id="3-2索引的分类"><a href="#3-2索引的分类" class="headerlink" title="3.2索引的分类"></a>3.2索引的分类</h2><p>我们可以按照四个角度来分类索引。</p><ul><li>按「数据结构」分类：<strong>B+tree索引、Hash索引、Full-text索引</strong>。</li><li>按「物理存储」分类：<strong>聚簇索引（主键索引）、二级索引（辅助索引）</strong>。</li><li>按「字段特性」分类：<strong>主键索引、唯一索引、普通索引、前缀索引</strong>。</li><li>按「字段个数」分类：<strong>单列索引、联合索引</strong>。</li></ul><p>InnoDB 是在 MySQL 5.5 之后成为默认的 MySQL 存储引擎，B+Tree 索引类型也是 MySQL 存储引擎采用最多的索引类型。</p><p>在创建表时，InnoDB 存储引擎会根据不同的场景选择不同的列作为索引：</p><ul><li>如果有主键，默认会使用主键作为聚簇索引的索引键（key）；</li><li>如果没有主键，就选择第一个不包含 NULL 值的唯一列作为聚簇索引的索引键（key）；</li><li>在上面两个都没有的情况下，<strong>InnoDB 将自动生成一个隐式自增 id 列作为聚簇索引的索引键（key）；</strong></li></ul><p>其它索引都属于辅助索引（Secondary Index），也被称为二级索引或非聚簇索引。<strong>创建的主键索引和二级索引默认使用的是 B+Tree 索引</strong>。</p><p>B+Tree 存储千万级的数据只需要 3-4 层高度就可以满足，这意味着从千万级的表查询目标数据最多需要 3-4 次磁盘 I&#x2F;O，所以<strong>B+Tree 相比于 B 树和二叉树来说，最大的优势在于查询效率很高，因为即使在数据量很大的情况，查询一个数据的磁盘 I&#x2F;O 依然维持在 3-4次</strong></p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230308105005454.png" alt="image-20230308105005454"></p><h3 id="为什么-MySQL-InnoDB-选择-B-tree-作为索引的数据结构？"><a href="#为什么-MySQL-InnoDB-选择-B-tree-作为索引的数据结构？" class="headerlink" title="为什么 MySQL InnoDB 选择 B+tree 作为索引的数据结构？"></a>为什么 MySQL InnoDB 选择 B+tree 作为索引的数据结构？</h3><ul><li>B+ 树的非叶子节点不存放实际的记录数据，仅存放索引，因此数据量相同的情况下，相比存储即存索引又存记录的 B 树，B+树的非叶子节点可以存放更多的索引，因此 B+ 树可以比 B 树更「矮胖」，查询底层节点的磁盘 I&#x2F;O次数会更少。</li><li>B+ 树有大量的冗余节点（所有非叶子节点都是冗余索引），这些冗余索引让 B+ 树在插入、删除的效率都更高，比如删除根节点的时候，不会像 B 树那样会发生复杂的树的变化；</li><li>B+ 树叶子节点之间用链表连接了起来，有利于范围查询，而 B 树要实现范围查询，因此只能通过树的遍历来完成范围查询，这会涉及多个节点的磁盘 I&#x2F;O 操作，范围查询效率不如 B+ 树。</li></ul><h2 id="3-3什么时候需要-不需要索引"><a href="#3-3什么时候需要-不需要索引" class="headerlink" title="3.3什么时候需要&#x2F;不需要索引"></a>3.3什么时候需要&#x2F;不需要索引</h2><p>索引最大的好处是提高查询速度，但是索引也是有缺点的，比如：</p><ul><li>需要占用物理空间，数量越大，占用空间越大；</li><li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增大；</li><li>会降低表的增删改的效率，因为每次增删改索引，B+ 树为了维护索引有序性，都需要进行动态维护。</li></ul><p>所以，索引不是万能钥匙，它也是根据场景来使用的。</p><h3 id="什么时候适用索引"><a href="#什么时候适用索引" class="headerlink" title="什么时候适用索引"></a>什么时候适用索引</h3><ul><li>字段有唯一性限制的，比如商品编码；</li><li>经常用于 <code>WHERE</code> 查询条件的字段，这样能够提高整个表的查询速度，如果查询条件不是一个字段，可以建立联合索引。</li><li>经常用于 <code>GROUP BY</code> 和 <code>ORDER BY</code> 的字段，这样在查询的时候就不需要再去做一次排序了，因为我们都已经知道了建立索引之后在 B+Tree 中的记录都是排序好的。</li></ul><h3 id="什么时候不需要索引"><a href="#什么时候不需要索引" class="headerlink" title="什么时候不需要索引"></a>什么时候不需要索引</h3><ul><li><code>WHERE</code> 条件，<code>GROUP BY</code>，<code>ORDER BY</code> 里用不到的字段，索引的价值是快速定位，如果起不到定位的字段通常是不需要创建索引的，因为索引是会占用物理空间的。</li><li>字段中存在大量重复数据，不需要创建索引，比如性别字段，只有男女，如果数据库表中，男女的记录分布均匀，那么无论搜索哪个值都可能得到一半的数据。在这些情况下，还不如不要索引，因为 MySQL 还有一个查询优化器，查询优化器发现某个值出现在表的数据行中的百分比很高的时候，它一般会忽略索引，进行全表扫描。</li><li>表数据太少的时候，不需要创建索引；</li><li>经常更新的字段不用创建索引，比如不要对电商项目的用户余额建立索引，因为索引字段频繁修改，由于要维护 B+Tree的有序性，那么就需要频繁的重建索引，这个过程是会影响数据库性能的。</li></ul><h2 id="3-4-索引的优化方法"><a href="#3-4-索引的优化方法" class="headerlink" title="3.4 索引的优化方法"></a>3.4 索引的优化方法</h2><h3 id="前缀索引优化"><a href="#前缀索引优化" class="headerlink" title="前缀索引优化"></a>前缀索引优化</h3><p>前缀索引顾名思义就是使用某个字段中字符串的前几个字符建立索引，那我们为什么需要使用前缀来建立索引呢？</p><p>使用前缀索引是为了减小索引字段大小，可以增加一个索引页中存储的索引值，有效提高索引的查询速度。在一些大字符串的字段作为索引时，使用前缀索引可以帮助我们减小索引项的大小。</p><p>不过，前缀索引有一定的局限性，例如：</p><ul><li>order by 就无法使用前缀索引；</li><li>无法把前缀索引用作覆盖索引；</li></ul><h3 id="覆盖索引优化"><a href="#覆盖索引优化" class="headerlink" title="覆盖索引优化"></a>覆盖索引优化</h3><p>覆盖索引是指 SQL 中 query 的所有字段，在索引 B+Tree 的叶子节点上都能找得到的那些索引，从二级索引中查询得到记录，而不需要通过聚簇索引查询获得，可以避免回表的操作。</p><p>假设我们只需要查询商品的名称、价格，有什么方式可以避免回表呢？</p><p>我们可以建立一个联合索引，即「商品ID、名称、价格」<strong>作为一个联合索引。</strong>如果索引中存在这些数据，查询将不会再次检索主键索引，从而避免回表。</p><p>所以，使用覆盖索引的好处就是，不需要查询出包含整行记录的所有信息，也就减少了大量的 I&#x2F;O 操作。</p><h3 id="主键索引最好是自增的"><a href="#主键索引最好是自增的" class="headerlink" title="主键索引最好是自增的"></a>主键索引最好是自增的</h3><p>InnoDB 创建主键索引默认为聚簇索引，数据被存放在了 B+Tree 的叶子节点上。也就是说，同一个叶子节点内的各个数据是按主键顺序存放的，因此，每当有一条新的数据插入时，数据库会根据主键将其插入到对应的叶子节点中。</p><p><strong>如果我们使用自增主键</strong>，那么每次插入的新数据就会按顺序添加到当前索引节点的位置，不需要移动已有的数据，当页面写满，就会自动开辟一个新页面。因为每次<strong>插入一条新记录，都是追加操作，不需要重新移动数据</strong>，因此这种插入数据的方法效率非常高。</p><p><strong>如果我们使用非自增主键</strong>，由于每次插入主键的索引值都是随机的，因此每次插入新的数据时，就可能会插入到现有数据页中间的某个位置，这将不得不移动其它数据来满足新数据的插入，甚至需要从一个页面复制数据到另外一个页面，我们通常将这种情况称为<strong>页分裂</strong>。<strong>页分裂还有可能会造成大量的内存碎片，导致索引结构不紧凑，从而影响查询效率</strong>。</p><p>举个例子，假设某个数据页中的数据是1、3、5、9，且数据页满了，现在准备插入一个数据7，则需要把数据页分割为两个数据页：</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230308105848496.png" alt="image-20230308105848496"></p><p>出现页分裂时，需要将一个页的记录移动到另外一个页，性能会受到影响，同时页空间的利用率下降，造成存储空间的浪费。</p><p>而如果记录是顺序插入的，例如插入数据11，则只需开辟新的数据页，也就不会发生页分裂：</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230308105859984.png" alt="image-20230308105859984"></p><p>另外，主键字段的长度不要太大，因为<strong>主键字段长度越小，意味着二级索引的叶子节点越小（二级索引的叶子节点存放的数据是主键值），这样二级索引占用的空间也就越小</strong>。</p><h3 id="索引最好设为NOT-NULL"><a href="#索引最好设为NOT-NULL" class="headerlink" title="索引最好设为NOT NULL"></a>索引最好设为NOT NULL</h3><p>为了更好的利用索引，索引列要设置为 NOT NULL 约束。有两个原因：</p><ul><li>第一原因：索引列存在 NULL 就会导致优化器在做索引选择的时候更加复杂，更加难以优化，因为可为 NULL 的列会使索引、索引统计和值比较都更复杂，比如进行索引统计时，count 会省略值为NULL 的行。</li><li>第二个原因：NULL 值是一个没意义的值，但是它会占用物理空间，所以会带来的存储空间的问题，因为 InnoDB 存储记录的时候，如果表中存在允许为 NULL 的字段，那么行格式 中<strong>至少会用 1 字节空间存储 NULL 值列表</strong></li></ul><h3 id="防止索引失效"><a href="#防止索引失效" class="headerlink" title="防止索引失效"></a>防止索引失效</h3><p>发生索引失效的情况：</p><ul><li>当我们使用左或者左右模糊匹配的时候，也就是 <code>like %xx</code> 或者 <code>like %xx%</code> 这两种方式都会造成索引失效；</li><li>当我们在查询条件中对索引列使用函数，就会导致索引失效。</li><li>当我们在查询条件中对索引列进行表达式计算，也是无法走索引的。</li><li>MySQL 在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较。如果字符串是索引列，而条件语句中的输入参数是数字的话，那么索引列会发生隐式类型转换，由于隐式类型转换是通过 CAST 函数实现的，等同于对索引列使用了函数，所以就会导致索引失效。</li><li>联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效。</li><li>在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。</li></ul><h1 id="四-事务"><a href="#四-事务" class="headerlink" title="四.事务"></a>四.事务</h1><h2 id="1-事务有哪些特性"><a href="#1-事务有哪些特性" class="headerlink" title="1.事务有哪些特性:"></a>1.事务有哪些特性:</h2><p>事务是由 MySQL 的引擎来实现的，我们常见的 InnoDB 引擎它是支持事务的。</p><p>不过并不是所有的引擎都能支持事务，比如 MySQL 原生的 MyISAM 引擎就不支持事务，也正是这样，所以大多数 MySQL 的引擎都是用 InnoDB。</p><ul><li><strong>原子性（Atomicity）</strong>：一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节，而且事务在执行过程中发生错误，会被回滚到事务开始前的状态，就像这个事务从来没有执行过一样，就好比买一件商品，购买成功时，则给商家付了钱，商品到手；购买失败时，则商品在商家手中，消费者的钱也没花出去。</li><li><strong>一致性（Consistency）</strong>：是指事务操作前和操作后，数据满足完整性约束，数据库保持一致性状态。比如，用户 A 和用户 B 在银行分别有 800 元和 600 元，总共 1400 元，用户 A 给用户 B 转账 200 元，分为两个步骤，从 A 的账户扣除 200 元和对 B 的账户增加 200 元。一致性就是要求上述步骤操作后，最后的结果是用户 A 还有 600 元，用户 B 有 800 元，总共 1400 元，而不会出现用户 A 扣除了 200 元，但用户 B 未增加的情况（该情况，用户 A 和 B 均为 600 元，总共 1200 元）。</li><li><strong>隔离性（Isolation）</strong>：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致，因为多个事务同时使用相同的数据时，不会相互干扰，每个事务都有一个完整的数据空间，对其他并发事务是隔离的。也就是说，消费者购买商品这个事务，是不影响其他消费者购买的。</li><li><strong>持久性（Durability）</strong>：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li></ul><p>InnoDB 引擎通过什么技术来保证事务的这四个特性的呢？</p><ul><li>持久性是通过 redo log （重做日志）来保证的；</li><li>原子性是通过 undo log（回滚日志） 来保证的；</li><li>隔离性是通过 MVCC（多版本并发控制） 或锁机制来保证的；</li><li>一致性则是通过持久性+原子性+隔离性来保证；</li></ul><h2 id="2-并行事务带来的问题"><a href="#2-并行事务带来的问题" class="headerlink" title="2.并行事务带来的问题"></a>2.并行事务带来的问题</h2><p><strong>在同时处理多个事务的时候，就可能出现脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）的问题</strong></p><p>脏读</p><ul><li>如果一个事务「读到」了另一个<strong>「未提交事务修改过的数据」</strong>，就意味着发生了「脏读」现象。</li></ul><p>不可重复读</p><ul><li>在一个事务内多次读取同一个数据，<strong>如果出现前后两次读到的数据不一样的情况</strong>，就意味着发生了「不可重复读」现象。</li></ul><p>幻读</p><ul><li>在一个事务内多次查询某个符合查询条件的「记录数量」，如果出现前后两次查询到的<strong>记录数量不一样</strong>的情况，就意味着发生了「幻读」现象。</li></ul><h2 id="3-事务的隔离级别"><a href="#3-事务的隔离级别" class="headerlink" title="3.事务的隔离级别"></a>3.事务的隔离级别</h2><p>SQL 标准提出了四种隔离级别来规避这些现象，隔离级别越高，性能效率就越低，这四个隔离级别如下：</p><ul><li><strong>读未提交（read uncommitted）</strong>，指一个事务还没提交时，它做的变更就能被其他事务看到；</li><li><strong>读提交（*read committed*）</strong>，指一个事务提交之后，它做的变更才能被其他事务看到；</li><li><strong>可重复读（*repeatable read*）</strong>，指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，<strong>MySQL InnoDB 引擎的默认隔离级别</strong>；</li><li><strong>串行化（*serializable* ）</strong>；会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行；</li></ul><p>这四种隔离级别具体是如何实现的呢？</p><ul><li>对于「读未提交」隔离级别的事务来说，因为可以读到未提交事务修改的数据，所以直接读取最新的数据就好了；</li><li>对于「串行化」隔离级别的事务来说，通过加<strong>读写锁</strong>的方式来避免并行访问；</li><li>对于「读提交」和「可重复读」隔离级别的事务来说，它们是通过 **Read View **来实现的，它们的区别在于创建 Read View 的时机不同，大家可以把 Read View 理解成一个数据快照，就像相机拍照那样，定格某一时刻的风景。「读提交」隔离级别是在「每个语句执行前」都会重新生成一个 Read View，而「可重复读」隔离级别是「启动事务时」生成一个 Read View，然后整个事务期间都在用这个 Read View**。</li></ul><h2 id="4-Read-View-在-MVCC-里如何工作的？"><a href="#4-Read-View-在-MVCC-里如何工作的？" class="headerlink" title="4. Read View 在 MVCC 里如何工作的？"></a>4. Read View 在 MVCC 里如何工作的？</h2><p>我们需要了解两个知识：</p><ul><li>Read View 中四个字段作用；</li><li>聚簇索引记录中两个跟事务有关的隐藏列；</li></ul><p>那 Read View 到底是个什么东西？</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230309145149478.png" alt="image-20230309145149478"></p><p>Read View 有四个重要的字段：</p><ul><li>m_ids ：指的是在创建 Read View 时，当前数据库中「活跃事务」的<strong>事务 id 列表</strong>，注意是一个列表，<strong>“活跃事务”指的就是，启动了但还没提交的事务</strong>。</li><li>min_trx_id ：指的是在创建 Read View 时，当前数据库中「活跃事务」中事务 <strong>id 最小的事务</strong>，也就是 m_ids 的最小值。</li><li>max_trx_id ：这个并不是 m_ids 的最大值，而是<strong>创建 Read View 时当前数据库中应该给下一个事务的 id 值</strong>，也就是全局事务中最大的事务 id 值 + 1；</li><li>creator_trx_id ：指的是<strong>创建该 Read View 的事务的事务 id</strong>。</li></ul><p>知道了 Read View 的字段，我们还需要了解聚簇索引记录中的两个隐藏列。</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230309145234755.png" alt="image-20230309145234755"></p><ul><li>trx_id，当一个事务对某条聚簇索引记录进行改动时，就会<strong>把该事务的事务 id 记录在 trx_id 隐藏列里</strong>；</li><li>roll_pointer，每次对某条聚簇索引记录进行改动时，都会把旧版本的记录写入到 undo 日志中，然后<strong>这个隐藏列是个指针，指向每一个旧版本记录</strong>，于是就可以通过它找到修改前的记录。</li></ul><p>在创建 Read View 后，我们可以将记录中的 trx_id 划分这三种情况：</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230309145312473.png" alt="image-20230309145312473"></p><ul><li>如果记录的 trx_id 值小于 Read View 中的 <code>min_trx_id</code> 值，表示这个版本的记录是在创建 Read View <strong>前</strong>已经提交的事务生成的，所以该版本的记录对当前事务<strong>可见</strong>。</li><li>如果记录的 trx_id 值大于等于 Read View 中的 <code>max_trx_id</code> 值，表示这个版本的记录是在创建 Read View <strong>后</strong>才启动的事务生成的，所以该版本的记录对当前事务<strong>不可见</strong>。</li><li>如果记录的 trx_id 值在 Read View 的min_trx_id和max_trx_id之间，需要判断 trx_id 是否在 m_ids 列表中：<ul><li>如果记录的 trx_id <strong>在</strong> <code>m_ids</code> 列表中，表示生成该版本记录的活跃事务依然活跃着（还没提交事务），所以该版本的记录对当前事务<strong>不可见</strong>。</li><li>如果记录的 trx_id <strong>不在</strong> <code>m_ids</code>列表中，表示生成该版本记录的活跃事务已经被提交，所以该版本的记录对当前事务<strong>可见</strong>。</li></ul></li></ul><p><strong>这种通过「版本链」来控制并发事务访问同一个记录时的行为就叫 MVCC（多版本并发控制）</strong></p><h3 id="可重复读是如何工作的？"><a href="#可重复读是如何工作的？" class="headerlink" title="可重复读是如何工作的？"></a>可重复读是如何工作的？</h3><p><strong>可重复读隔离级别是启动事务时生成一个 Read View，然后整个事务期间都在用这个 Read View</strong>。</p><h3 id="读提交是如何工作的？"><a href="#读提交是如何工作的？" class="headerlink" title="读提交是如何工作的？"></a>读提交是如何工作的？</h3><p><strong>读提交隔离级别是在每次读取数据时，都会生成一个新的 Read View</strong>。</p><h2 id="5-可重复读隔离级别完全解决幻读了吗"><a href="#5-可重复读隔离级别完全解决幻读了吗" class="headerlink" title="5.可重复读隔离级别完全解决幻读了吗"></a>5.可重复读隔离级别完全解决幻读了吗</h2><h3 id="5-1快照读是如何避免幻读的？"><a href="#5-1快照读是如何避免幻读的？" class="headerlink" title="5.1快照读是如何避免幻读的？"></a>5.1快照读是如何避免幻读的？</h3><p>可重复读隔离级是由 MVCC（多版本并发控制）实现的，实现的方式是开始事务后（执行 begin 语句后），在执行第一个查询语句后，会创建一个 Read View，<strong>后续的查询语句利用这个 Read View，通过这个 Read View 就可以在 undo log 版本链找到事务开始时的数据，所以事务过程中每次查询的数据都是一样的</strong>，即使中途有其他事务插入了新纪录，是查询不出来这条数据的，所以就很好了避免幻读问题。</p><h3 id="5-2当前读是如何避免幻读的？"><a href="#5-2当前读是如何避免幻读的？" class="headerlink" title="5.2当前读是如何避免幻读的？"></a>5.2当前读是如何避免幻读的？</h3><p>MySQL 里除了普通查询是快照读，其他都是<strong>当前读</strong>，比如 update、insert、delete，这些语句执行前都会查询最新版本的数据，然后再做进一步的操作</p><ul><li>针对<strong>当前读</strong>（select … for update 等语句），是通过 next-key lock（记录锁+间隙锁）方式解决了幻读。</li></ul><p>第一个例子：对于快照读， MVCC 并不能完全避免幻读现象。因为当事务 A 更新了一条事务 B 插入的记录，那么事务 A 前后两次查询的记录条目就不一样了，所以就发生幻读。</p><p>第二个例子：对于当前读，如果事务开启后，并没有执行当前读，而是先快照读，然后这期间如果其他事务插入了一条记录，那么事务后续使用当前读进行查询的时候，就会发现两次查询的记录条目就不一样了，所以就发生幻读。</p><p>所以，<strong>MySQL 可重复读隔离级别并没有彻底解决幻读，只是很大程度上避免了幻读现象的发生。</strong></p><p>要避免这类特殊场景下发生幻读的现象的话，就是尽量在开启事务之后，马上执行 select … for update 这类当前读的语句，因为它会对记录加 next-key lock，从而避免其他事务插入一条新记录。</p><h1 id="五-日志"><a href="#五-日志" class="headerlink" title="五.日志"></a>五.日志</h1><h2 id="5-1为什么需要-undo-log？"><a href="#5-1为什么需要-undo-log？" class="headerlink" title="5.1为什么需要 undo log？"></a>5.1为什么需要 undo log？</h2><p><strong>undo log（回滚日志），它保证了事务的原子性</strong>,undo log 是一种用于撤销回退的日志。在事务没提交之前，MySQL 会先记录更新前的数据到 undo log 日志文件里面，当事务回滚时，可以利用 undo log 来进行回滚。如下图：</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230309150948768.png" alt="image-20230309150948768"></p><p>每当 InnoDB 引擎对一条记录进行操作（修改、删除、新增）时，要把回滚时需要的信息都记录到 undo log 里，比如：</p><ul><li>在<strong>插入</strong>一条记录时，要把这条记录的主键值记下来，这样之后回滚时只需要把这个主键值对应的记录<strong>删掉</strong>就好了；</li><li>在<strong>删除</strong>一条记录时，要把这条记录中的内容都记下来，这样之后回滚时再把由这些内容组成的记录<strong>插入</strong>到表中就好了；</li><li>在<strong>更新</strong>一条记录时，要把被更新的列的旧值记下来，这样之后回滚时再把这些列<strong>更新为旧值</strong>就好了。</li></ul>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈JDk的偏向锁</title>
      <link href="/2022/06/26/2022-06-26-qian-tan-jdk-de-pian-xiang-suo/"/>
      <url>/2022/06/26/2022-06-26-qian-tan-jdk-de-pian-xiang-suo/</url>
      
        <content type="html"><![CDATA[<h1 id="浅谈JDK的偏向锁"><a href="#浅谈JDK的偏向锁" class="headerlink" title="浅谈JDK的偏向锁:"></a>浅谈JDK的偏向锁:</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>偏向锁</strong>是从 JDK1.6 引入的一种针对 <strong>synchronized</strong> 的锁优化技术，然而从 <strong>JDK 15</strong> 开始，这一特性被官方标记为废弃状态，如果还想继续使用的话需要通过 JVM 参数手动启用。</p><pre><code class="go">-XX:+UseBiasedLocking</code></pre><p>那么问题来了，JDK15 为什么要废弃偏向锁呢？</p><p>在 JDK1.5 之前，面对 Java 并发问题， synchronized 是一招鲜的解决方案：</p><ol><li>普通同步方法，锁上当前实例对象</li><li>静态同步方法，锁上当前类 Class 对象</li><li>同步块，锁上括号里面配置的对象</li></ol><p>拿同步块来举例:</p><pre><code class="java">public void test()&#123;  synchronized (object) &#123;    i++;  &#125;&#125;</code></pre><p>经过 <code>javap -v</code> 编译后的指令如下：</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/537fa4c708be3b83d7e6c4cc2f664e59.png" alt="537fa4c708be3b83d7e6c4cc2f664e59"></p><p><code>monitorenter</code> 指令是在编译后插入到同步代码块的开始位置；<code>monitorexit</code>是插入到方法结束和异常的位置(实际隐藏了try-finally)，每个对象都有一个 monitor 与之关联，当一个线程执行到 monitorenter 指令时，就会获得对象所对应的 <code>monitor</code> 的所有权，也就获得到了对象的锁</p><p>当另外一个线程执行到同步块的时候，由于它没有对应 <code>monitor</code> 的所有权，就会被阻塞，此时控制权只能交给操作系统，也就会从 <code>user mode</code> 切换到 <code>kernel mode</code>, 由操作系统来负责线程间的调度和线程的状态变更, 需要频繁的在这两个模式下切换（上下文转换）。这种有点竞争就找内核的行为很不好，会引起很大的开销，所以大家都叫它重量级锁，自然效率也很低，这也就给很多童鞋留下了一个根深蒂固的印象 —— synchronized关键字相比于其他同步机制性能不好</p><h2 id="锁的演变"><a href="#锁的演变" class="headerlink" title="锁的演变"></a>锁的演变</h2><p>来到 JDK1.6，要怎样优化才能让锁变的轻量级一些？答案就是：</p><h3 id="轻量级锁：CPU-CAS"><a href="#轻量级锁：CPU-CAS" class="headerlink" title="轻量级锁：CPU CAS"></a>轻量级锁：CPU CAS</h3><p>如果 CPU 通过简单的 CAS 能处理加锁&#x2F;释放锁，这样就不会有上下文的切换，较重量级锁而言自然就轻了很多。但是当竞争很激烈，CAS 尝试再多也是浪费 CPU，权衡一下，不如升级成重量级锁，阻塞线程排队竞争，也就有了轻量级锁升级成重量级锁的过程</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/80daeec8490041cce2cfd17e060d29cb.png" alt="80daeec8490041cce2cfd17e060d29cb"></p><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>偏向锁实际就是锁对象潜意识「偏心」同一个线程来访问，让锁对象记住线程 ID，当线程再次获取锁时，亮出身份，如果同一个 ID 直接就获取锁就好了，是一种 <code>load-and-test</code> 的过程，相较 CAS 自然又轻量级了一些</p><p>可是多线程环境，也不可能只是同一个线程一直获取这个锁，其他线程也是要干活的，如果出现多个线程竞争的情况，也就有了偏向锁升级的过程</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/82cf0fccfcf101a59234e91f2cb8a91f.png" alt="82cf0fccfcf101a59234e91f2cb8a91f"></p><p>都是同一个锁对象，却有多种锁状态，其目的显而易见</p><blockquote><p>占用的资源越少，程序执行的速度越快</p></blockquote><p>偏向锁，轻量锁，它俩都不会调用系统互斥量（Mutex Lock），只是为了提升性能，多出的两种锁的状态，这样可以在不同场景下采取最合适的策略，所以可以总结性的说：</p><ul><li>偏向锁：无竞争的情况下，只有一个线程进入临界区，采用偏向锁</li><li>轻量级锁：多个线程可以交替进入临界区，采用轻量级锁</li><li>重量级锁：多线程同时进入临界区，交给操作系统互斥量来处理</li></ul><p>到这里，理解了全局大框，但仍然会有很多疑问：</p><ol><li>锁对象是在哪存储线程 ID 才可以识别同一个线程的？</li><li>整个升级过程是如何过渡的？</li></ol><p>想理解这些问题，需要先知道 Java 对象头的结构</p><h2 id="认识-Java-对象头"><a href="#认识-Java-对象头" class="headerlink" title="认识 Java 对象头"></a>认识 Java 对象头</h2><p>按照常规理解，识别线程 ID 需要一组 mapping 映射关系来搞定，如果单独维护这个 mapping 关系又要考虑线程安全的问题。奥卡姆剃刀原理，Java 万物皆是对象，对象皆可用作锁，与其单独维护一个 mapping 关系，不如中心化将锁的信息维护在 Java 对象本身上</p><p>Java 对象头最多由三部分构成：</p><ol><li><code>MarkWord</code></li><li>ClassMetadata Address</li><li>Array Length （如果对象是数组才会有这部分）</li></ol><p>其中 <code>Markword</code> 是保存锁状态的关键，对象锁状态可以从偏向锁升级到轻量级锁，再升级到重量级锁，加上初始的无锁状态，可以理解为有 4 种状态。想在一个对象中表示这么多信息自然就要用<code>位</code>存储，在 64 位操作系统中，是这样存储的（注意颜色标记），想看具体注释的可以看 hotspot(1.8) 源码文件 <code>path/hotspot/src/share/vm/oops/markOop.hpp</code> 第 30 行</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/bbd9b10844afd8b73f90cfc5f3b1bbab.png" alt="bbd9b10844afd8b73f90cfc5f3b1bbab"></p><h2 id="认识偏向锁"><a href="#认识偏向锁" class="headerlink" title="认识偏向锁"></a>认识偏向锁</h2><p>单纯的看上图，还是显得十分抽象，作为程序员的我们最喜欢用代码说话，贴心的 openjdk 官网提供了可以查看对象内存布局的工具 JOL (java object layout)</p><p>Maven Package</p><pre><code class="xml">&lt;dependency&gt;  &lt;groupId&gt;org.openjdk.jol&lt;/groupId&gt;  &lt;artifactId&gt;jol-core&lt;/artifactId&gt;  &lt;version&gt;0.14&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>Gradle Package</p><pre><code class="xml">implementation &#39;org.openjdk.jol:jol-core:0.14&#39;</code></pre><p>接下来我们就通过代码来深入了解一下偏向锁吧</p><p>注意：</p><blockquote><p>上图(从左到右) 代表 <code>高位 -&gt; 低位</code></p><p>JOL 输出结果（从左到右）代表 <code>低位 -&gt; 高位</code></p></blockquote><p>测试代码:</p><pre><code class="java">public void test1() throws InterruptedException &#123;    Dog dog1 = new Dog(&quot;name&quot;);    String s = ClassLayout.parseInstance(dog1).toPrintable();    log.debug(s);    synchronized (dog1)&#123;        log.debug(ClassLayout.parseInstance(dog1).toPrintable());    &#125;    log.debug(ClassLayout.parseInstance(dog1).toPrintable());&#125;</code></pre><p>结果:(该结果是直接可以获取偏向锁的)</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221123180718475.png" alt="image-20221123180718475"></p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221123180950266.png" alt="image-20221123180950266"></p><p>上面用到的 JOL 版本为 <code>0.14</code>, 带领大家快速了解一下位具体值，接下来我们就要用 <code>0.16</code> 版本查看输出结果，因为这个版本给了我们更友好的说明，同样的代码，来看输出结果：</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/4c2d7ab1c855f0ad81b6ec00394954ec.png" alt="4c2d7ab1c855f0ad81b6ec00394954ec"></p><p>看到这个结果，你应该是有疑问的，JDK 1.6 之后默认是开启偏向锁的，为什么初始化的代码是无锁状态，进入同步块产生竞争就绕过偏向锁直接变成轻量级锁了呢？</p><blockquote><p>虽然默认开启了偏向锁，但是开启有延迟，大概 4s。原因是 JVM 内部的代码有很多地方用到了synchronized，如果直接开启偏向，产生竞争就要有锁升级，会带来额外的性能损耗，所以就有了延迟策略</p></blockquote><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/06447571f760484b2606cf73e50e6299.png" alt="06447571f760484b2606cf73e50e6299"></p><p>我们可以通过参数 <code>-XX:BiasedLockingStartupDelay=0</code> 将延迟改为0，但是不建议这么做。我们可以通过一张图来理解一下目前的情况：</p><h3 id="场景2"><a href="#场景2" class="headerlink" title="场景2"></a>场景2</h3><p>那我们就代码延迟 5 秒来创建对象，来看看偏向是否生效</p><pre><code class="java">public static void main(String[] args) throws InterruptedException &#123;  // 睡眠 5s  Thread.sleep(5000);  Object o = new Object();  log.info(&quot;未进入同步块，MarkWord 为：&quot;);  log.info(ClassLayout.parseInstance(o).toPrintable());  synchronized (o)&#123;   log.info((&quot;进入同步块，MarkWord 为：&quot;));   log.info(ClassLayout.parseInstance(o).toPrintable());  &#125; &#125;</code></pre><p>重新查看运行结果：</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/9b3106bea5415246f6330790f58de65b.png" alt="9b3106bea5415246f6330790f58de65b"></p><p>这样的结果是符合我们预期的，但是结果中的 <code>biasable</code> 状态，在 MarkWord 表格中并不存在，其实这是一种匿名偏向状态，是对象初始化中，JVM 帮我们做的</p><p>这样当有线程进入同步块：</p><ol><li>可偏向状态：直接就 CAS 替换 ThreadID，如果成功，就可以获取偏向锁了</li><li>不可偏向状态：就会变成轻量级锁</li></ol><p>那问题又来了，现在锁对象有具体偏向的线程，如果新的线程过来执行同步块会偏向新的线程吗？</p><h3 id="场景3"><a href="#场景3" class="headerlink" title="场景3"></a>场景3</h3><pre><code class="java">public static void main(String[] args) throws InterruptedException &#123;  // 睡眠 5s  Thread.sleep(5000);  Object o = new Object();  log.info(&quot;未进入同步块，MarkWord 为：&quot;);  log.info(ClassLayout.parseInstance(o).toPrintable());  synchronized (o)&#123;   log.info((&quot;进入同步块，MarkWord 为：&quot;));   log.info(ClassLayout.parseInstance(o).toPrintable());  &#125;   Thread t2 = new Thread(() -&gt; &#123;   synchronized (o) &#123;    log.info(&quot;新线程获取锁，MarkWord为：&quot;);    log.info(ClassLayout.parseInstance(o).toPrintable());   &#125;  &#125;);   t2.start();  t2.join();  log.info(&quot;主线程再次查看锁对象，MarkWord为：&quot;);  log.info(ClassLayout.parseInstance(o).toPrintable());   synchronized (o)&#123;   log.info((&quot;主线程再次进入同步块，MarkWord 为：&quot;));   log.info(ClassLayout.parseInstance(o).toPrintable());  &#125; &#125;</code></pre><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221123181842323.png" alt="image-20221123181842323"></p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221123182019997.png" alt="image-20221123182019997"></p><p>或者这张图:</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/73455d914806a7888f8b0906bd51aa09.png" alt="73455d914806a7888f8b0906bd51aa09"></p><p>过程为: 初始可偏向状态–&gt;偏向第一个线程–&gt;新线程获取锁–&gt;升级为轻量锁–&gt;主线程查看变为不可偏向状态–&gt;由于对象不可偏向，同场景1主线程再次进入同步块，自然就会用轻量级锁</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/214511852e26fdef782ecc6132e8087b.png" alt="214511852e26fdef782ecc6132e8087b"></p><p>从这样的运行结果上来看，偏向锁像是“一锤子买卖”，只要偏向了某个线程，后续其他线程尝试获取锁，都会变为轻量级锁，这样的偏向非常有局限性。事实上并不是这样，如果你仔细看标记2（已偏向状态），还有个 epoch 没有提及，这个值就是打破这种局限性的关键，在了解 epoch 之前，我们还要了解一个概念——偏向撤销</p><h3 id="偏向撤销"><a href="#偏向撤销" class="headerlink" title="偏向撤销"></a>偏向撤销</h3><p>在真正讲解偏向撤销之前，需要和大家明确一个概念——偏向锁撤销和偏向锁释放是两码事</p><ol><li>撤销：笼统的说就是多个线程竞争导致不能再使用偏向模式的时候，主要是告知这个锁对象不能再用偏向模式</li><li>释放：和你的常规理解一样，对应的就是 synchronized 方法的退出或 synchronized 块的结束</li></ol><p>何为偏向撤销？</p><blockquote><p>从偏向状态撤回原有的状态，也就是将 MarkWord 的第 3 位（是否偏向撤销）的值，<code>从 1 变回 0</code></p></blockquote><p>如果只是一个线程获取锁，再加上「偏心」的机制，是没有理由撤销偏向的，所以偏向的撤销只能发生在<strong>有竞争的情况下</strong></p><p>想要撤销偏向锁，还不能对持有偏向锁的线程有影响，所以就要等待持有偏向锁的线程到达一个 <code>safepoint 安全点</code> (这里的安全点是 <strong>JVM 为了保证在垃圾回收的过程中引用关系不会发生变化设置的一种安全状态，在这个状态上会暂停所有线程工作</strong>)， 在这个安全点会挂起获得偏向锁的线程</p><p>在这个安全点，线程可能还是处在不同状态的，先说结论（因为源码就是这么写的，可能有疑惑的地方会在后面解释）</p><ol><li>线程不存活或者活着的线程但退出了同步块，很简单，直接撤销偏向就好了</li><li>活着的线程但仍在同步块之内，那就要升级成轻量级锁</li></ol><p>这个和 epoch 貌似还是没啥关系，因为这还不是全部场景。偏向锁是特定场景下提升程序效率的方案，可并不代表程序员写的程序都满足这些特定场景，比如这些场景（在开启偏向锁的前提下）：</p><ol><li>一个线程创建了大量对象并执行了初始的同步操作，之后在另一个线程中将这些对象作为锁进行之后的操作。这种case下，会导致大量的偏向锁撤销操作</li><li>明知有多线程竞争（生产者&#x2F;消费者队列），还要使用偏向锁，也会导致各种撤销</li></ol><p>很显然，这两种场景肯定会导致偏向撤销的，一个偏向撤销的成本无所谓，大量偏向撤销的成本是不能忽视的。那怎么办？既不想禁用偏向锁，还不想忍受大量撤销偏向增加的成本，这种方案就是设计一个有阶梯的底线</p><h4 id="批量重偏向（bulk-rebias）"><a href="#批量重偏向（bulk-rebias）" class="headerlink" title="批量重偏向（bulk rebias）"></a>批量重偏向（bulk rebias）</h4><p>这是第一种场景的快速解决方案，以 class 为单位，为每个 class 维护一个偏向锁撤销计数器，每一次该class的对象发生偏向撤销操作时，该计数器 <code>+1</code>，当这个值达到重偏向阈值（默认20）时：</p><pre><code class="java">BiasedLockingBulkRebiasThreshold = 20</code></pre><p>JVM 就认为该class的偏向锁有问题，因此会进行批量重偏向, 它的实现方式就用到了我们上面说的 <code>epoch</code></p><p><code>Epoch</code>，如其含义「纪元」一样，就是一个时间戳。每个 class 对象会有一个对应的<code>epoch</code>字段，每个处于偏向锁状态对象的<code>mark word</code> 中也有该字段，其初始值为创建该对象时 class 中的<code>epoch</code>的值（此时二者是相等的）。每次发生批量重偏向时，就将该值加1，同时遍历JVM中所有线程的栈</p><ol><li>找到该 class 所有正处于加锁状态的偏向锁对象，将其<code>epoch</code>字段改为新值</li><li>class 中不处于加锁状态的偏向锁对象（没被任何线程持有，但之前是被线程持有过的，这种锁对象的 markword 肯定也是有偏向的），保持 <code>epoch</code> 字段值不变</li></ol><p>这样下次获得锁时，发现当前对象的<code>epoch</code>值和class的<code>epoch</code>，本着今朝不问前朝事 的原则（上一个纪元），那就算当前已经偏向了其他线程，也不会执行撤销操作，而是直接通过 CAS 操作将其<code>mark word</code>的线程 ID 改成当前线程 ID，这也算是一定程度的优化，毕竟没升级锁；</p><p>如果 <code>epoch</code> 都一样，说明没有发生过批量重偏向, 如果 <code>markword</code> 有线程ID，还有其他锁来竞争，那锁自然是要升级的(如同前面举的例子 epoch&#x3D;0)</p><p>批量重偏向是第一阶梯底线，还有第二阶梯底线</p><h4 id="批量撤销（bulk-revoke）"><a href="#批量撤销（bulk-revoke）" class="headerlink" title="批量撤销（bulk revoke）"></a>批量撤销（bulk revoke）</h4><p>当达到重偏向阈值后，假设该 class 计数器继续增长，当其达到批量撤销的阈值后（默认40）时，</p><pre><code class="java">BiasedLockingBulkRevokeThreshold = 40</code></pre><p>JVM就认为该 class 的使用场景存在多线程竞争，会标记该 class 为不可偏向。之后对于该 class 的锁，直接走轻量级锁的逻辑</p><p>这就是第二阶梯底线，但是在第一阶梯到第二阶梯的过渡过程中，也就是在彻底禁用偏向锁之前，还给一次改过自新的机会，那就是另外一个计时器：</p><pre><code class="java">BiasedLockingDecayTime = 25000</code></pre><ol><li>如果在距离上次批量重偏向发生的 25 秒之内，并且累计撤销计数达到40，就会发生批量撤销（偏向锁彻底 game over）</li><li>如果在距离上次批量重偏向发生超过 25 秒之外，那么就会重置在 <code>[20, 40)</code> 内的计数, 再给次机会</li></ol><p>至此，整个偏向锁的工作流程可以用一张图表示：</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/838091a1fc9729c8de178e0641288e2a.png" alt="838091a1fc9729c8de178e0641288e2a"></p><h3 id="HashCode-哪去了"><a href="#HashCode-哪去了" class="headerlink" title="HashCode 哪去了"></a>HashCode 哪去了</h3><p>上面场景一，无锁状态，对象头中没有 hashcode；偏向锁状态，对象头还是没有 hashcode，那我们的 hashcode 哪去了？</p><p>首先要知道，hashcode 不是创建对象就帮我们写到对象头中的，而是要经过第一次调用 Object::hashCode() 或者System::identityHashCode(Object) 才会存储在对象头中的。第一次生成的 hashcode后，该值应该是一直保持不变的，但偏向锁又是来回更改锁对象的 markword，必定会对 hashcode 的生成有影响，那怎么办呢？，我们来用代码验证：</p><h4 id="场景一"><a href="#场景一" class="headerlink" title="场景一:"></a>场景一:</h4><pre><code class="java">public static void main(String[] args) throws InterruptedException &#123;  // 睡眠 5s  Thread.sleep(5000);   Object o = new Object();  log.info(&quot;未生成 hashcode，MarkWord 为：&quot;);  log.info(ClassLayout.parseInstance(o).toPrintable());   o.hashCode();  log.info(&quot;已生成 hashcode，MarkWord 为：&quot;);  log.info(ClassLayout.parseInstance(o).toPrintable());   synchronized (o)&#123;   log.info((&quot;进入同步块，MarkWord 为：&quot;));   log.info(ClassLayout.parseInstance(o).toPrintable());  &#125; &#125;</code></pre><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/589108d663596c111f35baadcb83662a.png" alt="589108d663596c111f35baadcb83662a"></p><blockquote><p>结论就是：即便初始化为可偏向状态的对象，一旦调用 <code>Object::hashCode()</code> 或者<code>System::identityHashCode(Object)</code> ，进入同步块就会直接使用轻量级锁</p></blockquote><h4 id="场景二"><a href="#场景二" class="headerlink" title="场景二:"></a>场景二:</h4><p>假如已偏向某一个线程，然后生成 hashcode，然后同一个线程又进入同步块，会发生什么呢？来看代码：</p><pre><code class="java">public static void main(String[] args) throws InterruptedException &#123;  // 睡眠 5s  Thread.sleep(5000);   Object o = new Object();  log.info(&quot;未生成 hashcode，MarkWord 为：&quot;);  log.info(ClassLayout.parseInstance(o).toPrintable());   synchronized (o)&#123;   log.info((&quot;进入同步块，MarkWord 为：&quot;));   log.info(ClassLayout.parseInstance(o).toPrintable());  &#125;   o.hashCode();  log.info(&quot;生成 hashcode&quot;);  synchronized (o)&#123;   log.info((&quot;同一线程再次进入同步块，MarkWord 为：&quot;));   log.info(ClassLayout.parseInstance(o).toPrintable());  &#125; &#125;</code></pre><p>结果:</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/67c6df79044a80691dfe3bfa8ff75bca.png" alt="67c6df79044a80691dfe3bfa8ff75bca"></p><blockquote><p>结论就是：同场景一，会直接使用轻量级锁</p></blockquote><h4 id="场景三"><a href="#场景三" class="headerlink" title="场景三:"></a>场景三:</h4><p>那假如对象处于已偏向状态，在同步块中调用了那两个方法会发生什么呢？继续代码验证：</p><pre><code class="java">public static void main(String[] args) throws InterruptedException &#123;  // 睡眠 5s  Thread.sleep(5000);   Object o = new Object();  log.info(&quot;未生成 hashcode，MarkWord 为：&quot;);  log.info(ClassLayout.parseInstance(o).toPrintable());   synchronized (o)&#123;   log.info((&quot;进入同步块，MarkWord 为：&quot;));   log.info(ClassLayout.parseInstance(o).toPrintable());   o.hashCode();   log.info(&quot;已偏向状态下，生成 hashcode，MarkWord 为：&quot;);   log.info(ClassLayout.parseInstance(o).toPrintable());  &#125; &#125;</code></pre><p>结果:</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/2fa41a1295231cf52d4465ac88271dad.png" alt="2fa41a1295231cf52d4465ac88271dad"></p><blockquote><p>结论就是:如果对象已近处在偏向状态,生成hashcode后,就直接会直接转为重量级锁</p></blockquote><p>锁和hashcode之间的关系:</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/67e201d2effd0a5456c268d48e1b9e80.png" alt="67e201d2effd0a5456c268d48e1b9e80"></p><h4 id="调用-Object-wait-方法会发生什么？"><a href="#调用-Object-wait-方法会发生什么？" class="headerlink" title="调用 Object.wait() 方法会发生什么？"></a>调用 Object.wait() 方法会发生什么？</h4><p>Object 除了提供了上述 hashcode 方法，还有 <code>wait()</code> 方法，这也是我们在同步块中常用的，那这会对锁产生哪些影响呢？来看代码：</p><pre><code class="go">public static void main(String[] args) throws InterruptedException &#123;  // 睡眠 5s  Thread.sleep(5000);   Object o = new Object();  log.info(&quot;未生成 hashcode，MarkWord 为：&quot;);  log.info(ClassLayout.parseInstance(o).toPrintable());   synchronized (o) &#123;   log.info((&quot;进入同步块，MarkWord 为：&quot;));   log.info(ClassLayout.parseInstance(o).toPrintable());    log.info(&quot;wait 2s&quot;);   o.wait(2000);    log.info((&quot;调用 wait 后，MarkWord 为：&quot;));   log.info(ClassLayout.parseInstance(o).toPrintable());  &#125; &#125;</code></pre><p>结果:</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/2cef02cb88fc16ad83c68e6f438392fa.png" alt="2cef02cb88fc16ad83c68e6f438392fa"></p><blockquote><p>结论就是，wait 方法是互斥量（重量级锁）独有的，一旦调用该方法，就会升级成重量级锁</p></blockquote><p>最后再继续丰富一下锁对象变化图：</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/152f54fc279d9cf30f428323f33da9ba.png" alt="152f54fc279d9cf30f428323f33da9ba"></p><h2 id="告别偏向锁"><a href="#告别偏向锁" class="headerlink" title="告别偏向锁"></a>告别偏向锁</h2><p>看到这个标题你应该是有些慌，为啥要告别偏向锁，因为维护成本有些高了，来看 Open JDK 官方声明，JEP 374: Deprecate and Disable Biased Locking，相信你看上面的文字说明也深有体会，为了一个现在少有的场景付出了巨大的代码实现</p><p>JDK15(2021-02-28)开始正式废除偏向锁,偏向锁给 JVM 增加了巨大的复杂性，只有少数非常有经验的程序员才能理解整个过程，维护成本很高，大大阻碍了开发新特性的进程，所以它的废除也在情理之中.</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java的偏向锁 </tag>
            
            <tag> java并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图解http</title>
      <link href="/2022/06/09/tu-jie-http/"/>
      <url>/2022/06/09/tu-jie-http/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章-了解Web及网络基础"><a href="#第一章-了解Web及网络基础" class="headerlink" title="第一章 .了解Web及网络基础"></a>第一章 .了解Web及网络基础</h1><h2 id="网络基础TCP-IP协议族"><a href="#网络基础TCP-IP协议族" class="headerlink" title="网络基础TCP&#x2F;IP协议族:"></a>网络基础TCP&#x2F;IP协议族:</h2><p>日常使用的网络是在TCP&#x2F;IP协议族的基础上运作的,http属于其内部的一个子集</p><p>计算机与网络需要相互建立通信,其中如何探测到通信目标,由哪一边发起通信,用哪种语言建立通信,怎样结束通信等等需要事先确定.我们把这些规则叫作<strong>协议</strong></p><p>把互联网相关联的协议集合的总称叫作TCP&#x2F;IP.</p><h2 id="1-1TCP-IP的分层管理"><a href="#1-1TCP-IP的分层管理" class="headerlink" title="1.1TCP&#x2F;IP的分层管理:"></a>1.1TCP&#x2F;IP的分层管理:</h2><p>TCP&#x2F;IP协议族按层次分可分为以下四层:</p><p>应用层,传输层,网络层以及数据链路层</p><h3 id="1-应用层"><a href="#1-应用层" class="headerlink" title="1.应用层"></a>1.应用层</h3><p>应用层决定了向用户提供应用服务时通信的活动.</p><p>TCP&#x2F;IP协议族<strong>预存</strong>了各类通用的应用服务.比如,FTP(File Transfer Protocol,文件传输协议)和DNS(Domain Name System,域名系统)服务就是其中两类.</p><p>http协议就位于该层.</p><h3 id="2-传输层"><a href="#2-传输层" class="headerlink" title="2.传输层"></a>2.传输层</h3><p>传输层对上层应用层提供处于网络连接中的两台计算机之间的数据传输</p><p>在传输层有两个性质不同的协议:TCP(Transmission Control Protocol,传输控制协议)和UDP(User Data Protocol,用户数据报协议)</p><h3 id="3-网络层"><a href="#3-网络层" class="headerlink" title="3.网络层"></a>3.网络层</h3><p>网络层用来处理在网络上流动的数据包.<strong>数据包</strong>是网络传输的最小数据单位.该层规定了通过什么传输路线到达对方计算机,并把数据包传送给对方.</p><h3 id="4-数据链路层-网络接口层"><a href="#4-数据链路层-网络接口层" class="headerlink" title="4.数据链路层(网络接口层)"></a>4.数据链路层(网络接口层)</h3><p>用来处理连接网络的硬件部分.包括控制操作系统,硬件的设备驱动,NIC(Network Interface Card,网络适配器即网卡),及光纤等物理可见部分.</p><h2 id="1-2TCP-IP通信传输流"><a href="#1-2TCP-IP通信传输流" class="headerlink" title="1.2TCP&#x2F;IP通信传输流"></a>1.2TCP&#x2F;IP通信传输流</h2><p>HTTP 举例来说明，</p><ol><li>首先作为发送端的客户端在应用层（HTTP 协议）发出一个想看某个 Web 页面的 HTTP 请求。</li><li>接着，为了传输方便，在传输层（TCP 协议）把从应用层处收到的数据（HTTP 请求报文）进行分割，并在各个报文上打上标记序号及端口号后转发给网络层。</li><li>在网络层（IP 协议），增加作为通信目的地的 MAC 地址后转发给链路层。这样一来，发往网络的通信请求就准备齐全了。</li><li>接收端的服务器在链路层接收到数据，按序往上层发送，一直到应用层。当传输到应用层，才能算真正接收到由客户端发送过来的 HTTP请求。</li></ol><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20220725150617985.png" alt="image-20220725150617985"></p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20220725151137532.png" alt="image-20220725151137532"></p><h2 id="1-3与HTTP密切相关的协议-IP-TCP和DNS"><a href="#1-3与HTTP密切相关的协议-IP-TCP和DNS" class="headerlink" title="1.3与HTTP密切相关的协议:IP,TCP和DNS"></a>1.3与HTTP密切相关的协议:IP,TCP和DNS</h2><h3 id="1-IP-Internet-Protocol-网际协议"><a href="#1-IP-Internet-Protocol-网际协议" class="headerlink" title="1.IP(Internet Protocol)网际协议"></a>1.IP(Internet Protocol)网际协议</h3><p>ip协议位于网络层,ip协议的作用是把各种数据包传送给对方,其中需要用到的重要条件是IP地址与MAC地址(Media Access Control Address).</p><p>Ip地址指明了节点被分配到的地址,MAC地址是指网卡所属的固定地址.IP地址可以变换,而MAC基本上不会改变.IP地址也可以和MAC地址进行配对.</p><p>使用ARP协议凭借MAC地址进行通信</p><p>IP间的通信依赖MAC地址。在网络上，通信的双发在同一局域网（LAN）内的情况是很少的，通常是经过台计算机和网络设备中转才能连接到对方。而在进行中转时，会利用下一站中转设备的MAC地址来搜索下一个中转目标。这是，会采用ARP协议（Address Resolution Protocol）。ARP是一种用以解析地址的协议，根据通信方的IP地址就可以反查出对应的MAC地址。<br><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20220725152131409.png" alt="image-20220725152131409"></p><h3 id="2-TCP协议"><a href="#2-TCP协议" class="headerlink" title="2.TCP协议"></a>2.TCP协议</h3><p>按层次分，TCP位于传输层，提供可靠的字节流服务。</p><p>所谓的字节流服务（Byte Stream Service）是指，为了方便传输，将大块数据分割成以报文段（segment）为单位的数据包进行管理。而可靠的传输服务是指，能够把数据准确可靠的传送给对方。</p><p>为确保能到达目标</p><p>为了准确无误的将数据送达目标处，TCP协议采用了三次握手（three-way handshaking）策略。用TCP协议把数据包送出去后，TCP不会对传送后的情况置之不理，它一定会向对方确认是否成功送达。握手过程中使用了TCP的标志（flag）–SYN（synchronize）和ACK（acknowledgement).</p><p>发送端首先发送一个带<strong>SYN</strong>标志的数据包给对方。接收端收到后，回传一个带有<strong>SYN&#x2F;ACK</strong>标志的数据包以传达确认信息。最后，发送端再回传一个带<strong>ACK</strong>标志的数据包，代表“握手”结束。</p><p>若在握手过程中某个阶段莫名中断，<strong>TCP协议会再次以相同的顺序发送相同的数据包。</strong></p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20220725152837792.png" alt="image-20220725152837792"></p><h3 id="3-负责域名解析的DNS服务"><a href="#3-负责域名解析的DNS服务" class="headerlink" title="3.负责域名解析的DNS服务"></a>3.负责域名解析的DNS服务</h3><p>DNS（Domain Name System）服务是和HTTP协议一样位于应用层的协议。它提供域名到IP地址之间的解析服务。</p><p>计算机既可以被赋予IP地址，也可以被赋予主机名和域名。比如<a href="http://www.baidu.com/">www.baidu.com</a></p><p>DNS协议通过提供域名查找IP地址，或逆向从IP地址反查域名的服务。</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20220725153118421.png" alt="image-20220725153118421"></p><h2 id="1-4各种协议之间的关系"><a href="#1-4各种协议之间的关系" class="headerlink" title="1.4各种协议之间的关系"></a>1.4各种协议之间的关系</h2><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20220725153325952.png" alt="image-20220725153325952"></p><h2 id="1-5URL与URI"><a href="#1-5URL与URI" class="headerlink" title="1.5URL与URI"></a>1.5URL与URI</h2><p>URI(Uniform Resource Identifier)：统一资源标识符；URL(Uniform Resource Locator)：统一资源定位符。</p><p>URI用字符串标识某一互联网资源,而URL标识资源在互联网上的位置.</p><h3 id="URI格式"><a href="#URI格式" class="headerlink" title="URI格式:"></a>URI格式:</h3><p>绝对 URI 的格式：</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20220725153929903.png" alt="image-20220725153929903"></p><p>登录信息,服务器端口号,查询字符串与片段标识符均是可选项,方案协议名不区分大小写</p><h1 id="第二章-简单的http协议"><a href="#第二章-简单的http协议" class="headerlink" title="第二章.简单的http协议"></a>第二章.简单的http协议</h1><p>应用http协议时,在一条通信线路上必然是一方担任服务端,一方担任客户端.因此.http协议与tcp&#x2F;ip协议族内的众多其他协议相同,用于客户端到服务器端之间的通信.</p><p>http协议规定,请求从客户端发出最后服务器端响应该请求并返回.</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20220725160037499.png" alt="image-20220725160037499"></p><h2 id="2-1请求报文"><a href="#2-1请求报文" class="headerlink" title="2.1请求报文"></a>2.1请求报文</h2><p>请求报文是由请求方法、请求 URI、协议版本、可选的请求首部字段和内容实体构成的。<br><img src="https://img-blog.csdnimg.cn/20200301150111741.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjQ1NTMw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="2-2响应报文"><a href="#2-2响应报文" class="headerlink" title="2.2响应报文"></a>2.2响应报文</h2><p>响应报文基本上由协议版本、状态码（表示请求成功或失败的数字代码）、用以解释状态码的原因短语、可选的响应首部字段以及实体主体构成。<br><img src="https://img-blog.csdnimg.cn/20200301150140237.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjQ1NTMw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="2-3http是不保存状态的协议"><a href="#2-3http是不保存状态的协议" class="headerlink" title="2.3http是不保存状态的协议"></a>2.3http是不保存状态的协议</h2><p>http自身不对请求和响应之间的通信状态进行保存,也就是说在http这个级别,协议对于发送过的请求和响应都不做持久化处理.因此在使用http协议时,每当有请求发送就会有新的响应产生.</p><h2 id="2-4告知服务器意图的-HTTP-方法"><a href="#2-4告知服务器意图的-HTTP-方法" class="headerlink" title="2.4告知服务器意图的 HTTP 方法"></a>2.4告知服务器意图的 HTTP 方法</h2><table><thead><tr><th>方法</th><th>说明</th><th>支持的http协议版本</th></tr></thead><tbody><tr><td>GET</td><td>获取资源</td><td>1.0,1.1</td></tr><tr><td>POST</td><td>传输实体主体</td><td>1.0,1.1</td></tr><tr><td>PUT</td><td>传输文件</td><td>1.0,1.1</td></tr><tr><td>HEAD</td><td>获得报文首部</td><td>1.0,1.1</td></tr><tr><td>DELETE</td><td>删除文件</td><td>1.0,1.1</td></tr><tr><td>OPTIONS</td><td>询问支持的方法</td><td>1.1</td></tr><tr><td>TRACE</td><td>追踪路径</td><td>1.1</td></tr><tr><td>CONNECT</td><td>要求用隧道协议连接代理</td><td>1.1</td></tr><tr><td>LINK</td><td>建立和资源之间的联系</td><td>1.0</td></tr><tr><td>UNLINE</td><td>断开连接关系</td><td>1.0</td></tr></tbody></table><p>LINK与UNLINE在http&#x2F;1.1中已经被废弃</p><h2 id="2-5持久连接"><a href="#2-5持久连接" class="headerlink" title="2.5持久连接"></a>2.5持久连接</h2><p>为了解决每次http请求与响应都要建立和断开TCP连接所带来的的额外的开销,http&#x2F;1.1和部分http&#x2F;1.0想出了持久连接方法(HTTP Persistent Connections,也称为 HTTP keep-alive或HTTP connection reuse),其特点是只要任意一方没有明确提出断开连接,则保持tcp连接状态.</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20220725164532513.png" alt="image-20220725164532513"></p><h2 id="2-6管线化"><a href="#2-6管线化" class="headerlink" title="2.6管线化"></a>2.6管线化</h2><p>持久连接使得多数请求以<strong>管线化（pipelining）</strong>方式发送成为可能。从前发送请求后需等待并收到响应，才能发送下一个请求。管线化技术出现后，不用等待响应亦可直接发送下一个请求。这样就能够做到同时并行发送多个请求，而不需要一个接一个地等待响应了。</p><p><img src="https://img-blog.csdnimg.cn/5a70dd04f7fc4a49826a528efa2bf8e4.png" alt="img"></p><p>比如，当请求一个包含10张图片的HTML Web页面，与挨个连接相比，用持久连接可以让请求更快结束。而管线化技术则比持久连接还要快。请求数越多，时间差就越明显。</p><h2 id="2-7使用Cookie的状态管理"><a href="#2-7使用Cookie的状态管理" class="headerlink" title="2.7使用Cookie的状态管理"></a>2.7使用Cookie的状态管理</h2><p>HTTP是无状态协议，它不对之前发生过的请求和响应的状态进行管理。也就是说，无法根据之前的状态进行本次的请求处理。假设要求登录认证的Web页面本身无法进行状态的管理（不记录已登录的状态），那么每次跳转新页面就要再次登录，或者要在每次请求报文中附加参数来管理登录状态。</p><p>不可否认，无状态协议当然也有它的优点。由于不必保存状态，自然可减少服务器的CPU及内存资源的消耗。从另一侧面来说，也正是因为HTTP协议本身是非常简单的，所以才会被应用在各种场景里。</p><p><img src="https://img-blog.csdnimg.cn/d8bc0bbac0f8468e97a7759bd9b6a9b9.png" alt="img"></p><p>保留无状态协议这个特征的同时又要解决类似的矛盾问题，于是引入了Cookie技术。Cookie技术通过在请求和响应报文中写入Cookie信息来控制客户端的状态。</p><p>Cookie会根据从服务器端发送的响应报文内的一个叫做<strong>Set-Cookie</strong>的首部字段信息，通知客户端保存Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入Cookie值后发送出去。</p><p>服务器端发现客户端发送过来的Cookie后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。</p><p>没有Cookie信息状态下的请求</p><p><img src="https://img-blog.csdnimg.cn/d51e12c4a116473ab22a113d900dd054.png" alt="img"></p><p>第2次以后（存有Cookie信息状态）的请求</p><p><img src="https://img-blog.csdnimg.cn/8cf124dded0f44bcac03fbd14b0893fe.png" alt="img"></p><p>①请求报文（没有Cookie信息的状态)</p><pre><code class="java">GET /reader/ HTTP/1.1Host:hackr.jp*首部字段内没有Cookie的相关信息</code></pre><p>②响应报文（服务器端生成Cookie信息）</p><pre><code class="java">HTTP/1.1 200 OKDate: Thu, 12 Jul 2012 07:12:20 GMTServer: Apache&lt;Set-Cookie: sid=1342077140226724; path=/; expires=Wed, 10-Oct-12 07:12:20 GMT&gt;Content-Type: text/plain; charset=UTP-8</code></pre><pre><code class="java">GET /image/ HTTP/1.1Host:hackr.jpCookie: 1342077140226724</code></pre><h1 id="第三章-HTTP报文内的信息"><a href="#第三章-HTTP报文内的信息" class="headerlink" title="第三章.HTTP报文内的信息"></a>第三章.HTTP报文内的信息</h1><h2 id="3-1HTTP报文"><a href="#3-1HTTP报文" class="headerlink" title="3.1HTTP报文"></a>3.1HTTP报文</h2><p>用于HTTP协议交互的信息被称为HTTP报文。请求端（客户端）的HTTP报文叫做请求报文，响应端（服务器端）的叫做响应报文。HTTP报文本身是由多行（用CR+LF作换行符）数据构成的字符串文本。</p><p>HTTP报文大致可分为报文首部和报文主体两块。两者由最初出现的空行（CR+LF，CR carriage return 回车符，0x0d，LF line Feed，换行符，0x0a）来划分。通常，并不一定要有报文主体。</p><p>HTTP报文的结构</p><p><img src="https://img-blog.csdnimg.cn/3bd4f034757d41db8ee9e74da53d60ae.png" alt="img"></p><h2 id="3-2请求报文及响应报文的结构"><a href="#3-2请求报文及响应报文的结构" class="headerlink" title="3.2请求报文及响应报文的结构"></a>3.2请求报文及响应报文的结构</h2><h3 id="1-请求报文与响应报文的结构"><a href="#1-请求报文与响应报文的结构" class="headerlink" title="1.请求报文与响应报文的结构"></a>1.请求报文与响应报文的结构</h3><p><img src="https://img-blog.csdnimg.cn/26b31406f6c84711adc073b6e815acfa.png" alt="img"></p><h3 id="2-实例-上为请求报文-下为响应报文"><a href="#2-实例-上为请求报文-下为响应报文" class="headerlink" title="2.实例(上为请求报文,下为响应报文)"></a>2.实例(上为请求报文,下为响应报文)</h3><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/0f39d65fc98548f69c47cc86ad02a102.png" alt="img"></p><p><strong>请求行</strong>：包含用于请求的方法，请求URI和HTTP版本。<br><strong>状态行</strong>：包含表明响应结果的状态码，原因短语和HTTP版本。<br><strong>首部字段</strong>：包含表示请求和响应的各种条件和属性的各类首部。一般有4种首部，分别是：通用首部、请求首部、响应首部和实体首部。<br><strong>其他</strong>：可能包含HTTP的RFC里未定义的首部（Cookie等）。</p><h2 id="3-3编码提升传输速率"><a href="#3-3编码提升传输速率" class="headerlink" title="3.3编码提升传输速率"></a>3.3编码提升传输速率</h2><p>HTTP在传输数据时可以按照数据原貌直接传输，但也可以在传输过程中通过编码提升传输速率。通过在传输时编码，能有效地处理大量的访问请求。但是，编码的操作需要计算机来完成，因此会消耗更多的CPU等资源。</p><h2 id="3-4报文主题和实体主体之间的差异"><a href="#3-4报文主题和实体主体之间的差异" class="headerlink" title="3.4报文主题和实体主体之间的差异"></a>3.4报文主题和实体主体之间的差异</h2><p><strong>报文（message）</strong>：是HTTP通信中的基本单位，由<strong>8位组字节流</strong>（octet sequence，其中octet为8个比特）组成，通过HTTP通信传输。</p><p><strong>实体（entity）</strong>：作为请求或响应的有效载荷数据（补充项）被传输，其内容由实体首部和实体主体组成。</p><p>HTTP报文的主体用于传输请求或响应的实体主体。通常，<strong>报文主体等于实体主体</strong>。只有当传输中进行编码操作时，实体主体的内容发生变化，才导致它和报文主体产生差异。报文和实体这两个术语在之后会经常出现，请事先理解两者的差异。</p><h2 id="3-5压缩传输的内容编码"><a href="#3-5压缩传输的内容编码" class="headerlink" title="3.5压缩传输的内容编码"></a>3.5压缩传输的内容编码</h2><p>向待发送邮件内增加附件时，为了使邮件容量变小，我们会先用ZIP压缩文件之后再添加附件发送。HTTP协议中有一种被称为<strong>内容编码</strong>的功能也能进行类似的操作。<strong>内容编码</strong>指明应用在实体内容上的编码格式，并保持实体信息原样压缩。<strong>内容编码后的实体由客户端接收并负责解码</strong>。</p><p><img src="https://img-blog.csdnimg.cn/27efc50b2bf046d09ca963bc8becdea1.png" alt="img"></p><p>常用的内容编码有以下几种：<strong>gzip（GNU zip）、compress（UNIX系统的标准压缩）、deflate（zlib）、identity（不进行编码）</strong></p><h2 id="3-6分割发送的分块传输编码"><a href="#3-6分割发送的分块传输编码" class="headerlink" title="3.6分割发送的分块传输编码"></a>3.6分割发送的分块传输编码</h2><p>在HTTP通信过程中，请求的编码实体资源尚未全部传输完成之前，浏览器无法显示请求页面。在传输大容量数据时，通过把数据分割成多块，能够让浏览器逐步显示页面。这种把实体主体分块的功能称为<strong>分块传输编码（Chunked Transfer Coding）</strong>。</p><p><img src="https://img-blog.csdnimg.cn/b5ee3468c0ca423eada7be8b786b91fb.png" alt="img"></p><p>分块传输编码会将实体主体分成多个部分（块）。每一块都会用十六进制来标记块的大小，而实体主体的最后一块会使用<strong>“0(CR+LF)”</strong>来标记。使用分块传输编码的实体主体会由接收的客户端负责解码，恢复到编码前的实体主体。HTTP&#x2F;1.1中存在一种称为传输编码（Transfer Coding）的机制，它可以在通信时按某种编码方式传输，但只定义作用于分块传输编码中。</p><h2 id="3-7发送多种数据的多部分对象集合"><a href="#3-7发送多种数据的多部分对象集合" class="headerlink" title="3.7发送多种数据的多部分对象集合"></a>3.7发送多种数据的多部分对象集合</h2><p><img src="https://img-blog.csdnimg.cn/8d235ddc3401450b881fca315c37b3e8.png" alt="img"></p><p>发送邮件时，我们可以在邮件里写入文字并添加多份附件。这是因为采用了<strong>MIME（Multipurpose Internet Mail Extensions，多用途因特网邮件扩展）机制</strong>，它允许邮件处理文本、图片、视频等多个不同类型的数据。例如，图片等二进制数据以<strong>ASCII码</strong>字符串编码的方式指明，就是利用MIME来描述标记数据类型。而在MIME扩展中会使用一种称为多部分对象集合（Multipart）的方法，来容纳多份不同类型的数据。</p><p>相应地，HTTP协议中也采纳了多部分对象集合，发送的一份报文主体内可含有多类型实体。通常是在图片或文本文件等上传时使用。</p><p>多部分对象集合包含的对象：</p><p><strong>multipart&#x2F;form-data</strong>：在Web表单文件上传时使用。<br><strong>multipart&#x2F;byteranges</strong>：状态码206（Partial Content，部分内容）响应报文包含了多个范围的内容时使用。<br>在HTTP报文中使用多部分对象集合时，需要在首部字段里加上Content-type。</p><p>使用boundary字符串来划分多部分对象集合指明的各类实体。在boundary字符串指定的各个实体的起始行之前插入“–”标记（例如：–AaB03x、–THIS_STRING_SEPARATES），而在多部分对象集合对应的字符串的最后插入“–”标记（例如：–AaB03x–、–THIS_STRING_SEPARATES–）作为结束。</p><p>多部分对象集合的每个部分类型中，都可以含有首部字段。另外，可以在某个部分中嵌套使用多部分对象集合。有关多部分对象集合更详细的解释，请参考RFC2046。</p><h2 id="3-8获取部分内容的范围请求"><a href="#3-8获取部分内容的范围请求" class="headerlink" title="3.8获取部分内容的范围请求"></a>3.8获取部分内容的范围请求</h2><p>以前，用户不能使用现在这种高速的带宽访问互联网，当时，下载一个尺寸稍大的图片或文件就已经很吃力了。如果下载过程中遇到网络中断的情况，那就必须重头开始。为了解决上述问题，需要一种可恢复的机制。<strong>所谓恢复是指能从之前下载中断处恢复下载</strong>。</p><p>要实现该功能需要指定下载的实体范围。像这样，指定范围发送的请求叫做<strong>范围请求（Range Request）</strong>。对一份10000字节大小的资源，如果使用范围请求，可以只请求5001～10000字节内的资源。</p><p>​<img src="https://img-blog.csdnimg.cn/ad6d05072eca4b56aa9d2e0df3a58015.png" alt="img"></p><pre><code class="java"># 5001～10000字节Range: bytes=5001-10000# 从5001字节之后全部的Range: bytes=5001-# 从一开始到3000字节和5000～7000字节的多重范围Range: bytes=-3000, 5000-7000</code></pre><p>针对范围请求，响应会返回状态码为206 Partial Content的响应报文。另外，对于多重范围的范围请求，响应会在首部字段Content-Type标明multipart&#x2F;byteranges后返回响应报文。</p><p>如果服务器端无法响应范围请求，则会返回状态码200 OK和完整的实体内容</p><h2 id="3-9内容协商返回最合适的内容"><a href="#3-9内容协商返回最合适的内容" class="headerlink" title="3.9内容协商返回最合适的内容"></a>3.9内容协商返回最合适的内容</h2><p>当浏览器的默认语言为英语或中文，访问相同URI的Web页面时，则会显示<strong>对应的英语版或中文版的Web页面。这样的机制称为内容协商（ContentNegotiation）</strong>。</p><p><img src="https://img-blog.csdnimg.cn/d44351fbd1434b838a5f0939b92cf11a.png" alt="img"></p><p>内容协商机制是指客户端和服务器端就响应的资源内容进行交涉，然后提供给客户端最为适合的资源。内容协商会以响应资源的<strong>语言、字符集、编码方式</strong>等作为判断的基准。</p><p>包含在请求报文中的某些首部字段（如下）就是判断的基准（Accept、Accept-Charset、Accept-Encoding、Accept-Language、Content-Language）。</p><p>内容协商技术有以下3种类型:</p><p><strong>服务器驱动协商（</strong>Server-driven Negotiation）：由服务器端进行内容协商。以请求的首部字段为参考，在服务器端自动处理。但对用户来说，以浏览器发送的信息作为判定的依据，并不一定能筛选出最优内容。<br><strong>客户端驱动协商</strong>（Agent-driven Negotiation）：由客户端进行内容协商的方式。用户从浏览器显示的可选项列表中手动选择。还可以利用JavaScript脚本在Web页面上自动进行上述选择。比如按OS的类型或浏览器类型，自行切换成PC版页面或手机版页面。<br><strong>透明协商</strong>（Transparent Negotiation）：是服务器驱动和客户端驱动的结合体，是由服务器端和客户端各自进行内容协商的一种方法。</p><h1 id="第四章-返回结果的HTTP状态码"><a href="#第四章-返回结果的HTTP状态码" class="headerlink" title="第四章 .返回结果的HTTP状态码"></a>第四章 .返回结果的HTTP状态码</h1><h2 id="4-1状态码告知从服务器端返回的请求结果"><a href="#4-1状态码告知从服务器端返回的请求结果" class="headerlink" title="4.1状态码告知从服务器端返回的请求结果"></a>4.1状态码告知从服务器端返回的请求结果</h2><p><strong>状态码</strong>的职责是当客户端向服务器端发送请求时，<strong>描述返回的请求结果</strong>。借助状态码，用户可以知道服务器端是正常处理了请求，还是出现了错误。</p><p><img src="https://img-blog.csdnimg.cn/d066863937324037a756d4d7e6d43cb6.png" alt="img"></p><p>状态码如200 OK，以3位数字和原因短语组成。数字中的第一位指定了响应类别，后两位无分类。响应类别有以下5种。</p><p><img src="https://img-blog.csdnimg.cn/3dd9c729bd994381bb4abe0dcdecce32.png" alt="img"></p><h2 id="4-2-2XX成功"><a href="#4-2-2XX成功" class="headerlink" title="4.2 2XX成功"></a>4.2 2XX成功</h2><h3 id="200-OK"><a href="#200-OK" class="headerlink" title="200 OK"></a><strong>200 OK</strong></h3><p><img src="https://img-blog.csdnimg.cn/ec660e360dd44eaea9184a7043f5d0db.png" alt="img"></p><p>表示从客户端发来的请求在服务器端被正常处理了。在响应报文内，随状态码一起返回的信息会因方法的不同而发生改变。比如，使用GET方法时，对应请求资源的实体会作为响应返回；而使用HEAD方法时，对应请求资源的实体主体不随报文首部作为响应返回（即在响应中只返回首部，不会返回实体的主体部分）。</p><h3 id="204-No-Content"><a href="#204-No-Content" class="headerlink" title="204 No Content"></a><strong>204 No Content</strong></h3><p><img src="https://img-blog.csdnimg.cn/5dc64a1bae1b45e189a83b58b2e766aa.png" alt="img"></p><p>该状态码代表服务器接收的请求已<strong>成功处理</strong>，<strong>但在返回的响应报文中不含实体的主体部分</strong>。另外，也不允许返回任何实体的主体。比如，当从浏览器发出请求处理后，返回204响应，那么浏览器显示的页面不发生更新。一般在只需要从客户端往服务器发送信息，而对客户端不需要发送新信息内容的情况下使用。</p><h3 id="206-Partial-Content"><a href="#206-Partial-Content" class="headerlink" title="206 Partial Content"></a><strong>206 Partial Content</strong></h3><p><img src="https://img-blog.csdnimg.cn/10cf2abd13494ccaa29bbe9e21b6a481.png" alt="img"></p><p>该状态码表示客户端进行了<strong>范围请求</strong>，而服务器<strong>成功执行</strong>了这部分的GET请求。响应报文中包含由Content-Range指定范围的实体内容。</p><h2 id="4-3-3XX重定向"><a href="#4-3-3XX重定向" class="headerlink" title="4.3 3XX重定向"></a>4.3 3XX重定向</h2><p>3XX响应结果表明浏览器需要执行某些特殊的处理以正确处理请求。</p><h3 id="301-Moved-Permanently"><a href="#301-Moved-Permanently" class="headerlink" title="301 Moved Permanently"></a><strong>301 Moved Permanently</strong></h3><p><img src="https://img-blog.csdnimg.cn/44ef39f7a0544e52b32ad490271b9efc.png" alt="img"></p><p><strong>永久性重定向</strong>。该状态码表示请求的资源已被分配了新的URI，以后应使用资源现在所指的URI。也就是说，如果已经把资源对应的URI保存为书签了，这时应该按Location首部字段提示的URI重新保存。像下方给出的请求URI，当指定资源路径的最后忘记添加斜杠“&#x2F;”，就会产生301状态码。（<a href="http://example.com/sample%EF%BC%89">http://example.com/sample）</a></p><h3 id="302-Found"><a href="#302-Found" class="headerlink" title="302 Found"></a><strong>302 Found</strong></h3><p><img src="https://img-blog.csdnimg.cn/4b1db5588a3b448a9b69c37b089ea3fc.png" alt="img"></p><p><strong>临时性重定向</strong>。该状态码表示请求的资源已被分配了新的URI，希望用户（本次）能使用新的URI访问。和301 Moved Permanently状态码相似，但302状态码代表的资源不是被永久移动，只是临时性质的。换句话说，已移动的资源对应的URI将来还有可能发生改变。比如，用户把URI保存成书签，但不会像301状态码出现时那样去更新书签，而是仍旧保留返回302状态码的页面对应的URI。</p><h3 id="303-See-Other"><a href="#303-See-Other" class="headerlink" title="303 See Other"></a><strong>303 See Other</strong></h3><p><img src="https://img-blog.csdnimg.cn/4c0e03b304fa4dc9a61467d25771201c.png" alt="img"></p><p>该状态码表示由于请求对应的资源<strong>存在着另一个URI</strong>，应使用GET方法定向获取请求的资源。303状态码和302 Found状态码有着相同的功能，但303状态码明确表示客户端应当<strong>采用GET方法获取资源</strong>，这点与302状态码有区别。</p><p>比如，当使用POST方法访问CGI程序，其执行后的处理结果是希望客户端能以GET方法重定向到另一个URI上去时，返回303状态码。虽然302 Found状态码也可以实现相同的功能，但这里使用303状态码是最理想的。</p><p>Tips: 当301、302、303响应状态码返回时，几乎所有的浏览器都会把<strong>POST改成GET</strong>，并删除请求报文内的主体，之后请求会自动再次发送。301、302标准是禁止将POST方法改变成GET方法的，但实际使用时大家都会这么做。</p><h3 id="304-Not-Modified"><a href="#304-Not-Modified" class="headerlink" title="304 Not Modified"></a><strong>304 Not Modified</strong></h3><p><img src="https://img-blog.csdnimg.cn/09ccbfbaf6804b94b28c3f04529f0c67.png" alt="img"></p><p>该状态码表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但因发生请求未满足条件的情况后，直接返回304 Not Modified（服务器端资源未改变，可直接使用客户端未过期的缓存）。304状态码返回时，不包含任何响应的主体部分。304虽然被划分在3XX类别中，但是和重定向没有关系。</p><h3 id="307-Temporary-Redirect"><a href="#307-Temporary-Redirect" class="headerlink" title="307 Temporary Redirect"></a><strong>307 Temporary Redirect</strong></h3><p>临时重定向。该状态码与302 Found有着相同的含义。尽管302标准禁止POST变换成GET，但实际使用时大家并不遵守。</p><p>307会遵照浏览器标准，不会从POST变成GET。但是，对于处理响应时的行为，每种浏览器有可能出现不同的情况。</p><h2 id="4-4-4XX客户端错误"><a href="#4-4-4XX客户端错误" class="headerlink" title="4.4 4XX客户端错误"></a>4.4 4XX客户端错误</h2><p>4XX的响应结果表明<strong>客户端是发生错误</strong>的原因所在。</p><h3 id="400-Bad-Request"><a href="#400-Bad-Request" class="headerlink" title="400 Bad Request"></a><strong>400 Bad Request</strong></h3><p><img src="https://img-blog.csdnimg.cn/f6918dfe94f445a9b7bc98178b14745d.png" alt="img"></p><p>该状态码表示<strong>请求报文中存在语法错误</strong>。当错误发生时，需修改请求的内容后再次发送请求。另外，浏览器会像200 OK一样对待该状态码。</p><h3 id="401-Unauthorized"><a href="#401-Unauthorized" class="headerlink" title="401 Unauthorized"></a><strong>401 Unauthorized</strong></h3><p><img src="https://img-blog.csdnimg.cn/8cf771200b1c4d3cbb547b2a00e025bd.png" alt="img"></p><p>该状态码表示发送的请求需要有通过HTTP认证（BASIC认证、DIGEST认证）的认证信息。另外若之前已进行过1次请求，则表示用户认证失败。返回含有401的响应必须包含一个适用于被请求资源的WWW-Authenticate首部用以质询（challenge）用户信息。当浏览器初次接收到401响应，会弹出认证用的对话窗口。</p><h3 id="403-Forbidden"><a href="#403-Forbidden" class="headerlink" title="403 Forbidden"></a><strong>403 Forbidden</strong></h3><p><img src="https://img-blog.csdnimg.cn/3f29d6d29eb44632a3d9c0664c0bb4fc.png" alt="img"></p><p>该状态码表明对请求资源的访问被服务器拒绝了。服务器端没有必要给出拒绝的详细理由，但如果想作说明的话，可以在实体的主体部分对原因进行描述，这样就能让用户看到了。</p><p>未获得文件系统的访问授权，访问权限出现某些问题（从未授权的发送源IP地址试图访问）等列举的情况都可能是发生403的原因。</p><h3 id="404-Not-Found"><a href="#404-Not-Found" class="headerlink" title="404 Not Found"></a><strong>404 Not Found</strong></h3><p><img src="https://img-blog.csdnimg.cn/c68e1c47a7fc41ab996cf2be9104d3be.png" alt="img"></p><p>该状态码表明<strong>服务器上无法找到请求的资源</strong>。除此之外，<strong>也可以在服务器端拒绝请求且不想说明理由时使用</strong>。</p><h2 id="4-5-5XX服务器错误"><a href="#4-5-5XX服务器错误" class="headerlink" title="4.5 5XX服务器错误"></a>4.5 5XX服务器错误</h2><p>5XX的响应结果表明<strong>服务器本身发生错误</strong>。</p><h3 id="500-Internal-Server-Error"><a href="#500-Internal-Server-Error" class="headerlink" title="500 Internal Server Error"></a><strong>500 Internal Server Error</strong></h3><p><img src="https://img-blog.csdnimg.cn/3bb0f23143594378a408ed21022ae457.png" alt="img"></p><p>该状态码表明<strong>服务器端在执行请求时发生了错误</strong>。也有可能是Web应用存在的bug或某些临时的故障。</p><p><strong>503 Service Unavailable</strong></p><p><img src="https://img-blog.csdnimg.cn/006041284d7c44338dbf372bd9e7a444.png" alt="img"></p><p>该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。如果事先得知解除以上状况需要的时间，最好写入Retry-After首部字段再返回给客户端。</p><p>状态码和状况的不一致：不少返回的状态码响应都是错误的，但是用户可能察觉不到这点。比如Web应用程序内部发生错误，状态码依然返回200 OK，这种情况也经常遇到。</p><h1 id="第五章-与http协作的WEB服务器"><a href="#第五章-与http协作的WEB服务器" class="headerlink" title="第五章. 与http协作的WEB服务器"></a>第五章. 与http协作的WEB服务器</h1><h2 id="5-1-用单台虚拟主机模拟多个域名"><a href="#5-1-用单台虚拟主机模拟多个域名" class="headerlink" title="5.1 用单台虚拟主机模拟多个域名"></a>5.1 用单台虚拟主机模拟多个域名</h2><p>http&#x2F;1.1 规范允许一台http服务器搭建多个Web站点.这是因为利用了<strong>虚拟主机</strong>（VirtualHost，又称虚拟服务器）的功能。</p><p>在互联网上,域名通过DNS服务器映射到IP地址之后访问目标网站.</p><p>可见，当请求发送到服务器时，已经是以IP地址形式访问了。</p><p>所以，如果一台服务器内托管了<a href="http://www.tricorder.jp和www.hackr.jp这两个域名,当收到请求时就需要弄清楚究竟要访问哪个域名./">www.tricorder.jp和www.hackr.jp这两个域名，当收到请求时就需要弄清楚究竟要访问哪个域名。</a></p><p><img src="https://img-blog.csdnimg.cn/d1f0868f26a34738abb3761ef267c0e2.png" alt="img"></p><p>在相同的IP地址下，由于虚拟主机可以寄存多个不同主机名和域名的Web网站，因此在发送HTTP请求时，必须在Host首部内完整指定主机名或域名的URI。</p><h2 id="5-2-通信数据转发程序-代理-网关-隧道"><a href="#5-2-通信数据转发程序-代理-网关-隧道" class="headerlink" title="5.2 通信数据转发程序: 代理,网关,隧道"></a>5.2 通信数据转发程序: 代理,网关,隧道</h2><ul><li><strong>代理</strong>：代理是一种有<strong>转发功能</strong>的应用程序，它扮演了位于服务器和客户端“<strong>中间人</strong>”的角色，接收由客户端发送的请求并转发给服务器，同时也接收服务器返回的响应并转发给客户端。</li><li><strong>网关</strong>：<strong>网关是转发其他服务器通信数据的服务器，接收从客户端发送来的请求时，它就像自己拥有资源的源服务器一样对请求进行处理</strong>。有时客户端可能都不会察觉，自己的通信目标是一个网关。</li><li><strong>隧道</strong>：隧道是在<strong>相隔甚远</strong>的客户端和服务器两者之间进行中转，并<strong>保持双方通信连接</strong>的应用程序。</li></ul><h3 id="1-代理"><a href="#1-代理" class="headerlink" title="1.代理"></a>1.代理</h3><p><img src="https://img-blog.csdnimg.cn/239216cc74154081a42c210801e878f1.png" alt="img"></p><p>代理服务器的基本行为就是接收客户端发送的请求后转发给其他服务器。代理不改变请求URI，会直接发送给前方持有资源的目标服务器。持有资源实体的服务器被称为源服务器。从源服务器返回的响应经过代理服务器后再传给客户端。</p><p><strong>每次通过代理服务器转发请求或响应时，会追加写入Via首部信息</strong></p><p><img src="https://img-blog.csdnimg.cn/a07a45fdaf144d5089661e67cb953f9f.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/e378f3d952e94c47b8ab71838186a20f.png" alt="img"></p><p>使用代理服务器的理由有：<strong>利用缓存技术（稍后讲解）减少网络带宽的流量</strong>，<strong>组织内部针对特定网站的访问控制</strong>，以获取访问日志为主要目的，等等。代理有多种使用方法，按两种基准分类。一种是<strong>是否使用缓存</strong>，另一种是<strong>是否会修改报文</strong>。</p><ul><li><strong>缓存代理</strong>：代理转发响应时，缓存代理（Caching Proxy）会预先将资源的副本（缓存）保存在代理服务器上。当代理再次接收到对相同资源的请求时，就可以<strong>不从源服务器那里获取资源，而是将之前缓存的资源作为响应返回</strong>。</li><li><strong>透明代理</strong>：转发请求或响应时，<strong>不对报文做任何加工的代理类型被称为透明代理（Transparent Proxy）</strong>。反之，对报文内容进行加工的代理被称为非透明代理。</li></ul><h3 id="2-网关"><a href="#2-网关" class="headerlink" title="2.网关"></a>2.网关</h3><p>网关的工作机制和代理十分相似。而网关能使通信线路上的服务器提供<strong>非HTTP协议服务</strong>。</p><p><img src="https://img-blog.csdnimg.cn/6a9141fdc45544c3afdb44a326f73532.png" alt="img"></p><p><strong>利用网关能提高通信的安全性，因为可以在客户端与网关之间的通信线路上加密以确保连接的安全。</strong>比如，网关可以连接数据库，使用SQL语句查询数据。另外，在Web购物网站上进行信用卡结算时，网关可以和信用卡结算系统联动。</p><h3 id="3-隧道"><a href="#3-隧道" class="headerlink" title="3.隧道"></a>3.隧道</h3><p>隧道可按要求建立起一条与其他服务器的通信线路，届时使用SSL等加密手段进行通信。隧道的目的是<strong>确保客户端能与服务器进行安全的通信。</strong>隧道本身不会去解析HTTP请求。也就是说，请求保持原样中转给之后的服务器。隧道会在通信双方断开连接时结束。</p><p>通过隧道的传输，可以和远距离的服务器安全通信。隧道本身是透明的，客户端不用在意隧道的存在。</p><p><img src="https://img-blog.csdnimg.cn/7d50e3cbc2be4318b4810d6defd69d3e.png" alt="img"></p><h2 id="5-3保存资源的缓存"><a href="#5-3保存资源的缓存" class="headerlink" title="5.3保存资源的缓存"></a>5.3保存资源的缓存</h2><p><strong>缓存</strong>是指代理服务器或客户端本地磁盘内保存的资源副本。利用缓存可减少对源服务器的访问，因此也就节省了通信流量和通信时间。</p><p><strong>缓存服务器</strong>是代理服务器的一种，并归类在缓存代理类型中。换句话说，当代理转发从服务器返回的响应时，<strong>代理服务器将会保存一份资源的副本</strong>。</p><p><img src="https://img-blog.csdnimg.cn/7adec532f5de40fba4829460adec1fe1.png" alt="img"></p><h3 id="5-3-1缓存的有效期限"><a href="#5-3-1缓存的有效期限" class="headerlink" title="5.3.1缓存的有效期限"></a>5.3.1缓存的有效期限</h3><p>即便缓存服务器内有缓存，也不能保证每次都会返回对同资源的请求。因为这关系到被缓存资源的<strong>有效性问题</strong>。当遇上源服务器上的资源更新时，如果还是使用不变的缓存，那就会演变成返回更新前的“旧”资源了。即使存在缓存，也会因为客户端的要求、缓存的有效期等因素，向源服务器确认资源的有效性。若判断缓存失效，缓存服务器将会再次从源服务器上获取“新”资源。</p><p><img src="https://img-blog.csdnimg.cn/3520a3d23cf343f79c7ca270fd522f49.png" alt="img"></p><h3 id="5-3-2-客户端的缓存"><a href="#5-3-2-客户端的缓存" class="headerlink" title="5.3.2 客户端的缓存"></a>5.3.2 客户端的缓存</h3><p>缓存不仅可以存在于缓存服务器内，还可以存在<strong>客户端浏览器中</strong>。以InternetExplorer程序为例，把客户端缓存称为<strong>临时网络文件（Temporary InternetFile）。</strong>浏览器缓存如果有效，就不必再向服务器请求相同的资源了，可以直接从本地磁盘内读取。另外，和缓存服务器相同的一点是，当判定缓存过期后，会向源服务器确认资源的有效性。若判断浏览器缓存失效，浏览器会再次请求新资源。</p><h2 id="Tips：在HTTP出现之前的协议"><a href="#Tips：在HTTP出现之前的协议" class="headerlink" title="Tips：在HTTP出现之前的协议"></a><strong>Tips：在HTTP出现之前的协议</strong></h2><p><strong>FTP（File Transfer Protocol）：</strong>传输文件时使用的协议。该协议历史久远，可追溯到1973年前后，比TCP&#x2F;IP协议族的出现还要早。虽然它在1995年被HTTP的流量（Traffic）超越，但时至今日，仍被广泛沿用。</p><p><strong>NNTP（Network News Transfer Protocol）：</strong>用于NetNews电子会议室内传送消息的协议。在1986年前后出现，属于比较古老的一类协议。现在，利用Web交换信息已成主流，所以该协议已经不怎么使用了。</p><p><strong>Archie：</strong>搜索anonymous FTP公开的文件信息的协议。1990年前后出现，现在已经不常使用。</p><p><strong>WAIS（Wide Area Information Servers）：</strong>以关键词检索多个数据库使用的协议。1991年前后出现。由于现在已经被HTTP协议替代，也已经不怎么使用了。</p><p><strong>Gophe：</strong>查找与互联网连接的计算机内信息的协议。1991年前后出现，由于现在已经被HTTP协议替代，也已经不怎么使用了。</p><h1 id="第六章-http首部"><a href="#第六章-http首部" class="headerlink" title="第六章. http首部"></a>第六章. http首部</h1><h2 id="6-1-HTTP报文首部"><a href="#6-1-HTTP报文首部" class="headerlink" title="6.1 HTTP报文首部"></a>6.1 HTTP报文首部</h2><p><img src="https://img-blog.csdnimg.cn/316d4d06d4104b7cb8b97a9686358aa5.png" alt="img"></p><p>HTTP协议的请求和响应报文中必定包含HTTP首部。首部内容为客户端和服务器分别处理请求和响应提供所需要的信息。对于客户端用户来说，这些信息中的大部分内容都无须亲自查看。</p><p><strong>HTTP请求报文</strong>：在请求中，HTTP报文由<strong>方法、URI、HTTP版本、HTTP首部字段</strong>等部分构成。</p><p><img src="https://img-blog.csdnimg.cn/6838e2ed8943488289c8783432b317ef.png" alt="img"></p><p>下面的示例是访问<a href="http://hackr.jp时,请求报文的首部信息./">http://hackr.jp时，请求报文的首部信息。</a></p><p><img src="https://img-blog.csdnimg.cn/e6000a4960784d31b3978b5fcf60887d.png" alt="img"></p><p><strong>HTTP响应报文</strong>：在响应中，HTTP报文由<strong>HTTP版本、状态码（数字和原因短语）、HTTP首部字段</strong>3部分构成。</p><p><img src="https://img-blog.csdnimg.cn/0c523d7989b6457fbfa0daf4f6808a20.png" alt="img"></p><p>以下示例是之前请求访问<a href="http://hackr.jp/%E6%97%B6%EF%BC%8C%E8%BF%94%E5%9B%9E%E7%9A%84%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87%E7%9A%84%E9%A6%96%E9%83%A8%E4%BF%A1%E6%81%AF%E3%80%82">http://hackr.jp/时，返回的响应报文的首部信息。</a></p><p><img src="https://img-blog.csdnimg.cn/fd357684b48446c58827dadb2bbe1aee.png" alt="img"></p><p>在报文众多的字段当中，HTTP首部字段包含的信息最为丰富。首部字段同时存在于请求和响应报文内，并涵盖HTTP报文相关的内容信息。因HTTP版本或扩展规范的变化，首部字段可支持的字段内容略有不同。本书主要涉及HTTP&#x2F;1.1及常用的首部字段。</p><h2 id="6-2-HTTP首部字段"><a href="#6-2-HTTP首部字段" class="headerlink" title="6.2 HTTP首部字段"></a>6.2 HTTP首部字段</h2><h3 id="6-2-1-HTTP首部字段传递重要信息"><a href="#6-2-1-HTTP首部字段传递重要信息" class="headerlink" title="6.2.1 HTTP首部字段传递重要信息"></a>6.2.1 HTTP首部字段传递重要信息</h3><p>HTTP首部字段是构成HTTP报文的要素之一。在客户端与服务器之间以HTTP协议进行通信的过程中，无论是请求还是响应都会使用首部字段，它能起到传递额外重要信息的作用。</p><p>使用首部字段是为了给浏览器和服务器提供<strong>报文主体大小、所使用的语言、认证信息等内容。</strong></p><p><img src="https://img-blog.csdnimg.cn/1130c9e305964cdcb7bc073002d155ed.png" alt="img"></p><h3 id="6-2-2-HTTP首部字段结构"><a href="#6-2-2-HTTP首部字段结构" class="headerlink" title="6.2.2 HTTP首部字段结构"></a>6.2.2 HTTP首部字段结构</h3><p>HTTP首部字段是由<strong>首部字段名和字段值构成的</strong>，<strong>中间用冒号“:”分隔。</strong>例如，在HTTP首部中以Content-Type这个字段来表示报文主体的对象类型。首部字段名为Content-Type，字符串text&#x2F;html是字段值。字段值对应单个HTTP首部字段可以有多个值。</p><pre><code class="java">Content-Type: text/htmlKeep-Alive: timeout=15, max=100</code></pre><p><strong>Tips：若HTTP首部字段重复了会如何</strong></p><p>当HTTP报文首部中出现了两个或两个以上具有相同首部字段名时会怎么样？这种情况在规范内尚未明确，根据浏览器内部处理逻辑的不同，结果可能并不一致。有些浏览器会优先处理第一次出现的首部字段，而有些则会优先处理最后出现的首部字段。</p><h3 id="6-2-3-4种HTTP首部字段类型"><a href="#6-2-3-4种HTTP首部字段类型" class="headerlink" title="6.2.3 4种HTTP首部字段类型"></a>6.2.3 4种HTTP首部字段类型</h3><ul><li><p><strong>通用首部字段（General Header Fields）</strong>：请求报文和响应报文两方都会使用的首部。</p></li><li><p><strong>请求首部字段（Request Header Fields）</strong>：从客户端向服务器端发送请求报文时使用的首部。补充了请求的附加内容、客户端信息、响应内容相关优先级等信息。</p></li><li><p><strong>响应首部字段（Response Header Fields）</strong>：从服务器端向客户端返回响应报文时使用的首部。补充了响应的附加内容，也会要求客户端附加额外的内容信息。</p></li><li><p><strong>实体首部字段（Entity Header Fields）</strong>：针对请求报文和响应报文的实体部分使用的首部。补充了资源内容更新时间等与实体有关的信息。</p></li></ul><h3 id="6-2-4-HTTP-1-1-首部字段一览"><a href="#6-2-4-HTTP-1-1-首部字段一览" class="headerlink" title="6.2.4 HTTP&#x2F;1.1 首部字段一览"></a>6.2.4 HTTP&#x2F;1.1 首部字段一览</h3><p>HTTP&#x2F;1.1规范定义了如下47种首部字段。</p><h4 id="通用首部字段（General-Header-Fields）"><a href="#通用首部字段（General-Header-Fields）" class="headerlink" title="通用首部字段（General Header Fields）"></a><strong>通用首部字段（General Header Fields）</strong></h4><p><img src="https://img-blog.csdnimg.cn/21def104da8a43798fbaace20b364e35.png" alt="img"></p><h4 id="请求首部字段（Request-Header-Fields）"><a href="#请求首部字段（Request-Header-Fields）" class="headerlink" title="请求首部字段（Request Header Fields）"></a><strong>请求首部字段（Request Header Fields）</strong></h4><p><img src="https://img-blog.csdnimg.cn/c0a613597ecb4022845e5ab4b731da1d.png" alt="img"></p><h4 id="响应首部字段（Response-Header-Fields"><a href="#响应首部字段（Response-Header-Fields" class="headerlink" title="响应首部字段（Response Header Fields"></a><strong>响应首部字段（Response Header Fields</strong></h4><p><img src="https://img-blog.csdnimg.cn/800d7fcc326c47bbaf27d90645f3152b.png" alt="img"></p><h4 id="实体首部字段（Entity-Header-Fields"><a href="#实体首部字段（Entity-Header-Fields" class="headerlink" title="实体首部字段（Entity Header Fields"></a><strong>实体首部字段（Entity Header Fields</strong></h4><p><img src="https://img-blog.csdnimg.cn/52a63b8e9dd348f59f4388ebdcbd4078.png" alt="img"></p><h3 id="6-2-5-非HTTP-1-1首部字段"><a href="#6-2-5-非HTTP-1-1首部字段" class="headerlink" title="6.2.5 非HTTP&#x2F;1.1首部字段"></a>6.2.5 非HTTP&#x2F;1.1首部字段</h3><p>在HTTP协议通信交互中使用到的首部字段，不限于RFC2616中定义的47种首部字段。还有Cookie、Set-Cookie和Content-Disposition等在其他RFC中定义的首部字段，它们的使用频率也很高。这些非正式的首部字段统一归纳在RFC4229 HTTP Header Field Registrations中。</p><h3 id="6-2-6-End-to-end首部和Hop-by-hop首部"><a href="#6-2-6-End-to-end首部和Hop-by-hop首部" class="headerlink" title="6.2.6 End-to-end首部和Hop-by-hop首部"></a>6.2.6 End-to-end首部和Hop-by-hop首部</h3><p>HTTP首部字段将定义成<strong>缓存代理和非缓存代理</strong>的行为，分成2种类型。</p><ul><li><p><strong>端到端首部（End-to-end Header）</strong>：分在此类别中的首部会转发给请求&#x2F;响应对应的最终接收目标，且必须保存在由缓存生成的响应中，另外规定它必须被转发。</p></li><li><p><strong>逐跳首部（Hop-by-hop Header）</strong>：分在此类别中的首部只对单次转发有效，会因通过缓存或代理而不再转发。HTTP&#x2F;1.1和之后版本中，如果要使用hop-by-hop首部，需提供Connection首部字段。</p></li></ul><p>下面列举了HTTP&#x2F;1.1中的逐跳首部字段。除这8个首部字段之外，其他所有字段都属于端到端首部。<strong>Connection、Keep-Alive、Proxy-Authenticate、Proxy-Authorization、Trailer、TE、Transfer-Encoding、Upgrade。</strong></p><h2 id="6-3-HTTP-1-1-通用首部字段"><a href="#6-3-HTTP-1-1-通用首部字段" class="headerlink" title="6.3 HTTP&#x2F;1.1 通用首部字段"></a>6.3 HTTP&#x2F;1.1 通用首部字段</h2><p>通用首部字段是指，请求报文和响应报文双方都会使用的首部。</p><h3 id="6-3-1-Cache-Control"><a href="#6-3-1-Cache-Control" class="headerlink" title="6.3.1 Cache-Control"></a>6.3.1 Cache-Control</h3><p>通过指定首部字段Cache-Control的指令，就能操作缓存的工作机制。</p><p><img src="https://img-blog.csdnimg.cn/0b49b14650874f44a1dda605a84ca173.png" alt="img"></p><p>指令的参数是可选的，多个指令之间通过“,”分隔。首部字段Cache-Control的指令可用于请求及响应时。</p><pre><code class="java">Cache-Control: private, max-age=0, no-cache</code></pre><p><strong>Cache-Control指令，缓存请求指令</strong></p><p><img src="https://img-blog.csdnimg.cn/28d039f330a7467a8aa20efe2558ed0b.png" alt="img"></p><p><strong>Cache-Control指令，缓存响应指令</strong></p><p><img src="https://img-blog.csdnimg.cn/ea005fd11b0344238351577d9b2e2185.png" alt="img"></p><p><strong>表示是否能缓存的指令</strong>:</p><pre><code class="java">Cache-Control: publicCache-Control: privateCache-Control: no-cacheCache-Control: no-cache=Location</code></pre><ul><li><p><strong>public指令</strong>：当指定使用public指令时，则明确表明其他用户也可利用缓存。</p></li><li><p><strong>private指令</strong>：当指定private指令后，响应只以特定的用户作为对象，这与public指令的行为相反。缓存服务器会对该特定用户提供资源缓存的服务，对于其他用户发送过来的请求，代理服务器则不会返回缓存。</p></li><li><p>no-cache指令：使用no-cache指令的目的是为了防止从缓存中返回过期的资源。客户端发送的请求中如果包含no-cache指令，则表示客户端将不会接收缓存过的响应。于是，“中间”的缓存服务器必须把客户端请求转发给源服务器。如果服务器返回的响应中包含no-cache指令，那么缓存服务器不能对资源进行缓存。源服务器以后也将不再对缓存服务器请求中提出的资源有效性进行确认，且禁止其对响应资源进行缓存操作。由服务器返回的响应中，若报文首部字段Cache-Control中对no-cache字段名具体指定参数值，那么客户端在接收到这个被指定参数值的首部字段对应的响应报文后，就不能使用缓存。换言之，无参数值的首部字段可以使用缓存。只能在响应指令中指定该参数。</p><p><img src="https://img-blog.csdnimg.cn/c314dae7b1a9425da71aae9709987db0.png" alt="img"></p><p>控制可执行缓存的对象的指令.</p></li><li><p><strong>no-store指令</strong>：当使用no-store指令时，暗示请求（和对应的响应）或响应中包含机密信息。因此，该指令规定缓存不能在本地存储请求或响应的任一部分。</p></li></ul><pre><code class="java">Cache-Control: no-store</code></pre><p><strong>指定缓存期限和认证的指令</strong></p><ul><li>s-maxage指令：s-maxage指令的功能和max-age指令的相同，它们的不同点是s-maxage指令只适用于供多位用户使用的公共缓存服务器。也就是说，对于向同一用户重复返回响应的服务器来说，这个指令没有任何作用。另外，当使用s-maxage指令后，则直接忽略对Expires首部字段及max-age指令的处理。</li></ul><pre><code class="java">Cache-Control: s-maxage=604800 // 单位秒</code></pre><ul><li><strong>max-age指令</strong></li></ul><p><img src="https://img-blog.csdnimg.cn/07c0941c7cc949dca4cf04ce52b30327.png" alt="img"></p><pre><code class="java">Cache-Control: max-age=604800 // 单位秒</code></pre><p>当客户端发送的请求中包含max-age指令时，如果判定缓存资源的缓存时间数值比指定时间的数值更小，那么客户端就接收缓存的资源。另外，当指定max-age值为0，那么缓存服务器通常需要将请求转发给源服务器。当服务器返回的响应中包含max-age指令时，缓存服务器将不对资源的有效性再作确认，而max-age数值代表资源保存为缓存的最长时间。应用HTTP&#x2F;1.1版本的缓存服务器遇到同时存在Expires首部字段的情况时，会优先处理max-age指令，而忽略掉Expires首部字段。而HTTP&#x2F;1.0版本的缓存服务器的情况却相反，max-age指令会被忽略掉。</p><ul><li><strong>min-fresh指令</strong></li></ul><p><img src="https://img-blog.csdnimg.cn/1f39f3aa4aec4735b1f6365e14db9362.png" alt="img"></p><pre><code class="javascript">Cache-Control: min-fresh=60 // 单位秒</code></pre><p>min-fresh指令要求缓存服务器返回至少还未过指定时间的缓存资源。比如，当指定min-fresh为60秒后，在这60秒以内如果有超过有效期限的资源都无法作为响应返回了。</p><ul><li><strong>max-stale指令</strong></li></ul><pre><code class="java">Cache-Control: max-stale=3600 // 单位秒</code></pre><p>使用max-stale可指示缓存资源，即使过期也照常接收。如果指令未指定参数值，那么无论经过多久，客户端都会接收响应；如果指令中指定了具体数值，那么即使过期，只要仍处于max-stale指定的时间内，仍旧会被客户端接收。</p><ul><li><strong>only-if-cached指令</strong></li></ul><pre><code class="java">Cache-Control: only-if-cached</code></pre><p>使用only-if-cached指令表示客户端仅在缓存服务器本地缓存目标资源的情况下才会要求其返回。换言之，该指令要求缓存服务器不重新加载响应，也不会再次确认资源有效性。若发生请求缓存服务器的本地缓存无响应，则返回状态码504Gateway Timeout。</p><ul><li><strong>must-revalidate指令</strong></li></ul><pre><code class="java">Cache-Control: must-revalidate</code></pre><p>使用must-revalidate指令，代理会向源服务器再次验证即将返回的响应缓存目前是否仍然有效。若代理无法连通源服务器再次获取有效资源的话，缓存必须给客户端一条504（Gateway Timeout）状态码。另外，使用must-revalidate指令会忽略请求的max-stale指令（即使已经在首部使用了max-stale，也不会再有效果）。</p><ul><li><strong>proxy-revalidate指令</strong></li></ul><pre><code class="java">Cache-Control: proxy-revalidate</code></pre><p>proxy-revalidate指令要求所有的缓存服务器在接收到客户端带有该指令的请求返回响应之前，必须再次验证缓存的有效性。</p><ul><li><strong>no-transform指令</strong></li></ul><pre><code class="java">Cache-Control: no-transform</code></pre><p>使用no-transform指令规定无论是在请求还是响应中，<strong>缓存都不能改变实体主体的媒体类型</strong>。这样做可防止缓存或代理压缩图片等类似操作。</p><p><strong>Cache-Control扩展</strong></p><ul><li><strong>cache-extension token</strong></li></ul><pre><code class="java">Cache-Control: private, community=&quot;UCI&quot;</code></pre><p>通过cache-extension标记（token），可以扩展Cache-Control首部字段内的指令。如上例，Cache-Control首部字段本身没有community这个指令。借助extension tokens实现了该指令的添加。如果缓存服务器不能理解community这个新指令，就会直接忽略。因此，extension tokens仅对能理解它的缓存服务器来说是有意义的。</p><h3 id="6-3-2-Connection"><a href="#6-3-2-Connection" class="headerlink" title="6.3.2 Connection"></a>6.3.2 Connection</h3><p>Connection首部字段具备如下两个作用。（<strong>控制不再转发给代理的首部字段、管理持久连接</strong>）</p><p><strong>控制不再转发给代理的首部字段</strong></p><p><img src="https://img-blog.csdnimg.cn/5ff413b28b9544e6afdf0e732073dfcd.png" alt="img"></p><pre><code class="java">Connection: 不在转发的首部字段名</code></pre><p>在客户端发送请求和服务器返回响应内，使用Connection首部字段，可控制不再转发给代理的首部字段（即Hop-by-hop首部）。</p><p><strong>管理持久连接</strong></p><p><img src="https://img-blog.csdnimg.cn/5500bdd20a91444dbeb5e16b630eefef.png" alt="img"></p><pre><code class="java">Connection: close</code></pre><p>HTTP&#x2F;1.1版本的默认连接都是持久连接。为此，客户端会在持久连接上连续发送请求。当服务器端想明确断开连接时，则指定Connection首部字段的值为<strong>Close</strong>。</p><p><img src="https://img-blog.csdnimg.cn/953496b86b3e46f1a5fb40aedca76cb4.png" alt="img"></p><pre><code class="java">Connection: Keep-Alive</code></pre><p>HTTP&#x2F;1.1之前的HTTP版本的默认连接都是非持久连接。为此，如果想在旧版本的HTTP协议上维持持续连接，则需要指定Connection首部字段的值为Keep-Alive。</p><p>如上图①所示，客户端发送请求给服务器时，服务器端会像上图②那样加上首部字段Keep-Alive及首部字段Connection后返回响应。</p><h3 id="6-3-3-Date"><a href="#6-3-3-Date" class="headerlink" title="6.3.3 Date"></a>6.3.3 Date</h3><p>首部字段Date表明<strong>创建HTTP报文的日期和时间</strong>。</p><p><img src="https://img-blog.csdnimg.cn/3e362b09127a49ebb91773532e04a011.png" alt="img"></p><p>HTTP&#x2F;1.1协议使用在RFC1123中规定的日期时间的格式，如下示例。</p><pre><code class="java">Date:Tue, 03 Jul 2012 04:40:59 GMT</code></pre><pre><code class="java">Date:Tue, 03-Jul-12 04:40:59 GMT</code></pre><p>除此之外，还有一种格式。它与C标准库内的asctime()函数的输出格式一致。</p><pre><code class="java">Date:Tue Jul 03 04:40:59 2012</code></pre><h3 id="6-3-4-Pragma"><a href="#6-3-4-Pragma" class="headerlink" title="6.3.4 Pragma"></a>6.3.4 Pragma</h3><p>Pragma是HTTP&#x2F;1.1之前版本的历史遗留字段，仅作为与HTTP&#x2F;1.0的向后兼容而定义。</p><pre><code class="java">Pragma: no-cache</code></pre><p>该首部字段属于通用首部字段，但只用在客户端发送的请求中。客户端会要求所有的中间服务器不返回缓存的资源。</p><p><img src="https://img-blog.csdnimg.cn/3084ff1485d8454389c2f630618b605b.png" alt="img"></p><p>所有的中间服务器如果都能以HTTP&#x2F;1.1为基准，那直接采用Cache-Control: no-cache指定缓存的处理方式是最为理想的。但要整体掌握全部中间服务器使用的HTTP协议版本却是不现实的。因此，发送的请求会同时含有下面两个首部字段。</p><pre><code class="java">Cache-Control: no-cachePragma: no-cache</code></pre><h3 id="6-3-5-Trailer"><a href="#6-3-5-Trailer" class="headerlink" title="6.3.5 Trailer"></a>6.3.5 Trailer</h3><p><img src="https://img-blog.csdnimg.cn/20f9d4e4804c4da29fed353057b81af3.png" alt="img"></p><p>首部字段Trailer会事先说明在报文主体后记录了哪些首部字段。该首部字段可应用在HTTP&#x2F;1.1版本分块传输编码时。</p><p><img src="https://img-blog.csdnimg.cn/4039c52f60344b1fa893be1bbbf090c5.png" alt="img"></p><p>以上用例中，指定首部字段Trailer的值为Expires，在报文主体之后（分块长度0之后）出现了首部字段Expires。</p><h3 id="6-3-6-Transfer-Encoding"><a href="#6-3-6-Transfer-Encoding" class="headerlink" title="6.3.6 Transfer-Encoding"></a>6.3.6 Transfer-Encoding</h3><p><img src="https://img-blog.csdnimg.cn/4663568fe73043f1a2c9d0039b7c97c3.png" alt="img"></p><p>首部字段Transfer-Encoding规定了传输报文主体时采用的编码方式。</p><p>HTTP&#x2F;1.1的传输编码方式仅对分块传输编码有效。</p><p><img src="https://img-blog.csdnimg.cn/0cbba38e403848b0b60daf7db7e12256.png" alt="img"></p><p>以上用例中，正如在首部字段Transfer-Encoding中指定的那样，有效使用分块传输编码，且分别被分成3312字节和914字节大小的分块数据。</p><h3 id="6-3-7-Upgrade"><a href="#6-3-7-Upgrade" class="headerlink" title="6.3.7 Upgrade"></a>6.3.7 Upgrade</h3><p>首部字段Upgrade用于检测HTTP协议及其他协议是否可使用更高的版本进行通信，其参数值可以用来指定一个完全不同的通信协议。</p><p><img src="https://img-blog.csdnimg.cn/f2760dd4ddd44dfa83c40516afe3bfad.png" alt="img"></p><p>上图用例中，首部字段Upgrade指定的值为TLS&#x2F;1.0。请注意此处两个字段首部字段的对应关系，Connection的值被指定为Upgrade。U<strong>pgrade首部字段产生作用的Upgrade对象仅限于客户端和邻接服务器之间。</strong>因此，使用首部字段Upgrade时，还需要额外指定Connection:Upgrade。</p><p>对于附有首部字段Upgrade的请求，<strong>服务器可用101 Switching Protocols状态码作为响应返回。</strong></p><h3 id="6-3-8-Via"><a href="#6-3-8-Via" class="headerlink" title="6.3.8 Via"></a>6.3.8 Via</h3><p>使用首部字段Via是为了追踪客户端与服务器之间的请求和响应报文的传输路径。<strong>报文经过代理或网关时，会先在首部字段Via中附加该服务器的信息，然后再进行转发。</strong>这个做法和traceroute及电子邮件的Received首部的工作机制很类似。首部字段Via不仅用于追踪报文的转发，还可避免请求回环的发生。所以必须在经过代理时附加该首部字段内容。</p><p><img src="https://img-blog.csdnimg.cn/48ff0e62aa284b8f99f654350188dc26.png" alt="img"></p><p>上图用例中，在经过代理服务器A时，Via首部附加了“1.0 gw. hackr.jp(Squid&#x2F;3.1)”这样的字符串值。行头的1.0是指接收请求的服务器上应用的HTTP协议版本。接下来经过代理服务器B时亦是如此，在Via首部附加服务器信息，也可增加1个新的Via首部写入服务器信息。</p><p>Via首部是为了追踪传输路径，所以经常会和TRACE方法一起使用。比如，代理服务器接收到由TRACE方法发送过来的请求（其中Max-Forwards: 0）时，代理服务器就不能再转发该请求了。这种情况下，代理服务器会将自身的信息附加到Via首部后，返回该请求的响应。</p><h3 id="6-3-9-Warning"><a href="#6-3-9-Warning" class="headerlink" title="6.3.9 Warning"></a>6.3.9 Warning</h3><p>HTTP&#x2F;1.1的Warning首部是从HTTP&#x2F;1.0的响应首部（Retry-After）演变过来的。该首部通常会告知用户一些与缓存相关的问题的警告。</p><p>Warning首部的格式如下。最后的日期时间部分可省略。</p><p>HTTP&#x2F;1.1中定义了7种警告。警告码对应的警告内容仅推荐参考。另外，警告码具备扩展性，今后有可能追加新的警告码。</p><p><img src="https://img-blog.csdnimg.cn/f2246c426f3f4818a4ed96a9461de035.png" alt="img"></p><h2 id="6-4-请求首部字段"><a href="#6-4-请求首部字段" class="headerlink" title="6.4 请求首部字段"></a>6.4 请求首部字段</h2><p>请求首部字段是从<strong>客户端往服务器端发送请求报文中所使用的字段</strong>，用于补充请求的附加信息、客户端信息、对响应内容相关的优先级等内容。</p><h3 id="6-4-1-Accept"><a href="#6-4-1-Accept" class="headerlink" title="6.4.1 Accept"></a>6.4.1 Accept</h3><p><img src="https://img-blog.csdnimg.cn/2bf118637622402997b7cda0178f69f4.png" alt="img"></p><pre><code class="java">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</code></pre><p>Accept首部字段可通知服务器，用户代理能够处理的媒体类型及媒体类型的相对优先级。可使用type&#x2F;subtype这种形式，一次指定多种媒体类型。下面我们试举几个媒体类型的例子。</p><p>下面我们试举几个媒体类型的例子。</p><ul><li><strong>文本文件</strong>：text&#x2F;html、text&#x2F;plain、text&#x2F;css、application&#x2F;xhtml+xml、application&#x2F;xml …</li><li><strong>图片文件</strong>：image&#x2F;jpeg、image&#x2F;gif、image&#x2F;png …</li><li><strong>视频文件</strong>：video&#x2F;mpeg、video&#x2F;quicktime …</li><li><strong>应用程序使用的二进制文件</strong>：application&#x2F;octet-stream, application&#x2F;zip …</li></ul><p>比如，如果浏览器不支持PNG图片的显示，那Accept就不指定image&#x2F;png，而指定可处理的image&#x2F;gif和image&#x2F;jpeg等图片类型。</p><p>若想要给显示的媒体类型增加优先级，则使用q&#x3D;来额外表示权重值，用分号（;）进行分隔。权重值q的范围是0～1（可精确到小数点后3位），且1为最大值。不指定权重q值时，默认权重为q&#x3D;1.0。当服务器提供多种内容时，将会首先返回权重值最高的媒体类型。</p><h3 id="6-4-2-Accept-Charset"><a href="#6-4-2-Accept-Charset" class="headerlink" title="6.4.2 Accept-Charset"></a>6.4.2 Accept-Charset</h3><p><img src="https://img-blog.csdnimg.cn/ec34307fe8b1415fbb460220d0246b75.png" alt="img"></p><pre><code class="java">Accept-Charset: iso-8859-5, unicode-1-1;q=0.8</code></pre><p>Accept-Charset首部字段可用来通知服务器<strong>用户代理支持的字符集及字符集的相对优先顺序</strong>。另外，可一次性指定多种字符集。与首部字段Accept相同的是可用权重q值来表示相对优先级。该首部字段应用于内容协商机制的服务器驱动协商。</p><h3 id="6-4-3-Accept-Encoding"><a href="#6-4-3-Accept-Encoding" class="headerlink" title="6.4.3 Accept-Encoding"></a>6.4.3 Accept-Encoding</h3><p><img src="https://img-blog.csdnimg.cn/44ab7978c3e540f9a58644b24e22ae9e.png" alt="img"></p><pre><code class="java">Accept-Encoding: gzip, deflate</code></pre><p>Accept-Encoding首部字段用来告知服务器<strong>用户代理支持的内容编码及内容编码的优先级顺序</strong>。可一次性指定多种内容编码。采用权重q值来表示相对优先级，这点与首部字段Accept相同。另外，也可使用星号（*）作为通配符，指定任意的编码格式。</p><p>下面试举出几个内容编码的例子。</p><ul><li><strong>gzip</strong>：由文件压缩程序gzip（GNU zip）生成的编码格式（RFC1952），采用Lempel-Ziv算法（LZ77）及32位循环冗余校验（Cyclic RedundancyCheck，通称CRC）。</li><li><strong>compress</strong>：由UNIX文件压缩程序compress生成的编码格式，采用Lempel-Ziv-Welch算法（LZW）。</li><li><strong>deflate</strong>：组合使用zlib格式（RFC1950）及由deflate压缩算法（RFC1951）生成的编码格式。</li><li><strong>identity</strong>：不执行压缩或不会变化的默认编码格式</li></ul><h3 id="6-4-4-Accept-Language"><a href="#6-4-4-Accept-Language" class="headerlink" title="6.4.4 Accept-Language"></a>6.4.4 Accept-Language</h3><p><img src="https://img-blog.csdnimg.cn/391f3d8c4471423bbbe021172c86fb43.png" alt="img"></p><pre><code class="java">Accept-Language: zh-cn, zh;q=0.7,en-us,en;q=0.3</code></pre><p>首部字段Accept-Language用来告知服务器用户代理能够处理的自然语言集（指中文或英文等），以及自然语言集的相对优先级。可一次指定多种自然语言集。和Accept首部字段一样，按权重值q来表示相对优先级。在上述图例中，客户端在服务器有中文版资源的情况下，会请求其返回中文版对应的响应，没有中文版时，则请求返回英文版响应。</p><h3 id="6-4-5-Authorization"><a href="#6-4-5-Authorization" class="headerlink" title="6.4.5 Authorization"></a>6.4.5 Authorization</h3><p><img src="https://img-blog.csdnimg.cn/231dff7f28d043379f39a9bce89bdb87.png" alt="img"></p><pre><code class="java">Authorization: Basic dWVub3N1bjpwYXNzd29yZA==</code></pre><p>首部字段Authorization是用来告知服务器，用户代理的认证信息（证书值）。通常，想要通过服务器认证的用户代理会在接收到返回的401状态码响应后，把首部字段Authorization加入请求中。共用缓存在接收到含有Authorization首部字段的请求时的操作处理会略有差异。有关HTTP访问认证及Authorization首部字段，稍后的章节还会详细说明。另外，读者也可参阅RFC2616。</p><h3 id="4-6-Expect"><a href="#4-6-Expect" class="headerlink" title="4.6 Expect"></a>4.6 Expect</h3><p><img src="https://img-blog.csdnimg.cn/4713167de35f4ae79c1a1111714944a5.png" alt="img"></p><pre><code class="java">Expect: 100-continue</code></pre><p> 客户端使用首部字段Expect来告知服务器，期望出现的某种特定行为。因服务器无法理解客户端的期望作出回应而发生错误时，会返回状态码417Expectation Failed。客户端可以利用该首部字段，写明所期望的扩展。虽然HTTP&#x2F;1.1规范只定义了100-continue（状态码100 Continue之意）。等待状态码100响应的客户端在发生请求时，需要指定Expect:100-continue。</p><h3 id="6-4-7-From"><a href="#6-4-7-From" class="headerlink" title="6.4.7 From"></a>6.4.7 From</h3><p><img src="https://img-blog.csdnimg.cn/992d7bbb2c2b4e459b5f2cae18523194.png" alt="img"></p><p>首部字段From用来告知服务器使用<strong>用户代理的用户的电子邮件地址</strong>。通常，其使用目的就是为了显示搜索引擎等用户代理的负责人的电子邮件联系方式。使用代理时，应尽可能包含From首部字段（但可能会因代理不同，将电子邮件地址记录在User-Agent首部字段内）。</p><h3 id="6-4-8-Host"><a href="#6-4-8-Host" class="headerlink" title="6.4.8 Host"></a>6.4.8 Host</h3><p>虚拟主机运行在同一个IP上，因此使用首部字段Host加以区分</p><p><img src="https://img-blog.csdnimg.cn/2bb8e80815b64d72b980e56831ae66bb.png" alt="img"></p><pre><code class="java">Host: www.hackr.jp</code></pre><p>首部字段Host会告知服务器，请求的资源所处的互联网<strong>主机名和端口号</strong>。Host首部字段在HTTP&#x2F;1.1规范内是唯一一个<strong>必须被包含在请求内的首部字段。</strong>首部字段Host和以单台服务器分配多个域名的虚拟主机的工作机制有很密切的关联，这是首部字段Host必须存在的意义。请求被发送至服务器时，请求中的主机名会用IP地址直接替换解决。但如果这时，相同的IP地址下部署运行着多个域名，那么服务器就会无法理解究竟是哪个域名对应的请求。因此，就需要使用首部字段Host来明确指出请求的主机名。若服务器未设定主机名，那直接发送一个<strong>空值</strong>即可。</p><h3 id="6-4-9-If-Match-条件请求"><a href="#6-4-9-If-Match-条件请求" class="headerlink" title="6.4.9 If-Match 条件请求"></a>6.4.9 If-Match 条件请求</h3><p>附带条件请求</p><p><img src="https://img-blog.csdnimg.cn/40c4300dd1a2497b9ca4c522e190f748.png" alt="img"></p><p>形如If-xxx这种样式的请求首部字段，都可称为<strong>条件请求</strong>。服务器接收到附带条件的请求后，只有判断指定条件为真时，才会执行请求。只有当<strong>If-Match的字段值跟ETag值匹配一致时</strong>，服务器才会接受请求。</p><p><img src="https://img-blog.csdnimg.cn/e4e1ad31fbcf45ebaac6287e201ad185.png" alt="img"></p><pre><code class="java">If-Match: &quot;123456&quot;</code></pre><p>首部字段If-Match，属附带条件之一，它会告知服务器匹配资源所用的<strong>实体标记（ETag）</strong>值。这时的服务器无法使用弱ETag值。（请参照本章有关首部字段ETag的说明）服务器会比对If-Match的字段值和资源的ETag值，仅当两者一致时，才会执行请求。反之，则返回状态码<strong>412 Precondition Failed</strong>的响应。还可以使用星号（*****）指定If-Match的字段值。针对这种情况，服务器将会忽略ETag的值，只要资源存在就处理请求。</p><h3 id="6-4-10-If-Modified-Since"><a href="#6-4-10-If-Modified-Since" class="headerlink" title="6.4.10 If-Modified-Since"></a>6.4.10 If-Modified-Since</h3><p><img src="https://img-blog.csdnimg.cn/e039fb7001ff49d7880d95a7e21b5e66.png" alt="img"></p><p>如果在If-Modified-Since字段指定的日期时间后，资源发生了<strong>更新</strong>，服务器会接受请求</p><pre><code class="java">If-Modified-Since: Thu, 15 Apr 2004 00:00:00 GMT</code></pre><p>首部字段If-Modified-Since，属附带条件之一，它会告知服务器若<strong>If-Modified-Since字段值早于资源的更新时间</strong>，则希望能处理该请求。而在指定If-Modified-Since字段值的日期时间之后，如果请求的资源都没有过更新，则返回状态码<strong>304 NotModified</strong>的响应。If-Modified-Since用于确认代理或客户端拥有的本地资源的有效性。获取资源的更新日期时间，可通过确认首部字段Last-Modified来确定。</p><h3 id="6-4-11-If-None-Match"><a href="#6-4-11-If-None-Match" class="headerlink" title="6.4.11 If-None-Match"></a>6.4.11 If-None-Match</h3><p>只有在If-None-Match的字段值与ETag值不一致时，可处理该请求。与<strong>If-Match首部字段的作用相反</strong></p><p><img src="https://img-blog.csdnimg.cn/80d99f870bf44dafa311848fa214fc67.png" alt="img"></p><p>首部字段If-None-Match属于附带条件之一。它和首部字段If-Match作用相反。用于指定If-None-Match字段值的实体标记（ETag）值与请求资源的ETag不一致时，它就告知服务器处理该请求。在<strong>GET或HEAD</strong>方法中使用首部字段If-None-Match<strong>可获取最新的资源</strong>。因此，这与使用首部字段If-Modified-Since时有些类似。</p><h3 id="6-4-12-If-Range"><a href="#6-4-12-If-Range" class="headerlink" title="6.4.12 If-Range"></a>6.4.12 If-Range</h3><p><img src="https://img-blog.csdnimg.cn/d475e1482e6e432ea0d9873899772a3c.png" alt="img"></p><p>首部字段If-Range属于附带条件之一。它告知服务器若指定的If-Range字段值（ETag值或者时间）和请求资源的ETag值或时间相一致时，则作为<strong>范围请求处理</strong>。反之，则返回<strong>全体资源。</strong></p><p><img src="https://img-blog.csdnimg.cn/44d0db217cc34094b6af8395fc9ae69f.png" alt="img"></p><p>下面我们思考一下不使用首部字段If-Range发送请求的情况。服务器端的资源如果更新，那客户端持有资源中的一部分也会随之无效，当然，范围请求作为前提是无效的。这时，服务器会暂且以状态码412 Precondition Failed作为响应返回，其目的是催促客户端再次发送请求。这样一来，与使用首部字段If-Range比起来，就需要花费两倍的功夫。</p><h3 id="6-4-13-If-Unmodified-Since"><a href="#6-4-13-If-Unmodified-Since" class="headerlink" title="6.4.13 If-Unmodified-Since"></a>6.4.13 If-Unmodified-Since</h3><pre><code class="java">If-Unmodified-Since: Thu, 15 Apr 2004 00:00:00 GMT</code></pre><p><strong>首部字段If-Unmodified-Since和首部字段If-Modified-Since的作用相反。</strong>它的作用的是告知服务器，指定的请求资源只有在字段值内指定的日期时间之后，未发生更新的情况下，才能处理请求。如果在指定日期时间后发生了更新，则以状态码412 Precondition Failed作为响应返回。</p><h3 id="6-4-14-Max-Forwards"><a href="#6-4-14-Max-Forwards" class="headerlink" title="6.4.14 Max-Forwards"></a>6.4.14 Max-Forwards</h3><p><strong>每次转发数值减1。当数值变0时返回响应</strong></p><p><img src="https://img-blog.csdnimg.cn/852e9c71ebb04ba1b2e56fac82422664.png" alt="img"></p><pre><code class="java">Max-Forwards: 10</code></pre><p>通过TRACE方法或OPTIONS方法，发送包含首部字段Max-Forwards的请求时，该字段以十进制整数形式指定可经过的服务器最大数目。服务器在往下一个服务器转发请求之前，会将Max-Forwards的值减1后重新赋值。当服务器接收到Max-Forwards值为0的请求时，则不再进行转发，而是直接返回响应。</p><p>使用HTTP协议通信时，请求可能会经过代理等多台服务器。途中，如果代理服务器由于某些原因导致请求转发失败，客户端也就等不到服务器返回的响应了。对此，我们无从可知。</p><p>可以灵活使用首部字段Max-Forwards，针对以上问题产生的原因展开调查。由于当Max-Forwards字段值为0时，服务器就会立即返回响应，由此我们至少可以对以那台服务器为终点的传输路径的通信状况有所把握。</p><p>代理B到源服务器的请求失败了，但客户端不知道<br><img src="https://img-blog.csdnimg.cn/6072513b15c64bc48b2b9712fdc7dc1d.png" alt="img"></p><h3 id="6-4-15-Proxy-Authorization"><a href="#6-4-15-Proxy-Authorization" class="headerlink" title="6.4.15 Proxy-Authorization"></a>6.4.15 Proxy-Authorization</h3><pre><code class="java">Proxy-Authorization: Basic dG1w0jkpNLAGfFY5</code></pre><p>接收到从代理服务器发来的认证质询时，客户端会发送包含首部字段Proxy-Authorization的请求，以告知服务器认证所需要的信息。这个行为是与客户端和服务器之间的HTTP访问认证相类似的，不同之处在于，认证行为发生在客户端与代理之间。客户端与服务器之间的认证，使用首部字段Authorization可起到相同作用。有关HTTP访问认证，后面的章节会作详尽阐述。</p><h3 id="6-4-16-Range"><a href="#6-4-16-Range" class="headerlink" title="6.4.16 Range"></a>6.4.16 Range</h3><pre><code class="java">Range: bytes=5001-10000</code></pre><p>对于只需获取部分资源的范围请求，包含首部字段Range即可告知服务器资源的指定范围。上面的示例表示请求获取从第5001字节至第10000字节的资源。接收到附带Range首部字段请求的服务器，会在处理请求之后返回状态码为206 Partial Content的响应。无法处理该范围请求时，则会返回状态码200 OK的响应及全部资源。</p><h3 id="6-4-17-Referer"><a href="#6-4-17-Referer" class="headerlink" title="6.4.17 Referer"></a>6.4.17 Referer</h3><p><img src="https://img-blog.csdnimg.cn/c0cf9ef88712477cb53f96498540f2a9.png" alt="img"></p><pre><code class="java">Referer: http://www.hackr.jp/index.html</code></pre><p>首部字段Referer会告知服务器<strong>请求的原始资源的URI。</strong>客户端一般都会发送Referer首部字段给服务器。但当直接在浏览器的地址栏输入URI，或出于安全性的考虑时，也可以不发送该首部字段。因为原始资源的URI中的查询字符串可能含有ID和密码等保密信息，要是写进Referer转发给其他服务器，则有可能导致保密信息的泄露。另外，Referer的正确的拼写应该是Referrer，但不知为何，大家一直沿用这个错误的拼写。</p><h3 id="6-4-18-TE"><a href="#6-4-18-TE" class="headerlink" title="6.4.18  TE"></a>6.4.18  TE</h3><pre><code class="java">TE: gzip, deflate; q=0.5</code></pre><p>首部字段TE会告知服务器<strong>客户端能够处理响应的传输编码方式及相对优先级</strong>。它和首部字段Accept-Encoding的功能很相像，但是用于传输编码。首部字段TE除指定传输编码之外，还可以指定伴随trailer字段的分块传输编码的方式。应用后者时，只需把trailers赋值给该字段值。</p><pre><code class="java">TE: trailers</code></pre><h3 id="6-4-19-User-Agent"><a href="#6-4-19-User-Agent" class="headerlink" title="6.4.19 User-Agent"></a>6.4.19 User-Agent</h3><p><img src="https://img-blog.csdnimg.cn/9c97014dd1b746098862b8d504500882.png" alt="img"></p><pre><code class="java">User-Agent: Mozilla/5.0(Windows NT 6.1; WOW64; rv:13.0) Gecko/=&gt;20100101 Firefox/13.0.1</code></pre><p>首部字段User-Agent会将创建请求的浏览器和用户代理名称等信息传达给服务器。由网络爬虫发起请求时，有可能会在字段内添加爬虫作者的电子邮件地址。此外，如果请求经过代理，那么中间也很可能被添加上代理服务器的名称。</p><h2 id="6-5-响应首部字段"><a href="#6-5-响应首部字段" class="headerlink" title="6.5 响应首部字段"></a>6.5 响应首部字段</h2><p>响应首部字段是由<strong>服务器端向客户端返回响应报文中所使用的字段</strong>，用于<strong>补充响应的附加信息、服务器信息</strong>，以及对客户端的附加要求等信息。</p><h3 id="6-5-1-Accept-Ranges"><a href="#6-5-1-Accept-Ranges" class="headerlink" title="6.5.1 Accept-Ranges"></a>6.5.1 Accept-Ranges</h3><pre><code class="java">Accept-Ranges: bytes##当不能处理范围请求时Accept-Ranges: none</code></pre><p>首部字段Accept-Ranges是用来告知客户端服务器是否能处理范围请求，以指定获取服务器端某个部分的资源。可指定的字段值有两种，可处理范围请求时指定其为bytes，反之则指定其为none。</p><h3 id="6-5-2-Age"><a href="#6-5-2-Age" class="headerlink" title="6.5.2 Age"></a>6.5.2 Age</h3><p>首部字段Age能告知客户端，源服务器在多久前创建了响应。字段值的单位为秒。若创建该响应的服务器是缓存服务器，Age值是指缓存后的响应再次发起认证到认证完成的时间值。代理创建响应时必须加上首部字段Age。</p><pre><code class="java">Age: 600(秒)</code></pre><h3 id="6-5-3-ETag"><a href="#6-5-3-ETag" class="headerlink" title="6.5.3 ETag"></a>6.5.3 ETag</h3><p><img src="https://img-blog.csdnimg.cn/399cd3366831469ca8f12ffff9a88e10.png" alt="img"></p><pre><code class="java">ETage: &quot;82e22293907ce725fafa67773957acd12&quot;</code></pre><p>首部字段ETag能告知客户端实体标识。它是一种可将资源以字符串形式做唯一性标识的方式。服务器会为每份资源分配对应的ETag值。另外，当资源更新时，ETag值也需要更新。生成ETag值时，并没有统一的算法规则，而仅仅是由服务器来分配。</p><p><img src="https://img-blog.csdnimg.cn/57472e17404c47f89a4f111a2d1fb860.png" alt="img"></p><p>资源被缓存时，就会被分配唯一性标识。例如，当使用中文版的浏览器访问<a href="http://www.google.com/%E6%97%B6%EF%BC%8C%E5%B0%B1%E4%BC%9A%E8%BF%94%E5%9B%9E%E4%B8%AD%E6%96%87%E7%89%88%E5%AF%B9%E5%BA%94%E7%9A%84%E8%B5%84%E6%BA%90%EF%BC%8C%E8%80%8C%E4%BD%BF%E7%94%A8%E8%8B%B1%E6%96%87%E7%89%88%E7%9A%84%E6%B5%8F%E8%A7%88%E5%99%A8%E8%AE%BF%E9%97%AE%E6%97%B6%EF%BC%8C%E5%88%99%E4%BC%9A%E8%BF%94%E5%9B%9E%E8%8B%B1%E6%96%87%E7%89%88%E5%AF%B9%E5%BA%94%E7%9A%84%E8%B5%84%E6%BA%90%E3%80%82%E4%B8%A4%E8%80%85%E7%9A%84URI%E6%98%AF%E7%9B%B8%E5%90%8C%E7%9A%84%EF%BC%8C%E6%89%80%E4%BB%A5%E4%BB%85%E5%87%ADURI%E6%8C%87%E5%AE%9A%E7%BC%93%E5%AD%98%E7%9A%84%E8%B5%84%E6%BA%90%E6%98%AF%E7%9B%B8%E5%BD%93%E5%9B%B0%E9%9A%BE%E7%9A%84%E3%80%82%E8%8B%A5%E5%9C%A8%E4%B8%8B%E8%BD%BD%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%87%BA%E7%8E%B0%E8%BF%9E%E6%8E%A5%E4%B8%AD%E6%96%AD%E3%80%81%E5%86%8D%E8%BF%9E%E6%8E%A5%E7%9A%84%E6%83%85%E5%86%B5%EF%BC%8C%E9%83%BD%E4%BC%9A%E4%BE%9D%E7%85%A7ETag%E5%80%BC%E6%9D%A5%E6%8C%87%E5%AE%9A%E8%B5%84%E6%BA%90%E3%80%82">http://www.google.com/时，就会返回中文版对应的资源，而使用英文版的浏览器访问时，则会返回英文版对应的资源。两者的URI是相同的，所以仅凭URI指定缓存的资源是相当困难的。若在下载过程中出现连接中断、再连接的情况，都会依照ETag值来指定资源。</a><br><strong>强ETag值和弱Tag值</strong></p><ul><li><strong>强ETag值</strong>：强ETag值，不论实体发生多么细微的变化都会改变其值。</li></ul><pre><code class="java">ETage: &quot;usagi-1234&quot;</code></pre><ul><li><strong>弱Tag值</strong>：弱ETag值只用于提示资源是否相同。只有资源发生了根本改变，产生差异时才会改变ETag值。这时，会在字段值最开始处附加W&#x2F;。</li></ul><pre><code class="java">ETage: W/&quot;usagi-1234&quot;</code></pre><h3 id="6-5-4-Location"><a href="#6-5-4-Location" class="headerlink" title="6.5.4 Location"></a>6.5.4 Location</h3><p><img src="https://img-blog.csdnimg.cn/3ee2dcb614d3477a9dbcf257f74f49f0.png" alt="img"></p><pre><code class="java">Location: http://www.usagidesign.jp/sample.html</code></pre><p>使用首部字段Location可以将响应接收方引导至某个与请求URI位置不同的资源。基本上，该字段会配合3xx:Redirection的响应，提供重定向的URI。几乎所有的浏览器在接收到包含首部字段Location的响应后，都会强制性地尝试对已提示的重定向资源的访问。</p><h3 id="6-5-5-Proxy-Authenticate"><a href="#6-5-5-Proxy-Authenticate" class="headerlink" title="6.5.5 Proxy-Authenticate"></a>6.5.5 Proxy-Authenticate</h3><pre><code class="java">Proxy-Authenticate: Basic realm=&quot;Usagi design Auth&quot;</code></pre><p>它与客户端和服务器之间的HTTP访问认证的行为相似，不同之处在于其认证行为是在客户端与代理之间进行的。而客户端与服务器之间进行认证时，首部字段WWW-Authorization有着相同的作用。有关HTTP访问认证，后面的章节会再进行详尽阐述。<br>首部字段Proxy-Authenticate会把由代理服务器所要求的认证信息发送给客户端。</p><h3 id="6-5-6-Retry-After"><a href="#6-5-6-Retry-After" class="headerlink" title="6.5.6 Retry-After"></a>6.5.6 Retry-After</h3><p><img src="https://img-blog.csdnimg.cn/2e2bb38737af4113b73591fb7e1d4e58.png" alt="img"></p><pre><code class="java">Retry-After: 120(秒)</code></pre><p>首部字段Retry-After告知客户端应该在多久之后再次发送请求。主要配合状态码503 ServiceUnavailable响应，或3xx Redirect响应一起使用。字段值可以指定为具体的日期时间（Wed, 04 Jul2012 06:34:24 GMT等格式），也可以是创建响应后的秒数。</p><h3 id="6-5-7-Server"><a href="#6-5-7-Server" class="headerlink" title="6.5.7 Server"></a>6.5.7 Server</h3><p><img src="https://img-blog.csdnimg.cn/e0070c625fb540cdbd2e99e66b7c7dec.png" alt="img"></p><pre><code class="java">Server: Apache/2.2.17(Unix)</code></pre><p>首部字段Server告知客户端当前服务器上安装的HTTP服务器应用程序的信息。不单单会标出服务器上的软件应用名称，还有可能包括版本号和安装时启用的可选项。</p><pre><code class="java">Server: Apache/2.2.6(Unix) PHP/5.2.5</code></pre><h3 id="6-5-8-Vary"><a href="#6-5-8-Vary" class="headerlink" title="6.5.8 Vary"></a>6.5.8 Vary</h3><p><img src="https://img-blog.csdnimg.cn/19c1b6797fef413c924908fd97e052e2.png" alt="img"></p><p>当代理服务器接收到带有Vary首部字段指定获取资源的请求时，如果使用的Accept-Language字段的值相同，那么就直接从缓存返回响应。反之，则需要先从源服务器端获取资源后才能作为响应返回</p><pre><code class="java">Vary: Accept-Language</code></pre><p>首部字段Vary可对缓存进行控制。源服务器会向代理服务器传达关于本地缓存使用方法的命令。从代理服务器接收到源服务器返回包含Vary指定项的响应之后，若再要进行缓存，仅对请求中含有相同Vary指定首部字段的请求返回缓存。即使对相同资源发起请求，但由于Vary指定的首部字段不相同，因此必须要从源服务器重新获取资源。</p><h3 id="6-5-9-WWW-Authenticate"><a href="#6-5-9-WWW-Authenticate" class="headerlink" title="6.5.9 WWW-Authenticate"></a>6.5.9 WWW-Authenticate</h3><pre><code class="java">WWW-Authenticate: Basic realm=&quot;Usagide sign Auth&quot;</code></pre><p>首部字段WWW-Authenticate用于HTTP访问认证。它会告知客户端适用于访问请求URI所指定资源的认证方案（Basic或是Digest）和带参数提示的质询（challenge）。状态码401Unauthorized响应中，肯定带有首部字段WWW-Authenticate。</p><p>上述示例中，realm字段的字符串是为了辨别请求URI指定资源所受到的保护策略。有关该首部，请参阅本章之后的内容。</p><h2 id="6-6-实体首部字段"><a href="#6-6-实体首部字段" class="headerlink" title="6.6 实体首部字段"></a>6.6 实体首部字段</h2><p>实体首部字段是包含在请求报文和响应报文中的实体部分所使用的首部，用于补充内容的更新时间等与实体相关的信息。</p><h3 id="6-6-1-Allow"><a href="#6-6-1-Allow" class="headerlink" title="6.6.1 Allow"></a>6.6.1 Allow</h3><p><img src="https://img-blog.csdnimg.cn/e55b0694bbf940f886ad9b95ac7803e0.png" alt="img"></p><pre><code class="java">Allow: GET, HEAD</code></pre><p>首部字段Allow用于通知客户端能够支持Request-URI指定资源的所有HTTP方法。当服务器接收到不支持的HTTP方法时，会以状态码405 MethodNot Allowed作为响应返回。与此同时，还会把所有能支持的HTTP方法写入首部字段Allow后返回.</p><h3 id="6-6-2-Content-Encoding"><a href="#6-6-2-Content-Encoding" class="headerlink" title="6.6.2 Content-Encoding"></a>6.6.2 Content-Encoding</h3><pre><code class="java">Content-Encoding: gzip</code></pre><p>首部字段Content-Encoding会告知客户端服务器对实体的主体部分选用的内容编码方式。内容编码是指在不丢失实体信息的前提下所进行的压缩。主要采用以下4种内容编码的方式，gzip, compress, deflate, identity。（各方式的说明请参考6.4.3节Accept-Encoding首部字段）。</p><h3 id="6-6-3-Content-Language"><a href="#6-6-3-Content-Language" class="headerlink" title="6.6.3 Content-Language"></a>6.6.3 Content-Language</h3><pre><code class="java">Content-Language: zh-CN</code></pre><p>首部字段Content-Language会告知客户端，实体主体使用的自然语言（指中文或英文等语言）。</p><h3 id="6-6-4-Content-Length"><a href="#6-6-4-Content-Length" class="headerlink" title="6.6.4 Content-Length"></a>6.6.4 Content-Length</h3><pre><code class="java">Content-Length: 15000</code></pre><p>首部字段Content-Length表明了实体主体部分的大小（<strong>单位是字节</strong>）。对实体主体进行内容编码传输时，不能再使用Content-Length首部字段。由于实体主体大小的计算方法略微复杂，所以在此不再展开。读者若想一探究竟，可参考RFC2616的4.4。</p><h4 id="6-6-5-Content-Location"><a href="#6-6-5-Content-Location" class="headerlink" title="6.6.5 Content-Location"></a>6.6.5 Content-Location</h4><pre><code class="java">Content-Location: http://www.hackr.jp/index-ja.html</code></pre><p>首部字段Content-Location给出与报文主体部分相对应的URI。和首部字段Location不同，Content-Location表示的是报文主体返回资源对应的URI。比如，对于使用首部字段Accept-Language的服务器驱动型请求，当返回的页面内容与实际请求的对象不同时，首部字段Content-Location内会写明URI。（访问<a href="http://www.hackr.jp/%E8%BF%94%E5%9B%9E%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%8D%B4%E6%98%AFhttp://www.hackr.jp/index-ja.html%E7%AD%89%E7%B1%BB%E4%BC%BC%E6%83%85%E5%86%B5%EF%BC%89">http://www.hackr.jp/返回的对象却是http://www.hackr.jp/index-ja.html等类似情况）</a></p><h3 id="6-6-6-Content-MD5"><a href="#6-6-6-Content-MD5" class="headerlink" title="6.6.6 Content-MD5"></a>6.6.6 Content-MD5</h3><p><img src="https://img-blog.csdnimg.cn/bf4b48af144d43d59815496d3ecae7e5.png" alt="img"></p><p>客户端会对接收的报文主体执行相同的MD5算法，然后与首部字段Content-MD5的字段值比较</p><pre><code class="java">Content-MD5: 0GFkZDUwNGVhNGY3N2MxMDIwZmQ4NTBmY2IyTY==</code></pre><p>首部字段Content-MD5是一串由MD5算法生成的值，其目的在于检查报文主体在传输过程中是否保持完整，以及确认传输到达。</p><p>对报文主体执行MD5算法获得的128位二进制数，再通过Base64编码后将结果写入Content-MD5字段值。由于HTTP首部无法记录二进制值，所以要通过Base64编码处理。为确保报文的有效性，作为接收方的客户端会对报文主体再执行一次相同的MD5算法。计算出的值与字段值作比较后，即可判断出报文主体的准确性。</p><p>采用这种方法，对内容上的偶发性改变是无从查证的，也无法检测出恶意篡改。其中一个原因在于，内容如果能够被篡改，那么同时意味着Content-MD5也可重新计算然后被篡改。所以处在接收阶段的客户端是无法意识到报文主体以及首部字段Content-MD5是已经被篡改过的。</p><h3 id="6-6-7-Content-Range"><a href="#6-6-7-Content-Range" class="headerlink" title="6.6.7 Content-Range"></a>6.6.7 Content-Range</h3><p><img src="https://img-blog.csdnimg.cn/b25f34d185104f1cbf6a9486f528218c.png" alt="img"></p><pre><code class="java">Content-Range: bytes 5001-10000/10000</code></pre><p>针对范围请求，返回响应时使用的首部字段Content-Range，能告知客户端作为响应返回的实体的哪个部分符合范围请求。字段值以字节为单位，表示当前发送部分及整个实体大小。</p><h3 id="6-6-8-Content-Type"><a href="#6-6-8-Content-Type" class="headerlink" title="6.6.8 Content-Type"></a>6.6.8 Content-Type</h3><pre><code class="java">Content-Type: text/html; charset=UTF-8</code></pre><p>首部字段Content-Type说明了实体主体内对象的媒体类型。和首部字段Accept一样，字段值用type&#x2F;subtype形式赋值。参数charset使用iso-8859-1或euc-jp等字符集进行赋值。</p><h3 id="6-6-9-Expires"><a href="#6-6-9-Expires" class="headerlink" title="6.6.9 Expires"></a>6.6.9 Expires</h3><p><img src="https://img-blog.csdnimg.cn/dc07ee72aab8494aa5a3ca1b174d8cd7.png" alt="img"></p><pre><code class="java">Expires: Wed, 04 Jul 2012 08:26:05 GMT</code></pre><p>首部字段Expires会将资源失效的日期告知客户端。缓存服务器在接收到含有首部字段Expires的响应后，会以缓存来应答请求，在Expires字段值指定的时间之前，响应的副本会一直被保存。当超过指定的时间后，缓存服务器在请求发送过来时，会转向源服务器请求资源。源服务器不希望缓存服务器对资源缓存时，最好在Expires字段内写入与首部字段Date相同的时间值。但是，当首部字段Cache-Control有指定max-age指令时，比起首部字段Expires，会优先处理max-age指令。</p><h3 id="6-6-10-Last-Modified"><a href="#6-6-10-Last-Modified" class="headerlink" title="6.6.10 Last-Modified"></a>6.6.10 Last-Modified</h3><p><img src="https://img-blog.csdnimg.cn/64ee4389538c4384917b55f17a8eea86.png" alt="img"></p><pre><code class="java">Last-Modified: Wed, 04 Jul 2012 08:26:05 GMT</code></pre><p>首部字段Last-Modified指明资源最终修改的时间。一般来说，这个值就是Request-URI指定资源被修改的时间。但类似使用CGI脚本进行动态数据处理时，该值有可能会变成数据最终修改时的时间。</p><h2 id="6-7-为Cookie服务的首部字段"><a href="#6-7-为Cookie服务的首部字段" class="headerlink" title="6.7 为Cookie服务的首部字段"></a>6.7 为Cookie服务的首部字段</h2><p>管理服务器与客户端之间状态的Cookie，虽然没有被编入标准化HTTP&#x2F;1.1的RFC2616中，但在Web网站方面得到了广泛的应用。</p><p>Cookie的工作机制是用户识别及状态管理。Web网站为了管理用户的状态会通过Web浏览器，把一些数据临时写入用户的计算机内。接着当用户访问该Web网站时，可通过通信方式取回之前存放的Cookie。</p><p>调用Cookie时，由于可校验Cookie的有效期，以及发送方的域、路径、协议等信息，所以正规发布的Cookie内的数据不会因来自其他Web站点和攻击者的攻击而泄露。</p><p>至2013年5月，Cookie的规格标准文档有以下4种。</p><ul><li><p><strong>由网景公司颁布的规格标准</strong>：网景通信公司设计并开发了Cookie，并制定相关的规格标准。1994年前后，Cookie正式应用在网景浏览器中。目前最为普及的Cookie方式也是以此为基准的。</p></li><li><p><strong>RFC2109</strong>：某企业尝试以独立技术对Cookie规格进行标准化统筹。原本的意图是想和网景公司制定的标准交互应用，可惜发生了微妙的差异。现在该标准已淡出了人们的视线。</p></li><li><p><strong>RFC2965</strong>：为终结Internet Explorer浏览器与NetscapeNavigator的标准差异而导致的浏览器战争，RFC2965内定义了新的HTTP首部Set-Cookie2和Cookie2。可事实上，它们几乎没怎么投入使用。</p></li><li><p><strong>RFC6265</strong>：将网景公司制定的标准作为业界事实标准（De facto standard），重新定义Cookie标准后的产物。</p></li></ul><p>目前使用最广泛的Cookie标准却不是RFC中定义的任何一个。而是<strong>在网景公司制定的标准上进行扩展后的产物</strong>。</p><p><strong>为Cookie服务的首部字段</strong></p><p><img src="https://img-blog.csdnimg.cn/9d6d614223954ce599fc8646ae53529a.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/0cf5a98952654a2fbbaaef1d997ed6e1.png" alt="img"></p><pre><code class="java">Set-Cookie: status=enable; expires= Tue, 05 Jul 2011 07:26:21 GMT; =&gt;path=/; domain=.hackr.jp;</code></pre><p>当服务器准备开始管理客户端的状态时，会事先告知各种信息。</p><p><strong>Set-Cookie字段的属性</strong></p><p><img src="https://img-blog.csdnimg.cn/f0d6995100dc4c0d96dfb80541b297aa.png" alt="img"></p><ul><li><p>expires属性：Cookie的expires属性指定浏览器可发送Cookie的有效期。当省略expires属性时，其有效期仅限于维持浏览器会话（Session）时间段内。这通常限于浏览器应用程序被关闭之前。另外，一旦Cookie从服务器端发送至客户端，服务器端就不存在可以显式删除Cookie的方法。但可通过覆盖已过期的Cookie，实现对客户端Cookie的实质性删除操作。</p></li><li><p><strong>path属性</strong>：Cookie的path属性可用于限制指定Cookie的发送范围的文件目录。不过另有办法可避开这项限制，看来对其作为安全机制的效果不能抱有期待。</p></li><li><p>domain属性：通过Cookie的domain属性指定的域名可做到与结尾匹配一致。比如，当指定example.com后，除example.com以外，<a href="http://www.example.com或www2.example.com等都可以发送cookie.因此,除了针对具体指定的多个域名发送cookie之外,不指定domain属性显得更安全./">www.example.com或www2.example.com等都可以发送Cookie。因此，除了针对具体指定的多个域名发送Cookie之外，不指定domain属性显得更安全。</a></p></li><li><p><strong>secure属性</strong>：Cookie的secure属性用于限制Web页面<strong>仅在HTTPS安全连接时，才可以发送Cookie</strong>。发送Cookie时，指定secure属性的方法如下所示。</p></li></ul><pre><code class="java">Set-Cookie: name=value;secure</code></pre><p>以上例子仅当在<a href="https://www.example.com/%EF%BC%88HTTPS%EF%BC%89%E5%AE%89%E5%85%A8%E8%BF%9E%E6%8E%A5%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E6%89%8D%E4%BC%9A%E8%BF%9B%E8%A1%8CCookie%E7%9A%84%E5%9B%9E%E6%94%B6%E3%80%82%E4%B9%9F%E5%B0%B1%E6%98%AF%E8%AF%B4%EF%BC%8C%E5%8D%B3%E4%BD%BF%E5%9F%9F%E5%90%8D%E7%9B%B8%E5%90%8C%EF%BC%8Chttp://www.example.com/%EF%BC%88HTTP%EF%BC%89%E4%B9%9F%E4%B8%8D%E4%BC%9A%E5%8F%91%E7%94%9FCookie%E5%9B%9E%E6%94%B6%E8%A1%8C%E4%B8%BA%E3%80%82%E5%BD%93%E7%9C%81%E7%95%A5secure%E5%B1%9E%E6%80%A7%E6%97%B6%EF%BC%8C%E4%B8%8D%E8%AE%BAHTTP%E8%BF%98%E6%98%AFHTTPS%EF%BC%8C%E9%83%BD%E4%BC%9A%E5%AF%B9Cookie%E8%BF%9B%E8%A1%8C%E5%9B%9E%E6%94%B6%E3%80%82">https://www.example.com/（HTTPS）安全连接的情况下才会进行Cookie的回收。也就是说，即使域名相同，http://www.example.com/（HTTP）也不会发生Cookie回收行为。当省略secure属性时，不论HTTP还是HTTPS，都会对Cookie进行回收。</a></p><ul><li>HttpOnly属性：Cookie的HttpOnly属性是Cookie的扩展功能，它使JavaScript脚本无法获得Cookie。其主要目的为防止跨站脚本攻击（Cross-site scripting,XSS）对Cookie的信息窃取。发送指定HttpOnly属性的Cookie的方法如下所示。</li></ul><pre><code class="java">Set-Cookie: name=value;HttpOnly</code></pre><p>通过上述设置，通常从Web页面内还可以对Cookie进行读取操作。但使用JavaScript的document.cookie就无法读取附加HttpOnly属性后的Cookie的内容了。因此，也就无法在XSS中利用JavaScript劫持Cookie了。虽然是独立的扩展功能，但Internet Explorer 6SP1以上版本等当下的主流浏览器都已经支持该扩展了。另外顺带一提，该扩展并非是为了防止XSS而开发的。</p><h3 id="6-7-2-Cookie"><a href="#6-7-2-Cookie" class="headerlink" title="6.7.2 Cookie"></a>6.7.2 Cookie</h3><pre><code class="java">Cookie: status=enable</code></pre><p>首部字段Cookie会告知服务器，当客户端想获得HTTP状态管理支持时，就会在请求中包含从服务器接收到的Cookie。接收到多个Cookie时，同样可以以多个Cookie形式发送。</p><h2 id="6-8-其他首部字段"><a href="#6-8-其他首部字段" class="headerlink" title="6.8 其他首部字段"></a>6.8 其他首部字段</h2><p>HTTP首部字段是可以自行扩展的。所以在Web服务器和浏览器的应用上，会出现各种非标准的首部字段。接下来，我们就一些最为常用的首部字段进行说明。<strong>X-Frame-Options、X-XSS-Protection、DNT、P3P</strong></p><h3 id="6-8-1-X-Frame-Options"><a href="#6-8-1-X-Frame-Options" class="headerlink" title="6.8.1 X-Frame-Options"></a>6.8.1 X-Frame-Options</h3><pre><code class="java">X-Frame-Options: DENY</code></pre><p>首部字段X-Frame-Options属于HTTP响应首部，用于控制网站内容在其他Web网站的Frame标签内的显示问题。其主要目的是为了防止点击劫持（clickjacking）攻击。</p><p>首部字段X-Frame-Options有以下两个可指定的字段值。DENY：拒绝。SAMEORIGIN：仅同源域名下的页面（Top-level-browsing-context）匹配时许可。（比如，当指定<a href="http://hackr.jp/sample.html%E9%A1%B5%E9%9D%A2%E4%B8%BASAMEORIGIN%E6%97%B6%EF%BC%8C%E9%82%A3%E4%B9%88hackr.jp%E4%B8%8A%E6%89%80%E6%9C%89%E9%A1%B5%E9%9D%A2%E7%9A%84frame%E9%83%BD%E8%A2%AB%E5%85%81%E8%AE%B8%E5%8F%AF%E5%8A%A0%E8%BD%BD%E8%AF%A5%E9%A1%B5%E9%9D%A2%EF%BC%8C%E8%80%8Cexample.com%E7%AD%89%E5%85%B6%E4%BB%96%E5%9F%9F%E5%90%8D%E7%9A%84%E9%A1%B5%E9%9D%A2%E5%B0%B1%E4%B8%8D%E8%A1%8C%E4%BA%86%EF%BC%89">http://hackr.jp/sample.html页面为SAMEORIGIN时，那么hackr.jp上所有页面的frame都被允许可加载该页面，而example.com等其他域名的页面就不行了）</a></p><p>支持该首部字段的浏览器有：Internet Explorer8、Firefox 3.6.9+、Chrome 4.1.249.1042+、Safari 4+和Opera 10.50+ 等。现在主流的浏览器都已经支持。能在所有的Web服务器端预先设定好X-Frame-Options字段值是最理想的状态。</p><h3 id="6-8-2X-XSS-Protection"><a href="#6-8-2X-XSS-Protection" class="headerlink" title="6.8.2X-XSS-Protection"></a>6.8.2<strong>X-XSS-Protection</strong></h3><pre><code class="java">X-XSS-Protection: 1</code></pre><p>首部字段X-XSS-Protection属于HTTP响应首部，它是针对跨站脚本攻击（XSS）的一种对策，用于<strong>控制浏览器XSS防护机制的开关</strong>。</p><p>首部字段X-XSS-Protection可指定的字段值如下。</p><ul><li><p>0 ：将XSS过滤设置成无效状态</p></li><li><p>1 ：将XSS过滤设置成有效状态</p></li></ul><h3 id="6-8-3-DNT"><a href="#6-8-3-DNT" class="headerlink" title="6.8.3 DNT"></a>6.8.3 DNT</h3><pre><code class="java">DNT: 1</code></pre><p><img src="https://img-blog.csdnimg.cn/c64ebb48a1e44daa8d7224d0d6528f19.png" alt="img"></p><p>首部字段DNT属于HTTP请求首部，其中DNT是Do Not Track的简称，意为<strong>拒绝个人信息被收集</strong>，是表示拒绝被精准广告追踪的一种方法。首部字段DNT属于HTTP请求首部，其中DNT是Do Not Track的简称，意为<strong>拒绝个人信息被收集</strong>，是表示拒绝被精准广告追踪的一种方法。</p><p>首部字段DNT可指定的字段值如下。</p><ul><li><p>0 ：同意被追踪</p></li><li><p>1 : 拒绝被追踪</p></li></ul><p>由于首部字段DNT的功能具备有效性，所以Web服务器需要对DNT做对应的支持。</p><h3 id="6-8-4-P3P"><a href="#6-8-4-P3P" class="headerlink" title="6.8.4 P3P"></a>6.8.4 P3P</h3><pre><code class="java">P3P: CP=&quot;CAO DSP LAW CURa ADMa DEVa TAIa PSAa PSDa =&gt; IVAa IVDa OUR BUS IND UNI COM NAV INT&quot;</code></pre><p>首部字段P3P属于HTTP响应首部，通过利用<strong>P3P（The Platform for Privacy Preferences，在线隐私偏好平台）</strong>技术，可以让Web网站上的个人隐私变成一种仅供程序可理解的形式，以达到保护用户隐私的目的。</p><p>要进行P3P的设定，需按以下操作步骤进行。<br><strong>步骤1</strong>： 创建P3P隐私<br><strong>步骤2</strong>： 创建P3P隐私对照文件后，保存命名在&#x2F;w3c&#x2F;p3p.xml<br><strong>步骤3</strong>： 从P3P隐私中新建Compact policies后，输出到HTTP响应中</p><p>有关P3P的详细规范标准请参看下方链接。●The Platform for Privacy Preferences 1.0（P3P1.0）Specification<a href="http://www.w3.org/TR/P3P/">http://www.w3.org/TR/P3P/</a></p><p>Tips：（协议中对X-前缀的废除）在HTTP等多种协议中，通过给非标准参数加上前缀X-，来区别于标准参数，并使那些非标准的参数作为扩展变成可能。但是这种简单粗暴的做法有百害而无一益，因此在“RFC6648- Deprecating the “X-” Prefix andSimilar Constructs in ApplicationProtocols”中提议停止该做法。然而，对已经在使用中的X-前缀来说，不应该要求其变更。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> http </tag>
            
            <tag> tcp/ip </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java并发编程</title>
      <link href="/2022/05/06/java-bing-fa-bian-cheng-shi-zhan/"/>
      <url>/2022/05/06/java-bing-fa-bian-cheng-shi-zhan/</url>
      
        <content type="html"><![CDATA[<h1 id="第一部分-基础知识"><a href="#第一部分-基础知识" class="headerlink" title="第一部分:基础知识"></a>第一部分:基础知识</h1><h2 id="第一章-线程安全性"><a href="#第一章-线程安全性" class="headerlink" title="第一章:线程安全性"></a>第一章:线程安全性</h2><p>要编写出线程安全的代码, 其核心在于对状态访问操作进行管理, 特别是对**共享的(shared)<strong>和</strong>可变的(mutable)**状态的访问.</p><ul><li><p><strong>共享</strong>意味着变量可以由多个线程同时访问</p></li><li><p><strong>可变</strong>则意味着变量的值在其生命周期内可以发生变化.</p></li></ul><p>一个对象是否需要线程安全, 取决于它是否会被多个线程访问. 要使得对象是线程安全的, 需要采用<strong>同步机制</strong>来协同对对象可变状态的访问.</p><p>java的同步机制包括: synchronized关键字, volatile类型的变量, 显示锁(Explicit Lock)和原子变量.</p><h3 id="1-1什么是线程安全性"><a href="#1-1什么是线程安全性" class="headerlink" title="1.1什么是线程安全性:"></a>1.1什么是线程安全性:</h3><p>​当多个线程访问某个类时, 这个类始终都能表现出正确的行为, 那么就称这个类是线程安全的.</p><p>看一个简单实例, 一个无状态的servlet:</p><pre><code class="java">public class StatelessFactorizer extends GenericServlet implements Servlet &#123;    public void service(ServletRequest request, ServletResponse response)&#123;        BigInteger i=extractFromRequest(request);        BigInteger[]factors=factor(i);        encodeIntoResponse(response, factors);    &#125;    private void encodeIntoResponse(ServletResponse response, BigInteger[] factors) &#123;    &#125;    private BigInteger[] factor(BigInteger i) &#123;        return new BigInteger[]&#123;i&#125;;    &#125;    private BigInteger extractFromRequest(ServletRequest request) &#123;        return new BigInteger(&quot;7&quot;);    &#125;   ......&#125;</code></pre><p>与多数Servlet相同，StatelessFactorizer是无状态的。访问StatelessFactorizer的线程不会影响另一个访问同一个StatelessFactorizer的线程的计算结果，因为这两个线程并没有共享状态，就好像它们在访问不同的实例。</p><p><strong>有状态就是有数据存储功能。有状态对象(Stateful Bean)，就是有实例变量的对象 ，可以保存数据，是非线程安全的。在不同方法调用间不保留任何状态。</strong></p><p><strong>无状态就是一次操作，不能保存数据。无状态对象(Stateless Bean)，就是没有实例变量的对象 .不能保存数据，是不变类，是线程安全的。</strong></p><hr><h3 id="1-2原子性-Atomicity"><a href="#1-2原子性-Atomicity" class="headerlink" title="1.2原子性(Atomicity)"></a>1.2原子性(Atomicity)</h3><p>原子性的意思代表着——<em><strong>不可分割</strong></em>；</p><p>看下一个例子UnsafeCountingFactorizer:</p><pre><code class="java">//       2-2    在没有同步的情况下统计已处理请求数量的Servlet（不要这么做）@NotThreadSafe //注解public class UnsafeCountingFactorizer implements Servlet &#123;    private long count = 0;    public long getCount() &#123;        return count;    &#125;    public void service(ServletRequest req, ServletResponse resp) &#123;        BigInteger i = extractFromRequest(req);        BigInteger[] factors = factor(i);        ++count;        encodeIntoResponse(resp, factors);    &#125;</code></pre><p>UnsafeCountingFactorizer并非是线程安全的，尽管它在单线程环境中能正确运行。++count看起来是一个操作，但这个操作并非原子性的，因为它可以被分成三个独立的步骤:<br>①读取count的值<br>②值加一<br>③将计算结果写入count<br>这是一个”读取-修改-写入”的操作序列，并且结果状态依赖于之前的状态。下图给出了两个线程在没有同步的情况下对同一个计数器执行递增操作发生的情况。</p><p>下图给出了两个线程在没有同步的情况下对同一个计数器执行递增操作发生的情况。</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/20170801174753900" alt="这里写图片描述"></p><p>在一些特定的场景下这是致命的.</p><h3 id="1-3-竞态条件-race-condition"><a href="#1-3-竞态条件-race-condition" class="headerlink" title="1.3 竞态条件(race condition)"></a>1.3 竞态条件(race condition)</h3><p>是指设备或系统出现不恰当的执行时序，而得到不正确的结果。</p><p>最常见的竞态条件类型就是”先检查后执行(Check-Then-Act)”操作，这有可能通过一个可能失效的观测结果来决定下一步的动作.</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/20170801175517750" alt="这里写图片描述"></p><p>例如:首先观测到某个条件为真(假如文件X不存在)，然后根据这个结果采用相应的动作(创建文件X)，但事实上，在你观察到这个结果以及开始创建文件之间，观测结果可能变得无效(另一个线程在这期间创建了文件X)，从而导致各种问题(未预期的异常，数据被覆盖，文件被破坏等)。</p><p>“先检查后执行”的一种常见情况就是延迟初始化，其目的是将对象的初始化操作推迟到实际被使用时才进行，同时要确保只被初始化一次。下面是LazyInitRace示例：</p><pre><code class="java">//             2-3          延迟初始化中的竞态条件（不要这么做）@NotThreadSafepublic class LazyInitRace &#123;    private ExpensiveObject instance = null;    public ExpensiveObject getInstance() &#123;        if (instance == null)            instance = new ExpensiveObject();        return instance;    &#125;&#125;class ExpensiveObject &#123; &#125;</code></pre><h3 id="1-4-复合操作-Compound-Actions"><a href="#1-4-复合操作-Compound-Actions" class="headerlink" title="1.4 复合操作(Compound Actions)"></a>1.4 复合操作(Compound Actions)</h3><p>要避免竞态条件问题，就必须在某个线程修改该变量时，通过某中方式防止其他线程使用这个变量，从而确保其他线程只能在修改完成之前或之后读取和修改状态，而不是在修改状态的过程中。</p><p>假定有操作A和B，如果对于执行A的线程来说，当另一个线程执行B时，要么全部执行完，要不完全不执行，那么A和B对彼此来说就是原子性的。</p><p>我们将”先检查后执行”以及”读取-修改-写入”等操作称为复合操作:包含了一组必须以原子方式执行的操作以确保线程安全性。</p><p>我们现在使用一个现有的线程安全类来修复这个问题，如下面的CountingFactorizer:</p><pre><code class="java">//      2-4     使用AtomicLong类型的变量来统计已处理请求的数量@ThreadSafepublic class CountingFactorizer extends GenericServlet implements Servlet &#123;    private final AtomicLong count = new AtomicLong(0);   //final修饰的类不能被继承    public long getCount() &#123; return count.get(); &#125;    public void service(ServletRequest req, ServletResponse resp) &#123;        BigInteger i = extractFromRequest(req);        BigInteger[] factors = factor(i);        count.incrementAndGet();   //使用atomic中的方法        encodeIntoResponse(resp, factors);    &#125;    void encodeIntoResponse(ServletResponse res, BigInteger[] factors) &#123;&#125;    BigInteger extractFromRequest(ServletRequest req) &#123;return null; &#125;    BigInteger[] factor(BigInteger i) &#123; return null; &#125;&#125;</code></pre><p>在java.util.concurrent.atomic包中包含了一些原子变量类，用于实现在数值和对象引用上的原子状态转换。通过用AtomicLong来代替long类型的计时器，能够确保所有对计数器状态的访问操作都是原子的。因为计数器是线程安全的，所以这里的Servlet也是线程安全的。<br><em><strong>原子操作( atomic operations)</strong></em><br>原子操作指的是在一步之内就完成而且不能被中断。</p><p>为什么long型赋值不是原子操作呢？<br>例如：<br>long foo &#x3D; 65465498L;<br>实时上java会分两步写入这个long变量，先写前32位，再写后32位。这样就线程不安全了。</p><p>当在无状态的类中添加一个状态时，如果该状态完全由线程安全的对象来管理，那这个类仍是线程安全的。</p><p>在实际情况中，应尽可能使用现有的线程安全对象(例如AtomicLong)来管理类的状态，与非线程安全的对象相比，判断线程安全对象的可能状态及其状态转换情况要更加容易，从而更容易维护和验证线程安全性。</p><h3 id="1-5-加锁机制"><a href="#1-5-加锁机制" class="headerlink" title="1.5 加锁机制"></a>1.5 加锁机制</h3><p>当在无状态的类中添加一个状态时，可以用线程安全你的对象来管理类的状态以维护类的安全性，但是如果假如更多状态时，就不能一味得添加更多线程安全状态变量。</p><p>假如我们希望提升性能，将最近的计算结果缓存起来，当两个连续的请求对相同的数值进行因数分解时，可以直接使用上一次的计算结果。要实现该缓存策略，需要保存两个状态：最近执行过因数分解的数值，以及结果。</p><p>我们尝试用添加线程安全状态变量来完成这件事，UnsafeCachingFactorizer的代码为:</p><pre><code class="java">//    2-5  该Servlet在没有足够原子性保证的情况下对最近计算结果进行缓存（不要这么做）@NotThreadSafepublic class UnsafeCachingFactorizer extends GenericServlet implements Servlet &#123;    //AtomicReference是作用是对&quot;对象&quot;进行原子操作    private final AtomicReference&lt;BigInteger&gt; lastNumber            = new AtomicReference&lt;BigInteger&gt;();    private final AtomicReference&lt;BigInteger[]&gt; lastFactors            = new AtomicReference&lt;BigInteger[]&gt;();    public void service(ServletRequest req, ServletResponse resp) &#123;        BigInteger i = extractFromRequest(req);        if (i.equals(lastNumber.get()))            encodeIntoResponse(resp, lastFactors.get());        else &#123;            BigInteger[] factors = factor(i);            lastNumber.set(i);            lastFactors.set(factors);            encodeIntoResponse(resp, factors);        &#125;    &#125;    void encodeIntoResponse(ServletResponse resp, BigInteger[] factors) &#123;//保存执行过因数分解的数值及其结果    &#125;    BigInteger extractFromRequest(ServletRequest req) &#123;          return new BigInteger(&quot;7&quot;);    &#125;    BigInteger[] factor(BigInteger i) &#123;        return new BigInteger[]&#123;i&#125;;    &#125;&#125;</code></pre><p>然而，尽管这些原子引用本身各自都是线程安全的，但在UnsafeCachingFactorizer中存在着竞态条件，这可能导致错误。</p><p>在线程安全性的定义中要求，多个线程之间的操作无论采用何种执行顺序或交替方式，都要保证不变性条件不被破坏。UnsafeCachingFactorizer的不变性条件之一是:在lastFactors中缓存的因数之积应该等于在lastNumber中缓存的数值。只有确保了这个不变性条件不被破坏，上面的Servlet才是正确的。当在不变性条件中涉及多个变量时，各个变量之间并不是彼此独立的，而是某个变量的值会对其他变量的值产生约束。因此，在更新某一个变量时，需要在同一个原子操作中队其他变量同时进行更新。</p><p>在使用AtomicReference的情况下，尽管对set方法的每次调用都是原子de，但仍然无法同时更新lastNumber和lastFactors。如果只修改了其中一个变量，那么在这两次修改操作之间，其他线程将发现不变性条件被破环了。同样，我们也不能确保会同时获取两个值:线程A获取这两个值得过程中，线程B可能修改了它们，这样线程A也会发现不变性条件被破坏了。<br><em><strong>要保持状态的一致性，就需要在单个原子操作中更新所有相关的状态变量</strong></em></p><h3 id="1-6-内置锁"><a href="#1-6-内置锁" class="headerlink" title="1.6 内置锁"></a>1.6 内置锁</h3><p>Java提供一种内置的锁机制来支持原子性:同步代码块(Synchronized Block).同步代码块包括两部分:一<strong>个作为锁的对象引用</strong>，<strong>一个作为这个锁保护的代码块。</strong>以关键字synchronized(同步的)来修饰的方法就是一种横跨整个方法体的同步代码块，其中该同步代码块的锁就是方法调用所在的对象。静态的synchronized方法以Class对象作为锁。<br>synchronized(lock){<br>&#x2F;&#x2F;访问或修改由锁保护的共享状态<br>}<br>每个Java对象都可以用做一个实现同步的锁， 这些锁被称为内置锁(Intrinsic Lock)或者监视锁(Monitor Lock)。</p><p>线程在进入代码块之前会自动获得锁，并且在退出同步代码块时自动释放锁,无论是通过正常路径退出<strong>还是通过从代码块中抛出异常退出。</strong>获得内置锁的唯一路径就是进入由这个锁保护的同步代码块或方法。</p><p>Java的内置锁相当于一种<strong>互斥体(或互斥锁)，</strong>这意味这最多只有一个线程能持有这种锁。如果线程A尝试获取一个由线程B持有的锁时，线程A必须<strong>等待或者阻塞</strong>，知道B释放这个锁。如果B一直不释放这个锁，那么A将<strong>一直等待。</strong></p><p>由于每次只能有一个线程执行内置锁保护的代码块，因此，由这个锁保护的同步代码块会以原子方式执行，多个线程在执行该代码块也不会相互干扰。</p><p>并发环境中的原子性与事务应用程序中的原子性有着相同的含义——<strong>一组语句作为不可分割的单元被执行。</strong></p><p>下面我们使用synchronized关键字来改进：</p><pre><code class="java">//   2-6    这个Servlet能正确缓存最新的计算结果，但并发性却非常糟糕(不要这么做)@ThreadSafepublic class SynchronizedFactorizer extends GenericServlet implements Servlet &#123;    @GuardedBy(&quot;this&quot;) private BigInteger lastNumber;    @GuardedBy(&quot;this&quot;) private BigInteger[] lastFactors;    public synchronized void service(ServletRequest req,                                     ServletResponse resp) &#123;        BigInteger i = extractFromRequest(req);        if (i.equals(lastNumber))            encodeIntoResponse(resp, lastFactors);        else &#123;            BigInteger[] factors = factor(i);            lastNumber = i;            lastFactors = factors;            encodeIntoResponse(resp, factors);        &#125;    &#125;&#125;</code></pre><p>尽管SynchronizedFactorizer是线程安全，然而这种方法却过于极端，因为多个客户端无法同时使用因数分解Servlet，服务的响应性非常低。</p><h3 id="1-7-重入"><a href="#1-7-重入" class="headerlink" title="1.7 重入"></a>1.7 重入</h3><p>内置锁是可重入的，如果某个线程试图获得一个已经由它持有的锁，那么这个请求就会成功。”重入“获取锁操作的<strong>基本单位是“线程”而不是”调用“。</strong>重入的一种实现方法是，为每个锁关联一个获取计数值和一个所有者线程。当计数值为0时，这个锁就被认为是没有被任何线程持有。当线程请求一个未被持有的锁时，JVM将记下锁的持有者，并将获取值设置为1，如果同一线程再次获取这个锁，计数值递增，而当线程退出同步代码块时，计数器会相应地递减，当计数值为0时，这个锁将被释放。</p><p>”重入“进一步替身了加锁行为的封装性(encapsulation),因此简化了面向对象(Object-Oriented)并发代码的开发。</p><p>在以下代码中，子类改写了synchronized修饰的方法，然后调用父类中方法，如果没有可重入的时，这段代码将产生死锁。由于子类和父类的doSomething方法都是synchronized方法，因此每个doSomething方法在执行前都会获取Widget上的锁。如果内置锁是不可重入，那么在调用super.doSomething时将无法获得Widget上的锁，因为这个锁已经被持有，从而线程将永远停顿下去。重入避免了这种死锁情况的发生。</p><pre><code class="java">//        2-7    如果内置锁不是可重入的，这段代码将发生死锁public class Widget &#123;    public synchronized void doSomething() &#123;...    &#125;&#125;public class LoggingWidget extends Widget &#123;    public synchronized void doSomething() &#123;         System.out.println(toString() + &quot;: calling doSomething&quot;);         super.doSomething();    &#125;&#125;</code></pre><h3 id="1-8-用锁来保护状态"><a href="#1-8-用锁来保护状态" class="headerlink" title="1.8 用锁来保护状态"></a>1.8 用锁来保护状态</h3><p>锁能以<strong>串行</strong>形式访问其保护的代码路径，因此可以通过锁来构造一些协议以实现对共享状态的独占访问。只要始终遵守这些协议，就能确保状态的一致性。</p><p>对于可能被多个线程同时访问的可变状态变量，在访问它时都需要持有同一个锁，在这种情况下，我们成状态变量是由这个锁保护的。</p><p>上面的SynchronizedFactorizer(实现了Servlet接口)中，lastNumber和lastFactors这两个变量都是由Servlet对象的内置锁来保护的。</p><p>对象的内置锁与其状态之间没有内在的关联。虽然大多数类都将内置锁用做一种有效的加锁机制，对对象的域并一定要通过内置锁来保护。当获取与对象关联的锁时，并不能阻止其他线程访问该对象。某个线程在获得对象的锁之后，只能阻止其他线程获得同一个锁。之所以每个对象都有一个内置锁，是为了免去显式地创建锁对象。需自行构造加锁协议或同步策略来实现对共享状态的安全访问，并且在程序中一直使用它们。</p><p><strong>每个共享和可变的变量都应该只由一个锁来保护，从而使维护人员知道是哪一个锁。</strong></p><p>一种常见的加锁约定是，将所有的可变状态都封装在对象内部，并通过对象的内置锁对所有访问可变状态的代码路径进行同步，使得对该对象不会发生并发访问<strong>。例如Vector和其他的同步集合类都使用了这种模式。</strong>在这种情况下，对象状态中的所有变量都由对象的内置锁保护起来。如果在添加新的方法或代码路径时忘记使用同步，那么这种加锁协议就很容易被破坏。</p><p>只有被多个线程同时访问的可变数据才需要通过锁来保护，单线程程序不需要同步。</p><p>对于每个包含多个变量的不变性条件，其中涉及的所有变量都需要由同一个锁来保护。</p><p><strong>不加区别地滥用synchronized，可能导致程序中出现过度哦的同步。此外即使将每个方法都作为同步方法，在某些操作中仍然存在竞态条件。还会导致活跃性问题(Liveness)或性能问题(Performance)。</strong></p><h3 id="1-9活跃性-Liveness-和性能-Performance"><a href="#1-9活跃性-Liveness-和性能-Performance" class="headerlink" title="1.9活跃性(Liveness)和性能(Performance)"></a>1.9活跃性(Liveness)和性能(Performance)</h3><p>ynchronizedFactorizer中，通过Servlet对象的内置锁来保护每一个状态变量，该策略的实现方式也就是对整个service方法进行同步。虽然这种简单且粗鲁的方法能确保线程安全，但代价却很高。</p><p>Servlet需要能同时处理多个请求，SynchronizedFactorizer违背了这个初衷。其他客户端必须等待Servlet处理完当前的请求，才能开始新的因数分解运算。这浪费了很多时间和减低了CPU的使用率。</p><p>下图给出了当多个请求同时达到因数分解Servlet时发生的情况：这些请求将排队等待处理。我们将这种Web应用程序称为<strong>不良并发</strong>(Poor Concurrency)应用程序:<strong>可同时调用的数量，不仅受到可用处理资源的限制，还受到应用程序本身结构的限制。</strong></p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/20170801235552344" alt="这里写图片描述"></p><p>通过**缩小同步代码块的作用范围,**我们很容易做到既确保Servlet的并发性，同时又维护线程安全性。</p><p>CachedFactorizer将Servlet的代码修改为使用两个独立的同步代码块，一个同步代码块负责保护判断是否只需返回缓存结构的”先检查后执行”操作序列，另一个同步代码块负责确保对缓存的数值和因数分解结果进行同步更新。此外我们还引入了“命中计数器”，添加了“缓存命中”计数器，并在第一个同步代码块中更新这两个变量。由于这两个计数器也是共享可变状态的一部分，因此必须在所有访问它们的位置都使用同步。位于同步代码块之外的代码将以独占方式来访问局部（位于栈上的）变量，这些变量不会在多个线程贡献，因此不需要同步。</p><pre><code class="java">//   2-8     缓存最近执行因数分解的数值以及其计算结果的Servlet@ThreadSafepublic class CachedFactorizer extends GenericServlet implements Servlet &#123;    @GuardedBy(&quot;this&quot;) private BigInteger lastNumber;    @GuardedBy(&quot;this&quot;) private BigInteger[] lastFactors;    @GuardedBy(&quot;this&quot;) private long hits;    @GuardedBy(&quot;this&quot;) private long cacheHits;    public synchronized long getHits() &#123; //这两个计数器也是共享可变状态的一部分，因此必须在所有访问它们的位置都使用同步        return hits;    &#125;    public synchronized double getCacheHitRatio() &#123;//这两个计数器也是共享可变状态的一部分，因此必须在所有访问它们的位置都使用同步        return (double) cacheHits / (double) hits;    &#125;    public void service(ServletRequest req, ServletResponse resp) &#123;        BigInteger i = extractFromRequest(req);        BigInteger[] factors = null;        synchronized (this) &#123;     //负责保护判断是否只需返回缓存结构的&quot;先检查后执行&quot;操作序列            ++hits;            if (i.equals(lastNumber)) &#123;                ++cacheHits;                factors = lastFactors.clone();//clone()会复制对象。所谓的复制对象，首先要分配一个和源对象同样大小的空间，在这个空间中创建一个新的对象。            &#125;        &#125;        if (factors == null) &#123;            factors = factor(i);            synchronized (this) &#123;       //负责确保对缓存的数值和因数分解结果进行同步更新。                lastNumber = i;                lastFactors = factors.clone();            &#125;        &#125;        encodeIntoResponse(resp, factors);    &#125;    void encodeIntoResponse(ServletResponse resp, BigInteger[] factors) &#123;    &#125;    BigInteger extractFromRequest(ServletRequest req) &#123;        return new BigInteger(&quot;7&quot;);    &#125;    BigInteger[] factor(BigInteger i) &#123;        return new BigInteger[]&#123;i&#125;;    &#125;&#125;</code></pre><p>这里没有使用AtomicLong类型的命中计数器，而是使用long类型。对单个变量上实现原子操作来说，原子变量是很有用，但我们已经使用了同步代码块来构造原子操作，而使用两种不同的同步机制不仅会带来混乱，也不会在性能或安全性上带来任何好处，所以这里不使用原子变量。</p><p>CachedFactorizer与SynchronizedFactorizer相比，实现了简单性（对整个方法进行同步）与并发性（对尽可能短的代码路径进行同步）之间的平衡。在获取与释放锁等操作上都需要一定开销，如果同步代码块分得太细(例如将++this分解为一个同步代码块)，那样通常不好。</p><p>通常，在简单性与性能之间存在着互相制约因素。当实现某个同步策略时，一定不要盲目为了性能牺牲简单性，这可能破坏安全性。</p><p><strong>当执行时间较长的计算或者无法快速完成的操作时（例如，网络I&#x2F;O或控制台I&#x2F;O），一定不要持有锁。</strong></p>]]></content>
      
      
      <categories>
          
          <category> java并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java并发 </tag>
            
            <tag> javaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC并发编程</title>
      <link href="/2022/01/02/bing-fa-juc/"/>
      <url>/2022/01/02/bing-fa-juc/</url>
      
        <content type="html"><![CDATA[<h1 id="JUC并发编程"><a href="#JUC并发编程" class="headerlink" title="JUC并发编程"></a>JUC并发编程</h1><h2 id="1-进程与线程"><a href="#1-进程与线程" class="headerlink" title="1.进程与线程"></a>1.进程与线程</h2><h3 id="1-1概念"><a href="#1-1概念" class="headerlink" title="1.1概念"></a>1.1概念</h3><h5 id="进程"><a href="#进程" class="headerlink" title="进程:"></a>进程:</h5><ul><li>程序由指令和数据组成, 但这些指令要运行, 数据要读些, 就必须将指令加载至CPU, 数据加载至内存. 在指令运行过程中还需要用到磁盘,网络等设备. 进程就是用来加载指令, 管理内存, 管理IO的</li><li>当一个程序被执行, 从磁盘加载这个程序的代码至内存, 这时就开启了一个进程.</li><li>进程就可以视为程序的一个实例, 大部分程序可以同时运行多个实例进程(例如记事本, 画图, 浏览器等), 也有的程序只能启动一个实例进程(例如网易云音乐, 360安全卫士等)</li></ul><p><strong>线程</strong></p><ul><li>一个进程之内可以分为一到多个线程</li><li>一个线程就是一个指令流, 将指令流中的一条条指令以一定的顺序交个CPU执行</li><li>Java中, 线程作为最小的调度单位, 进程作为资源分配的最小单位,在windows中进程是不活动的, 只是作为线程的容器</li></ul><h3 id="1-3并行与并发"><a href="#1-3并行与并发" class="headerlink" title="1.3并行与并发"></a>1.3并行与并发</h3><table><thead><tr><th>CPU</th><th>时间片1</th><th>时间片2</th><th>时间片3</th><th>时间片4</th></tr></thead><tbody><tr><td>core</td><td>线程1</td><td>线程2</td><td>线程3</td><td>线程4</td></tr></tbody></table><p>多核 cpu下，每个 核（core） 都可以调度运行线程，这时候线程可以是并行的。</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221102010053315.png"></p><ul><li>并行：在同一时刻，有多个指令在多个 CPU 上同时执行</li><li><strong>并发：在同一时刻，有多个指令在单个 CPU 上交替执行</strong></li></ul><p>​单核 cpu 下，线程实际还是 串行执行 的。操作系统中有一个组件叫做任务调度器，将 cpu 的时间片（windows</p><p>下时间片最小约为 15 毫秒）分给不同的程序使用，只是由于 cpu 在线程间（时间片很短）的切换非常快，人类感</p><p>觉是 同时运行的 。总结为一句话就是： 微观串行，宏观并行 ，一般会将这种 线程轮流使用 CPU 的做法称为并发， concurrent</p><h3 id="1-4二者对比"><a href="#1-4二者对比" class="headerlink" title="1.4二者对比"></a>1.4二者对比</h3><p>线程进程对比：</p><ul><li><p>进程基本上相互独立的，而线程存在于进程内，是进程的一个子集</p></li><li><p>进程拥有共享的资源，如内存空间等，供其<strong>内部的线程共享</strong></p></li><li><p><strong>进程间通信较为复杂</strong></p><p>同一台计算机的进程通信称为 IPC（Inter-process communication）</p><ul><li><p>信号量：信号量是一个计数器，用于多进程对共享数据的访问，解决同步相关的问题并避免竞争条件</p></li><li><p>共享存储：多个进程可以访问同一块内存空间，需要使用信号量用来同步对共享存储的访问</p></li><li><p>管道通信：<strong>管道是用于连接一个读进程和一个写进程以实现它们之间通信的一个共享文件 pipe 文件，该文件同一时间只允许一个进程访问，所以只支持半双工通信</strong></p><ul><li>匿名管道（Pipes）：用于具有亲缘关系的父子进程间或者兄弟进程之间的通信</li></ul></li><li><p>命名管道（Names Pipes）：以磁盘文件的方式存在，可以实现本机任意两个进程通信，遵循 FIFO</p></li><li><p>消息队列：内核中存储消息的链表，由消息队列标识符标识，能在不同进程之间提供全双工通信</p><p>，对比管道：</p><ul><li>匿名管道存在于内存中的文件；命名管道存在于实际的磁盘介质或者文件系统；消息队列存放在内核中，只有在内核重启（操作系统重启）或者显示地删除一个消息队列时，该消息队列才被真正删除</li></ul></li></ul></li><li><p>读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收</p></li></ul><p>不同计算机之间的<strong>进程通信</strong>，需要通过网络，并遵守共同的协议，例如 HTTP</p><ul><li><p>套接字：与其它通信机制不同的是，可用于不同机器间的互相通信</p></li><li><p>线程通信相对简单，因为线程之间共享进程内的内存，一个例子是多个线程可以访问同一个共享变量</p><p><strong>Java 中的通信机制</strong>：volatile、等待&#x2F;通知机制、join 方式、InheritableThreadLocal、MappedByteBuffer</p></li><li><p>线程更轻量，线程上下文切换成本一般上要比进程上下文切换低</p></li></ul><h2 id="2-同步与异步"><a href="#2-同步与异步" class="headerlink" title="2.同步与异步"></a>2.同步与异步</h2><p>以调用方角度来讲，如果 :</p><ul><li><p>需要等待结果返回，才能继续运行就是同步 </p></li><li><p>不需要等待结果返回，就能继续运行就是异步</p></li></ul><ol><li><p>单核 cpu 下，多线程不能实际提高程序运行效率，只是为了能够在不同的任务之间切换，不同线程轮流使用 cpu ，不至于一个线程总占用 cpu，别的线程没法干活</p></li><li><p>多核 cpu 可以并行跑多个线程，但能否提高程序运行效率还是要分情况的 有些任务，经过精心设计，将任务拆分，并行执行，当然可以提高程序的运行效率。但不是所有计算任 务都能拆分（参考后文的【阿姆达尔定律】） 也不是所有任务都需要拆分，任务的目的如果不同，谈拆分和效率没啥意义</p></li><li><p>IO 操作不占用 cpu，只是我们一般拷贝文件使用的是【阻塞 IO】，这时相当于线程虽然不用 cpu，但需要一 直等待 IO 结束，没能充分利用线程。所以才有后面的【非阻塞 IO】和【异步 IO】优化</p></li></ol><h2 id="3-java线程"><a href="#3-java线程" class="headerlink" title="3.java线程"></a>3.java线程</h2><h3 id="3-1创建和运行线程"><a href="#3-1创建和运行线程" class="headerlink" title="3.1创建和运行线程"></a>3.1创建和运行线程</h3><h4 id="方法一，直接使用-Thread"><a href="#方法一，直接使用-Thread" class="headerlink" title="方法一，直接使用 Thread"></a>方法一，直接使用 Thread</h4><p>Thread 创建线程方式：创建线程类，匿名内部类方式</p><ul><li><strong>start() 方法底层其实是给 CPU 注册当前线程，并且触发 run() 方法执行</strong></li><li>线程的启动必须调用 start() 方法，如果线程直接调用 run() 方法，相当于变成了普通类的执行，此时主线程将只有执行该线程</li><li>建议线程先创建子线程，主线程的任务放在之后，否则主线程（main）永远是先执行完</li></ul><p>Thread 构造器：</p><ul><li><code>public Thread()</code></li><li><code>public Thread(String name)</code></li></ul><pre><code class="java">// 创建线程对象Thread t = new Thread() &#123;//匿名类 public void run() &#123; // 要执行的任务 &#125;&#125;;// 启动线程t.start();</code></pre><pre><code class="java">// 构造方法的参数是给线程指定名字，推荐Thread t1 = new Thread(&quot;t1&quot;) &#123; @Override // run 方法内实现了要执行的任务 public void run() &#123; log.debug(&quot;hello&quot;); &#125;&#125;;t1.start();</code></pre><p>或者创建类继承Thread:</p><pre><code class="java">public class ThreadDemo &#123;    public static void main(String[] args) &#123;        Thread t = new MyThread();        t.start();           for(int i = 0 ; i &lt; 100 ; i++ )&#123;            System.out.println(&quot;main线程&quot; + i)        &#125;        // main线程输出放在上面 就变成有先后顺序了，因为是 main 线程驱动的子线程运行    &#125;&#125;class MyThread extends Thread &#123;    @Override    public void run() &#123;        for(int i = 0 ; i &lt; 100 ; i++ ) &#123;            System.out.println(&quot;子线程输出：&quot;+i)        &#125;    &#125;&#125;</code></pre><p>继承 Thread 类的优缺点：</p><ul><li>优点：编码简单</li><li>缺点：线程类已经继承了 Thread 类无法继承其他类了，功能不能通过继承拓展（单继承的局限性）</li></ul><h4 id="方法二，使用-Runnable-配合-Thread"><a href="#方法二，使用-Runnable-配合-Thread" class="headerlink" title="方法二，使用 Runnable 配合 Thread"></a>方法二，使用 Runnable 配合 Thread</h4><p>将线程和任务代码分开</p><ul><li>Thread代表线程</li><li>Runnable代表可运行的任务</li></ul><pre><code class="java">@Slf4jpublic class runnableTest &#123;    public static void main(String[] args) &#123;        Runnable r=new Runnable() &#123;            @Override            public void run() &#123;                log.debug(&quot;running&quot;);            &#125;        &#125;;        Thread t=new Thread(r,&quot;t&quot;);        t.start();    &#125;&#125;</code></pre><p><strong>lambda表达式简化runnable接口</strong></p><pre><code class="java">@Slf4jpublic class runnableTest &#123;    public static void main(String[] args) &#123;        Runnable r=() -&gt;&#123;                log.debug(&quot;running&quot;);        &#125;;        Thread t=new Thread(r,&quot;t&quot;);        t.start();    &#125;&#125;</code></pre><p>还可以更加简便:</p><pre><code class="java">@Slf4jpublic class runnableTest &#123;    public static void main(String[] args) &#123;        Thread t=new Thread(()-&gt;log.debug(&quot;running&quot;),&quot;t&quot;);        t.start();    &#125;&#125;</code></pre><h4 id="Thread与Runnable的关系原理"><a href="#Thread与Runnable的关系原理" class="headerlink" title="Thread与Runnable的关系原理"></a>Thread与Runnable的关系原理</h4><p>分析 Thread 的源码，理清它与 Runnable 的关系</p><p>Thread自身实现了Runnable接口, 同时其也接受实现了Runnable的类对象作为它的构造函数的参数</p><p><strong>Thread 类本身也是实现了 Runnable 接口</strong>，Thread 类中持有 Runnable 的属性，执行线程 run 方法底层是调用 Runnable#run：</p><pre><code class="java">public class Thread implements Runnable &#123;    private Runnable target;        public void run() &#123;        if (target != null) &#123;              // 底层调用的是 Runnable 的 run 方法            target.run();        &#125;    &#125;&#125;</code></pre><p>小结</p><ul><li>方法1 是把线程和任务合并在了一起，</li><li>方法2 是把线程和任务分开了 用 Runnable 更容易与线程池等高级 API 配合 用 Runnable 让任务类脱离了 Thread 继承体系，更灵活</li></ul><p>Runnable 方式的优缺点：</p><ul><li>缺点：代码复杂一点。</li><li>优点：<ol><li>线程任务类只是实现了 Runnable 接口，可以继续继承其他类，避免了单继承的局限性</li><li>同一个线程任务对象可以被包装成多个线程对象</li><li>适合多个多个线程去共享同一个资源</li><li>实现解耦操作，线程任务代码可以被多个线程共享，线程任务代码和线程独立</li><li>线程池可以放入实现 Runnable 或 Callable 线程任务对象</li></ol></li></ul><h4 id="方法三，FutureTask-配合-Thread"><a href="#方法三，FutureTask-配合-Thread" class="headerlink" title="方法三，FutureTask 配合 Thread"></a>方法三，FutureTask 配合 Thread</h4><p>FutureTask 能够接收 Callable 类型的参数，用来处理有返回结果的情况</p><pre><code class="java">public static void main(String[] args) throws ExecutionException, InterruptedException &#123;    FutureTask&lt;Integer&gt; taskTest=new FutureTask&lt;Integer&gt;(new Callable&lt;Integer&gt;()&#123;        @Override        public Integer call() throws Exception &#123;            log.debug(&quot;running&quot;);            return 1;        &#125;    &#125;);    Thread t=new Thread(taskTest);    t.start();    log.debug(&quot;&#123;&#125;&quot;, taskTest.get());&#125;</code></pre><p>实现 Callable 接口：</p><ol><li>定义一个线程任务类实现 Callable 接口，申明线程执行的结果类型</li><li>重写线程任务类的 call 方法，这个方法可以直接返回执行的结果</li><li>创建一个 Callable 的线程任务对象</li><li>把 Callable 的线程任务对象<strong>包装成一个未来任务对象</strong></li><li>把未来任务对象包装成线程对象</li><li>调用线程的 start() 方法启动线程</li></ol><p><code>public FutureTask(Callable&lt;V&gt; callable)</code>：未来任务对象，在线程执行完后得到线程的执行结果</p><ul><li>FutureTask 就是 Runnable 对象，因为 <strong>Thread 类只能执行 Runnable 实例的任务对象</strong>，所以把 Callable 包装成未来任务对象</li><li>线程池部分详解了 FutureTask 的源码</li></ul><p><code>public V get()</code>：同步等待 task 执行完毕的结果，如果在线程中获取另一个线程执行结果，会阻塞等待，用于线程同步</p><ul><li>get() 线程会阻塞等待任务执行完成</li><li>run() 执行完后会把结果设置到 FutureTask 的一个成员变量，get() 线程可以获取到该变量的值</li></ul><p>优缺点：</p><ul><li>优点：同 Runnable，并且能得到线程执行的结果</li><li>缺点：编码复杂</li></ul><h3 id="3-2查看进程线程的方法"><a href="#3-2查看进程线程的方法" class="headerlink" title="3.2查看进程线程的方法"></a>3.2查看进程线程的方法</h3><p><strong>windows</strong></p><p> 任务管理器可以查看进程和线程数，也可以用来杀死进程</p><ul><li><p>(cmd中)tasklist 查看进程 </p></li><li><p>taskkill 杀死进程</p></li></ul><p><strong>linux</strong></p><ul><li><p>ps -fe 查看所有进程</p></li><li><p>ps -fT -p <PID> 查看某个进程（PID）的所有线程</p></li><li><p>kill 杀死进程 </p></li><li><p>top 按大写 H 切换是否显示线程</p></li><li><p>top -H -p  <PID>查看某个进程（PID）的所有线程</p></li></ul><p><strong>Java</strong></p><ul><li><p>jps 命令查看所有 Java 进程 </p></li><li><p>jstack<PID>  查看某个 Java 进程（PID）的所有线程状态 </p></li><li><p>jconsole 来查看某个 Java 进程中线程的运行情况（图形界面）</p></li></ul><p><strong>jconsole</strong> <strong>远程监控配置</strong></p><ul><li>需要以如下方式运行你的 java 类</li></ul><blockquote><p>java -Djava.rmi.server.hostname&#x3D;<code>ip地址</code> -Dcom.sun.management.jmxremote - Dcom.sun.management.jmxremote.port&#x3D;<code>连接端口</code> -Dcom.sun.management.jmxremote.ssl&#x3D;是否安全连接 - Dcom.sun.management.jmxremote.authenticate&#x3D;是否认证 java类</p></blockquote><ul><li>修改 &#x2F;etc&#x2F;hosts 文件将 127.0.0.1 映射至主机名</li></ul><p>如果要认证访问，还需要做如下步骤</p><ul><li><p>复制 jmxremote.password 文件 </p></li><li><p>修改 jmxremote.password 和 jmxremote.access 文件的权限为 600 即文件所有者可读写 </p></li><li><p>连接时填入 controlRole（用户名），R&amp;D（密码）</p></li></ul><hr><h3 id="3-3线程运行原理"><a href="#3-3线程运行原理" class="headerlink" title="3.3线程运行原理"></a>3.3线程运行原理</h3><p><strong>栈与栈帧</strong> </p><p>Java Virtual Machine Stacks （Java 虚拟机栈） </p><p>我们都知道 JVM 中由堆、栈、方法区所组成，其中栈内存是给谁用的呢？其实就是线程，每个线程启动后，虚拟 机就会为其分配一块栈内存。</p><ul><li><p>每个栈由多个栈帧（Frame）组成，对应着每次方法调用时所占用的内存 </p></li><li><p>每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法</p></li></ul><p><strong>线程上下文切换（Thread Context Switch）</strong></p><p>因为以下一些原因导致 cpu 不再执行当前的线程，转而执行另一个线程的代码</p><ul><li><p>线程的 cpu 时间片用完 </p></li><li><p>垃圾回收 </p></li><li><p>有更高优先级的线程需要运行 </p></li><li><p>线程自己调用了 sleep、yield、wait、join、park、synchronized、lock 等方法</p></li></ul><p>当 Context Switch 发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，Java 中对应的概念就是<strong>程序计数器（Program Counter Register）</strong>，它的作用是记住下一条 jvm 指令的执行地址，是<strong>线程私有的</strong></p><ul><li><p>状态包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等 </p></li><li><p><strong>线程的调度是在内核态运行的，而线程中的代码是在用户态运行</strong>，所以线程切换（状态改变）会导致用户与内核态转换进行系统调用，这是非常消耗性能, Context Switch 频繁发生会影响性能</p></li></ul><p>Java 中 main 方法启动的是一个进程也是一个主线程，main 方法里面的其他线程均为子线程，main 线程是这些线程的父线程</p><hr><h3 id="3-4常见方法"><a href="#3-4常见方法" class="headerlink" title="3.4常见方法"></a>3.4常见方法</h3><h4 id="API"><a href="#API" class="headerlink" title="API"></a>API</h4><p>Thread 类 API：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>public void start()</td><td>启动一个新线程，Java虚拟机调用此线程的 run 方法</td></tr><tr><td>public void run()</td><td>线程启动后调用该方法</td></tr><tr><td>public void setName(String name)</td><td>给当前线程取名字</td></tr><tr><td>public void getName()</td><td>获取当前线程的名字 线程存在默认名称：子线程是 Thread-索引，主线程是 main</td></tr><tr><td>public static Thread currentThread()</td><td>获取当前线程对象，代码在哪个线程中执行</td></tr><tr><td>public static void sleep(long time)</td><td>让当前线程休眠多少毫秒再继续执行 <strong>Thread.sleep(0)</strong> : <strong>让操作系统立刻重新进行一次 CPU 竞争</strong></td></tr><tr><td>public static native void yield()</td><td>提示线程调度器让出当前线程对 CPU 的使用</td></tr><tr><td>public final int getPriority()</td><td>返回此线程的优先级</td></tr><tr><td>public final void setPriority(int priority)</td><td>更改此线程的优先级，常用 1 5 10</td></tr><tr><td>public void interrupt()</td><td>中断这个线程，异常处理机制</td></tr><tr><td>public static boolean interrupted()</td><td>判断当前线程是否被打断，清除打断标记</td></tr><tr><td>public boolean isInterrupted()</td><td>判断当前线程是否被打断，不清除打断标记</td></tr><tr><td>public final void join()</td><td>等待这个线程结束</td></tr><tr><td>public final void join(long millis)</td><td>等待这个线程死亡 millis 毫秒，0 意味着永远等待</td></tr><tr><td>public final native boolean isAlive()</td><td>线程是否存活（还没有运行完毕）</td></tr><tr><td>public final void setDaemon(boolean on)</td><td>将此线程标记为守护线程或用户线程</td></tr></tbody></table><hr><h4 id="run-start"><a href="#run-start" class="headerlink" title="run start"></a>run start</h4><p>run：称为线程体，包含了要执行的这个线程的内容，方法运行结束，此线程随即终止。直接调用 run 是在主线程中执行了 run，没有启动新的线程，需要顺序执行</p><p>start：使用 start 是启动新的线程，此线程处于就绪（可运行）状态，通过新的线程间接执行 run 中的代码</p><p>说明：<strong>线程控制资源类</strong></p><p>run() 方法中的异常不能抛出，只能 try&#x2F;catch</p><ul><li>因为父类中没有抛出任何异常，子类不能比父类抛出更多的异常</li><li><strong>异常不能跨线程传播回 main() 中</strong>，因此必须在本地进行处理</li></ul><hr><h4 id="sleep-yield"><a href="#sleep-yield" class="headerlink" title="sleep yield"></a>sleep yield</h4><p>sleep：</p><ul><li>调用 sleep 会让当前线程从 <code>Running</code> 进入 <code>Timed Waiting</code> 状态（阻塞）</li><li>sleep() 方法的过程中，<strong>线程不会释放对象锁</strong></li><li>其它线程可以使用 interrupt 方法打断正在睡眠的线程，这时 sleep 方法会抛出 InterruptedException</li><li>睡眠结束后的线程未必会立刻得到执行，需要抢占 CPU</li><li>建议用 TimeUnit 的 sleep 代替 Thread 的 sleep 来获得更好的可读性</li></ul><p>yield：</p><ul><li>调用 yield 会让提示线程调度器让出当前线程对 CPU 的使用</li><li>具体的实现依赖于操作系统的任务调度器</li><li><strong>会放弃 CPU 资源，锁资源不会释放</strong></li></ul><hr><h4 id="join"><a href="#join" class="headerlink" title="join"></a>join</h4><p>public final void join()：等待这个线程结束</p><p>原理：调用者轮询检查线程 alive 状态，t1.join() 等价于：</p><pre><code class="java">public final synchronized void join(long millis) throws InterruptedException &#123;    // 调用者线程进入 thread 的 waitSet 等待, 直到当前线程运行结束    while (isAlive()) &#123;        wait(0);    &#125;&#125;</code></pre><ul><li>join 方法是被 synchronized 修饰的，本质上是一个对象锁，其内部的 wait 方法调用也是释放锁的，但是<strong>释放的是当前的线程对象锁，而不是外面的锁</strong></li><li>当调用某个线程（t1）的 join 方法后，该线程（t1）抢占到 CPU 资源，就不再释放，直到线程执行完毕</li></ul><p>线程同步：</p><ul><li>join 实现线程同步，因为会阻塞等待另一个线程的结束，才能继续向下运行<ul><li>需要外部共享变量，不符合面向对象封装的思想</li><li>必须等待线程结束，不能配合线程池使用</li></ul></li><li>Future 实现（同步）：get() 方法阻塞等待执行结果<ul><li>main 线程接收结果</li><li>get 方法是让调用线程同步等待</li></ul></li></ul><pre><code class="java">public class Test &#123;    static int r = 0;    public static void main(String[] args) throws InterruptedException &#123;        test1();    &#125;    private static void test1() throws InterruptedException &#123;        Thread t1 = new Thread(() -&gt; &#123;            try &#123;                Thread.sleep(1000);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            r = 10;        &#125;);        t1.start();        t1.join();//不等待线程执行结束，输出的10        System.out.println(r);    &#125;&#125;</code></pre><hr><h4 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt"></a>interrupt</h4><p><strong>打断线程</strong></p><p>**public void interrupt()**：打断这个线程，异常处理机制</p><p><strong>public static boolean interrupted()<strong>：判断当前线程是否被打断，打断返回 true，</strong>清除打断标记</strong>，<strong>连续调用两次一定返回 false</strong></p><p>**public boolean isInterrupted()**：判断当前线程是否被打断，不清除打断标记</p><p>打断的线程会发生<strong>上下文切换</strong>，操作系统会保存线程信息，抢占到 CPU 后会从中断的地方接着运行（打断不是停止）</p><ul><li><p>sleep、wait、join 方法都会让线程进入阻塞状态，且<strong>会清空打断状态</strong>（false）</p><pre><code class="java">public static void main(String[] args) throws InterruptedException &#123;    Thread t1 = new Thread(()-&gt;&#123;        try &#123;            Thread.sleep(1000);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;, &quot;t1&quot;);    t1.start();    Thread.sleep(500);    t1.interrupt();    System.out.println(&quot; 打断状态: &#123;&#125;&quot; + t1.isInterrupted());// 打断状态: &#123;&#125;false&#125;</code></pre></li><li><p>打断正常运行的线程：不会清空打断状态（true）</p><pre><code class="java">public static void main(String[] args) throws Exception &#123;    Thread t2 = new Thread(()-&gt;&#123;        while(true) &#123;            Thread current = Thread.currentThread();            boolean interrupted = current.isInterrupted();            if(interrupted) &#123;                System.out.println(&quot; 打断状态: &#123;&#125;&quot; + interrupted);//打断状态: &#123;&#125;true                break;            &#125;        &#125;    &#125;, &quot;t2&quot;);    t2.start();    Thread.sleep(500);    t2.interrupt();&#125;</code></pre></li></ul><hr><h4 id="打断-park"><a href="#打断-park" class="headerlink" title="打断 park"></a>打断 park</h4><p>park 作用类似 sleep，打断 park 线程，不会清空打断状态（true）</p><pre><code class="java">public static void main(String[] args) throws Exception &#123;    Thread t1 = new Thread(() -&gt; &#123;        System.out.println(&quot;park...&quot;);        LockSupport.park();        System.out.println(&quot;unpark...&quot;);        System.out.println(&quot;打断状态：&quot; + Thread.currentThread().isInterrupted());//打断状态：true    &#125;, &quot;t1&quot;);    t1.start();    Thread.sleep(2000);    t1.interrupt();&#125;</code></pre><p><strong>如果打断标记已经是 true, 则 park 会失效</strong></p><pre><code class="java">LockSupport.park();System.out.println(&quot;unpark...&quot;);LockSupport.park();//失效，不会阻塞System.out.println(&quot;unpark...&quot;);//和上一个unpark同时执行</code></pre><p>可以修改获取打断状态方法，使用 <code>Thread.interrupted()</code>，清除打断标记</p><p>LockSupport 类在 同步 → park-un 详解</p><hr><h4 id="终止模式"><a href="#终止模式" class="headerlink" title="终止模式"></a>终止模式</h4><p>终止模式之两阶段终止模式：Two Phase Termination</p><p>目标：在一个线程 T1 中如何优雅终止线程 T2？优雅指的是给 T2 一个后置处理器</p><p>错误思想：</p><ul><li>使用线程对象的 stop() 方法停止线程：stop 方法会真正杀死线程，如果这时线程锁住了共享资源，当它被杀死后就再也没有机会释放锁，其它线程将永远无法获取锁</li><li>使用 System.exit(int) 方法停止线程：目的仅是停止一个线程，但这种做法会让整个程序都停止</li></ul><p>两阶段终止模式图示：</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221123205323957.png" alt="image-20221123205323957"></p><p>打断线程可能在任何时间，所以需要考虑在任何时刻被打断的处理方法：</p><pre><code class="java">public class Test &#123;    public static void main(String[] args) throws InterruptedException &#123;        TwoPhaseTermination tpt = new TwoPhaseTermination();        tpt.start();        Thread.sleep(3500);        tpt.stop();    &#125;&#125;class TwoPhaseTermination &#123;    private Thread monitor;    // 启动监控线程    public void start() &#123;        monitor = new Thread(new Runnable() &#123;            @Override            public void run() &#123;                while (true) &#123;                    Thread thread = Thread.currentThread();                    if (thread.isInterrupted()) &#123;                        System.out.println(&quot;后置处理&quot;);                        break;                    &#125;                    try &#123;                        Thread.sleep(1000);// 睡眠                        System.out.println(&quot;执行监控记录&quot;);// 在此被打断不会异常                    &#125; catch (InterruptedException e) &#123;// 在睡眠期间被打断，进入异常处理的逻辑                        e.printStackTrace();                        // 重新设置打断标记，打断 sleep 会清除打断状态                        thread.interrupt();                    &#125;                &#125;            &#125;        &#125;);        monitor.start();    &#125;    // 停止监控线程    public void stop() &#123;        monitor.interrupt();    &#125;&#125;</code></pre><hr><h4 id="daemon"><a href="#daemon" class="headerlink" title="daemon"></a>daemon</h4><p><code>public final void setDaemon(boolean on)</code>：如果是 true ，将此线程标记为守护线程</p><p>线程<strong>启动前</strong>调用此方法：</p><pre><code class="java">Thread t = new Thread() &#123;    @Override    public void run() &#123;        System.out.println(&quot;running&quot;);    &#125;&#125;;// 设置该线程为守护线程t.setDaemon(true);t.start();</code></pre><p>用户线程：平常创建的普通线程</p><p>守护线程：服务于用户线程，只要其它非守护线程运行结束了，<strong>即使守护线程代码没有执行完，也会强制结束</strong>。守护进程是<strong>脱离于终端并且在后台运行的进程</strong>，脱离终端是为了避免在执行的过程中的信息在终端上显示</p><p>说明：当运行的线程都是守护线程，Java 虚拟机将退出，因为普通线程执行完后，JVM 是守护线程，不会继续运行下去</p><p>常见的守护线程：</p><ul><li>垃圾回收器线程就是一种守护线程</li><li>Tomcat 中的 Acceptor 和 Poller 线程都是守护线程，所以 Tomcat 接收到 shutdown 命令后，不会等待它们处理完当前请求</li></ul><hr><h4 id="不推荐"><a href="#不推荐" class="headerlink" title="不推荐"></a>不推荐</h4><p>不推荐使用的方法，这些方法已过时，容易破坏同步代码块，造成线程死锁：</p><ul><li><p><code>public final void stop()</code>：停止线程运行</p><p>废弃原因：方法粗暴，除非可能执行 finally 代码块以及释放 synchronized 外，线程将直接被终止，如果线程持有 JUC 的互斥锁可能导致锁来不及释放，造成其他线程永远等待的局面</p></li><li><p><code>public final void suspend()</code>：<strong>挂起（暂停）线程运行</strong></p><p>废弃原因：如果目标线程在暂停时对系统资源持有锁，则在目标线程恢复之前没有线程可以访问该资源，如果<strong>恢复目标线程的线程</strong>在调用 resume 之前会尝试访问此共享资源，则会导致死锁</p></li><li><p><code>public final void resume()</code>：恢复线程运行</p></li></ul><hr><h3 id="3-5线程调度"><a href="#3-5线程调度" class="headerlink" title="3.5线程调度"></a>3.5线程调度</h3><p>线程调度指系统为线程分配处理器使用权的过程，方式有两种：协同式线程调度、抢占式线程调度（Java 选择）</p><p>协同式线程调度：线程的执行时间由线程本身控制</p><ul><li>优点：线程做完任务才通知系统切换到其他线程，相当于所有线程串行执行，不会出现线程同步问题</li><li>缺点：线程执行时间不可控，如果代码编写出现问题，可能导致程序一直阻塞，引起系统的奔溃</li></ul><p>抢占式线程调度：线程的执行时间由系统分配</p><ul><li>优点：线程执行时间可控，不会因为一个线程的问题而导致整体系统不可用</li><li>缺点：无法主动为某个线程多分配时间</li></ul><p>Java 提供了线程优先级的机制，优先级会提示（hint）调度器优先调度该线程，但这仅仅是一个提示，调度器可以忽略它。在线程的就绪状态时，如果 CPU 比较忙，那么优先级高的线程会获得更多的时间片，但 CPU 闲时，优先级几乎没作用</p><p><strong>说明：并不能通过优先级来判断线程执行的先后顺序</strong></p><hr><h4 id="未来优化"><a href="#未来优化" class="headerlink" title="未来优化"></a>未来优化</h4><p>内核级线程调度的成本较大，所以引入了更轻量级的协程。用户线程的调度由用户自己实现（多对一的线程模型，多<strong>个用户线程映射到一个内核级线程</strong>），被设计为协同式调度，所以叫协程</p><ul><li>有栈协程：协程会完整的做调用栈的保护、恢复工作，所以叫有栈协程</li><li>无栈协程：本质上是一种有限状态机，状态保存在闭包里，比有栈协程更轻量，但是功能有限</li></ul><p>有栈协程中有一种特例叫纤程，在新并发模型中，一段纤程的代码被分为两部分，执行过程和调度器：</p><ul><li>执行过程：用于维护执行现场，保护、恢复上下文状态</li><li>调度器：负责编排所有要执行的代码顺序</li></ul><hr><h3 id="3-6线程状态"><a href="#3-6线程状态" class="headerlink" title="3.6线程状态"></a>3.6线程状态</h3><p>进程的状态参考操作系统：创建态、就绪态、运行态、阻塞态、终止态</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221103214027597.png" alt="image-20221103214027597"></p><p>线程由生到死的完整过程（生命周期）：当线程被创建并启动以后，既不是一启动就进入了执行状态，也不是一直处于执行状态，在 API 中 <code>java.lang.Thread.State</code> 这个枚举中给出了<strong>六种线程状态</strong>：</p><table><thead><tr><th>线程状态</th><th>导致状态发生条件</th></tr></thead><tbody><tr><td>NEW（新建）</td><td>线程刚被创建，但是并未启动，还没调用 start 方法，只有线程对象，没有线程特征</td></tr><tr><td>Runnable（可运行）</td><td>线程可以在 Java 虚拟机中运行的状态，可能正在运行自己代码，也可能没有，这取决于操作系统处理器，调用了 t.start() 方法：就绪（经典叫法）</td></tr><tr><td>Blocked（阻塞）</td><td>当一个线程试图获取一个对象锁，而该对象锁被其他的线程持有，则该线程进入 Blocked 状态；当该线程持有锁时，该线程将变成 Runnable 状态</td></tr><tr><td>Waiting（无限等待）</td><td>一个线程在等待另一个线程执行一个（唤醒）动作时，该线程进入 Waiting 状态，进入这个状态后不能自动唤醒，必须等待另一个线程调用 notify 或者 notifyAll 方法才能唤醒</td></tr><tr><td>Timed Waiting （限期等待）</td><td>有几个方法有超时参数，调用将进入 Timed Waiting 状态，这一状态将一直保持到超时期满或者接收到唤醒通知。带有超时参数的常用方法有 Thread.sleep 、Object.wait</td></tr><tr><td>Teminated（结束）</td><td>run 方法正常退出而死亡，或者因为没有捕获的异常终止了 run 方法而死亡</td></tr></tbody></table><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221123205352428.png" alt="image-20221123205352428"></p><ul><li><p>NEW → RUNNABLE：当调用 t.start() 方法时，由 NEW → RUNNABLE</p></li><li><p>RUNNABLE &lt;–&gt; WAITING：</p><ul><li><p>调用 obj.wait() 方法时</p><p>调用 obj.notify()、obj.notifyAll()、t.interrupt()：</p><ul><li>竞争锁成功，t 线程从 WAITING → RUNNABLE</li><li>竞争锁失败，t 线程从 WAITING → BLOCKED</li></ul></li><li><p>当前线程调用 t.join() 方法，注意是当前线程在 t 线程对象的监视器上等待</p></li><li><p>当前线程调用 LockSupport.park() 方法</p></li></ul></li><li><p>RUNNABLE &lt;–&gt; TIMED_WAITING：调用 obj.wait(long n) 方法、当前线程调用 t.join(long n) 方法、当前线程调用 Thread.sleep(long n)</p></li><li><p>RUNNABLE &lt;–&gt; BLOCKED：t 线程用 synchronized(obj) 获取了对象锁时竞争失败</p></li></ul><p>本章小结</p><p> 本章的重点在于掌握 </p><ul><li><p>线程创建 </p></li><li><p>线程重要 api，如 start，run，sleep，join，interrupt 等 </p></li><li><p>线程状态 </p></li><li><p>应用方面 +</p><ul><li>异步调用：主线程执行期间，其它线程异步执行耗时操作 </li><li>提高效率：并行计算，缩短运算时间 </li><li>同步等待：join </li><li>统筹规划：合理使用线程，得到最优效果</li></ul></li><li><p>原理方面</p></li><li><p>线程运行流程：栈、栈帧、上下文切换、程序计数器 </p></li><li><p>Thread 两种创建方式 的源码 </p></li><li><p>模式方面 </p><ul><li>终止模式之两阶段终止</li></ul></li></ul><hr><h2 id="4-共享模型之管程"><a href="#4-共享模型之管程" class="headerlink" title="4.共享模型之管程"></a>4.共享模型之管程</h2><h3 id="4-1共享带来的问题"><a href="#4-1共享带来的问题" class="headerlink" title="4.1共享带来的问题"></a>4.1共享带来的问题</h3><p>两个线程对初始值为 0 的静态变量一个做自增，一个做自减，各做 5000 次，结果是 0 吗？</p><pre><code class="java">static int counter = 0;public static void main(String[] args) throws InterruptedException &#123;  Thread t1 = new Thread(() -&gt; &#123;     for (int i = 0; i &lt; 5000; i++) &#123;     counter++;      &#125;  &#125;, &quot;t1&quot;);  Thread t2 = new Thread(() -&gt; &#123;     for (int i = 0; i &lt; 5000; i++) &#123;     counter--;     &#125;  &#125;, &quot;t2&quot;); t1.start(); t2.start(); t1.join(); t2.join(); log.debug(&quot;&#123;&#125;&quot;,counter);    //不一定会是零&#125;</code></pre><h4 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h4><p>以上的结果可能是正数、负数、零。为什么呢？因为 Java 中对静态变量的自增，自减并不是原子操作，要彻底理</p><p>解，必须从字节码来进行分析</p><p>例如对于 i++ 而言（i 为静态变量），实际会产生如下的 JVM 字节码指令：</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221121182704979.png" alt="image-20221121182704979"></p><p>而对应 i– 也是类似:</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221121182724403.png" alt="image-20221121182724403"></p><p>而 Java 的内存模型如下，完成静态变量的自增，自减需要在主存和工作内存中进行数据交换：</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221121182736943.png" alt="image-20221121182736943"></p><p>如果是单线程以上 8 行代码是顺序执行（不会交错）没有问题：</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221121182759801.png" alt="image-20221121182759801"></p><p>但是多线程就会出现如下问题:</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221121182828009.png" alt="image-20221121182828009"></p><p>这个时候static i的值为-1, 究其原因, i++或者i–不是原子性的, 并且i这个变量会被多个线程共享</p><h4 id="临界区-Critical-Section"><a href="#临界区-Critical-Section" class="headerlink" title="临界区 Critical Section"></a>临界区 Critical Section</h4><ul><li>一个程序运行多个线程本身是没有问题的</li><li>问题出在多个线程访问<strong>共享资源</strong><ul><li>多个线程读<strong>共享资源</strong>其实也没有问题</li><li>在多个线程对<strong>共享资源</strong>读写操作时发生指令交错，就会出现问题</li></ul></li><li>一段代码块内如果存在对<strong>共享资源</strong>的多线程读写操作，称这段代码块为<strong>临界区</strong></li></ul><p>例如，下面代码中的临界区:</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221121183143817.png" alt="image-20221121183143817"></p><h4 id="竞态条件"><a href="#竞态条件" class="headerlink" title="竞态条件"></a>竞态条件</h4><p>多个线程在临界区内执行，由于代码的<strong>执行序列不同</strong>而导致结果无法预测，称之为发生了<strong>竞态条件</strong></p><hr><h3 id="4-2-synchronized-解决方案"><a href="#4-2-synchronized-解决方案" class="headerlink" title="4.2 synchronized 解决方案"></a>4.2 synchronized 解决方案</h3><h4 id="应用之互斥"><a href="#应用之互斥" class="headerlink" title="应用之互斥"></a>应用之互斥</h4><p>为了避免临界区的竞态条件发生，有多种手段可以达到目的。</p><ul><li><p>阻塞式的解决方案：synchronized，Lock</p></li><li><p>非阻塞式的解决方案：原子变量</p></li></ul><p>本次课使用阻塞式的解决方案：synchronized，来解决上述问题，即俗称的【对象锁】，它采用互斥的方式让同一</p><p>时刻至多只有一个线程能持有【对象锁】，其它线程再想获取这个【对象锁】时就会阻塞住。这样就能保证拥有锁</p><p>的线程可以安全的执行临界区内的代码，不用担心线程上下文切换</p><blockquote><p><strong>注意</strong></p><p>虽然 java 中互斥和同步都可以采用 synchronized 关键字来完成，但它们还是有区别的：</p><ul><li><p>互斥是保证临界区的竞态条件发生，同一时刻只能有一个线程执行临界区代码</p></li><li><p>同步是由于线程执行的先后、顺序不同、需要一个线程等待其它线程运行到某个点</p></li></ul></blockquote><h4 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h4><p>语法:</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221121183417946.png" alt="image-20221121183417946"></p><p>解决</p><pre><code class="java">static int counter = 0;static final Object room = new Object();public static void main(String[] args) throws InterruptedException &#123; Thread t1 = new Thread(() -&gt; &#123; for (int i = 0; i &lt; 5000; i++) &#123;     synchronized (room) &#123;   //可以优化一下把for也包裹进来     counter++;     &#125; &#125; &#125;, &quot;t1&quot;); Thread t2 = new Thread(() -&gt; &#123;     for (int i = 0; i &lt; 5000; i++) &#123;     synchronized (room) &#123;     counter--;     &#125; &#125; &#125;, &quot;t2&quot;); t1.start(); t2.start(); t1.join(); t2.join(); log.debug(&quot;&#123;&#125;&quot;,counter);&#125;</code></pre><h4 id="synchronized理解"><a href="#synchronized理解" class="headerlink" title="synchronized理解:"></a>synchronized理解:</h4><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221121183519239.png" alt="image-20221121183519239"></p><p>你可以做这样的类比：</p><ul><li>synchronized(对象) 中的对象，可以想象为一个房间（room），有唯一入口（门）房间只能一次进入一人</li></ul><p>​进行计算，线程 t1，t2 想象成两个人</p><ul><li>当线程 t1 执行到 synchronized(room) 时就好比 t1 进入了这个房间，并锁住了门拿走了钥匙，在门内执行</li></ul><p>​count++ 代码</p><ul><li>这时候如果 t2 也运行到了 synchronized(room) 时，它发现门被锁住了，只能在门外等待，发生了上下文切</li></ul><p>​换，阻塞住了</p><ul><li>这中间即使 t1 的 cpu 时间片不幸用完，被踢出了门外（不要错误理解为锁住了对象就能一直执行下去哦），</li></ul><p>​这时门还是锁住的，t1 仍拿着钥匙，t2 线程还在阻塞状态进不来，只有下次轮到 t1 自己再次获得时间片时才</p><p>​能开门进入</p><ul><li>当 t1 执行完 synchronized{} 块内的代码，这时候才会从 obj 房间出来并解开门上的锁，唤醒 t2 线程把钥</li></ul><p>​匙给他。t2 线程这时才可以进入 obj 房间，锁住了门拿上钥匙，执行它的 count– 代码</p><p>用图来表示:</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221121183640971.png" alt="image-20221121183640971"></p><p>synchronized 实际是用<strong>对象锁</strong>保证了<strong>临界区内代码的原子性</strong>，临界区内的代码对外是不可分割的，不会被线程切</p><p>换所打断。</p><h4 id="面向对象改进"><a href="#面向对象改进" class="headerlink" title="面向对象改进"></a>面向对象改进</h4><p>把需要保护的共享变量放入一个类:</p><pre><code class="java">class Room &#123;     int value = 0;     public void increment() &#123;         synchronized (this) &#123;         value++;      &#125;     &#125;     public void decrement() &#123;         synchronized (this) &#123;         value--;         &#125;     &#125;     public int get() &#123;         synchronized (this) &#123;         return value;         &#125;     &#125;&#125;@Slf4jpublic class Test1 &#123;  public static void main(String[] args) throws InterruptedException &#123;     Room room = new Room();     Thread t1 = new Thread(() -&gt; &#123;     for (int j = 0; j &lt; 5000; j++) &#123;         room.increment();        &#125;     &#125;, &quot;t1&quot;);     Thread t2 = new Thread(() -&gt; &#123;         for (int j = 0; j &lt; 5000; j++) &#123;         room.decrement();        &#125;     &#125;, &quot;t2&quot;);     t1.start();     t2.start();     t1.join();     t2.join();     log.debug(&quot;count: &#123;&#125;&quot; , room.get()); &#125;&#125;</code></pre><hr><h3 id="4-3-方法上的-synchronized"><a href="#4-3-方法上的-synchronized" class="headerlink" title="4.3 方法上的 synchronized"></a>4.3 方法上的 synchronized</h3><pre><code class="java">class Test&#123; public synchronized void test() &#123;  //锁非静态方法上相当于锁类的实例对象                                  &#125;&#125;等价于class Test&#123; public void test() &#123;     synchronized(this) &#123;      &#125; &#125;&#125;class Test&#123;     public synchronized static void test() &#123;  //锁在static方法上相当于所当前的类对象                                             //类名.class     &#125;&#125;等价于class Test&#123; public static void test() &#123;     synchronized(Test.class) &#123;  &#125; &#125;&#125;</code></pre><hr><h3 id="4-4线程八锁"><a href="#4-4线程八锁" class="headerlink" title="4.4线程八锁"></a>4.4线程八锁</h3><p>线程八锁就是考察 synchronized 锁住的是哪个对象，直接百度搜索相关的实例</p><p>说明：主要关注锁住的对象是不是同一个</p><ul><li>锁住类对象，所有类的实例的方法都是安全的，类的所有实例都相当于同一把锁</li><li>锁住 this 对象，只有在当前实例对象的线程内是安全的，如果有多个实例就不安全</li></ul><p>线程不安全：因为锁住的不是同一个对象，线程 1 调用 a 方法锁住的类对象，线程 2 调用 b 方法锁住的 n2 对象，不是同一个对象</p><pre><code class="java">class Number&#123;    public static synchronized void a()&#123;        Thread.sleep(1000);        System.out.println(&quot;1&quot;);    &#125;    public synchronized void b() &#123;        System.out.println(&quot;2&quot;);    &#125;&#125;public static void main(String[] args) &#123;    Number n1 = new Number();    Number n2 = new Number();    new Thread(()-&gt;&#123; n1.a(); &#125;).start();    new Thread(()-&gt;&#123; n2.b(); &#125;).start();&#125;</code></pre><hr><p>线程安全：因为 n1 调用 a() 方法，锁住的是类对象，n2 调用 b() 方法，锁住的也是类对象，所以线程安全</p><pre><code class="java">class Number&#123;    public static synchronized void a()&#123;        Thread.sleep(1000);        System.out.println(&quot;1&quot;);    &#125;    public static synchronized void b() &#123;        System.out.println(&quot;2&quot;);    &#125;&#125;public static void main(String[] args) &#123;    Number n1 = new Number();    Number n2 = new Number();    new Thread(()-&gt;&#123; n1.a(); &#125;).start();    new Thread(()-&gt;&#123; n2.b(); &#125;).start();&#125;</code></pre><hr><h3 id="4-5-变量的线程安全分析"><a href="#4-5-变量的线程安全分析" class="headerlink" title="4.5 变量的线程安全分析"></a>4.5 变量的线程安全分析</h3><p><strong>成员变量和静态变量是否线程安全？</strong></p><ul><li><p>如果它们没有共享，则线程安全</p></li><li><p>如果它们被共享了，根据它们的状态是否能够改变，又分两种情况</p><ul><li><p>如果只有读操作，则线程安全</p></li><li><p>如果有读写操作，则这段代码是临界区，需要考虑线程安全</p></li></ul></li></ul><p><strong>局部变量是否线程安全？</strong></p><ul><li><p>局部变量是线程安全的</p></li><li><p>但局部变量引用的对象则未必(逃逸分析)</p><ul><li><p>如果该对象没有逃离方法的作用访问，它是线程安全的(一个方法一个栈帧)</p></li><li><p>如果该对象逃离方法的作用范围，需要考虑线程安全(暴露引用)</p></li></ul></li></ul><h4 id="局部变量线程安全分析"><a href="#局部变量线程安全分析" class="headerlink" title="局部变量线程安全分析"></a>局部变量线程安全分析</h4><pre><code class="java">public static void test1() &#123;     int i = 10;     i++;&#125;</code></pre><p>每个线程调用 test1() 方法时局部变量 i，会在每个线程的栈帧内存中被创建多份，因此不存在共享</p><pre><code class="java">public static void test1();     descriptor: ()V     flags: ACC_PUBLIC, ACC_STATIC     Code:     stack=1, locals=1, args_size=0         0: bipush 10         2: istore_0         3: iinc 0, 1         6: return     LineNumberTable:         line 10: 0         line 11: 3         line 12: 6     LocalVariableTable:         Start Length Slot Name Signature         3 4 0 i I</code></pre><p>如图</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221121185925581.png" alt="image-20221121185925581"></p><h4 id="局部变量的引用稍有不同"><a href="#局部变量的引用稍有不同" class="headerlink" title="局部变量的引用稍有不同"></a>局部变量的引用稍有不同</h4><p>先看一个成员变量的例子:</p><pre><code class="java">class ThreadUnsafe &#123;     ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();     public void method1(int loopNumber) &#123;         for (int i = 0; i &lt; loopNumber; i++) &#123;         // &#123; 临界区, 会产生竞态条件         method2();         method3();         // &#125; 临界区       &#125; &#125;     private void method2() &#123;         list.add(&quot;1&quot;);    &#125;     private void method3() &#123;         list.remove(0);    &#125;&#125;</code></pre><p>执行</p><pre><code class="java">static final int THREAD_NUMBER = 2;static final int LOOP_NUMBER = 200;public static void main(String[] args) &#123;     ThreadUnsafe test = new ThreadUnsafe();     for (int i = 0; i &lt; THREAD_NUMBER; i++) &#123;         new Thread(() -&gt; &#123;         test.method1(LOOP_NUMBER);     &#125;, &quot;Thread&quot; + i).start(); &#125;&#125;</code></pre><p>其中一种情况是，如果线程2 还未 add，线程1 remove 就会报错：</p><pre><code class="java">Exception in thread &quot;Thread1&quot; java.lang.IndexOutOfBoundsException: Index: 0, Size: 0      at java.util.ArrayList.rangeCheck(ArrayList.java:657)      at java.util.ArrayList.remove(ArrayList.java:496)      at cn.itcast.n6.ThreadUnsafe.method3(TestThreadSafe.java:35)      at cn.itcast.n6.ThreadUnsafe.method1(TestThreadSafe.java:26)      at cn.itcast.n6.TestThreadSafe.lambda$main$0(TestThreadSafe.java:14)      at java.lang.Thread.run(Thread.java:748)</code></pre><p>分析：</p><ul><li><p>无论哪个线程中的 method2 引用的都是同一个对象中的 list 成员变量</p></li><li><p>method3 与 method2 分析相同</p></li></ul><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221121190255515.png" alt="image-20221121190255515"></p><p>将 list 修改为局部变量</p><pre><code class="java">class ThreadSafe &#123;     public final void method1(int loopNumber) &#123;         ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();         for (int i = 0; i &lt; loopNumber; i++) &#123;         method2(list);         method3(list);        &#125; &#125;     private void method2(ArrayList&lt;String&gt; list) &#123;         list.add(&quot;1&quot;);     &#125;     private void method3(ArrayList&lt;String&gt; list) &#123;         list.remove(0);     &#125;&#125;</code></pre><p>分析：</p><ul><li><p>list 是局部变量，每个线程调用时会创建其不同实例，没有共享</p></li><li><p>而 method2 的参数是从 method1 中传递过来的，与 method1 中引用同一个对象</p></li><li><p>method3 的参数分析与 method2 相同</p></li></ul><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221121190359511.png" alt="image-20221121190359511"></p><h4 id="方法访问修饰符带来的思考"><a href="#方法访问修饰符带来的思考" class="headerlink" title="方法访问修饰符带来的思考"></a>方法访问修饰符带来的思考</h4><p>如果把 method2 和 method3 的方法修改为 public 会不会代理线程安全问题？</p><ul><li><p>情况1：有其它线程调用 method2 和 method3</p></li><li><p>情况2：在 情况1 的基础上，为 ThreadSafe 类添加子类，子类覆盖 method2 或 method3 方法，即</p></li></ul><pre><code class="java">class ThreadSafe &#123; public final void method1(int loopNumber) &#123;     ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();         for (int i = 0; i &lt; loopNumber; i++) &#123;         method2(list);         method3(list);     &#125; &#125; private void method2(ArrayList&lt;String&gt; list) &#123;         list.add(&quot;1&quot;);     &#125; private void method3(ArrayList&lt;String&gt; list) &#123;         list.remove(0);     &#125;&#125;class ThreadSafeSubClass extends ThreadSafe&#123;     @Override     public void method3(ArrayList&lt;String&gt; list) &#123;         new Thread(() -&gt; &#123;         list.remove(0);         &#125;).start();     &#125;&#125;</code></pre><blockquote><p>从这个例子可以看出 private 或 fifinal 提供【安全】的意义所在，请体会开闭原则中的【闭】</p></blockquote><h4 id="常见线程安全类"><a href="#常见线程安全类" class="headerlink" title="常见线程安全类"></a>常见线程安全类</h4><ul><li><p>String</p></li><li><p>Integer</p></li><li><p>StringBuffffer</p></li><li><p>Random</p></li><li><p>Vector</p></li><li><p>Hashtable</p></li><li><p>java.util.concurrent 包下的类</p></li></ul><p>这里说它们是线程安全的是指，多个线程调用它们同一个实例的某个方法时，是线程安全的。也可以理解为</p><pre><code class="java">Hashtable table = new Hashtable();new Thread(()-&gt;&#123; table.put(&quot;key&quot;, &quot;value1&quot;);&#125;).start();new Thread(()-&gt;&#123; table.put(&quot;key&quot;, &quot;value2&quot;);&#125;).start();</code></pre><ul><li><p>它们的每个方法是原子的</p></li><li><p>但<strong>注意</strong>它们多个方法的组合不是原子的，见后面分析</p></li></ul><h4 id="线程安全类方法的组合"><a href="#线程安全类方法的组合" class="headerlink" title="线程安全类方法的组合"></a>线程安全类方法的组合</h4><pre><code class="java">Hashtable table = new Hashtable();// 线程1，线程2if( table.get(&quot;key&quot;) == null) &#123; table.put(&quot;key&quot;, value);&#125;</code></pre><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221121190822456.png" alt="image-20221121190822456"></p><h4 id="不可变类线程安全性"><a href="#不可变类线程安全性" class="headerlink" title="不可变类线程安全性"></a>不可变类线程安全性</h4><p>String、Integer 等都是不可变类，因为其内部的状态不可以改变，因此它们的方法都是线程安全的</p><p>但String 有 replace，substring 等方法【可以】改变值啊，那么这些方法又是如何保证线程安全的呢？</p><pre><code class="java">public class Immutable&#123;     private int value = 0;     public Immutable(int value)&#123;     this.value = value; &#125; public int getValue()&#123;     return this.value; &#125;&#125;</code></pre><p>如果想增加一个增加的方法呢？</p><pre><code class="java">public class Immutable&#123; private int value = 0; public Immutable(int value)&#123;     this.value = value; &#125; public int getValue()&#123;     return this.value; &#125;  public Immutable add(int v)&#123;     return new Immutable(this.value + v); &#125; &#125;</code></pre><hr><h3 id="4-6练习"><a href="#4-6练习" class="headerlink" title="4.6练习"></a>4.6练习</h3><h4 id="卖票练习"><a href="#卖票练习" class="headerlink" title="卖票练习:"></a>卖票练习:</h4><p>下面的卖票实例是否会出现线程安全问题:</p><pre><code class="java">public class ticketSeller &#123;    public static void main(String[] args) throws InterruptedException &#123;        //模拟多人买票        TicketWindow window=new TicketWindow(4000);        //List&lt;Integer&gt;list=new ArrayList&lt;&gt;();//arraylist不是线程安全类, 需要改变        List&lt;Integer&gt;list=new Vector&lt;&gt;();        //所有线程的集合        List&lt;Thread&gt;threadList=new ArrayList&lt;&gt;();        for (int i = 0; i &lt; 1000; i++) &#123;            Thread t1=new Thread(()-&gt;&#123;                int amount = window.sell(randomInt());                list.add(amount);            &#125;);            threadList.add(t1);            t1.start();        &#125;        for (Thread thread : threadList) &#123;            thread.join();        &#125;        //统计卖出的票数和剩余票数        System.out.println(&quot;剩余票数: &quot;+window.getCount());        int total=0;        for (Integer integer : list) &#123;            total+=integer;        &#125;        System.out.println(&quot;卖出的票数: &quot;+total);        System.out.println(total+ window.getCount());    &#125;&#125;class TicketWindow&#123;    private int count;    public TicketWindow(int count)&#123;        this.count=count;    &#125;    public int getCount()&#123;        return count;    &#125;    //售票    public  int sell(int amount)&#123;   //解决问题的关键在于sell方法涉及到了对于共享变量的读和写                                //因此需要在其方法上加上synchronized的关键字        if(this.count&gt;=amount)&#123;            this.count-=amount;            return amount;        &#125;        else&#123;            return 0;        &#125;    &#125;&#125;</code></pre><h4 id="转账练习"><a href="#转账练习" class="headerlink" title="转账练习:"></a>转账练习:</h4><pre><code class="java">@Testpublic void testTrans() throws InterruptedException &#123;    Account a=new Account(10000);    Account b=new Account(10000);    Thread t1=new Thread(()-&gt;&#123;        for (int i = 0; i &lt; 1000; i++) &#123;            a.transferMoney(b,randomInt()*10);        &#125;    &#125;);    Thread t2=new Thread(()-&gt;&#123;        b.transferMoney(a,randomInt()*10);    &#125;);    t1.start();    t2.start();    t1.join();    t2.join();    System.out.println(a.getMoney()+b.getMoney());&#125;class Account&#123;    private int money;    public Account(int money) &#123;        this.money = money;    &#125;    public int getMoney()&#123;        return this.money;    &#125;    public  void setMoney(int money)&#123;        this.money=money;    &#125;    public  void transferMoney(Account a,int amount)&#123;        //synchronized (Account.class) &#123;     该临界区涉及到了两个实例对象对于共享变量的读和写, 因此要对Account类对象上锁            if (this.money &gt;= amount) &#123;                this.setMoney(this.getMoney() - amount);                a.setMoney(a.getMoney() + amount);            &#125;        &#125;  //  &#125;&#125;</code></pre><hr><h3 id="4-7monitor概念"><a href="#4-7monitor概念" class="headerlink" title="4.7monitor概念"></a>4.7monitor概念</h3><h4 id="monitor"><a href="#monitor" class="headerlink" title="monitor"></a>monitor</h4><p>Monitor 被翻译为监视器或管程</p><p>每个 Java 对象都可以关联一个 Monitor 对象，Monitor 也是 class，其<strong>实例存储在堆中</strong>，如果使用 synchronized 给对象上锁（重量级）之后，该对象头的 Mark Word 中就被设置指向 Monitor 对象的指针，这就是重量级锁</p><p><strong>Java</strong> <strong>对象头</strong></p><p>以 32 位虚拟机为例:</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221122210552964.png" alt="image-20221122210552964"></p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221122210601929.png" alt="image-20221122210601929"></p><ul><li>Mark Word 结构(32位)：最后两位是<strong>锁标志位</strong></li></ul><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221123205430258.png" alt="image-20221123205430258"></p><ul><li>64 位虚拟机 Mark Word：</li></ul><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221123205450193.png" alt="image-20221123205450193"></p><h4 id="工作流程："><a href="#工作流程：" class="headerlink" title="工作流程："></a>工作流程：</h4><ul><li>开始时 Monitor 中 Owner 为 null</li><li><strong>当 Thread-2 执行 synchronized(obj) 就会将 Monitor 的所有者 Owner 置为 Thread-2</strong>，Monitor 中只能有一个 Owner，<strong>obj 对象的 Mark Word 指向 Monitor</strong>，把<strong>对象原有的 MarkWord 存入线程栈中的锁记录</strong>中（轻量级锁部分详解）</li></ul><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221123205504120.png" alt="image-20221123205504120"></p><p>注意：</p><ul><li>synchronized 必须是进入同一个对象的 Monitor 才有上述的效果</li><li>不加 synchronized 的对象不会关联监视器，不遵从以上规则</li></ul><h4 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h4><p>代码：</p><pre><code class="java">public static void main(String[] args) &#123;    Object lock = new Object();    synchronized (lock) &#123;        System.out.println(&quot;ok&quot;);    &#125;&#125;</code></pre><pre><code class="java">0: new#2// new Object3: dup4: invokespecial #1 // invokespecial &lt;init&gt;:()V，非虚方法7: astore_1 // lock引用 -&gt; lock8: aload_1// lock （synchronized开始）9: dup// 一份用来初始化，一份用来引用10: astore_2 // lock引用 -&gt; slot 211: monitorenter // 【将 lock对象 MarkWord 置为 Monitor 指针】12: getstatic #3// System.out15: ldc #4// &quot;ok&quot;17: invokevirtual #5 // invokevirtual println:(Ljava/lang/String;)V20: aload_2 // slot 2(lock引用)21: monitorexit // 【将 lock对象 MarkWord 重置, 唤醒 EntryList】22: goto 3025: astore_3 // any -&gt; slot 326: aload_2 // slot 2(lock引用)27: monitorexit // 【将 lock对象 MarkWord 重置, 唤醒 EntryList】28: aload_329: athrow30: returnException table:    from to target type      12 22 25 any      25 28 25 anyLineNumberTable: ...LocalVariableTable:    Start Length Slot Name Signature        0 31 0 args [Ljava/lang/String;        8 23 1 lock Ljava/lang/Object;</code></pre><p>说明：</p><ul><li>通过异常 <strong>try-catch 机制</strong>，确保一定会被解锁</li><li>方法级别的 synchronized 不会在字节码指令中有所体现</li></ul><hr><h3 id="4-8锁升级"><a href="#4-8锁升级" class="headerlink" title="4.8锁升级"></a>4.8锁升级</h3><h4 id="升级过程"><a href="#升级过程" class="headerlink" title="升级过程"></a>升级过程</h4><p>synchronized是可重入,不公平的重量级锁,所以可以对其进行优化</p><blockquote><p>无锁-&gt;偏向锁-&gt;轻量级锁-&gt;重量级锁        &#x2F;&#x2F;随着竞争升级,只能对锁升级, 不能降级</p></blockquote><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221123205517001.png" alt="image-20221123205517001"></p><h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><p>一个对象有多个线程要加锁，但加锁的时间是错开的（没有竞争），可以使用轻量级锁来优化，轻量级锁对使用者是透明的（不可见）</p><p>可重入锁：线程可以进入任何一个它已经拥有的锁所同步着的代码块，可重入锁最大的作用是<strong>避免死锁</strong></p><p>轻量级锁在没有竞争时（锁重入时），每次重入仍然需要执行 CAS 操作，Java 6 才引入的偏向锁来优化</p><p>锁重入实例：</p><pre><code class="java">static final Object obj = new Object();public static void method1() &#123;    synchronized( obj ) &#123;        // 同步块 A        method2();    &#125;&#125;public static void method2() &#123;    synchronized( obj ) &#123;        // 同步块 B    &#125;&#125;</code></pre><ul><li>创建锁记录（Lock Record）对象，每个线程的<strong>栈帧</strong>都会包含一个锁记录的结构，存储锁定对象的 Mark Word</li></ul><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221123205530036.png" alt="image-20221123205530036"></p><ul><li>让锁记录中 Object reference 指向锁住的对象，并尝试用 CAS 替换 Object 的 Mark Word，将 Mark Word 的值存入锁记录</li><li>如果 CAS 替换成功，对象头中存储了锁记录地址和状态 00（轻量级锁） ，表示由该线程给对象加锁</li></ul><p>如果 CAS 失败，有两种情况：</p><ul><li>如果是其它线程已经持有了该 Object 的轻量级锁，这时表明有竞争，进入锁膨胀过程</li><li>如果是线程自己执行了 synchronized 锁重入，就添加一条 Lock Record 作为重入的计数</li></ul><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221123205538062.png" alt="image-20221123205538062"></p><ul><li><p>当退出 synchronized 代码块（解锁时）</p><ul><li><p>如果有取值为 null 的锁记录，表示有重入，这时重置锁记录，表示重入计数减 1</p></li><li><p>如果锁记录的值不为 null，这时使用 CAS将 Mark Word 的值恢复给对象头</p><ul><li>成功，则解锁成功</li><li>失败，说明轻量级锁进行了锁膨胀或已经升级为重量级锁，进入重量级锁解锁流程</li></ul></li></ul></li></ul><hr><h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>偏向锁定思想是偏向让第一个获取锁对象的线程,这个线程重新获取该锁不需要进行同步操作:</p><ul><li>当锁对象第一次被线程获得的时候进入偏向状态，标记为 101，同时<strong>使用 CAS 操作将线程 ID 记录到 Mark Word</strong>。如果 CAS 操作成功，这个线程以后进入这个锁相关的同步块，查看这个线程 ID 是自己的就表示没有竞争，就不需要再进行任何同步操作</li><li>当有另外一个线程去尝试获取这个锁对象时，偏向状态就宣告结束，此时撤销偏向（Revoke Bias）后恢复到未锁定或轻量级锁状态</li></ul><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221123205548902.png" alt="image-20221123205548902"></p><p>一个对象创建时：</p><ul><li>如果开启了偏向锁（默认开启），那么对象创建后，MarkWord 值为 0x05 即最后 3 位为 101，thread、epoch、age 都为 0</li><li>偏向锁是默认是延迟的，不会在程序启动时立即生效，如果想避免延迟，可以加 VM 参数 <code>-XX:BiasedLockingStartupDelay=0</code> 来禁用延迟。JDK 8 延迟 4s 开启偏向锁原因：在刚开始执行代码时，会有好多线程来抢锁，如果开偏向锁效率反而降低</li><li>当一个对象已经计算过 hashCode，就再也无法进入偏向状态了</li><li>添加 VM 参数 <code>-XX:-UseBiasedLocking</code> 禁用偏向锁</li></ul><p>撤销偏向锁的状态：</p><ul><li>调用对象的 hashCode：偏向锁的对象 MarkWord 中存储的是线程 id，调用 hashCode 导致偏向锁被撤销</li><li><strong>当有其它线程使用偏向锁对象时，会将偏向锁升级为轻量级锁</strong></li><li>调用 wait&#x2F;notify，需要申请 Monitor，进入 WaitSet</li></ul><p><strong>批量撤销</strong>:如果对象被多个线程访问,但没有竞争,这时偏向了线程<strong>T1</strong>的对象仍然有机会偏向T2,重偏向会重置对象的ThreadID</p><ul><li>批量重偏向: 当撤销偏向锁阈值超过 20 次后(前二十次都是撤销重偏向)，JVM 会觉得是不是偏向错了，于是在给这些对象加锁时重新偏向至加锁线程(到了第二十次往后, 重新为当前线程加上重偏向)</li></ul><ul><li>批量撤销：当撤销偏向锁阈值超过 40 次后，JVM 会觉得自己确实偏向错了，根本就不该偏向，于是整个类的所有对象都会变为不可偏向的，新建的对象也是不可偏向的</li></ul><hr><h4 id="锁膨胀"><a href="#锁膨胀" class="headerlink" title="锁膨胀"></a>锁膨胀</h4><p>在尝试加轻量级锁的过程中,CAS操作无法成功,可能是其他线程为此对象加上了轻量级锁(有竞争),这时需要锁膨胀,将轻量级锁变为<strong>重量级锁</strong> </p><ul><li>当Thread-1进行轻量级加锁时, 若Thread-0已经为该对象加上轻量级锁</li></ul><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221123205600487.png" alt="image-20221123205600487"></p><ul><li>Thread-1 加轻量级锁失败，进入锁膨胀流程：为 Object 对象申请 Monitor 锁，<strong>通过 Object 对象头获取到持锁线程</strong>，将 Monitor 的 Owner 置为 Thread-0，将 Object 的对象头指向重量级锁地址，然后自己进入 Monitor 的 EntryList BLOCKED</li></ul><hr><h3 id="4-9锁优化"><a href="#4-9锁优化" class="headerlink" title="4.9锁优化"></a>4.9锁优化</h3><h4 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h4><p>**重量锁竞争时,**尝试获取锁的线程不会立即阻塞,可以使用自旋(<strong>默认十次</strong>)来进行优化,采用循环的方式去获取锁</p><p>注意:</p><ul><li>自旋占用CPU时间,单核CPU自旋就是浪费时间,因为同一时刻只能运行一个线程,多核CPU自旋才能发挥优势</li><li>自旋失败的线程会进入阻塞状态</li></ul><p>优点: 不会进入阻塞状态,<strong>减少线程上下文切换的消耗</strong></p><p>缺点: 当自旋的线程越来越多时,会不断地消耗CPU的资源</p><p>自旋锁情况:</p><ul><li>自旋成功的情况:</li></ul><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221123205610780.png" alt="image-20221123205610780"></p><ul><li>自旋失败的情况:</li></ul><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221123205618678.png" alt="image-20221123205618678"></p><p>自旋锁说明:</p><ul><li>在java6之后自旋是自适应的,比如对象刚刚的一次自旋操作成功过,那么认为这次自旋成功的可能性会高,就多自旋几次;反之,就少自旋甚至不自旋,比较智能</li><li>java7之后不能控制开启自旋功能,由JVM控制</li></ul><pre><code class="java">//手写自旋锁实例public class Spinlock &#123;    //泛型装的是Thread,原子引用线程    AtomicReference&lt;Thread&gt; atomicReference=new AtomicReference&lt;&gt;();    public void lock() throws InterruptedException &#123;        Thread thread=Thread.currentThread();        System.out.println(thread.getName()+&quot;come in&quot;);        //开始自旋, 期望值是null,更新值是当前线程        while (!atomicReference.compareAndSet(null,thread))&#123;            Thread.sleep(1000);            System.out.println(thread.getName()+&quot;正在自旋&quot;);        &#125;    &#125;    public void unlock()&#123;        Thread thread=Thread.currentThread();        //线程使用完锁把引用变为null        atomicReference.compareAndSet(thread,null);        System.out.println(thread.getName()+&quot;invoke unlock&quot;);    &#125;    public static void main(String[]args) throws InterruptedException &#123;        Spinlock spinlock=new Spinlock();        new Thread(()-&gt;&#123;            //占有锁            try &#123;                spinlock.lock();                Thread.sleep(10000);                spinlock.unlock();            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;,&quot;t1&quot;).start();        //让main线程暂停1秒,使得t1线程先执行        Thread.sleep(1000);        new Thread(()-&gt;&#123;            try &#123;                spinlock.lock();            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            spinlock.unlock();        &#125;,&quot;t2&quot;).start();    &#125;&#125;</code></pre><hr><h4 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h4><p>锁消除是指对于被检测出不可能存在竞争的共享数据的锁进行消除，这是 JVM <strong>即时编译器的优化</strong>(JIT)</p><p>锁消除主要是通过<strong>逃逸分析</strong>来支持，如果堆上的共享数据不可能逃逸出去被其它线程访问到，那么就可以把它们当成私有数据对待，也就可以将它们的锁进行消除（同步消除：JVM 逃逸分析）</p><hr><h4 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h4><p>对相同对象多次加锁，导致线程发生多次重入，频繁的加锁操作就会导致性能损耗，可以使用锁粗化方式优化</p><p>如果虚拟机探测到一串的操作都对同一个对象加锁，将会把加锁的范围扩展（粗化）到整个操作序列的外部</p><ul><li><p>一些看起来没有加锁的代码，其实隐式的加了很多锁：</p><pre><code class="java">public static String concatString(String s1, String s2, String s3) &#123;    return s1 + s2 + s3;&#125;</code></pre></li><li><p>String 是一个不可变的类，编译器会对 String 的拼接自动优化。在 JDK 1.5 之前，转化为 StringBuffer 对象的连续 append() 操作，每个 append() 方法中都有一个同步块</p><pre><code class="java">public static String concatString(String s1, String s2, String s3) &#123;    StringBuffer sb = new StringBuffer();    sb.append(s1);    sb.append(s2);    sb.append(s3);    return sb.toString();&#125;</code></pre></li></ul><p>扩展到第一个 append() 操作之前直至最后一个 append() 操作之后，只需要加锁一次就可以</p><h4 id="多把锁"><a href="#多把锁" class="headerlink" title="多把锁"></a>多把锁</h4><p>多把不相干的锁：一间大屋子有两个功能睡觉、学习，互不相干。现在一人要学习，一人要睡觉，如果只用一间屋子（一个对象锁）的话，那么并发度很低</p><p>将锁的粒度细分：</p><ul><li>好处，是可以增强并发度</li><li>坏处，如果一个线程需要同时获得多把锁，就容易发生死锁</li></ul><p>解决方法：准备多个对象锁</p><pre><code class="java">public static void main(String[] args) &#123;    BigRoom bigRoom = new BigRoom();    new Thread(() -&gt; &#123; bigRoom.study(); &#125;).start();    new Thread(() -&gt; &#123; bigRoom.sleep(); &#125;).start();&#125;class BigRoom &#123;    private final Object studyRoom = new Object();    private final Object sleepRoom = new Object();    public void sleep() throws InterruptedException &#123;        synchronized (sleepRoom) &#123;            System.out.println(&quot;sleeping 2 小时&quot;);            Thread.sleep(2000);        &#125;    &#125;    public void study() throws InterruptedException &#123;        synchronized (studyRoom) &#123;            System.out.println(&quot;study 1 小时&quot;);            Thread.sleep(1000);        &#125;    &#125;&#125;</code></pre><hr><h3 id="4-10-wait-notify"><a href="#4-10-wait-notify" class="headerlink" title="4.10 wait-notify"></a>4.10 wait-notify</h3><h4 id="wait作用效果的图解"><a href="#wait作用效果的图解" class="headerlink" title="wait作用效果的图解:"></a>wait作用效果的图解:</h4><ul><li>小南拿到了锁, 拥有owner</li></ul><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221124143609907.png" alt="image-20221124143609907"></p><ul><li>其他人在阻塞队列中等待小南释放锁</li><li>此时小南想抽烟,没烟干不了活,于是就告诉锁对象,锁对象开了一间休息室让小南休息(wait方法),等待有人给他送烟</li><li>小南从Owner中到了waitset中,<strong>小王</strong>从阻塞队列中拿到锁,进入Owner中</li><li><strong>小王</strong>告诉小南他的烟到了</li></ul><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221124143953655.png" alt="image-20221124143953655"></p><ul><li>小南于是可以离开休息室，重新进入竞争锁的队列</li></ul><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221124144027717.png" alt="image-20221124144027717"></p><h4 id="API介绍"><a href="#API介绍" class="headerlink" title="API介绍:"></a>API介绍:</h4><ul><li><p>obj.wait()让进入 object 监视器的线程到 waitSet 等待(会释放锁)</p></li><li><p>obj.notify() 在 object 上正在 waitSet 等待的线程中<strong>挑一个</strong>唤醒(notify 只能随机唤醒一个 WaitSet 中的线程，这时如果有其它线程也在等待，那么就可能唤醒不了正确的线</p><p>程，称之为<strong>虚假唤醒</strong>)</p></li><li><p>obj.notifyAll() 让 object 上正在 waitSet 等待的线程全部唤醒</p></li></ul><blockquote><p>它们都是线程之间进行协作的手段，都属于 Object 对象的方法<strong>。必须获得此对象的锁</strong>，才能调用这几个方法</p></blockquote><p>notifyAll 仅解决某个线程的唤醒问题，使用 if + wait 判断仅有一次机会，一旦条件不成立，无法重新判断</p><p>解决方法：用 while + wait，当条件不成立，再次 wait</p><pre><code class="java">@Slf4j(topic = &quot;c.demo&quot;)public class demo &#123;    static final Object room = new Object();    static boolean hasCigarette = false;    //有没有烟    static boolean hasTakeout = false;     //有么有外卖    public static void main(String[] args) throws InterruptedException &#123;        new Thread(() -&gt; &#123;            synchronized (room) &#123;                log.debug(&quot;有烟没？[&#123;&#125;]&quot;, hasCigarette);                while (!hasCigarette) &#123;//while防止虚假唤醒                    log.debug(&quot;没烟，先歇会！&quot;);                    try &#123;                        room.wait();                    &#125; catch (InterruptedException e) &#123;                        e.printStackTrace();                    &#125;                &#125;                log.debug(&quot;有烟没？[&#123;&#125;]&quot;, hasCigarette);                if (hasCigarette) &#123;                    log.debug(&quot;可以开始干活了&quot;);                &#125; else &#123;                    log.debug(&quot;没干成活...&quot;);                &#125;            &#125;        &#125;, &quot;小南&quot;).start();        new Thread(() -&gt; &#123;            synchronized (room) &#123;                Thread thread = Thread.currentThread();                log.debug(&quot;外卖送到没？[&#123;&#125;]&quot;, hasTakeout);                if (!hasTakeout) &#123;                    log.debug(&quot;没外卖，先歇会！&quot;);                    try &#123;                        room.wait();                    &#125; catch (InterruptedException e) &#123;                        e.printStackTrace();                    &#125;                &#125;                log.debug(&quot;外卖送到没？[&#123;&#125;]&quot;, hasTakeout);                if (hasTakeout) &#123;                    log.debug(&quot;可以开始干活了&quot;);                &#125; else &#123;                    log.debug(&quot;没干成活...&quot;);                &#125;            &#125;        &#125;, &quot;小女&quot;).start();        Thread.sleep(1000);        new Thread(() -&gt; &#123;        // 这里能不能加 synchronized (room)？            synchronized (room) &#123;                hasTakeout = true;                //log.debug(&quot;烟到了噢！&quot;);                log.debug(&quot;外卖到了噢！&quot;);                room.notifyAll();            &#125;        &#125;, &quot;送外卖的&quot;).start();    &#125;&#125;</code></pre><hr><h3 id="4-11-同步模式"><a href="#4-11-同步模式" class="headerlink" title="4.11 同步模式"></a>4.11 同步模式</h3><h4 id="保护性暂停"><a href="#保护性暂停" class="headerlink" title="保护性暂停"></a>保护性暂停</h4><h5 id="单任务版"><a href="#单任务版" class="headerlink" title="单任务版"></a>单任务版</h5><p>Guarded Suspension，用在一个线程等待另一个线程的执行结果</p><ul><li>有一个结果需要从一个线程传递到另一个线程，让它们关联同一个 GuardedObject</li><li>如果有结果不断从一个线程到另一个线程那么可以使用消息队列（见生产者&#x2F;消费者）</li><li>JDK 中，join 的实现、Future 的实现，采用的就是此模式</li></ul><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/68747470733a2f2f7365617a65616e2e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f696d672f4a6176612f4a55432d254534254246253944254536253841254134254536253830254137254536253941253832254535253831253.png" alt="68747470733a2f2f7365617a65616e2e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f696d672f4a6176612f4a55432d254534254246253944254536253841254134254536253830254137254536253941253832254535253831253"></p><pre><code class="java">@Slf4jpublic class testGuardedObject &#123;    public static void main(String[] args) &#123;        GuardedObject guardedObject=new GuardedObject();        //线程一等待线程二的下载结果        new Thread(()-&gt;&#123;            //等待结果            log.debug(&quot;等待结果&quot;);            List&lt;String&gt;list = (List&lt;String&gt;) guardedObject.get();            log.debug(&quot;结果是:&#123;&#125;&quot;, list.size());        &#125;,&quot;t1&quot;).start();        new Thread(()-&gt;&#123;            try &#123;                log.debug(&quot;正在下载....&quot;);                List&lt;String&gt; download = download();                guardedObject.complete(download);            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125;        &#125;,&quot;t2&quot;).start();    &#125;    public static List&lt;String&gt;download() throws IOException &#123;        HttpURLConnection conn=(HttpURLConnection) new URL(&quot;https://www.baidu.com/&quot;).openConnection();        List&lt;String&gt;lines=new ArrayList&lt;&gt;();        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(conn.getInputStream(), StandardCharsets.UTF_8));        String line;        while ((line= bufferedReader.readLine())!=null)&#123;            lines.add(line);        &#125;        return lines;    &#125;&#125;class GuardedObject&#123;    private Object response;    public Object get()&#123;       synchronized (this)&#123;           while (response==null)&#123;               try &#123;                   this.wait();               &#125; catch (InterruptedException e) &#123;                   e.printStackTrace();               &#125;           &#125;       &#125;       return response;    &#125;    public void complete(Object response)&#123;        synchronized (this)&#123;            this.response=response;            this.notifyAll();        &#125;    &#125;&#125;</code></pre><h5 id="增强超时效果"><a href="#增强超时效果" class="headerlink" title="增强超时效果"></a>增强超时效果</h5><pre><code class="java">@Slf4jpublic class testGuardedObject &#123;    public static void main(String[] args) &#123;        GuardedObject guardedObject=new GuardedObject();        //线程一等待线程二的下载结果        new Thread(()-&gt;&#123;            //等待结果            log.debug(&quot;等待结果&quot;);            List&lt;String&gt;list = (List&lt;String&gt;) guardedObject.get(2000);            if(list==null)&#123;                log.debug(&quot;超时啦!&quot;);            &#125;else&#123;                log.debug(&quot;结果是:&#123;&#125;&quot;, list.size());            &#125;        &#125;,&quot;t1&quot;).start();        new Thread(()-&gt;&#123;            log.debug(&quot;正在下载....&quot;);            List&lt;String&gt; download = null;            try &#123;                download = download();            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125;            guardedObject.complete(download);        &#125;,&quot;t2&quot;).start();    &#125;    public static List&lt;String&gt;download() throws IOException &#123;        HttpURLConnection conn=(HttpURLConnection) new URL(&quot;https://www.baidu.com/&quot;).openConnection();        List&lt;String&gt;lines=new ArrayList&lt;&gt;();        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(conn.getInputStream(), StandardCharsets.UTF_8));        String line;        while ((line= bufferedReader.readLine())!=null)&#123;            lines.add(line);        &#125;        return lines;    &#125;&#125;class GuardedObject&#123;    private Object response;    //添加超时效果    //timeout表示等待的最大时间    public Object get(long timeout)&#123;       synchronized (this)&#123;           //开始时间           long begin = System.currentTimeMillis();           //记录一个经历时间           long durTime=0;           while (response==null)&#123;               //该轮循环应该等待的时间               long waitTime=timeout-durTime;               if(waitTime&lt;=0)&#123;                   break;               &#125;               try &#123;                   this.wait(waitTime);               &#125; catch (InterruptedException e) &#123;                   e.printStackTrace();               &#125;               //经历时间               durTime = System.currentTimeMillis() - begin;           &#125;       &#125;       return response;    &#125;    public void complete(Object response)&#123;        synchronized (this)&#123;            this.response=response;            this.notifyAll();        &#125;    &#125;&#125;</code></pre><h5 id="多任务版"><a href="#多任务版" class="headerlink" title="多任务版"></a>多任务版</h5><p>多任务版保护性暂停：</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/dwadwbujnfdjs55151.png" alt="dwadwbujnfdjs55151"></p><pre><code class="java">public static void main(String[] args) throws InterruptedException &#123;    for (int i = 0; i &lt; 3; i++) &#123;        new People().start();    &#125;    Thread.sleep(1000);    for (Integer id : Mailboxes.getIds()) &#123;        new Postman(id, id + &quot;号快递到了&quot;).start();    &#125;&#125;@Slf4j(topic = &quot;c.People&quot;)class People extends Thread&#123;    @Override    public void run() &#123;        // 收信        GuardedObject guardedObject = Mailboxes.createGuardedObject();        log.debug(&quot;开始收信i d:&#123;&#125;&quot;, guardedObject.getId());        Object mail = guardedObject.get(5000);        log.debug(&quot;收到信id:&#123;&#125;，内容:&#123;&#125;&quot;, guardedObject.getId(),mail);    &#125;&#125;class Postman extends Thread&#123;    private int id;    private String mail;    //构造方法    @Override    public void run() &#123;        GuardedObject guardedObject = Mailboxes.getGuardedObject(id);        log.debug(&quot;开始送信i d:&#123;&#125;，内容:&#123;&#125;&quot;, guardedObject.getId(),mail);        guardedObject.complete(mail);    &#125;&#125;class  Mailboxes &#123;    private static Map&lt;Integer, GuardedObject&gt; boxes = new Hashtable&lt;&gt;();    private static int id = 1;    //产生唯一的id    private static synchronized int generateId() &#123;        return id++;    &#125;    public static GuardedObject getGuardedObject(int id) &#123;        return boxes.remove(id);    &#125;    public static GuardedObject createGuardedObject() &#123;        GuardedObject go = new GuardedObject(generateId());        boxes.put(go.getId(), go);        return go;    &#125;    public static Set&lt;Integer&gt; getIds() &#123;        return boxes.keySet();    &#125;&#125;class GuardedObject &#123;    //标识，Guarded Object    private int id;//添加get set方法&#125;</code></pre><hr><h3 id="4-12异步模式"><a href="#4-12异步模式" class="headerlink" title="4.12异步模式"></a>4.12异步模式</h3><p>异步模式之生产者&#x2F;消费者：</p><ul><li>消费队列可以用来平衡生产和消费的线程资源，不需要产生结果和消费结果的线程一一对应</li><li>生产者仅负责产生结果数据，不关心数据该如何处理，而消费者专心处理结果数据</li><li>消息队列是有容量限制的，满时不会再加入数据，空时不会再消耗数据</li><li>JDK 中各种阻塞队列，采用的就是这种模式</li></ul><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/38254538254234254.png" alt="38254538254234254"></p><pre><code class="java">public class demo &#123;    public static void main(String[] args) &#123;        MessageQueue queue = new MessageQueue(2);        for (int i = 0; i &lt; 3; i++) &#123;            int id = i;            new Thread(() -&gt; &#123;                queue.put(new Message(id,&quot;值&quot;+id));            &#125;, &quot;生产者&quot; + i).start();        &#125;                new Thread(() -&gt; &#123;            while (true) &#123;                try &#123;                    Thread.sleep(1000);                    Message message = queue.take();                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;,&quot;消费者&quot;).start();    &#125;&#125;//消息队列类，Java间线程之间通信class MessageQueue &#123;    private LinkedList&lt;Message&gt; list = new LinkedList&lt;&gt;();//消息的队列集合    private int capacity;//队列容量    public MessageQueue(int capacity) &#123;        this.capacity = capacity;    &#125;    //获取消息    public Message take() &#123;        //检查队列是否为空        synchronized (list) &#123;            while (list.isEmpty()) &#123;                try &#123;                    sout(Thread.currentThread().getName() + &quot;:队列为空，消费者线程等待&quot;);                    list.wait();                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;            //从队列的头部获取消息返回            Message message = list.removeFirst();            sout(Thread.currentThread().getName() + &quot;：已消费消息--&quot; + message);            list.notifyAll();            return message;        &#125;    &#125;    //存入消息    public void put(Message message) &#123;        synchronized (list) &#123;            //检查队列是否满            while (list.size() == capacity) &#123;                try &#123;                    sout(Thread.currentThread().getName()+&quot;:队列为已满，生产者线程等待&quot;);                    list.wait();                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;            //将消息加入队列尾部            list.addLast(message);            sout(Thread.currentThread().getName() + &quot;:已生产消息--&quot; + message);            list.notifyAll();        &#125;    &#125;&#125;final class Message &#123;    private int id;    private Object value;    //get set&#125;</code></pre><h3 id="4-13-Park-Unpark"><a href="#4-13-Park-Unpark" class="headerlink" title="4.13 Park&amp;Unpark"></a>4.13 Park&amp;Unpark</h3><p>LockSupport 是用来创建锁和其他同步类的<strong>线程原语</strong></p><p>LockSupport 类方法：</p><ul><li><code>LockSupport.park()</code>：暂停当前线程，挂起原语</li><li><code>LockSupport.unpark(暂停的线程对象)</code>：恢复某个线程的运行</li></ul><pre><code class="java">@Slf4jpublic class testParkUnpark &#123;    public static void main(String[] args) &#123;        Thread t1 = new Thread(() -&gt; &#123;            log.debug(&quot;start.....&quot;);            Sleeper.sleep(1000);            log.debug(&quot;park......&quot;);            LockSupport.park();            log.debug(&quot;resume&quot;);        &#125;, &quot;t1&quot;);        t1.start();        Sleeper.sleep(2000);        log.debug(&quot;unpark.....&quot;);        LockSupport.unpark(t1);    &#125;&#125;</code></pre><p>LockSupport 出现就是为了增强 wait &amp; notify 的功能：</p><ul><li>wait，notify 和 notifyAll 必须配合 Object Monitor 一起使用，而 park、unpark 不需要</li><li>park &amp; unpark <strong>以线程为单位</strong>来阻塞和唤醒线程，而 notify 只能随机唤醒一个等待线程，notifyAll 是唤醒所有等待线程</li><li><strong>park &amp; unpark 可以先 unpark</strong>，而 wait &amp; notify 不能先 notify。类比生产消费，先消费发现有产品就消费，没有就等待；先生产就直接产生商品，然后线程直接消费</li><li>wait 会释放锁资源进入等待队列，<strong>park 不会释放锁资源</strong>，只负责阻塞当前线程，会释放 CPU</li></ul><p>原理：类似生产者消费者</p><ul><li>先 park：<ol><li>当前线程调用 Unsafe.park() 方法</li><li>检查 _counter ，本情况为 0，这时获得 _mutex 互斥锁</li><li>线程进入 _cond 条件变量挂起</li><li>调用 Unsafe.unpark(Thread_0) 方法，设置 _counter 为 1</li><li>唤醒 _cond 条件变量中的 Thread_0，Thread_0 恢复运行，设置 _counter 为 0</li></ol></li></ul><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/dwa3.jpg"></p><ul><li>先unpark:</li></ul><p>​1.调用Unsafe.unpark(Thread_0)方法,设置_counter为1</p><p>​2.当前线程调用Unsafe.park()方法</p><p>​3.检查_counter,本情况为1,这时线程无需挂起,将_counter设置为0,继续运行</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/dwa.jpg" alt="dwa"></p><h3 id="4-14重新理解线程状态转换"><a href="#4-14重新理解线程状态转换" class="headerlink" title="4.14重新理解线程状态转换"></a>4.14重新理解线程状态转换</h3><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221125165942324.png" alt="image-20221125165942324"></p><h4 id="情况1-New-Runnable"><a href="#情况1-New-Runnable" class="headerlink" title="情况1 New-&gt;Runnable"></a>情况1 New-&gt;Runnable</h4><ul><li>当调用t.start()的时候,线程状态由New变为Runnable</li></ul><h4 id="情况2-RunnableWaiting"><a href="#情况2-RunnableWaiting" class="headerlink" title="情况2 Runnable&lt;-&gt;Waiting"></a>情况2 Runnable&lt;-&gt;Waiting</h4><p>t线程调用synchronized(obj)获取了对象锁之后</p><ul><li>调用obj.waiting()方法时,t线程由Runnable变为Waiting</li><li>调用obj.notify(),obj.notifyAll(),t.interrupt()时,<ul><li>竞争锁失败, t线程由waiting–&gt;blocked</li><li>竞争锁成功, t线程由waiting–&gt;Runnable</li></ul></li></ul><pre><code class="java">public class TestWaitNotify &#123; final static Object obj = new Object();         public static void main(String[] args) &#123;             new Thread(() -&gt; &#123;                 synchronized (obj) &#123;                         log.debug(&quot;执行....&quot;);                     try &#123;                             obj.wait();                         &#125; catch (InterruptedException e) &#123;                         e.printStackTrace();                     &#125;                         log.debug(&quot;其它代码....&quot;); // 断点                 &#125;             &#125;,&quot;t1&quot;).start();                 new Thread(() -&gt; &#123;                     synchronized (obj) &#123;                         log.debug(&quot;执行....&quot;);                         try &#123;                             obj.wait();                     &#125; catch (InterruptedException e) &#123;                         e.printStackTrace();                 &#125;                     log.debug(&quot;其它代码....&quot;); // 断点                 &#125;             &#125;,&quot;t2&quot;).start();             sleep(0.5);             log.debug(&quot;唤醒 obj 上其它线程&quot;);             synchronized (obj) &#123;                 obj.notifyAll(); // 唤醒obj上所有等待线程 断点,此时waiting状态的线程变为blocked             &#125;//执行到这一步主线程释放锁,blocked的线程一个争取到锁,变为Runnable     &#125;&#125;</code></pre><h4 id="情况3-RunnableWaiting"><a href="#情况3-RunnableWaiting" class="headerlink" title="情况3 Runnable&lt;-&gt;Waiting"></a>情况3 Runnable&lt;-&gt;Waiting</h4><ul><li><p><strong>当前线程</strong>调用t.join()方法时,当前线程会从Runnable–&gt;Waiting</p><ul><li>注意是<strong>当前线程</strong>等待t线程执行结束, <strong>当前线程</strong>在t线程对象的监视器上等待</li></ul></li><li><p>t线程运行结束后,或调用了当前线程的interrupt时,当前线程从Waiting–&gt;Runnable</p></li></ul><h4 id="情况4-RunnableWaiting"><a href="#情况4-RunnableWaiting" class="headerlink" title="情况4 Runnable&lt;-&gt;Waiting"></a>情况4 Runnable&lt;-&gt;Waiting</h4><ul><li><strong>当前线程</strong>调用LockSupport.park()方法会让当前线程从Runnable–&gt;Waiting</li><li>调用LockSupport.unpark**(目标线程**)或调用了线程的interrupt(),会让目标线程从Waiting-&gt;Runnable</li></ul><h4 id="情况5-RunnableTimed-Waiting"><a href="#情况5-RunnableTimed-Waiting" class="headerlink" title="情况5 Runnable&lt;-&gt;Timed_Waiting"></a>情况5 Runnable&lt;-&gt;Timed_Waiting</h4><p><strong>t线程</strong>用synchronized(obj)获取了对象锁之后</p><ul><li>调用 obj.wait(long n) 方法时，<strong>t</strong> <strong>线程</strong>从 RUNNABLE –&gt; TIMED_WAITING</li><li><strong>t</strong> <strong>线程</strong>等待时间超过了 n 毫秒，或调用 obj.notify() ， obj.notifyAll() ， t.interrupt() 时<ul><li>竞争锁成功，<strong>t</strong> <strong>线程</strong>从 TIMED_WAITING –&gt; RUNNABLE</li><li>竞争锁失败，<strong>t</strong> <strong>线程</strong>从 TIMED_WAITING –&gt; BLOCKED</li></ul></li></ul><p><strong>情况</strong> <strong>6</strong> <strong>RUNNABLE &lt;-&gt; TIMED_WAITING</strong></p><ul><li><strong>当前线程</strong>调用 t.join(long n) 方法时，<strong>当前线程</strong>从 RUNNABLE –&gt; TIMED_WAITING<ul><li>注意是<strong>当前线程</strong>在<strong>t线程对象</strong>的监视器上等待</li></ul></li><li>当前线程等待时间超过了n毫秒,或者t线程结束,或调用了当前线程的interrupt()时,当前线程从Timed_Waiting–&gt;Runnable</li></ul><p><strong>情况</strong> <strong>7</strong> <strong>RUNNABLE &lt;-&gt; TIMED_WAITING</strong></p><ul><li>当前线程调用 Thread.sleep(long n) ，当前线程从 RUNNABLE –&gt; TIMED_WAITING</li><li><strong>当前线程</strong>等待时间超过了 n 毫秒，<strong>当前线程</strong>从 TIMED_WAITING –&gt; RUNNABLE</li></ul><h4 id="情况8-RunnableTimed-Waiting"><a href="#情况8-RunnableTimed-Waiting" class="headerlink" title="情况8 Runnable&lt;-&gt;Timed_Waiting"></a>情况8 Runnable&lt;-&gt;Timed_Waiting</h4><ul><li>当前线程调用LockSupport.parkNanos(long nanos)或者LockSuppor.parkUntil(long mills)时,当前线程从Runnable–&gt;Timed_Waiting</li><li>调用LockSupport.unpark(目标线程)或调用了线程的interrupt(),或是等待超时,让目标线程从Timed_Waiting–&gt;Runnable</li></ul><p><strong>情况</strong> <strong>9</strong> <strong>RUNNABLE &lt;-&gt; BLOCKED</strong></p><ul><li><p><strong>t</strong> <strong>线程</strong>用 synchronized(obj) 获取了对象锁时如果竞争失败，从 RUNNABLE –&gt; BLOCKED</p></li><li><p>持 obj 锁线程的同步代码块执行完毕，会唤醒该对象上所有 BLOCKED 的线程重新竞争，如果其中 <strong>t</strong> <strong>线程</strong>竞争</p></li></ul><p>​成功，从 BLOCKED –&gt; RUNNABLE ，其它失败的线程仍然 Blocked</p><p><strong>情况</strong> <strong>10</strong> <strong>RUNNABLE &lt;-&gt; TERMINATED</strong></p><p>当前线程所有代码运行完毕,进入 TERMINATED</p><h3 id="4-15活跃性"><a href="#4-15活跃性" class="headerlink" title="4.15活跃性"></a>4.15活跃性</h3><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>有这样的情况：一个线程需要同时获取多把锁，这时就容易发生死锁</p><p>t1 线程 获得 A对象 锁，接下来想获取 B对象 的锁 t2 线程 获得 B对象 锁，接下来想获取 A对象 的锁 例：</p><pre><code class="java">@Slf4jpublic class testDeadLock &#123;    //测试死锁    public static void main(String[] args) &#123;        Object o1 = new Object();        Object o2 = new Object();        Thread t1 = new Thread(() -&gt; &#123;            synchronized (o1) &#123;                log.debug(&quot;获取了o1的锁&quot;);                Sleeper.sleep(1000);                synchronized (o2)&#123;                    log.debug(&quot;获取了o2的锁&quot;);                &#125;            &#125;        &#125;, &quot;t1&quot;);        Thread t2 = new Thread(() -&gt; &#123;            synchronized (o2) &#123;                log.debug(&quot;获取了o2的锁&quot;);                Sleeper.sleep(500);                synchronized (o1) &#123;                    log.debug(&quot;获取了o1的锁&quot;);                &#125;            &#125;        &#125;, &quot;t2&quot;);        t1.start();        t2.start();    &#125;&#125;</code></pre><p><strong>定位死锁</strong></p><ul><li>检测死锁可以使用 jconsole工具，或者使用 jps 定位进程 id，再用 jstack 定位死锁:</li></ul><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221125205010972.png" alt="image-20221125205010972"></p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221125205041826.png" alt="image-20221125205041826"></p><ul><li>使用jconsole:</li></ul><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221125205213286.png" alt="image-20221125205213286"></p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221125205237507.png" alt="image-20221125205237507"></p><ul><li>jvisualVM:</li></ul><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221125205326146.png" alt="image-20221125205326146"></p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221125205406507.png" alt="image-20221125205406507"></p><h4 id="哲学家就餐问题"><a href="#哲学家就餐问题" class="headerlink" title="哲学家就餐问题"></a>哲学家就餐问题</h4><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221125205516274.png" alt="image-20221125205516274"></p><p>筷子类:</p><pre><code class="java">class Chopstick&#123;    String name;    public Chopstick(String name) &#123;        this.name = name;    &#125;    @Override    public String toString() &#123;        return &quot;Chopstick&#123;&quot; +                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +                &#39;&#125;&#39;;    &#125;&#125;</code></pre><p>哲学家类:</p><pre><code class="java">@Slf4jpublic class Philosopher extends Thread&#123;    Chopstick left;    Chopstick right;    public static void main(String[] args) &#123;        Chopstick c1 = new Chopstick(&quot;1&quot;);        Chopstick c2 = new Chopstick(&quot;2&quot;);        Chopstick c3 = new Chopstick(&quot;3&quot;);        Chopstick c4 = new Chopstick(&quot;4&quot;);        Chopstick c5 = new Chopstick(&quot;5&quot;);        new Philosopher(&quot;pan&quot;,c1,c2).start();        new Philosopher(&quot;wang&quot;,c2,c3).start();        new Philosopher(&quot;li&quot;,c3,c4).start();        new Philosopher(&quot;zhang&quot;,c4,c5).start();        new Philosopher(&quot;han&quot;,c5,c1).start();    &#125;    Philosopher(String name,Chopstick left,Chopstick right)&#123;        super(name);        this.left=left;        this.right=right;    &#125;    @Override    public void run() &#123;        while (true)&#123;            synchronized (left)&#123;                synchronized (right)&#123;                    eating();                &#125;            &#125;        &#125;    &#125;    private void eating()&#123;        log.debug(&quot;正在吃饭&quot;);        Sleeper.sleep(1000);    &#125;&#125;</code></pre><p>就餐:</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221125205658536.png" alt="image-20221125205658536"></p><p>jconsole检测死锁:</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221125205759887.png" alt="image-20221125205759887"></p><h4 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h4><p>活锁出现在两个线程互相改变对方的结束条件，最后谁也无法结束，例如</p><pre><code class="java">public class TestLiveLock &#123; static volatile int count = 10;    static final Object lock = new Object();     public static void main(String[] args) &#123;         new Thread(() -&gt; &#123;             // 期望减到 0 退出循环             while (count &gt; 0) &#123;                 sleep(0.2);                 count--;                 log.debug(&quot;count: &#123;&#125;&quot;, count);             &#125;         &#125;, &quot;t1&quot;).start();         new Thread(() -&gt; &#123;             // 期望超过 20 退出循环             while (count &lt; 20) &#123;                 sleep(0.2);                 count++;                 log.debug(&quot;count: &#123;&#125;&quot;, count);             &#125;         &#125;, &quot;t2&quot;).start();     &#125;&#125;</code></pre><h4 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h4><p>饥饿的定义为，一个线程由于优先级太低，始终得不到 CPU 调度执行，也不能够结束.</p><p>用顺序加锁的方式解决之前的死锁问题</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221125210221811.png" alt="image-20221125210221811"></p><p>顺序加锁的解决方案</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221125210238788.png" alt="image-20221125210238788"></p><h3 id="4-16-ReentrantLock"><a href="#4-16-ReentrantLock" class="headerlink" title="4.16 ReentrantLock"></a>4.16 ReentrantLock</h3><p>相对于 synchronized 它具备如下特点:</p><ul><li><p>可中断</p></li><li><p>可以设置超时时间</p></li><li><p>可以设置为公平锁</p></li><li><p>支持多个条件变量</p></li></ul><p><strong>与 synchronized 一样，都支持可重入</strong></p><p>基本语法</p><pre><code class="java">// 获取锁reentrantLock.lock();try &#123; // 临界区&#125; finally &#123; // 释放锁 reentrantLock.unlock();&#125;</code></pre><h4 id="可重入"><a href="#可重入" class="headerlink" title="可重入"></a>可重入</h4><p>可重入是指同一个线程如果首次获得了这把锁，那么因为它是这把锁的拥有者，因此有权利再次获取这把锁 如果是不可重入锁，那么第二次获得锁时，自己也会被锁挡住</p><pre><code class="java">static ReentrantLock lock = new ReentrantLock();    public static void main(String[] args) &#123;         method1();    &#125;    public static void method1() &#123;         lock.lock();             try &#123;             log.debug(&quot;execute method1&quot;);             method2();             &#125; finally &#123;                 lock.unlock();             &#125;    &#125;    public static void method2() &#123;         lock.lock();         try &#123;             log.debug(&quot;execute method2&quot;);             method3();         &#125; finally &#123;             lock.unlock();         &#125;    &#125;    public static void method3() &#123;         lock.lock();         try &#123;             log.debug(&quot;execute method3&quot;);         &#125; finally &#123;             lock.unlock();     &#125;&#125;</code></pre><h4 id="可打断"><a href="#可打断" class="headerlink" title="可打断"></a>可打断</h4><pre><code class="java">ReentrantLock lock = new ReentrantLock();    Thread t1 = new Thread(() -&gt; &#123;        log.debug(&quot;启动...&quot;);         try &#123;             lock.lockInterruptibly();         &#125; catch (InterruptedException e) &#123;             e.printStackTrace();             log.debug(&quot;等锁的过程中被打断&quot;);             return;             &#125;         try &#123;             log.debug(&quot;获得了锁&quot;);             &#125; finally &#123;                 lock.unlock();                 &#125;        &#125;, &quot;t1&quot;);    lock.lock();    log.debug(&quot;获得了锁&quot;);    t1.start();    try &#123;           sleep(1);         t1.interrupt();     log.debug(&quot;执行打断&quot;);    &#125; finally &#123;         lock.unlock();    &#125;</code></pre><p>输出</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221126194506458.png" alt="image-20221126194506458"></p><p>注意如果是不可中断模式，那么即使使用了 interrupt 也不会让等待中断</p><pre><code class="java">ReentrantLock lock = new ReentrantLock();Thread t1 = new Thread(() -&gt; &#123; log.debug(&quot;启动...&quot;);    lock.lock();     try &#123;         log.debug(&quot;获得了锁&quot;);         &#125; finally &#123;             lock.unlock();         &#125;    &#125;, &quot;t1&quot;);    lock.lock();    log.debug(&quot;获得了锁&quot;);    t1.start();    try &#123;         sleep(1);         t1.interrupt();         log.debug(&quot;执行打断&quot;);         sleep(1);    &#125; finally &#123;         log.debug(&quot;释放了锁&quot;);     lock.unlock();&#125;</code></pre><p>输出</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221126194859724.png" alt="image-20221126194859724"></p><h4 id="锁超时"><a href="#锁超时" class="headerlink" title="锁超时"></a>锁超时</h4><p>立刻失败</p><pre><code class="java">ReentrantLock lock = new ReentrantLock();Thread t1 = new Thread(() -&gt; &#123;     log.debug(&quot;启动...&quot;);     if (!lock.tryLock()) &#123;         log.debug(&quot;获取立刻失败，返回&quot;);         return;     &#125;     try &#123;         log.debug(&quot;获得了锁&quot;);     &#125; finally &#123;         lock.unlock();     &#125;&#125;, &quot;t1&quot;);lock.lock();log.debug(&quot;获得了锁&quot;);t1.start();try &#123;     sleep(2);&#125; finally &#123;     lock.unlock();&#125;</code></pre><p>输出</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221126195236367.png" alt="image-20221126195236367"></p><p>超时失败</p><pre><code class="java">ReentrantLock lock = new ReentrantLock();Thread t1 = new Thread(() -&gt; &#123;     log.debug(&quot;启动...&quot;);     try &#123;         if (!lock.tryLock(1, TimeUnit.SECONDS)) &#123;         log.debug(&quot;获取等待 1s 后失败，返回&quot;);         return;     &#125;     &#125; catch (InterruptedException e) &#123;         e.printStackTrace();     &#125;     try &#123;     log.debug(&quot;获得了锁&quot;);     &#125; finally &#123;     lock.unlock();     &#125;&#125;, &quot;t1&quot;);    lock.lock();    log.debug(&quot;获得了锁&quot;);    t1.start();try &#123;     sleep(2);&#125; finally &#123;     lock.unlock();&#125;</code></pre><p>输出</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221126195512158.png" alt="image-20221126195512158"></p><p>使用 tryLock 解决哲学家就餐问题</p><pre><code class="java">@Slf4jpublic class Philosopher extends Thread&#123;    Chopstick left;    Chopstick right;    public static void main(String[] args) &#123;        Chopstick c1 = new Chopstick(&quot;1&quot;);        Chopstick c2 = new Chopstick(&quot;2&quot;);        Chopstick c3 = new Chopstick(&quot;3&quot;);        Chopstick c4 = new Chopstick(&quot;4&quot;);        Chopstick c5 = new Chopstick(&quot;5&quot;);        new Philosopher(&quot;潘&quot;,c1,c2).start();        new Philosopher(&quot;王&quot;,c2,c3).start();        new Philosopher(&quot;李&quot;,c3,c4).start();        new Philosopher(&quot;张&quot;,c4,c5).start();        new Philosopher(&quot;韩&quot;,c5,c1).start();    &#125;    Philosopher(String name,Chopstick left,Chopstick right)&#123;        super(name);        this.left=left;        this.right=right;    &#125;    @Override    public void run() &#123;        while (true)&#123;            if (left.tryLock()) &#123;                try &#123;                    if(right.tryLock())&#123;                        try &#123;                            eating();                        &#125;finally &#123;                            right.unlock();                        &#125;                    &#125;                &#125;finally &#123;                    left.unlock();                &#125;            &#125;        &#125;    &#125;    private void eating()&#123;        log.debug(&quot;正在吃饭&quot;);        Sleeper.sleep(1000);    &#125;&#125;class Chopstick extends ReentrantLock &#123;    String name;    public Chopstick(String name) &#123;        this.name = name;    &#125;    @Override    public String toString() &#123;        return &quot;Chopstick&#123;&quot; +                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +                &#39;&#125;&#39;;    &#125;&#125;</code></pre><h4 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h4><p>ReentrantLock 默认是不公平的</p><pre><code class="java">ReentrantLock lock = new ReentrantLock(false);lock.lock();for (int i = 0; i &lt; 500; i++) &#123; new Thread(() -&gt; &#123;     lock.lock();     try &#123;         System.out.println(Thread.currentThread().getName() + &quot; running...&quot;);     &#125; finally &#123;         lock.unlock();     &#125;     &#125;, &quot;t&quot; + i).start();&#125;// 1s 之后去争抢锁Thread.sleep(1000);new Thread(() -&gt; &#123;     System.out.println(Thread.currentThread().getName() + &quot; start...&quot;);         lock.lock();     try &#123;         System.out.println(Thread.currentThread().getName() + &quot; running...&quot;);     &#125; finally &#123;         lock.unlock();     &#125;&#125;, &quot;强行插入&quot;).start();lock.unlock();</code></pre><p>强行插入，有机会在中间输出</p><blockquote><p>不一定总能出现这种结果</p></blockquote><p>改为公平锁后</p><pre><code class="java">ReentrantLock lock = new ReentrantLock(true);</code></pre><p>强行插入，总是在最后输出</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221126195741896.png" alt="image-20221126195741896"></p><p>公平锁一般没有必要，会降低并发度</p><h4 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h4><p>synchronized 中也有条件变量，就是我们讲原理时那个 waitSet 休息室，当条件不满足时进入 waitSet 等待 ReentrantLock 的条件变量比 synchronized 强大之处在于，它是支持多个条件变量的，这就好比</p><ul><li>synchronized 是那些不满足条件的线程都在一间休息室等消息</li><li>而 ReentrantLock 支持多间休息室，有专门等烟的休息室、专门等早餐的休息室、唤醒时也是按休息室来唤 醒</li></ul><p>使用要点：</p><ul><li><p>await 前需要获得锁 </p></li><li><p>await 执行后，会释放锁，进入 conditionObject 等待 </p></li><li><p>await 的线程被唤醒（或打断、或超时）取重新竞争 lock 锁</p></li></ul><ul><li>竞争 lock 锁成功后，从 await 后继续执行</li></ul><p>例子：</p><pre><code class="java">@Slf4jpublic class testLockCondition &#123;    static ReentrantLock lock=new ReentrantLock();    static Condition waitCigaretteQueue=lock.newCondition();    static Condition waitTakeoutQueue=lock.newCondition();    static boolean haCi=false;    static boolean hasTa=false;    public static void main(String[] args) &#123;        Thread t1 = new Thread(() -&gt; &#123;            lock.lock();            try &#123;                while (!haCi)&#123;                    log.debug(&quot;没烟,在等烟&quot;);                    try &#123;                        waitCigaretteQueue.await();                    &#125; catch (InterruptedException e) &#123;                        e.printStackTrace();                    &#125;                &#125;                log.debug(&quot;等到了烟&quot;);            &#125;finally &#123;                lock.unlock();            &#125;        &#125;, &quot;t1&quot;);        t1.start();        new Thread(()-&gt;&#123;            lock.lock();            try &#123;                while (!hasTa)&#123;                    log.debug(&quot;在等外卖&quot;);                    try &#123;                        waitTakeoutQueue.await();                    &#125; catch (InterruptedException e) &#123;                        e.printStackTrace();                    &#125;                &#125;                log.debug(&quot;等到了外卖&quot;);            &#125;finally &#123;                lock.unlock();            &#125;        &#125;).start();        Sleeper.sleep(100);        sendBreakfast();        Sleeper.sleep(100);        sendCigarette();    &#125;    private static void sendCigarette() &#123;        lock.lock();        try &#123;            log.debug(&quot;送烟来了&quot;);            haCi = true;            waitCigaretteQueue.signal();        &#125; finally &#123;            lock.unlock();        &#125;    &#125;    private static void sendBreakfast() &#123;        lock.lock();        try &#123;            log.debug(&quot;送早餐来了&quot;);            hasTa = true;            waitTakeoutQueue.signal();        &#125; finally &#123;            lock.unlock();        &#125;    &#125;&#125;</code></pre><p>输出:</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221126200121559.png" alt="image-20221126200121559"></p><h4 id="设计模式之顺序控制"><a href="#设计模式之顺序控制" class="headerlink" title="设计模式之顺序控制"></a>设计模式之顺序控制</h4><h5 id="严格串行执行"><a href="#严格串行执行" class="headerlink" title="严格串行执行:"></a>严格串行执行:</h5><p>指定线程运行的顺序,比如先执行t2的结果,再执行t1的结果</p><h6 id="第一种方式–-synchronized方式"><a href="#第一种方式–-synchronized方式" class="headerlink" title="第一种方式–&gt;synchronized方式:"></a>第一种方式–&gt;synchronized方式:</h6><pre><code class="java">@Slf4jpublic class testOrder1 &#123;    static final Object lock=new Object();    static boolean t2Run=false;    public static void main(String[] args) &#123;        new Thread(()-&gt;&#123;            synchronized (lock)&#123;                while (!t2Run)&#123;                    try &#123;                        lock.wait();                    &#125; catch (InterruptedException e) &#123;                        e.printStackTrace();                    &#125;                &#125;                log.debug(&quot;1&quot;);            &#125;        &#125;,&quot;t1&quot;).start();        new Thread(()-&gt;&#123;            synchronized (lock)&#123;                log.debug(&quot;2&quot;);                t2Run=true;                lock.notifyAll();            &#125;        &#125;,&quot;t2&quot;).start();    &#125;&#125;</code></pre><h6 id="第二种方式–-ReentrantLock方式"><a href="#第二种方式–-ReentrantLock方式" class="headerlink" title="第二种方式–&gt;ReentrantLock方式"></a>第二种方式–&gt;ReentrantLock方式</h6><p>利用ReentrantLock的condition:</p><pre><code class="java">@Slf4jpublic class testOrder2 &#123;    static boolean isRun=false;    static ReentrantLock lock=new ReentrantLock();    static Condition condition = lock.newCondition();    public static void main(String[] args) &#123;        new Thread(()-&gt;&#123;           lock.lock();           while (!isRun)&#123;               try &#123;                   condition.await();               &#125; catch (InterruptedException e) &#123;                   e.printStackTrace();               &#125;finally &#123;                   lock.unlock();               &#125;           &#125;            log.debug(&quot;1&quot;);        &#125;,&quot;t1&quot;).start();        new Thread(()-&gt;&#123;            lock.lock();            try &#123;                log.debug(&quot;2&quot;);                isRun=true;                condition.signal();            &#125;finally &#123;                lock.unlock();            &#125;        &#125;,&quot;t2&quot;).start();    &#125;&#125;</code></pre><h6 id="第三种方式–-利用LockSupport的park和unPark方法"><a href="#第三种方式–-利用LockSupport的park和unPark方法" class="headerlink" title="第三种方式–&gt;利用LockSupport的park和unPark方法:"></a>第三种方式–&gt;利用LockSupport的park和unPark方法:</h6><pre><code class="java">@Slf4jpublic class testOrder3 &#123;    public static void main(String[] args) &#123;        Thread t1 = new Thread(() -&gt; &#123;            LockSupport.park();            log.debug(&quot;1&quot;);        &#125;, &quot;t1&quot;);        t1.start();        new Thread(()-&gt;&#123;            log.debug(&quot;2&quot;);            LockSupport.unpark(t1);        &#125;).start();    &#125;&#125;</code></pre><h5 id="指定顺序交替执行"><a href="#指定顺序交替执行" class="headerlink" title="指定顺序交替执行:"></a>指定顺序交替执行:</h5><h6 id="第一种方式–-wait和notify实现"><a href="#第一种方式–-wait和notify实现" class="headerlink" title="第一种方式–&gt;wait和notify实现"></a>第一种方式–&gt;wait和notify实现</h6><pre><code class="java">@Slf4jpublic class testOrder4 &#123;    public static void main(String[] args) &#123;        WaitNotify wn=new WaitNotify(1,2);         new Thread(() -&gt; &#123;             try &#123;                 wn.print(&quot;a&quot;,1,2);             &#125; catch (InterruptedException e) &#123;                 e.printStackTrace();             &#125;         &#125;).start();        new Thread(() -&gt; &#123;            try &#123;                wn.print(&quot;b&quot;,2,3);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;).start();        new Thread(() -&gt; &#123;            try &#123;                wn.print(&quot;c&quot;,3,1);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;).start();    &#125;&#125;class WaitNotify&#123;    public void print(String str,int waitFlag,int nextFlag) throws InterruptedException &#123;        for (int i = 0; i &lt; loopCount; i++) &#123;            synchronized (this)&#123;                while (flag!=waitFlag)&#123;                    this.wait();                &#125;                System.out.print(str);                flag=nextFlag;                this.notifyAll();            &#125;        &#125;    &#125;    private int flag;    private int loopCount;    WaitNotify(int flag,int loopCount)&#123;        this.flag=flag;        this.loopCount=loopCount;    &#125;&#125;</code></pre><h6 id="第二种方式–-ReentrantLock的condition实现"><a href="#第二种方式–-ReentrantLock的condition实现" class="headerlink" title="第二种方式–&gt;ReentrantLock的condition实现"></a>第二种方式–&gt;ReentrantLock的condition实现</h6><pre><code class="java">@Slf4jpublic class testOrder5 &#123;    public static void main(String[] args) throws InterruptedException &#123;        awaitSignal as=new awaitSignal(5);        Condition condition1 = as.newCondition();        Condition condition2 = as.newCondition();        Condition condition3 = as.newCondition();        new Thread(()-&gt;&#123;            as.print(&quot;a&quot;,condition1,condition2);        &#125;,&quot;t1&quot;).start();        new Thread(()-&gt;&#123;            as.print(&quot;b&quot;,condition2,condition3);        &#125;,&quot;t2&quot;).start();        new Thread(()-&gt;&#123;            as.print(&quot;c&quot;,condition3,condition1);        &#125;,&quot;t3&quot;).start();        Thread.sleep(1000);        as.lock();       try&#123;           condition1.signal();       &#125;finally &#123;           as.unlock();       &#125;    &#125;&#125;class awaitSignal extends ReentrantLock &#123;    private int loopNum;    awaitSignal(int loopNum)&#123;        this.loopNum=loopNum;    &#125;    public void print(String str,Condition condition,Condition next)&#123;        for (int i = 0; i &lt; loopNum; i++) &#123;            lock();            try &#123;                condition.await();                System.out.print(str);                next.signal();            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125; finally &#123;                unlock();            &#125;        &#125;    &#125;&#125;</code></pre><h6 id="第三种方式–-park和unPark实现"><a href="#第三种方式–-park和unPark实现" class="headerlink" title="第三种方式–&gt;park和unPark实现"></a>第三种方式–&gt;park和unPark实现</h6><pre><code class="java">@Slf4jpublic class testOrder6 &#123;    static Thread t1;    static Thread t2;    static Thread t3;    public static void main(String[] args) &#123;        parkUnpark pu=new parkUnpark(5);        t1 = new Thread(() -&gt; &#123;            pu.print(&quot;a&quot;,t2);        &#125;);         t2 = new Thread(() -&gt; &#123;            pu.print(&quot;b&quot;,t3);        &#125;);         t3 = new Thread(() -&gt; &#123;            pu.print(&quot;c&quot;,t1);        &#125;);         t1.start();         t2.start();         t3.start();        LockSupport.unpark(t1);    &#125;&#125;class parkUnpark&#123;    public void print(String str,Thread next)&#123;        for (int i = 0; i &lt; loopNum; i++) &#123;            LockSupport.park();            System.out.print(str);            LockSupport.unpark(next);        &#125;    &#125;    private  int loopNum;    public parkUnpark(int loopNum) &#123;        this.loopNum = loopNum;    &#125;&#125;</code></pre><h3 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h3><p> 本章我们需要重点掌握的是 </p><ul><li><p>分析多线程访问共享资源时，哪些代码片段属于临界区</p></li><li><p>使用 synchronized 互斥解决临界区的线程安全问题 </p><ul><li>掌握 synchronized 锁对象语法 </li><li>掌握 synchronzied 加载成员方法和静态方法语法 </li><li>掌握 wait&#x2F;notify 同步方法</li></ul></li><li><p>使用 lock 互斥解决临界区的线程安全问题</p><ul><li>掌握 lock 的使用细节：可打断、锁超时、公平锁、条件变量</li></ul></li><li><p>学会分析变量的线程安全性、掌握常见线程安全类的使用 </p></li><li><p>了解线程活跃性问题：死锁、活锁、饥饿 </p></li><li><p>应用方面 </p><ul><li>互斥：使用 synchronized 或 Lock 达到共享资源互斥效果 </li><li>同步：使用 wait&#x2F;notify 或 Lock 的条件变量来达到线程间通信效果</li></ul></li><li><p>原理方面 </p><ul><li>monitor、synchronized 、wait&#x2F;notify 原理 </li><li>synchronized 进阶原理 </li><li>park &amp; unpark 原理</li></ul></li><li><p>模式方面</p><ul><li>同步模式之保护性暂停</li><li>异步模式之生产者消费者 </li><li>同步模式之顺序控制</li></ul></li></ul><hr><h2 id="5-共享模型之内存"><a href="#5-共享模型之内存" class="headerlink" title="5.共享模型之内存"></a>5.共享模型之内存</h2><p>上一章的 Monitor 主要关注的是访问共享变量时，保证临界区代码的原子性,这一章将要进一步深入学习共享变量在多线程间的【<strong>可见性</strong>】问题与多条指令执行时的【<strong>有序性</strong>】问题.</p><h3 id="5-1-Java内存模型-Java-Memory-Model或JMM"><a href="#5-1-Java内存模型-Java-Memory-Model或JMM" class="headerlink" title="5.1 Java内存模型( Java Memory Model或JMM)"></a>5.1 Java内存模型( Java Memory Model或JMM)</h3><p>ava 内存模型是 Java Memory Model（JMM），本身是一种<strong>抽象的概念</strong>，实际上并不存在，描述的是一组规则或规范，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式</p><p>JMM作用:</p><ul><li>屏蔽各种硬件和操作系统的内存访问差异，实现让 Java 程序在各种平台下都能达到一致的内存访问效果</li><li>规定了线程和内存之间的一些关系</li></ul><p>根据 JMM 的设计，系统存在一个主内存（Main Memory），Java 中<strong>所有变量</strong>都存储在主存中，<strong>对于所有线程都是共享的；每条线程都有自己的工作内存（Working Memory）</strong>，工作内存中保存的是主存中某些<strong>变量的拷贝</strong>，线程对所有变量的操作都是先对变量进行拷贝，然后在工作内存中进行，不能直接操作主内存中的变量；<strong>线程之间无法相互直接访问，</strong>线程间的通信（传递）必须通过主内存来完成</p><p><img src="https://gitee.com/DylanToT99/images/raw/b2afc01be0cc893bccbcff37628ab9a94f1ae333/images/image-20221201171921822.png" alt="images/image-20221201171921822.png  0 → 100644"></p><p>主内存和工作内存：</p><ul><li>主内存：计算机的内存，也就是经常提到的 8G 内存，16G 内存，存储所有共享变量的值</li><li>工作内存：存储该线程使用到的共享变量在主内存的的值的副本拷贝</li></ul><h4 id="JVM-和-JMM-之间的关系："><a href="#JVM-和-JMM-之间的关系：" class="headerlink" title="JVM 和 JMM 之间的关系："></a><strong>JVM 和 JMM 之间的关系</strong>：</h4><p>JMM 中的主内存、工作内存与 JVM 中的 Java 堆、栈、方法区等并不是同一个层次的内存划分，这两者基本上是没有关系的，如果两者一定要勉强对应起来：</p><ul><li>主内存主要对应于 Java 堆中的对象实例数据部分，而工作内存则对应于虚拟机栈中的部分区域</li><li>从更低层次上说，主内存直接对应于物理硬件的内存，工作内存对应寄存器和高速缓存</li></ul><h3 id="5-2-可见性"><a href="#5-2-可见性" class="headerlink" title="5.2 可见性"></a>5.2 可见性</h3><h4 id="退不出的循环"><a href="#退不出的循环" class="headerlink" title="退不出的循环"></a><strong>退不出的循环</strong></h4><p>先看一个例子:</p><pre><code class="java">@Slf4jpublic class test1 &#123;    static boolean run=true;    public static void main(String[] args) &#123;        Thread t1 = new Thread(() -&gt; &#123;            while (run) &#123;            &#125;        &#125;, &quot;t1&quot;);        t1.start();        Sleeper.sleep(1);        run=false;  //虽然设置run为false但是还是无法停止    &#125;&#125;</code></pre><p>这个线程无法停止</p><p>这是因为:</p><p> 1.初始状态,t1线程从主存中读取了run的值到工作内存</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221201172711889.png" alt="image-20221201172711889"></p><p> 2.因为 t 1线程要频繁从主内存中读取 run 的值，JIT 编译器会将 run 的值缓存至自己工作内存中的高速缓存中，</p><p>减少对主存中 run 的访问，提高效率.</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221201172746055.png" alt="image-20221201172746055"></p><ol start="3"><li>1 秒之后，main 线程修改了 run 的值，并同步至主存，而 t 1是从自己工作内存中的高速缓存中读取这个变量</li></ol><p>   的值，结果永远是旧值</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221201172824186.png" alt="image-20221201172824186"></p><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a><strong>解决方法</strong></h4><p>volatile（易变关键字）</p><p>它可以用来修饰成员变量和静态成员变量，他可以避免线程从自己的工作缓存中查找变量的值，<strong>必须到主存中获取</strong></p><p>它的值，<strong>线程操作 volatile 变量都是直接操作主存</strong></p><h4 id="可见性vs原子性"><a href="#可见性vs原子性" class="headerlink" title="可见性vs原子性"></a>可见性vs原子性</h4><p>前面例子体现的实际就是可见性，它保证的是在多个线程之间，一个线程对 volatile 变量的修改对另一个线程可</p><p>见， 不能保证原子性，仅用在一个写线程，多个读线程的情况： </p><p>上例从字节码理解是这样的：</p><pre><code class="java">getstatic run // 线程 t 获取 run true getstatic run // 线程 t 获取 run true getstatic run // 线程 t 获取 run true getstatic run // 线程 t 获取 run true putstatic run // 线程 main 修改 run 为 false， 仅此一次getstatic run // 线程 t 获取 run false </code></pre><p>比较一下之前我们将线程安全时举的例子：两个线程一个 i++ 一个 i– ，只能保证看到最新值，不能解决指令交错</p><pre><code class="java">// 假设i的初始值为0 getstatic i // 线程2-获取静态变量i的值 线程内i=0 getstatic i // 线程1-获取静态变量i的值 线程内i=0 iconst_1 // 线程1-准备常量1 iadd // 线程1-自增 线程内i=1 putstatic i // 线程1-将修改后的值存入静态变量i 静态变量i=1 iconst_1 // 线程2-准备常量1 isub // 线程2-自减 线程内i=-1 putstatic i // 线程2-将修改后的值存入静态变量i 静态变量i=-1</code></pre><blockquote><p><strong>注意</strong> synchronized 语句块既可以保证代码块的原子性，也同时保证代码块内变量的可见性。但缺点是</p><p>synchronized 是属于重量级操作，性能相对更低</p><p>如果在前面示例的死循环中加入 System.out.println() 会发现即使不加 volatile 修饰符，线程 t 也能正确看到</p><p>对 run 变量的修改了，想一想为什么？</p><p>是因为System.out.println()源码加了synchronized(),上锁则会导致工作内存刷新,线程需要重新去主内存中取</p></blockquote><h4 id="设计模式之终止模式"><a href="#设计模式之终止模式" class="headerlink" title="设计模式之终止模式"></a>设计模式之终止模式</h4><p>​终止模式之两阶段终止模式：停止标记用 volatile 是为了保证该变量在多个线程之间的可见性</p><pre><code class="java">class TwoPhaseTermination &#123;    // 监控线程    private Thread monitor;    // 停止标记    private volatile boolean stop = false;;    // 启动监控线程    public void start() &#123;        monitor = new Thread(() -&gt; &#123;            while (true) &#123;                Thread thread = Thread.currentThread();                if (stop) &#123;                    System.out.println(&quot;后置处理&quot;);                    break;                &#125;                try &#123;                    Thread.sleep(1000);// 睡眠                    System.out.println(thread.getName() + &quot;执行监控记录&quot;);                &#125; catch (InterruptedException e) &#123;                       System.out.println(&quot;被打断，退出睡眠&quot;);                &#125;            &#125;        &#125;);        monitor.start();    &#125;    // 停止监控线程    public void stop() &#123;        stop = true;        monitor.interrupt();// 让线程尽快退出Timed Waiting    &#125;&#125;// 测试public static void main(String[] args) throws InterruptedException &#123;    TwoPhaseTermination tpt = new TwoPhaseTermination();    tpt.start();    Thread.sleep(3500);    System.out.println(&quot;停止监控&quot;);    tpt.stop();&#125;</code></pre><h4 id="设计模式之犹豫模式-balking"><a href="#设计模式之犹豫模式-balking" class="headerlink" title="设计模式之犹豫模式(balking)"></a>设计模式之犹豫模式(balking)</h4><p>Balking （犹豫）模式用在一个线程发现另一个线程或本线程已经做了某一件相同的事，那么本线程就无需再做了，直接结束返回</p><pre><code class="java">public class MonitorService &#123;    // 用来表示是否已经有线程已经在执行启动了    private volatile boolean starting = false;    public void start() &#123;        System.out.println(&quot;尝试启动监控线程...&quot;);        synchronized (this) &#123;            if (starting) &#123;                return;            &#125;            starting = true;        &#125;        // 真正启动监控线程...    &#125;&#125;</code></pre><p>对比保护性暂停模式：保护性暂停模式用在一个线程等待另一个线程的执行结果，当条件不满足时线程等待</p><p>例子：希望 doInit() 方法仅被调用一次，下面的实现出现的问题：</p><ul><li>当 t1 线程进入 init() 准备 doInit()，t2 线程进来，initialized 还为false，则 t2 就又初始化一次</li><li>volatile 适合一个线程写，其他线程读的情况，这个代码需要加锁</li></ul><pre><code class="java">public class TestVolatile &#123;    volatile boolean initialized = false;        void init() &#123;        if (initialized) &#123;            return;        &#125;        doInit();        initialized = true;    &#125;    private void doInit() &#123;    &#125;&#125;</code></pre><h3 id="5-3-有序性"><a href="#5-3-有序性" class="headerlink" title="5.3 有序性"></a>5.3 有序性</h3><h4 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h4><p><strong>有序性</strong>：在本线程内观察，所有操作都是有序的；在一个线程观察另一个线程，所有操作都是无序的，无序是因为发生了指令重排序</p><p>CPU 的基本工作是执行存储的指令序列，即程序，程序的执行过程实际上是不断地<strong>取出指令</strong>、<strong>分析指令</strong>、<strong>执行指令</strong>的过程，为了提高性能，编译器和处理器会对指令重排，一般分为以下三种：</p><blockquote><p>源代码 -&gt; 编译器优化的重排 -&gt; 指令并行的重排 -&gt; 内存系统的重排 -&gt; 最终执行指令</p></blockquote><p>现代 CPU 支持多级指令流水线，几乎所有的冯•诺伊曼型计算机的 CPU，其工作都可以分为 5 个阶段：取指令、指令译码、执行指令、访存取数和结果写回，可以称之为<strong>五级指令流水线</strong>。CPU 可以在一个时钟周期内，同时运行五条指令的<strong>不同阶段</strong>（每个线程不同的阶段），本质上流水线技术并不能缩短单条指令的执行时间，但变相地提高了指令地吞吐率</p><p>处理器在进行重排序时，必须要考虑<strong>指令之间的数据依赖性</strong></p><ul><li>单线程环境也存在指令重排，由于存在依赖性，最终执行结果和代码顺序的结果一致</li><li>多线程环境中线程交替执行，由于编译器优化重排，会获取其他线程处在不同阶段的指令同时执行</li></ul><p>补充知识：</p><ul><li>指令周期是取出一条指令并执行这条指令的时间，一般由若干个机器周期组成</li><li>机器周期也称为 CPU 周期，一条指令的执行过程划分为若干个阶段（如取指、译码、执行等），每一阶段完成一个基本操作，完成一个基本操作所需要的时间称为机器周期</li><li>振荡周期指周期性信号作周期性重复变化的时间间隔</li></ul><h4 id="java层面"><a href="#java层面" class="headerlink" title="java层面"></a>java层面</h4><p>JVM 会在不影响正确性的前提下，可以调整语句的执行顺序，思考下面一段代码</p><pre><code class="java">static int i;static int j;// 在某个线程内执行如下赋值操作i = ...;j = ...; </code></pre><p>可以看到，至于是先执行 i 还是 先执行 j ，对最终的结果不会产生影响。所以，上面代码真正执行时，既可以是</p><pre><code class="java">i = ...;j = ...;</code></pre><p>也可以是</p><pre><code class="java">j = ...;i = ...; </code></pre><h4 id="诡异的结果"><a href="#诡异的结果" class="headerlink" title="诡异的结果"></a>诡异的结果</h4><pre><code class="java">int num = 0;boolean ready = false;// 线程1 执行此方法public void actor1(I_Result r) &#123;     if(ready) &#123;         r.r1 = num + num;     &#125; else &#123;         r.r1 = 1;     &#125;&#125;// 线程2 执行此方法public void actor2(I_Result r) &#123;     num = 2;     ready = true;&#125;</code></pre><p>I_Result 是一个对象，有一个属性 r1 用来保存结果，问，可能的结果有几种？</p><p> 有人这么分析 </p><p>情况1：线程1 先执行，这时 ready &#x3D; false，所以进入 else 分支结果为 1</p><p> 情况2：线程2 先执行 num &#x3D; 2，但没来得及执行 ready &#x3D; true，线程1 执行，还是进入 else 分支，结果为1</p><p> 情况3：线程2 执行到 ready &#x3D; true，线程1 执行，这回进入 if 分支，结果为 4（因为 num 已经执行过了） </p><p>但我告诉你，结果还有可能是 0 😁😁😁，信不信吧！ 这种情况下是：线程2 执行 ready &#x3D; true，切换到线程1，进入 if 分支，相加为 0，再切回线程2 执行 num &#x3D; 2 相信很多人已经晕了 😵😵�</p><p>这种现象叫做指令重排，是 <strong>JIT 编译器</strong>在运行时的一些优化，这个现象需要通过大量测试才能复现： 借助 java 并发压测工具 jcstress <a href="https://wiki.openjdk.java.net/display/CodeTools/jcstress">https://wiki.openjdk.java.net/display/CodeTools/jcstress</a></p><p>创建 maven 项目，</p><p>依赖:</p><pre><code class="xml">  &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.openjdk.jcstress&lt;/groupId&gt;            &lt;artifactId&gt;jcstress-core&lt;/artifactId&gt;            &lt;version&gt;0.14&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;</code></pre><p>提供如下测试类</p><pre><code class="java">@JCStressTest@State@Outcome(id = &#123;&quot;1&quot;, &quot;4&quot;&#125;, expect = Expect.ACCEPTABLE, desc = &quot;这是期待的结果&quot;)@Outcome(id = &quot;0&quot;, expect = Expect.ACCEPTABLE_INTERESTING, desc = &quot;这是不期待的结果&quot;)public class test1 &#123;    /**     * 结果有三种可能 4， 1，0(这个0是因为指令重排）     */    private int a = 0;    private boolean flag = false;    @Actor    public void method(I_Result result) &#123;        if (flag) &#123;            result.r1 = a * 2;        &#125; else &#123;            result.r1 = 1;        &#125;    &#125;    @Actor    public void method2(I_Result result) &#123;        a = 2;               //这个地方有可能会发生指令重排，也就是a=2和flag=true互换        flag = true;    &#125;&#125;</code></pre><p>配置运行环境:</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221209172327260.png" alt="image-20221209172327260"></p><p>运行结果可以直观地在控制台上看到:</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221209172427466.png" alt="image-20221209172427466"></p><p>也可以在输出的result文件夹中看到:</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221209172536276.png" alt="image-20221209172536276"></p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221209172812034.png" alt="image-20221209172812034"></p><h4 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h4><p>volatile 修饰的变量，可以禁用指令重排</p><pre><code class="java">@JCStressTest@State@Outcome(id = &#123;&quot;1&quot;, &quot;4&quot;&#125;, expect = Expect.ACCEPTABLE, desc = &quot;这是期待的结果&quot;)@Outcome(id = &quot;0&quot;, expect = Expect.ACCEPTABLE_INTERESTING, desc = &quot;这是不期待的结果&quot;)public class test1 &#123;    /**     * 结果有三种可能 4， 1，0(这个0是因为指令重排）     */    private int a = 0;    private volatile boolean flag = false;    @Actor    public void method(I_Result result) &#123;        if (flag) &#123;            result.r1 = a * 2;        &#125; else &#123;            result.r1 = 1;        &#125;    &#125;    @Actor    public void method2(I_Result result) &#123;        a = 2;               //这个地方有可能会发生指令重排，也就是a=2和flag=true互换        flag = true;    &#125;&#125;</code></pre><p>运行结果:</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221209173232787.png" alt="image-20221209173232787"></p><h3 id="5-4-volatile原理"><a href="#5-4-volatile原理" class="headerlink" title="5.4 volatile原理"></a>5.4 volatile原理</h3><h4 id="同步机制"><a href="#同步机制" class="headerlink" title="同步机制"></a>同步机制</h4><p>volatile 是 Java 虚拟机提供的<strong>轻量级</strong>的同步机制（三大特性）</p><ul><li>保证可见性</li><li>不保证原子性</li><li>保证有序性（禁止指令重排）</li></ul><p>性能：volatile 修饰的变量进行读操作与普通变量几乎没什么差别，但是写操作相对慢一些，因为需要在本地代码中插入很多内存屏障来<strong>保证指令不会发生乱序执行</strong>，但是开销比锁要小</p><p>synchronized 无法禁止指令重排和处理器优化，为什么可以保证有序性可见性</p><ul><li>加了锁之后，只能有一个线程获得到了锁，获得不到锁的线程就要阻塞，所以同一时间只有一个线程执行，相当于单线程，由于数据依赖性的存在，单线程的指令重排是没有问题的</li><li>线程加锁前，将<strong>清空工作内存</strong>中共享变量的值，使用共享变量时需要从主内存中重新读取最新的值；线程解锁前，必须把共享变量的最新值<strong>刷新到主内存</strong>中（JMM 内存交互章节有讲）</li></ul><h4 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h4><h5 id="缓存一致"><a href="#缓存一致" class="headerlink" title="缓存一致"></a>缓存一致</h5><p>使用 volatile 修饰的共享变量，总线会开启 <strong>CPU 总线嗅探机制</strong>来解决 JMM 缓存一致性问题，也就是共享变量在多线程中可见性的问题，实现 MESI 缓存一致性协议</p><p>底层是通过汇编 lock 前缀指令，共享变量加了 lock 前缀指令就会进行缓存锁定，在线程修改完共享变量后写回主存，其他的 CPU 核心上运行的线程根据总线嗅探机制会修改其共享变量为失效状态，读取时会重新从主内存中读取最新的数据</p><p>lock 前缀指令就相当于内存屏障，Memory Barrier（Memory Fence）</p><ul><li>对 volatile 变量的写指令后会加入写屏障</li><li>对 volatile 变量的读指令前会加入读屏障</li></ul><p>内存屏障有三个作用：</p><ul><li>确保对内存的读-改-写操作原子执行</li><li><strong>阻止屏障两侧的指令重排序</strong></li><li>强制把缓存中的脏数据写回主内存，让缓存行中相应的数据失效</li></ul><h5 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h5><p>保证<strong>可见性</strong>：</p><ul><li><p>写屏障（sfence，Store Barrier）保证在该屏障之前的，对共享变量的改动，都同步到主存当中</p><pre><code class="java">public void actor2(I_Result r) &#123;    num = 2;    ready = true; // ready 是 volatile 赋值带写屏障    // 写屏障&#125;</code></pre></li><li><p>读屏障（lfence，Load Barrier）保证在该屏障之后的，对共享变量的读取，从主存刷新变量值，加载的是主存中最新数据</p><pre><code class="java">public void actor1(I_Result r) &#123;    // 读屏障    // ready 是 volatile 读取值带读屏障    if(ready) &#123;        r.r1 = num + num;    &#125; else &#123;        r.r1 = 1;    &#125;&#125;</code></pre></li></ul><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221209191936046.png" alt="image-20221209191936046"></p><ul><li>全能屏障：mfence（modify&#x2F;mix Barrier），兼具 sfence 和 lfence 的功能</li></ul><p>保证<strong>有序性</strong>：</p><ul><li>写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后</li><li>读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前</li></ul><p>不能解决指令交错：</p><ul><li>写屏障仅仅是保证之后的读能够读到最新的结果，但不能保证其他线程的读跑到写屏障之前</li><li>有序性的保证也只是保证了本线程内相关代码不被重排序</li></ul><pre><code class="java">volatile i = 0;new Thread(() -&gt; &#123;i++&#125;);new Thread(() -&gt; &#123;i--&#125;);</code></pre><p>i++ 反编译后的指令：</p><pre><code class="dylan">0: iconst_1// 当int取值 -1~5 时，JVM采用iconst指令将常量压入栈中1: istore_1// 将操作数栈顶数据弹出，存入局部变量表的 slot 12: iinc1, 1</code></pre><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221209192411625.png" alt="image-20221209192411625"></p><h5 id="交互规则"><a href="#交互规则" class="headerlink" title="交互规则"></a>交互规则</h5><p>对于 volatile 修饰的变量：</p><ul><li>线程对变量的 use 与 load、read 操作是相关联的，所以变量使用前必须先从主存加载</li><li>线程对变量的 assign 与 store、write 操作是相关联的，所以变量使用后必须同步至主存</li><li>线程 1 和线程 2 谁先对变量执行 read 操作，就会先进行 write 操作，防止指令重排</li></ul><h4 id="双端检锁"><a href="#双端检锁" class="headerlink" title="双端检锁"></a>双端检锁</h4><h5 id="检锁机制"><a href="#检锁机制" class="headerlink" title="检锁机制"></a>检锁机制</h5><p><strong>Double-Checked Locking</strong>：双端检锁机制</p><p>DCL（双端检锁）机制不一定是线程安全的，原因是有指令重排的存在，加入 volatile 可以禁止指令重排</p><pre><code class="java">public final class Singleton &#123;    private Singleton() &#123; &#125;    private static Singleton INSTANCE = null;        public static Singleton getInstance() &#123;        if(INSTANCE == null) &#123; // t2，这里的判断不是线程安全的            // 首次访问会同步，而之后的使用没有 synchronized            synchronized(Singleton.class) &#123;                // 这里是线程安全的判断，防止其他线程在当前线程等待锁的期间完成了初始化                if (INSTANCE == null) &#123;                     INSTANCE = new Singleton();                &#125;            &#125;        &#125;        return INSTANCE;    &#125;&#125;</code></pre><p>不锁 INSTANCE 的原因：</p><ul><li>INSTANCE 要重新赋值</li><li>INSTANCE 是 null，线程加锁之前需要获取对象的引用，设置对象头，null 没有引用</li></ul><p>实现特点：</p><ul><li>懒惰初始化</li><li>首次使用 getInstance() 才使用 synchronized 加锁，后续使用时无需加锁</li><li>第一个 if 使用了 INSTANCE 变量，是在同步块之外，但在多线程环境下会产生问题</li></ul><h5 id="DCL问题"><a href="#DCL问题" class="headerlink" title="DCL问题"></a>DCL问题</h5><p>getInstance 方法对应的字节码为</p><pre><code class="dylan">0: getstatic #2 // Field INSTANCE:Ltest/Singleton;3: ifnonnull 376: ldc #3 // class test/Singleton8: dup9: astore_010: monitorenter11: getstatic #2 // Field INSTANCE:Ltest/Singleton;14: ifnonnull 2717: new #3 // class test/Singleton20: dup21: invokespecial #4 // Method &quot;&lt;init&gt;&quot;:()V24: putstatic #2 // Field INSTANCE:Ltest/Singleton;27: aload_028: monitorexit29: goto 3732: astore_133: aload_034: monitorexit35: aload_136: athrow37: getstatic #2 // Field INSTANCE:Ltest/Singleton;40: areturn</code></pre><ul><li>17 表示创建对象，将对象引用入栈</li><li>20 表示复制一份对象引用，引用地址</li><li>21 表示利用一个对象引用，调用构造方法初始化对象</li><li>24 表示利用一个对象引用，赋值给 static INSTANCE</li></ul><p><strong>步骤 21 和 24 之间不存在数据依赖关系</strong>，而且无论重排前后，程序的执行结果在单线程中并没有改变，因此这种重排优化是允许的</p><ul><li>关键在于 0:getstatic 这行代码在 monitor 控制之外，可以越过 monitor 读取 INSTANCE 变量的值</li><li>当其他线程访问 INSTANCE 不为 null 时，由于 INSTANCE 实例未必已初始化，那么 t2 拿到的是将是一个未初始化完毕的单例返回，这就造成了线程安全的问题</li></ul><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221209192631467.png" alt="image-20221209192631467"></p><h5 id="解决方法-2"><a href="#解决方法-2" class="headerlink" title="解决方法"></a>解决方法</h5><p>指令重排只会保证串行语义的执行一致性（单线程），但并不会关系多线程间的语义一致性</p><p>引入 volatile，来保证出现指令重排的问题，从而保证单例模式的线程安全性：</p><pre><code class="java">private static volatile SingletonDemo INSTANCE = null;</code></pre><h4 id="happens-before-先行发生规则"><a href="#happens-before-先行发生规则" class="headerlink" title="happens-before 先行发生规则"></a>happens-before 先行发生规则</h4><p>Java 内存模型具备一些先天的“有序性”，即不需要通过任何同步手段（volatile、synchronized 等）就能够得到保证的安全，这个通常也称为 happens-before 原则，它是可见性与有序性的一套规则总结</p><p>抛开以下 happens-before 规则，JMM 并不能保证一个线程的可见性和有序性</p><ol><li><p>程序次序规则 (Program Order Rule)：一个线程内，逻辑上书写在前面的操作先行发生于书写在后面的操作 ，因为多个操作之间有先后依赖关系，则不允许对这些操作进行重排序</p></li><li><p>锁定规则 (Monitor Lock Rule)：一个 unlock 操作先行发生于后面（时间的先后）对同一个锁的 lock 操作，所以线程解锁 m 之前对变量的写（解锁前会刷新到主内存中），对于接下来对 m 加锁的其它线程对该变量的读可见</p></li><li><p><strong>volatile 变量规则</strong> (Volatile Variable Rule)：对 volatile 变量的写操作先行发生于后面对这个变量的读</p></li><li><p>传递规则 (Transitivity)：具有传递性，如果操作 A 先行发生于操作 B，而操作 B 又先行发生于操作 C，则可以得出操作 A 先行发生于操作 C</p></li><li><p>线程启动规则 (Thread Start Rule)：Thread 对象的 start()方 法先行发生于此线程中的每一个操作</p><pre><code>static int x = 10;//线程 start 前对变量的写，对该线程开始后对该变量的读可见new Thread(()-&gt;&#123;System.out.println(x);&#125;,&quot;t1&quot;).start();</code></pre></li><li><p>线程中断规则 (Thread Interruption Rule)：对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生</p></li><li><p>线程终止规则 (Thread Termination Rule)：线程中所有的操作都先行发生于线程的终止检测，可以通过 Thread.join() 方法结束、Thread.isAlive() 的返回值手段检测到线程已经终止执行</p></li><li><p>对象终结规则（Finaizer Rule）：一个对象的初始化完成（构造函数执行结束）先行发生于它的 finalize() 方法的开始</p></li></ol><h4 id="线程安全单例示例"><a href="#线程安全单例示例" class="headerlink" title="线程安全单例示例"></a>线程安全单例示例</h4><p>单例模式有很多实现方法，饿汉、懒汉、静态内部类、枚举类，试分析每种实现下获取单例对象（即调用 getInstance）时的线程安全，并思考注释中的问题</p><blockquote><p>饿汉式：类加载就会导致该单实例对象被创建 </p><p>懒汉式：类加载不会导致该单实例对象被创建，而是首次使用该对象时才会创建</p></blockquote><h5 id="实现1"><a href="#实现1" class="headerlink" title="实现1"></a>实现1</h5><pre><code class="java">// 问题1：为什么加 final---&gt;防止子类重写父类的方法,破坏单例// 问题2：如果实现了序列化接口, 还要做什么来防止反序列化破坏单例public final class Singleton implements Serializable &#123; // 问题3：为什么设置为私有? 是否能防止反射创建新的实例?   // --&gt;防止别的类创建该对象,不能防止反射,因为反射可以强制设置accessible为true,获取私有成员变量 private Singleton() &#123;&#125; // 问题4：这样初始化是否能保证单例对象创建时的线程安全?    //可以保证线程安全,因为静态字段在类加载阶段jvm就帮助我们完成了 private static final Singleton INSTANCE = new Singleton(); // 问题5：为什么提供静态方法而不是直接将 INSTANCE 设置为 public, 说出你知道的理由    //使用方法可以提供更好的封装性,也可以提供泛型的支持,还可以对这个单例对象提供更多的控制 public static Singleton getInstance() &#123; return INSTANCE; &#125;    //解决问题2的方法 public Object readResolve() &#123;     return INSTANCE; &#125;&#125;</code></pre><h5 id="实现2"><a href="#实现2" class="headerlink" title="实现2"></a>实现2</h5><pre><code class="java">// 问题1：枚举单例是如何限制实例个数的//定义了几个就是几个// 问题2：枚举单例在创建时是否有并发问题//没有,该实例也是静态成员变量,在类加载时完成的// 问题3：枚举单例能否被反射破坏单例//不能// 问题4：枚举单例能否被反序列化破坏单例//不能// 问题5：枚举单例属于懒汉式还是饿汉式//饿汉式// 问题6：枚举单例如果希望加入一些单例创建时的初始化逻辑该如何做//直接写一些构造方法就行enum Singleton &#123; INSTANCE;&#125;</code></pre><h5 id="实现3"><a href="#实现3" class="headerlink" title="实现3"></a>实现3</h5><pre><code class="java">public final class Singleton &#123;     private Singleton() &#123; &#125;     private static Singleton INSTANCE = null;     // 分析这里的线程安全, 并说明有什么缺点     public static synchronized Singleton getInstance() &#123;         if( INSTANCE != null )&#123;             return INSTANCE;         &#125;         INSTANCE = new Singleton();         return INSTANCE;     &#125;    //懒汉式的单例模式,并且是线程安全的,但是每次尝试获取单例对象时都要加锁,性能相对较差&#125;</code></pre><h5 id="实现4-DCL"><a href="#实现4-DCL" class="headerlink" title="实现4 DCL"></a>实现4 DCL</h5><pre><code class="java">public final class Singleton &#123; private Singleton() &#123; &#125; // 问题1：解释为什么要加 volatile ?    //防止指令重排序 private static volatile Singleton INSTANCE = null; // 问题2：对比实现3, 说出这样做的意义    //不需要每次获取对象时都要加锁 public static Singleton getInstance() &#123;     if (INSTANCE != null) &#123;         return INSTANCE; &#125; synchronized (Singleton.class) &#123;     // 问题3：为什么还要在这里加为空判断, 之前不是判断过了吗     if (INSTANCE != null) &#123; // 防止阻塞的线程创建多个实例对象         return INSTANCE;     &#125;     INSTANCE = new Singleton();     return INSTANCE; &#125; &#125;&#125;</code></pre><h5 id="实现-5-推荐"><a href="#实现-5-推荐" class="headerlink" title="实现 5(推荐)"></a>实现 5(推荐)</h5><pre><code class="java">public final class Singleton &#123;     private Singleton() &#123; &#125;     // 问题1：属于懒汉式还是饿汉式    //懒汉式    //因为该静态内部类的加载就是懒惰的,若未用到getInstance方法就不会加载该内部类     private static class LazyHolder &#123;         static final Singleton INSTANCE = new Singleton();     &#125;     // 问题2：在创建时是否有并发问题    //     public static Singleton getInstance() &#123;         return LazyHolder.INSTANCE;     &#125;&#125;</code></pre><h3 id="5-5小结"><a href="#5-5小结" class="headerlink" title="5.5小结"></a>5.5小结</h3><p>本章重点讲解了 JMM 中的</p><ul><li><p>可见性 - 由 JVM 缓存优化引起 </p></li><li><p>有序性 - 由 JVM 指令重排序优化引起 </p></li><li><p>happens-before 规则</p></li><li><p>原理方面 </p><ul><li><p>CPU 指令并行 </p></li><li><p>volatile</p></li></ul></li><li><p>模式方面 </p><ul><li><p>两阶段终止模式的 volatile 改进 </p></li><li><p>同步模式之 balking</p></li></ul></li></ul><h2 id="6-共享模型之无锁"><a href="#6-共享模型之无锁" class="headerlink" title="6 共享模型之无锁"></a>6 共享模型之无锁</h2><p>内容:</p><ul><li>CAS 与 volatile</li><li>原子整数</li><li>原子引用</li><li>原子累加器</li><li>Unsafe</li></ul><h3 id="6-1-CAS"><a href="#6-1-CAS" class="headerlink" title="6.1 CAS"></a>6.1 CAS</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>无锁编程：Lock Free</p><p>CAS 的全称是 Compare-And-Swap，是 <strong>CPU 并发原语</strong></p><ul><li>CAS 并发原语体现在 Java 语言中就是 sun.misc.Unsafe 类的各个方法，调用 UnSafe 类中的 CAS 方法，JVM 会实现出 CAS 汇编指令，这是一种完全依赖于硬件的功能，实现了原子操作</li><li>CAS 是一种系统原语，原语属于操作系统范畴，是由若干条指令组成 ，用于完成某个功能的一个过程，并且原语的执行必须是连续的，执行过程中不允许被中断，所以 CAS 是一条 CPU 的原子指令，不会造成数据不一致的问题，是线程安全的</li></ul><p>底层原理：CAS 的底层是 <strong><code>lock cmpxchg</code> 指令（X86 架构）</strong>，在单核和多核 CPU 下都能够保证比较交换的原子性</p><ul><li>程序是在单核处理器上运行，会省略 lock 前缀，单处理器自身会维护处理器内的顺序一致性，不需要 lock 前缀的内存屏障效果</li><li>程序是在多核处理器上运行，会为 cmpxchg 指令加上 lock 前缀。当某个核执行到带 lock 的指令时，CPU 会执行<strong>总线锁定或缓存锁定</strong>，将修改的变量写入到主存，这个过程不会被线程的调度机制所打断，保证了多个线程对内存操作的原子性</li></ul><p>作用：比较当前工作内存中的值和主物理内存中的值，如果相同则执行规定操作，否则继续比较直到主内存和工作内存的值一致为止</p><p>CAS 特点：</p><ul><li>CAS 体现的是<strong>无锁并发、无阻塞并发</strong>，线程不会陷入阻塞，线程不需要频繁切换状态（上下文切换，系统调用）</li><li>CAS 是基于乐观锁的思想</li></ul><p>CAS 缺点：</p><ul><li>执行的是循环操作，如果比较不成功一直在循环，最差的情况某个线程一直取到的值和预期值都不一样，就会无限循环导致饥饿，<strong>使用 CAS 线程数不要超过 CPU 的核心数</strong>，采用分段 CAS 和自动迁移机制</li><li>只能保证一个共享变量的原子操作<ul><li>对于一个共享变量执行操作时，可以通过循环 CAS 的方式来保证原子操作</li><li>对于多个共享变量操作时，循环 CAS 就无法保证操作的原子性，这个时候<strong>只能用锁来保证原子性</strong></li></ul></li><li>引出来 ABA 问题</li></ul><h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h4><p>CAS 与 synchronized 总结：</p><ul><li>synchronized 是从悲观的角度出发：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程），因此 synchronized 也称之为悲观锁，ReentrantLock 也是一种悲观锁，性能较差</li><li>CAS 是从乐观的角度出发：总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据。<strong>如果别人修改过，则获取现在最新的值，如果别人没修改过，直接修改共享数据的值</strong>，CAS 这种机制也称之为乐观锁，综合性能较好</li></ul><h3 id="6-2-Atomic"><a href="#6-2-Atomic" class="headerlink" title="6.2 Atomic"></a>6.2 Atomic</h3><p>常见原子类：AtomicInteger、AtomicBoolean、AtomicLong</p><p>构造方法：</p><ul><li><code>public AtomicInteger()</code>：初始化一个默认值为 0 的原子型 Integer</li><li><code>public AtomicInteger(int initialValue)</code>：初始化一个指定值的原子型 Integer</li></ul><p>常用API：</p><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td>public final int get()</td><td>获取 AtomicInteger 的值</td></tr><tr><td>public final int getAndIncrement()</td><td>以原子方式将当前值加 1，返回的是自增前的值</td></tr><tr><td>public final int incrementAndGet()</td><td>以原子方式将当前值加 1，返回的是自增后的值</td></tr><tr><td>public final int getAndSet(int value)</td><td>以原子方式设置为 newValue 的值，返回旧值</td></tr><tr><td>public final int addAndGet(int data)</td><td>以原子方式将输入的数值与实例中的值相加并返回 实例：AtomicInteger 里的 value</td></tr></tbody></table><h4 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h4><p><strong>AtomicInteger 原理</strong>：自旋锁 + CAS 算法</p><p>CAS 算法：有 3 个操作数（内存值 V， 旧的预期值 A，要修改的值 B）</p><ul><li>当旧的预期值 A &#x3D;&#x3D; 内存值 V 此时可以修改，将 V 改为 B</li><li>当旧的预期值 A !&#x3D; 内存值 V 此时不能修改，并重新获取现在的最新值，重新获取的动作就是自旋</li></ul><p>分析 getAndSet 方法：</p><ul><li><p>AtomicInteger：</p><pre><code class="java">public final int getAndSet(int newValue) &#123;    /**    * this: 当前对象    * valueOffset:内存偏移量，内存地址    */    return unsafe.getAndSetInt(this, valueOffset, newValue);&#125;</code></pre><p>valueOffset：偏移量表示该变量值相对于当前对象地址的偏移，Unsafe 就是根据内存偏移地址获取数据</p><pre><code class="java">valueOffset = unsafe.objectFieldOffset                (AtomicInteger.class.getDeclaredField(&quot;value&quot;));//调用本地方法   --&gt;public native long objectFieldOffset(Field var1);</code></pre></li><li><p>unsafe 类：</p><pre><code class="java">// val1: AtomicInteger对象本身，var2: 该对象值得引用地址，var4: 需要变动的数public final int getAndSetInt(Object var1, long var2, int var4) &#123;    int var5;    do &#123;        // var5: 用 var1 和 var2 找到的内存中的真实值        var5 = this.getIntVolatile(var1, var2);    &#125; while(!this.compareAndSwapInt(var1, var2, var5, var4));    return var5;&#125;</code></pre><p>var5：从主内存中拷贝到工作内存中的值（每次都要从主内存拿到最新的值到本地内存），然后执行 <code>compareAndSwapInt()</code> 再和主内存的值进行比较，假设方法返回 false，那么就一直执行 while 方法，直到期望的值和真实值一样，修改数据</p></li><li><p>变量 value 用 volatile 修饰，保证了多线程之间的内存可见性，避免线程从工作缓存中获取失效的变量</p><pre><code class="java">private volatile int value</code></pre><p><strong>CAS 必须借助 volatile 才能读取到共享变量的最新值来实现比较并交换的效果</strong></p></li></ul><p>分析 getAndUpdate 方法：</p><ul><li><p>getAndUpdate：</p><pre><code class="java">public final int getAndUpdate(IntUnaryOperator updateFunction) &#123;    int prev, next;    do &#123;        prev = get();//当前值，cas的期望值        next = updateFunction.applyAsInt(prev);//期望值更新到该值    &#125; while (!compareAndSet(prev, next));//自旋    return prev;&#125;</code></pre><p>函数式接口：可以自定义操作逻辑</p><pre><code class="java">AtomicInteger a = new AtomicInteger();a.getAndUpdate(i -&gt; i + 10);</code></pre></li><li><p>compareAndSet：</p><pre><code class="java">public final boolean compareAndSet(int expect, int update) &#123;    /**    * this: 当前对象    * valueOffset:内存偏移量，内存地址    * expect:期望的值    * update: 更新的值    */    return unsafe.compareAndSwapInt(this, valueOffset, expect, update);&#125;</code></pre></li></ul><h4 id="原子引用"><a href="#原子引用" class="headerlink" title="原子引用"></a>原子引用</h4><p>原子引用：对 Object 进行原子操作，提供一种读和写都是原子性的对象引用变量</p><p>原子引用类：AtomicReference、AtomicStampedReference、AtomicMarkableReference</p><p>AtomicReference 类：</p><ul><li>构造方法：<code>AtomicReference&lt;T&gt; atomicReference = new AtomicReference&lt;T&gt;()</code></li><li>常用 API：<ul><li><code>public final boolean compareAndSet(V expectedValue, V newValue)</code>：CAS 操作</li><li><code>public final void set(V newValue)</code>：将值设置为 newValue</li><li><code>public final V get()</code>：返回当前值</li></ul></li></ul><pre><code class="java">public class AtomicReferenceDemo &#123;    public static void main(String[] args) &#123;        Student s1 = new Student(33, &quot;z3&quot;);                // 创建原子引用包装类        AtomicReference&lt;Student&gt; atomicReference = new AtomicReference&lt;&gt;();        // 设置主内存共享变量为s1        atomicReference.set(s1);        // 比较并交换，如果现在主物理内存的值为 z3，那么交换成 l4        while (true) &#123;            Student s2 = new Student(44, &quot;l4&quot;);            if (atomicReference.compareAndSet(s1, s2)) &#123;                break;            &#125;        &#125;        System.out.println(atomicReference.get());    &#125;&#125;class Student &#123;    private int id;    private String name;    //。。。。&#125;</code></pre><h4 id="原子数组"><a href="#原子数组" class="headerlink" title="原子数组"></a>原子数组</h4><p>原子数组类：AtomicIntegerArray、AtomicLongArray、AtomicReferenceArray</p><p>AtomicIntegerArray 类方法：</p><pre><code class="java">/***   ithe index* expect the expected value* update the new value*/public final boolean compareAndSet(int i, int expect, int update) &#123;    return compareAndSetRaw(checkedByteOffset(i), expect, update);&#125;</code></pre><p>原子数组和普通数组的差异:</p><pre><code class="java">public class testAtomArray &#123;    public static void main(String[] args) &#123;        demo(                ()-&gt;new int[10],                (array)-&gt;array.length,                (array,index)-&gt;array[index]++,                array-&gt; System.out.println(Arrays.toString(array))        );        demo(                ()-&gt;new AtomicIntegerArray(10),                (array)-&gt;array.length(),                (array,index)-&gt;array.getAndIncrement(index),                array-&gt; System.out.println(array)        );    &#125;    /**     参数1，提供数组、可以是线程不安全数组或线程安全数组     参数2，获取数组长度的方法     参数3，自增方法，回传 array, index     参数4，打印数组的方法     */// supplier 提供者 无中生有 ()-&gt;结果// function 函数 一个参数一个结果 (参数)-&gt;结果 , BiFunction (参数1,参数2)-&gt;结果// consumer 消费者 一个参数没结果 (参数)-&gt;void, BiConsumer (参数1,参数2)-&gt;    private static &lt;T&gt; void demo(            Supplier&lt;T&gt; arraySupplier,            Function&lt;T, Integer&gt; lengthFun,            BiConsumer&lt;T, Integer&gt; putConsumer,            Consumer&lt;T&gt; printConsumer ) &#123;        List&lt;Thread&gt; ts = new ArrayList&lt;&gt;();        T array = arraySupplier.get();        int length = lengthFun.apply(array);        for (int i = 0; i &lt; length; i++) &#123;            // 每个线程对数组作 10000 次操作            ts.add(new Thread(() -&gt; &#123;                for (int j = 0; j &lt; 10000; j++) &#123;                    putConsumer.accept(array, j%length);                &#125;            &#125;));        &#125;        ts.forEach(Thread::start); // 启动所有线程        ts.forEach(t -&gt; &#123;            try &#123;                t.join();            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;); // 等所有线程结束        printConsumer.accept(array);    &#125;&#125;</code></pre><p>执行结果:</p><p>[6104, 6034, 6051, 6050, 6096, 6087, 6098, 6133, 6075, 6041]</p><p>[10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000]</p><h4 id="原子更新器"><a href="#原子更新器" class="headerlink" title="原子更新器"></a>原子更新器</h4><p>原子更新器类：AtomicReferenceFieldUpdater、AtomicIntegerFieldUpdater、AtomicLongFieldUpdater</p><p>利用字段更新器，可以针对对象的某个域（Field）进行原子操作，<strong>只能配合 volatile 修饰的字段使用</strong>，否则会出现异常 <code>IllegalArgumentException: Must be volatile type</code></p><p>常用 API：</p><ul><li><code>static &lt;U&gt; AtomicIntegerFieldUpdater&lt;U&gt; newUpdater(Class&lt;U&gt; c, String fieldName)</code>：构造方法</li><li><code>abstract boolean compareAndSet(T obj, int expect, int update)</code>：CAS</li></ul><pre><code class="java">public class UpdateDemo &#123;    private volatile int field;        public static void main(String[] args) &#123;        AtomicIntegerFieldUpdater fieldUpdater = AtomicIntegerFieldUpdater                    .newUpdater(UpdateDemo.class, &quot;field&quot;);        UpdateDemo updateDemo = new UpdateDemo();        fieldUpdater.compareAndSet(updateDemo, 0, 10);        System.out.println(updateDemo.field);//10    &#125;&#125;</code></pre><h4 id="原子累加器"><a href="#原子累加器" class="headerlink" title="原子累加器"></a>原子累加器</h4><p>原子累加器类：LongAdder、DoubleAdder、LongAccumulator、DoubleAccumulator</p><p>LongAdder 和 LongAccumulator 区别：</p><p>相同点：</p><ul><li>LongAddr 与 LongAccumulator 类都是使用非阻塞算法 CAS 实现的</li><li>LongAddr 类是 LongAccumulator 类的一个特例，只是 LongAccumulator 提供了更强大的功能，可以自定义累加规则，当accumulatorFunction 为 null 时就等价于 LongAddr</li></ul><p>不同点：</p><ul><li>调用 casBase 时，LongAccumulator 使用 function.applyAsLong(b &#x3D; base, x) 来计算，LongAddr 使用 casBase(b &#x3D; base, b + x)</li><li>LongAccumulator 类功能更加强大，构造方法参数中<ul><li>accumulatorFunction 是一个双目运算器接口，可以指定累加规则，比如累加或者相乘，其根据输入的两个参数返回一个计算值，LongAdder 内置累加规则</li><li>identity 则是 LongAccumulator 累加器的初始值，LongAccumulator 可以为累加器提供非0的初始值，而 LongAdder 只能提供默认的 0</li></ul></li></ul><h3 id="6-3-Adder"><a href="#6-3-Adder" class="headerlink" title="6.3 Adder"></a>6.3 Adder</h3><h4 id="优化机制"><a href="#优化机制" class="headerlink" title="优化机制"></a>优化机制</h4><p>LongAdder 是 Java8 提供的类，跟 AtomicLong 有相同的效果，但对 CAS 机制进行了优化，尝试使用分段 CAS 以及自动分段迁移的方式来大幅度提升多线程高并发执行 CAS 操作的性能</p><p>CAS 底层实现是在一个循环中不断地尝试修改目标值，直到修改成功。如果竞争不激烈修改成功率很高，否则失败率很高，失败后这些重复的原子性操作会耗费性能（导致大量线程<strong>空循环，自旋转</strong>）</p><p>优化核心思想：数据分离，将 AtomicLong 的<strong>单点的更新压力分担到各个节点，空间换时间</strong>，在低并发的时候直接更新，可以保障和 AtomicLong 的性能基本一致，而在高并发的时候通过分散减少竞争，提高了性能</p><p><strong>分段 CAS 机制</strong>：</p><ul><li>在发生竞争时，创建 Cell 数组用于将不同线程的操作离散（通过 hash 等算法映射）到不同的节点上</li><li>设置多个累加单元（会根据需要扩容，最大为 CPU 核数），Therad-0 累加 Cell[0]，而 Thread-1 累加 Cell[1] 等，最后将结果汇总</li><li>在累加时操作的不同的 Cell 变量，因此减少了 CAS 重试失败，从而提高性能</li></ul><p><strong>自动分段迁移机制</strong>：某个 Cell 的 value 执行 CAS 失败，就会自动寻找另一个 Cell 分段内的 value 值进行 CAS 操作</p><p>性能对比:</p><pre><code class="java">public class testLongAdder &#123;    public static void main(String[] args) &#123;        for (int i = 0; i &lt; 5; i++) &#123;            demo(()-&gt;new LongAdder(),longAdder -&gt; longAdder.increment());        &#125;        for (int i = 0; i &lt; 5; i++) &#123;            demo(()-&gt;new AtomicLong(),atomicLong -&gt; atomicLong.incrementAndGet());        &#125;    &#125;    private static &lt;T&gt;void demo(            Supplier&lt;T&gt;supplier,            Consumer&lt;T&gt;consumer    )&#123;        T adder = supplier.get();        long start=System.currentTimeMillis();        List&lt;Thread&gt;ts=new ArrayList&lt;&gt;();        for (int i = 0; i &lt; 40; i++) &#123;            ts.add(new Thread(()-&gt;&#123;                for (int j = 0; j &lt; 500000; j++) &#123;                    consumer.accept(adder);                &#125;            &#125;));        &#125;        ts.forEach(Thread::start);        ts.forEach(t-&gt;&#123;            try &#123;                t.join();            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;);        long end=System.currentTimeMillis();        System.out.println(adder+&quot; cost:&quot;+(end-start));    &#125;&#125;</code></pre><p>结果:</p><p>20000000 cost:85<br>20000000 cost:18<br>20000000 cost:22<br>20000000 cost:19<br>20000000 cost:22</p><p>20000000 cost:452<br>20000000 cost:380<br>20000000 cost:402<br>20000000 cost:409<br>20000000 cost:465</p><p>可以看出,性能差距还是比较明显的.</p><h4 id="伪共享"><a href="#伪共享" class="headerlink" title="伪共享:"></a>伪共享:</h4><p>Cell 为累加单元：数组访问索引是通过 Thread 里的 threadLocalRandomProbe 域取模实现的，这个域是 ThreadLocalRandom 更新的</p><pre><code class="java">// Striped64.Cell@sun.misc.Contended static final class Cell &#123;    volatile long value;    Cell(long x) &#123; value = x; &#125;    // 用 cas 方式进行累加, prev 表示旧值, next 表示新值    final boolean cas(long prev, long next) &#123;        return UNSAFE.compareAndSwapLong(this, valueOffset, prev, next);    &#125;    // 省略不重要代码&#125;</code></pre><p>Cell 是数组形式，<strong>在内存中是连续存储的</strong>，64 位系统中，一个 Cell 为 24 字节（16 字节的对象头和 8 字节的 value），每一个 cache line(缓存行) 为 64 字节，因此缓存行可以存下 2 个的 Cell 对象，当 Core-0 要修改 Cell[0]、Core-1 要修改 Cell[1]，无论谁修改成功都会导致当前缓存行失效，从而导致对方的数据失效，需要重新去主存获取，影响效率</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221219205052787.png" alt="image-20221219205052787"></p><p>@sun.misc.Contended：防止缓存行伪共享，在使用此注解的对象或字段的前后各增加 <strong>128 字节</strong>大小的 padding，使用 2 倍于大多数硬件缓存行让 CPU 将对象预读至缓存时<strong>占用不同的缓存行</strong>，这样就不会造成对方缓存行的失效</p><h4 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h4><p>Striped64 类成员属性：</p><pre><code class="java">// 表示当前计算机CPU数量static final int NCPU = Runtime.getRuntime().availableProcessors()// 累加单元数组, 懒惰初始化transient volatile Cell[] cells;// 基础值, 如果没有竞争, 则用 cas 累加这个域，当 cells 扩容时，也会将数据写到 base 中transient volatile long base;// 在 cells 初始化或扩容时只能有一个线程执行, 通过 CAS 更新 cellsBusy 置为 1 来实现一个锁transient volatile int cellsBusy;</code></pre><p>工作流程：</p><ul><li>cells 占用内存是相对比较大的，是惰性加载的，在无竞争或者其他线程正在初始化 cells 数组的情况下，直接更新 base 域</li><li>在第一次发生竞争时（casBase 失败）会创建一个大小为 2 的 cells 数组，将当前累加的值包装为 Cell 对象，放入映射的槽位上</li><li>分段累加的过程中，如果当前线程对应的 cells 槽位为空，就会新建 Cell 填充，如果出现竞争，就会重新计算线程对应的槽位，继续自旋尝试修改</li><li>分段迁移后还出现竞争就会扩容 cells 数组长度为原来的两倍，然后 rehash，<strong>数组长度总是 2 的 n 次幂</strong>，默认最大为 CPU 核数，但是可以超过，如果核数是 6 核，数组最长是 8</li></ul><p>方法分析：</p><ul><li>LongAdder#add：累加方法</li></ul><pre><code class="java">public void add(long x) &#123;    // as 为累加单元数组的引用，b 为基础值，v 表示期望值    // m 表示 cells 数组的长度 - 1，a 表示当前线程命中的 cell 单元格    Cell[] as; long b, v; int m; Cell a;        // cells 不为空说明 cells 已经被初始化，线程发生了竞争，去更新对应的 cell 槽位    // 进入 || 后的逻辑去更新 base 域，更新失败表示发生竞争进入条件    if ((as = cells) != null || !casBase(b = base, b + x)) &#123;        // uncontended 为 true 表示 cell 没有竞争        boolean uncontended = true;                // 条件一: true 说明 cells 未初始化，多线程写 base 发生竞争需要进行初始化 cells 数组        //  fasle 说明 cells 已经初始化，进行下一个条件寻找自己的 cell 去累加        // 条件二: getProbe() 获取 hash 值，&amp; m 的逻辑和 HashMap 的逻辑相同，保证散列的均匀性        //   true 说明当前线程对应下标的 cell 为空，需要创建 cell        //        false 说明当前线程对应的 cell 不为空，进行下一个条件【将 x 值累加到对应的 cell 中】        // 条件三: 有取反符号，false 说明 cas 成功，直接返回，true 说明失败，当前线程对应的 cell 有竞争        if (as == null || (m = as.length - 1) &lt; 0 ||            (a = as[getProbe() &amp; m]) == null ||            !(uncontended = a.cas(v = a.value, v + x)))            longAccumulate(x, null, uncontended);            // 【uncontended 在对应的 cell 上累加失败的时候才为 false，其余情况均为 true】    &#125;&#125;</code></pre><ul><li>Striped64#longAccumulate：cell 数组创建</li></ul><pre><code class="java">                            // x  null false | truefinal void longAccumulate(long x, LongBinaryOperator fn, boolean wasUncontended) &#123;    int h;    // 当前线程还没有对应的 cell, 需要随机生成一个 hash 值用来将当前线程绑定到 cell    if ((h = getProbe()) == 0) &#123;        // 初始化 probe，获取 hash 值        ThreadLocalRandom.current();         h = getProbe();        // 默认情况下 当前线程肯定是写入到了 cells[0] 位置，不把它当做一次真正的竞争        wasUncontended = true;    &#125;    // 表示【扩容意向】，false 一定不会扩容，true 可能会扩容    boolean collide = false;     //自旋    for (;;) &#123;        // as 表示cells引用，a 表示当前线程命中的 cell，n 表示 cells 数组长度，v 表示 期望值        Cell[] as; Cell a; int n; long v;        // 【CASE1】: 表示 cells 已经初始化了，当前线程应该将数据写入到对应的 cell 中        if ((as = cells) != null &amp;&amp; (n = as.length) &gt; 0) &#123;            // CASE1.1: true 表示当前线程对应的索引下标的 Cell 为 null，需要创建 new Cell            if ((a = as[(n - 1) &amp; h]) == null) &#123;                // 判断 cellsBusy 是否被锁                if (cellsBusy == 0) &#123;                       // 创建 cell, 初始累加值为 x                    Cell r = new Cell(x);                      // 加锁                    if (cellsBusy == 0 &amp;&amp; casCellsBusy()) &#123;                        // 创建成功标记，进入【创建 cell 逻辑】                        boolean created = false;                        try &#123;                            Cell[] rs; int m, j;                            // 把当前 cells 数组赋值给 rs，并且不为 null                            if ((rs = cells) != null &amp;&amp;                                (m = rs.length) &gt; 0 &amp;&amp;                                // 再次判断防止其它线程初始化过该位置，当前线程再次初始化该位置会造成数据丢失                                // 因为这里是线程安全的判断，进行的逻辑不会被其他线程影响                                rs[j = (m - 1) &amp; h] == null) &#123;                                // 把新创建的 cell 填充至当前位置                                rs[j] = r;                                created = true;// 表示创建完成                            &#125;                        &#125; finally &#123;                            cellsBusy = 0;// 解锁                        &#125;                        if (created)// true 表示创建完成，可以推出循环了                            break;                        continue;                    &#125;                &#125;                collide = false;            &#125;            // CASE1.2: 条件成立说明线程对应的 cell 有竞争, 改变线程对应的 cell 来重试 cas            else if (!wasUncontended)                wasUncontended = true;            // CASE 1.3: 当前线程 rehash 过，如果新命中的 cell 不为空，就尝试累加，false 说明新命中也有竞争            else if (a.cas(v = a.value, ((fn == null) ? v + x : fn.applyAsLong(v, x))))                break;            // CASE 1.4: cells 长度已经超过了最大长度 CPU 内核的数量或者已经扩容            else if (n &gt;= NCPU || cells != as)                collide = false; // 扩容意向改为false，【表示不能扩容了】            // CASE 1.5: 更改扩容意向，如果 n &gt;= NCPU，这里就永远不会执行到，case1.4 永远先于 1.5 执行            else if (!collide)                collide = true;            // CASE 1.6: 【扩容逻辑】，进行加锁            else if (cellsBusy == 0 &amp;&amp; casCellsBusy()) &#123;                try &#123;                    // 线程安全的检查，防止期间被其他线程扩容了                    if (cells == as) &#123;                             // 扩容为以前的 2 倍                        Cell[] rs = new Cell[n &lt;&lt; 1];                        // 遍历移动值                        for (int i = 0; i &lt; n; ++i)                            rs[i] = as[i];                        // 把扩容后的引用给 cells                        cells = rs;                    &#125;                &#125; finally &#123;                    cellsBusy = 0;// 解锁                &#125;                collide = false;// 扩容意向改为 false，表示不扩容了                continue;            &#125;            // 重置当前线程 Hash 值，这就是【分段迁移机制】            h = advanceProbe(h);        &#125;        // 【CASE2】: 运行到这说明 cells 还未初始化，as 为null        // 判断是否没有加锁，没有加锁就用 CAS 加锁        // 条件二判断是否其它线程在当前线程给 as 赋值之后修改了 cells，这里不是线程安全的判断        else if (cellsBusy == 0 &amp;&amp; cells == as &amp;&amp; casCellsBusy()) &#123;            // 初始化标志，开始 【初始化 cells 数组】            boolean init = false;            try &#123;                    // 再次判断 cells == as 防止其它线程已经提前初始化了，当前线程再次初始化导致丢失数据                // 因为这里是【线程安全的，重新检查，经典 DCL】                if (cells == as) &#123;                    Cell[] rs = new Cell[2];// 初始化数组大小为2                    rs[h &amp; 1] = new Cell(x);// 填充线程对应的cell                    cells = rs;                    init = true;// 初始化成功，标记置为 true                &#125;            &#125; finally &#123;                cellsBusy = 0;// 解锁啊            &#125;            if (init)                break;// 初始化成功直接跳出自旋        &#125;        // 【CASE3】: 运行到这说明其他线程在初始化 cells，当前线程将值累加到 base，累加成功直接结束自旋        else if (casBase(v = base, ((fn == null) ? v + x :                                    fn.applyAsLong(v, x))))            break;     &#125;&#125;</code></pre><ul><li>sum：获取最终结果通过 sum 整合，<strong>保证最终一致性，不保证强一致性</strong></li></ul><pre><code class="java">public long sum() &#123;    Cell[] as = cells; Cell a;    long sum = base;    if (as != null) &#123;        // 遍历 累加        for (int i = 0; i &lt; as.length; ++i) &#123;            if ((a = as[i]) != null)                sum += a.value;        &#125;    &#125;    return sum;&#125;</code></pre><h3 id="6-4-ABA问题"><a href="#6-4-ABA问题" class="headerlink" title="6.4 ABA问题"></a>6.4 ABA问题</h3><p>ABA 问题：当进行获取主内存值时，该内存值在写入主内存时已经被修改了 N 次，但是最终又改成原来的值</p><p>其他线程先把 A 改成 B 又改回 A，主线程<strong>仅能判断出共享变量的值与最初值 A 是否相同</strong>，不能感知到这种从 A 改为 B 又 改回 A 的情况，这时 CAS 虽然成功，但是过程存在问题</p><ul><li>构造方法：<ul><li><code>public AtomicStampedReference(V initialRef, int initialStamp)</code>：初始值和初始版本号</li></ul></li><li>常用API：<ul><li><code> public boolean compareAndSet(V expectedReference, V newReference, int expectedStamp, int newStamp)</code>：<strong>期望引用和期望版本号都一致</strong>才进行 CAS 修改数据</li><li><code>public void set(V newReference, int newStamp)</code>：设置值和版本号</li><li><code>public V getReference()</code>：返回引用的值</li><li><code>public int getStamp()</code>：返回当前版本号</li></ul></li></ul><pre><code class="java">public static void main(String[] args) &#123;    AtomicStampedReference&lt;Integer&gt; atomicReference = new AtomicStampedReference&lt;&gt;(100,1);    int startStamp = atomicReference.getStamp();    new Thread(() -&gt;&#123;        int stamp = atomicReference.getStamp();        atomicReference.compareAndSet(100, 101, stamp, stamp + 1);        stamp = atomicReference.getStamp();        atomicReference.compareAndSet(101, 100, stamp, stamp + 1);    &#125;,&quot;t1&quot;).start();    new Thread(() -&gt;&#123;        try &#123;            Thread.sleep(1000);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;        if (!atomicReference.compareAndSet(100, 200, startStamp, startStamp + 1)) &#123;            System.out.println(atomicReference.getReference());//100            System.out.println(Thread.currentThread().getName() + &quot;线程修改失败&quot;);        &#125;    &#125;,&quot;t2&quot;).start();&#125;</code></pre><h3 id="6-5-Unsafe"><a href="#6-5-Unsafe" class="headerlink" title="6.5 Unsafe"></a>6.5 Unsafe</h3><p>Unsafe 是 CAS 的核心类，由于 Java 无法直接访问底层系统，需要通过本地（Native）方法来访问</p><p>Unsafe 类存在 sun.misc 包，其中所有方法都是 native 修饰的，都是直接调用<strong>操作系统底层资源</strong>执行相应的任务，基于该类可以直接操作特定的内存数据，其内部方法操作类似 C 的指针</p><p>模拟实现原子整数：</p><pre><code class="java">public static void main(String[] args) &#123;    MyAtomicInteger atomicInteger = new MyAtomicInteger(10);    if (atomicInteger.compareAndSwap(20)) &#123;        System.out.println(atomicInteger.getValue());    &#125;&#125;class MyAtomicInteger &#123;    private static final Unsafe UNSAFE;    private static final long VALUE_OFFSET;    private volatile int value;    static &#123;        try &#123;            //Unsafe unsafe = Unsafe.getUnsafe()这样会报错，需要反射获取            Field theUnsafe = Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;);            theUnsafe.setAccessible(true);            UNSAFE = (Unsafe) theUnsafe.get(null);            // 获取 value 属性的内存地址，value 属性指向该地址，直接设置该地址的值可以修改 value 的值            VALUE_OFFSET = UNSAFE.objectFieldOffset(                           MyAtomicInteger.class.getDeclaredField(&quot;value&quot;));        &#125; catch (NoSuchFieldException | IllegalAccessException e) &#123;            e.printStackTrace();            throw new RuntimeException();        &#125;    &#125;    public MyAtomicInteger(int value) &#123;        this.value = value;    &#125;    public int getValue() &#123;        return value;    &#125;    public boolean compareAndSwap(int update) &#123;        while (true) &#123;            int prev = this.value;            int next = update;            //当前对象  内存偏移量    期望值 更新值            if (UNSAFE.compareAndSwapInt(this, VALUE_OFFSET, prev, update)) &#123;                System.out.println(&quot;CAS成功&quot;);                return true;            &#125;        &#125;    &#125;&#125;</code></pre><h1 id="7-共享模型之不可变"><a href="#7-共享模型之不可变" class="headerlink" title="7.共享模型之不可变"></a>7.共享模型之不可变</h1><h2 id="7-1-日期转换的问题"><a href="#7-1-日期转换的问题" class="headerlink" title="7.1 日期转换的问题"></a>7.1 日期转换的问题</h2><p>问题的提出:</p><p>由于SimpleDateFormat不是线程安全的, 所以下面的方法直接运行就会出现问题:</p><pre><code class="java">private static void extracted() &#123;    SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);    for (int i = 0; i &lt; 10; i++) &#123;        new Thread(()-&gt;&#123;               try &#123;                   log.debug(&quot;&#123;&#125;&quot;,simpleDateFormat.parse(&quot;1950-01-25&quot;));               &#125; catch (ParseException e) &#123;                   e.printStackTrace();               &#125;        &#125;).start();    &#125;&#125;</code></pre><p>解决思路:同步锁. 虽然用锁能解决问题, 但是这样性能并不好.</p><pre><code class="java">private static void extracted() &#123;    SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);    for (int i = 0; i &lt; 10; i++) &#123;        new Thread(()-&gt;&#123;           synchronized (simpleDateFormat)&#123;               try &#123;                   log.debug(&quot;&#123;&#125;&quot;,simpleDateFormat.parse(&quot;1950-01-25&quot;));               &#125; catch (ParseException e) &#123;                   e.printStackTrace();               &#125;           &#125;        &#125;).start();    &#125;&#125;</code></pre><p>思路: 不可变</p><p>如果一个对象不能够修改其内部属性,那么它就是线程安全的,因为不存在并发修改. 这样的对象在java中有很多,例如在java8之后有一个新的日期格式化类:<strong>DateTimeFormatter</strong></p><pre><code class="java">public static void main(String[] args) &#123;    DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd&quot;);    for (int i = 0; i &lt; 10; i++) &#123;        new Thread(() -&gt; &#123;            TemporalAccessor parse = dateTimeFormatter.parse(&quot;1950-01-25&quot;);            log.debug(&quot;&#123;&#125;&quot;, parse);        &#125;).start();    &#125;&#125;</code></pre><p>可以看 DateTimeFormatter 的文档：</p><pre><code class="java">@implSpecThis class is immutable and thread-safe.</code></pre><p>不可变对象，实际是另一种避免竞争的方式。</p><h2 id="7-2-不可变设计"><a href="#7-2-不可变设计" class="headerlink" title="7.2 不可变设计"></a>7.2 不可变设计</h2><p>String类也是不可变的.</p><pre><code class="java">public final class String    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence,               Constable, ConstantDesc &#123;    /**     * The value is used for character storage.     *     * @implNote This field is trusted by the VM, and is a subject to     * constant folding if String instance is constant. Overwriting this     * field after construction will cause problems.     *     * Additionally, it is marked with &#123;@link Stable&#125; to trust the contents     * of the array. No other facility in JDK provides this functionality (yet).     * &#123;@link Stable&#125; is safe here, because value is never null.     */    @Stable    private final byte[] value;    /**     * The identifier of the encoding used to encode the bytes in     * &#123;@code value&#125;. The supported values in this implementation are     *     * LATIN1     * UTF16     *     * @implNote This field is trusted by the VM, and is a subject to     * constant folding if String instance is constant. Overwriting this     * field after construction will cause problems.     */    private final byte coder;    /** Cache the hash code for the string */    private int hash; // Default to 0          //............               &#125;</code></pre><p>可以看到该类的几个关键字段都是final的.</p><ul><li><p>属性用 final 修饰保证了该属性是只读的，不能修改</p></li><li><p>类用 final 修饰保证了该类中的方法不能被覆盖，防止子类无意间破坏不可变性</p></li></ul><h3 id="保护性拷贝"><a href="#保护性拷贝" class="headerlink" title="保护性拷贝"></a>保护性拷贝</h3><p>使用字符串时,有一些和修改有关的方法,比如substring:</p><pre><code class="java">public String substring(int beginIndex, int endIndex) &#123;    int length = length();    checkBoundsBeginEnd(beginIndex, endIndex, length);    if (beginIndex == 0 &amp;&amp; endIndex == length) &#123;        return this;    &#125;    int subLen = endIndex - beginIndex;    return isLatin1() ? StringLatin1.newString(value, beginIndex, subLen)                      : StringUTF16.newString(value, beginIndex, subLen);&#125;</code></pre><p>发现其内部是调用了各种newString方法,跟踪到newString方法:</p><pre><code class="java">public static String newString(byte[] val, int index, int len) &#123;    if (len == 0) &#123;        return &quot;&quot;;    &#125;    return new String(Arrays.copyOfRange(val, index, index + len),                      LATIN1);&#125;</code></pre><p>发现其并未对final byte[] value做出修改,而是直接将其对应的值复制下来创造一个新的String, 将复制好的value传递给新的字符串的value.这种通过创建副本对象来避免共享的手段称之为【<strong>保护性拷贝</strong>（defensive copy）】</p><h2 id="7-3-设计模式之享元"><a href="#7-3-设计模式之享元" class="headerlink" title="7.3 设计模式之享元"></a>7.3 设计模式之享元</h2><p>享元模式（Flyweight pattern）： 用于减少创建对象的数量，以减少内存占用和提高性能，这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式</p><p>异步模式：让有限的工作线程（Worker Thread）来轮流异步处理无限多的任务，也可将其归类为分工模式，典型实现就是线程池</p><p>工作机制：享元模式尝试重用现有的同类对象，如果未找到匹配的对象，则创建新对象</p><p>自定义连接池：</p><pre><code class="java">public static void main(String[] args) &#123;    Pool pool = new Pool(2);    for (int i = 0; i &lt; 5; i++) &#123;        new Thread(() -&gt; &#123;            Connection con = pool.borrow();            try &#123;                Thread.sleep(new Random().nextInt(1000));            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            pool.free(con);        &#125;).start();    &#125;&#125;class Pool &#123;    //连接池的大小    private final int poolSize;    //连接对象的数组    private Connection[] connections;    //连接状态数组 0表示空闲  1表示繁忙    private AtomicIntegerArray states;  //int[] -&gt; AtomicIntegerArray    //构造方法    public Pool(int poolSize) &#123;        this.poolSize = poolSize;        this.connections = new Connection[poolSize];        this.states = new AtomicIntegerArray(new int[poolSize]);        for (int i = 0; i &lt; poolSize; i++) &#123;            connections[i] = new MockConnection(&quot;连接&quot; + (i + 1));        &#125;    &#125;    //使用连接    public Connection borrow() &#123;        while (true) &#123;            for (int i = 0; i &lt; poolSize; i++) &#123;                if (states.get(i) == 0) &#123;                    if (states.compareAndSet(i, 0, 1)) &#123;                        System.out.println(Thread.currentThread().getName() + &quot; borrow &quot; +  connections[i]);                        return connections[i];                    &#125;                &#125;            &#125;            //如果没有空闲连接，当前线程等待            synchronized (this) &#123;                try &#123;                    System.out.println(Thread.currentThread().getName() + &quot; wait...&quot;);                    this.wait();                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;    &#125;    //归还连接    public void free(Connection con) &#123;        for (int i = 0; i &lt; poolSize; i++) &#123;            if (connections[i] == con) &#123;//判断是否是同一个对象                states.set(i, 0);//不用cas的原因是只会有一个线程使用该连接                synchronized (this) &#123;                    System.out.println(Thread.currentThread().getName() + &quot; free &quot; + con);                    this.notifyAll();                &#125;                break;            &#125;        &#125;    &#125;&#125;class MockConnection implements Connection &#123;    private String name;    //.....&#125;</code></pre><h2 id="7-4-final原理"><a href="#7-4-final原理" class="headerlink" title="7.4 final原理"></a>7.4 final原理</h2><h3 id="7-4-1-设置final变量的原理"><a href="#7-4-1-设置final变量的原理" class="headerlink" title="7.4.1 设置final变量的原理"></a>7.4.1 设置final变量的原理</h3><pre><code class="java">public class testFinal &#123;    final int a=20;&#125;</code></pre><p>对应的字节码为:</p><pre><code class="java"> // access flags 0x10  final I a = 20  // access flags 0x1  public &lt;init&gt;()V   L0    LINENUMBER 9 L0    ALOAD 0    INVOKESPECIAL java/lang/Object.&lt;init&gt; ()V   L1    LINENUMBER 10 L1    ALOAD 0    BIPUSH 20    PUTFIELD com/dylan/test/testFinal.a : I        &lt;---加入写屏障    RETURN   L2    LOCALVARIABLE this Lcom/dylan/test/testFinal; L0 L2 0    MAXSTACK = 2    MAXLOCALS = 1  // access flags 0x9</code></pre><p>发现final变量的赋值也会通过putfield指令来完成,同样在这条指令之后也会加入写屏障,保证在其他线程读到它的值时不会出现为0的情况</p><h3 id="7-4-2-获取final变量的原理"><a href="#7-4-2-获取final变量的原理" class="headerlink" title="7.4.2 获取final变量的原理"></a>7.4.2 获取final变量的原理</h3><p>测试类:</p><pre><code class="java">public class testFinal &#123;    final int a=20;    final int b=Integer.MAX_VALUE;    final static int A=10;    final static int B=Short.MAX_VALUE+1;    @Test    public void test()&#123;        System.out.println(testFinal.A);        System.out.println(testFinal.B);        System.out.println(new testFinal().a);        System.out.println(new testFinal().b);    &#125;&#125;</code></pre><p>该类测试方法的字节码:</p><pre><code class="java">public test()V  @Lorg/junit/Test;()   L0    LINENUMBER 19 L0    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;    BIPUSH 10  //直接将testFinal.A的值复制到了栈内存当中,没有共享的操作    INVOKEVIRTUAL java/io/PrintStream.println (I)V   L1    LINENUMBER 20 L1    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;    LDC 32768    INVOKEVIRTUAL java/io/PrintStream.println (I)V   L2    LINENUMBER 21 L2    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;    NEW com/dylan/test/testFinal    DUP    INVOKESPECIAL com/dylan/test/testFinal.&lt;init&gt; ()V    INVOKESTATIC java/util/Objects.requireNonNull (Ljava/lang/Object;)Ljava/lang/Object;    POP    BIPUSH 20    INVOKEVIRTUAL java/io/PrintStream.println (I)V   L3    LINENUMBER 22 L3    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;    NEW com/dylan/test/testFinal    DUP    INVOKESPECIAL com/dylan/test/testFinal.&lt;init&gt; ()V    INVOKESTATIC java/util/Objects.requireNonNull (Ljava/lang/Object;)Ljava/lang/Object;    POP    LDC 2147483647    INVOKEVIRTUAL java/io/PrintStream.println (I)V   L4    LINENUMBER 23 L4    RETURN   L5    LOCALVARIABLE this Lcom/dylan/test/testFinal; L0 L5 0    MAXSTACK = 3    MAXLOCALS = 1</code></pre><p>若将测试类的成员变量前的final去掉:</p><pre><code class="java">public class testFinal &#123;    final int a=20;    final int b=Integer.MAX_VALUE;    static int A=10;     static int B=Short.MAX_VALUE+1;    @Test    public void test()&#123;        System.out.println(testFinal.A);        System.out.println(testFinal.B);        System.out.println(new testFinal().a);        System.out.println(new testFinal().b);    &#125;&#125;</code></pre><p>对应的字节码:</p><pre><code class="java">public test()V  @Lorg/junit/Test;()   L0    LINENUMBER 19 L0    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;    GETSTATIC com/dylan/test/testFinal.A : I //此时获取的指令就变为了GETSTATIC,获取的就是共享内存的值了,比从栈内存中直接获取值的效率要更低    INVOKEVIRTUAL java/io/PrintStream.println (I)V   L1    LINENUMBER 20 L1    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;    GETSTATIC com/dylan/test/testFinal.B : I    INVOKEVIRTUAL java/io/PrintStream.println (I)V   L2    LINENUMBER 21 L2    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;    NEW com/dylan/test/testFinal    DUP    INVOKESPECIAL com/dylan/test/testFinal.&lt;init&gt; ()V    INVOKESTATIC java/util/Objects.requireNonNull (Ljava/lang/Object;)Ljava/lang/Object;    POP    BIPUSH 20    INVOKEVIRTUAL java/io/PrintStream.println (I)V   L3    LINENUMBER 22 L3    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;    NEW com/dylan/test/testFinal    DUP    INVOKESPECIAL com/dylan/test/testFinal.&lt;init&gt; ()V    INVOKESTATIC java/util/Objects.requireNonNull (Ljava/lang/Object;)Ljava/lang/Object;    POP    LDC 2147483647    INVOKEVIRTUAL java/io/PrintStream.println (I)V   L4    LINENUMBER 23 L4    RETURN   L5    LOCALVARIABLE this Lcom/dylan/test/testFinal; L0 L5 0    MAXSTACK = 3    MAXLOCALS = 1  // access flags 0x8  static &lt;clinit&gt;()V   L0    LINENUMBER 14 L0    BIPUSH 10    PUTSTATIC com/dylan/test/testFinal.A : I   L1    LINENUMBER 15 L1    LDC 32768    PUTSTATIC com/dylan/test/testFinal.B : I    RETURN    MAXSTACK = 1    MAXLOCALS = 0</code></pre><h1 id="8-共享模型之数据"><a href="#8-共享模型之数据" class="headerlink" title="8. 共享模型之数据"></a>8. 共享模型之数据</h1><h2 id="8-1-线程池"><a href="#8-1-线程池" class="headerlink" title="8.1 线程池"></a>8.1 线程池</h2><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230101192028976.png" alt="image-20230101192028976"></p><h3 id="步骤1：自定义拒绝策略接口"><a href="#步骤1：自定义拒绝策略接口" class="headerlink" title="步骤1：自定义拒绝策略接口"></a>步骤1：自定义拒绝策略接口</h3><pre><code class="java">@FunctionalInterface//拒绝策略interface RejectPolicy&lt;T&gt;&#123;    void reject(BlockingQueue&lt;T&gt; queue,T task);&#125;</code></pre><h3 id="步骤2-自定义阻塞任务队列"><a href="#步骤2-自定义阻塞任务队列" class="headerlink" title="步骤2: 自定义阻塞任务队列"></a>步骤2: 自定义阻塞任务队列</h3><pre><code class="java">@Slf4jclass BlockingQueue&lt;T&gt;&#123;    //任务队列    private Deque&lt;T&gt;queue=new ArrayDeque&lt;&gt;();    //锁    private ReentrantLock lock=new ReentrantLock();    //消费者条件变量    private Condition emptyWaitSet=lock.newCondition();    //生产者条件变量    private Condition fullWaitSet=lock.newCondition();    //容量    private int capacity;    public BlockingQueue(int capacity) &#123;        this.capacity = capacity;    &#125;    //带超时的阻塞获取    public T poll(long timeout, TimeUnit timeUnit)&#123;        lock.lock();        try &#123;            //将timeout超时时间统一转换为纳秒            long nanos = timeUnit.toNanos(timeout);            while (queue.isEmpty())&#123;                try &#123;                    if(nanos&lt;=0)&#123;                        return null;                    &#125;                    //返回的是剩余需要等待的时间                    nanos=emptyWaitSet.awaitNanos(nanos);                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;            T t = queue.removeFirst();            fullWaitSet.signal();            return t;        &#125;finally &#123;            lock.unlock();        &#125;    &#125;    //阻塞获取    public T take()&#123;        lock.lock();        try &#123;            while (queue.isEmpty())&#123;                try &#123;                    emptyWaitSet.await();                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;            T t = queue.removeFirst();            fullWaitSet.signal();            return t;        &#125;finally &#123;            lock.unlock();        &#125;    &#125;    //阻塞添加    public void put(T element)&#123;        lock.lock();        try &#123;            while (queue.size()==capacity)&#123;                try &#123;                    log.debug(&quot;等待加入任务队列&quot;);                    fullWaitSet.await();                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;            log.debug(&quot;加入任务队列&#123;&#125;&quot;,element);            queue.addLast(element);            emptyWaitSet.signal();        &#125;finally &#123;            lock.unlock();        &#125;    &#125;    //带超时时间的阻塞添加    public boolean offer(T element,long timeout,TimeUnit timeUnit)&#123;        lock.lock();        try &#123;            long nanos = timeUnit.toNanos(timeout);            while (queue.size()==capacity)&#123;                try &#123;                    if(nanos&lt;=0)&#123;                        return false;                    &#125;                    log.debug(&quot;等待加入任务队列&quot;);                    nanos = fullWaitSet.awaitNanos(nanos);                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;            log.debug(&quot;加入任务队列&#123;&#125;&quot;,element);            queue.addLast(element);            emptyWaitSet.signal();            return true;        &#125;finally &#123;            lock.unlock();        &#125;    &#125;    //获取当前队列大小    public int size()&#123;        lock.lock();        try &#123;            return queue.size();        &#125;finally &#123;            lock.unlock();        &#125;    &#125;    public void tryPut(RejectPolicy&lt;T&gt; rejectPolicy, T task) &#123;        lock.lock();        try &#123;            //判断队列是否已满            if(queue.size()==capacity)&#123;                rejectPolicy.reject(this,task);            &#125;else&#123;                log.debug(&quot;加入任务队列&#123;&#125;&quot;,task);                queue.addLast(task);                emptyWaitSet.signal();            &#125;        &#125;finally &#123;            lock.unlock();        &#125;    &#125;&#125;</code></pre><h3 id="步骤3-自定义线程池"><a href="#步骤3-自定义线程池" class="headerlink" title="步骤3: 自定义线程池"></a>步骤3: 自定义线程池</h3><pre><code class="java">@Slf4jclass ThreadPool&#123;    //任务队列    BlockingQueue&lt;Runnable&gt;taskQueue;    //线程集合    private HashSet&lt;Worker&gt;workers=new HashSet&lt;&gt;();    //核心线程数    private int coreSize;    //获取任务的超时时间    private long timeout;    private TimeUnit timeUnit;    private RejectPolicy&lt;Runnable&gt; rejectPolicy;    public ThreadPool(int coreSize, long timeout, TimeUnit timeUnit,int queueSize,RejectPolicy&lt;Runnable&gt;rejectPolicy) &#123;        this.coreSize = coreSize;        this.timeout = timeout;        this.timeUnit = timeUnit;        this.taskQueue=new BlockingQueue&lt;&gt;(queueSize);        this.rejectPolicy=rejectPolicy;    &#125;    public void execute(Runnable task)&#123;        //当任务数没有超过coreSize时,直接交给worker对象        //如果超过, 那么就要加入任务队列       synchronized (workers)&#123;           if(workers.size()&lt;coreSize)&#123;               Worker worker=new Worker(task);               log.debug(&quot;新增worker&#123;&#125;,&#123;&#125;&quot;,worker,task);               workers.add(worker);               worker.start();           &#125;else&#123;               //taskQueue.put(task);               //1) 死等               //2) 带超时时间的等待               //3) 放弃任务的执行               //4) 抛出异常               //5) 让调用者自己执行任务               taskQueue.tryPut(rejectPolicy,task);           &#125;       &#125;    &#125;    class Worker extends Thread&#123;        private Runnable task;        public Worker(Runnable task) &#123;            this.task = task;        &#125;        @Override        public void run() &#123;            //执行任务            //while(task!=null || (task=taskQueue.take())!=null)&#123;            while(task!=null || (task=taskQueue.poll(timeout,timeUnit))!=null)&#123;                try &#123;                    log.debug(&quot;正在执行&#123;&#125;&quot;,task);                    task.run();                &#125;catch (Exception e)&#123;                    e.printStackTrace();                &#125;finally &#123;                    task=null;                &#125;            &#125;            synchronized (workers)&#123;                log.debug(&quot;work&#123;&#125;被移除&quot;,this);                workers.remove(this);            &#125;        &#125;    &#125;&#125;</code></pre><h3 id="步骤4-测试"><a href="#步骤4-测试" class="headerlink" title="步骤4:测试"></a>步骤4:测试</h3><pre><code class="java">  ThreadPool threadPool = new ThreadPool(1, 1000, TimeUnit.MILLISECONDS, 1,            (queue,task)-&gt;&#123;                //1.死等                //queue.put(task);                //2) 带超时时间的等待                //queue.offer(task,500,TimeUnit.MILLISECONDS);                //3) 放弃任务的执行                //log.debug(&quot;放弃task任务&quot;);                //4) 抛出异常                //throw new RuntimeException(&quot;任务执行失败&quot;+task);                //5) 让调用者自己执行任务                task.run();            &#125;);    for (int i = 0; i &lt; 3; i++) &#123;        int j=i;        threadPool.execute(()-&gt;&#123;            Sleeper.sleep(1000);            log.debug(&quot;&#123;&#125;&quot;,j);        &#125;);    &#125;&#125;</code></pre><h3 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h3><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><h5 id="状态信息"><a href="#状态信息" class="headerlink" title="状态信息"></a>状态信息</h5><p>ThreadPoolExecutor 使用 int 的<strong>高 3 位来表示线程池状态，低 29 位表示线程数量</strong>。这些信息存储在一个原子变量 ctl 中，目的是将线程池状态与线程个数合二为一，这样就可以用一次 CAS 原子操作进行赋值</p><p>状态表示：</p><pre><code class="java">// 高3位：表示当前线程池运行状态，除去高3位之后的低位：表示当前线程池中所拥有的线程数量private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));// 表示在 ctl 中，低 COUNT_BITS 位，是用于存放当前线程数量的位private static final int COUNT_BITS = Integer.SIZE - 3;// 低 COUNT_BITS 位所能表达的最大数值，000 11111111111111111111 =&gt; 5亿多private static final int CAPACITY   = (1 &lt;&lt; COUNT_BITS) - 1;</code></pre><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230102140706665.png" alt="image-20230102140706665"></p><pre><code class="java">// 111 000000000000000000，转换成整数后其实就是一个【负数】private static final int RUNNING    = -1 &lt;&lt; COUNT_BITS;// 000 000000000000000000private static final int SHUTDOWN   =  0 &lt;&lt; COUNT_BITS;// 001 000000000000000000private static final int STOP       =  1 &lt;&lt; COUNT_BITS;// 010 000000000000000000private static final int TIDYING    =  2 &lt;&lt; COUNT_BITS;// 011 000000000000000000private static final int TERMINATED =  3 &lt;&lt; COUNT_BITS;</code></pre><table><thead><tr><th>状态</th><th>高3位</th><th>接收新任务</th><th>处理阻塞任务队列</th><th>说明</th></tr></thead><tbody><tr><td>RUNNING</td><td>111</td><td>Y</td><td>Y</td><td></td></tr><tr><td>SHUTDOWN</td><td>000</td><td>N</td><td>Y</td><td>不接收新任务，但处理阻塞队列剩余任务</td></tr><tr><td>STOP</td><td>001</td><td>N</td><td>N</td><td>中断正在执行的任务，并抛弃阻塞队列任务</td></tr><tr><td>TIDYING</td><td>010</td><td>-</td><td>-</td><td>任务全执行完毕，活动线程为 0 即将进入终结</td></tr><tr><td>TERMINATED</td><td>011</td><td>-</td><td>-</td><td>终止状态</td></tr></tbody></table><ul><li><p>获取当前线程池运行状态：</p><pre><code class="java">// ~CAPACITY = ~000 11111111111111111111 = 111 000000000000000000000（取反）// c == ctl = 111 000000000000000000111// 111 000000000000000000111// 111 000000000000000000000// 111 000000000000000000000获取到了运行状态private static int runStateOf(int c)     &#123; return c &amp; ~CAPACITY; &#125;</code></pre></li><li><p>获取当前线程池线程数量：</p><pre><code class="java">//        c = 111 000000000000000000111// CAPACITY = 000 111111111111111111111//            000 000000000000000000111 =&gt; 7private static int workerCountOf(int c)  &#123; return c &amp; CAPACITY; &#125;</code></pre></li><li><p>重置当前线程池状态 ctl：</p><pre><code class="java">// rs 表示线程池状态，wc 表示当前线程池中 worker（线程）数量，相与以后就是合并后的状态private static int ctlOf(int rs, int wc) &#123; return rs | wc; &#125;</code></pre></li><li><p>比较当前线程池 ctl 所表示的状态：</p><pre><code class="java">// 比较当前线程池 ctl 所表示的状态，是否小于某个状态 s// 状态对比：RUNNING &lt; SHUTDOWN &lt; STOP &lt; TIDYING &lt; TERMINATEDprivate static boolean runStateLessThan(int c, int s) &#123; return c &lt; s; &#125;// 比较当前线程池 ctl 所表示的状态，是否大于等于某个状态sprivate static boolean runStateAtLeast(int c, int s) &#123; return c &gt;= s; &#125;// 小于 SHUTDOWN 的一定是 RUNNING，SHUTDOWN == 0private static boolean isRunning(int c) &#123; return c &lt; SHUTDOWN; &#125;</code></pre></li><li><p>设置线程池 ctl：</p><pre><code class="java">// 使用 CAS 方式 让 ctl 值 +1 ，成功返回 true, 失败返回 falseprivate boolean compareAndIncrementWorkerCount(int expect) &#123;    return ctl.compareAndSet(expect, expect + 1);&#125;// 使用 CAS 方式 让 ctl 值 -1 ，成功返回 true, 失败返回 falseprivate boolean compareAndDecrementWorkerCount(int expect) &#123;    return ctl.compareAndSet(expect, expect - 1);&#125;// 将 ctl 值减一，do while 循环会一直重试，直到成功为止private void decrementWorkerCount() &#123;    do &#123;&#125; while (!compareAndDecrementWorkerCount(ctl.get()));&#125;</code></pre></li></ul><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><pre><code class="java">public ThreadPoolExecutor(int corePoolSize,                          int maximumPoolSize,                          long keepAliveTime,                          TimeUnit unit,                          BlockingQueue&lt;Runnable&gt; workQueue,                          ThreadFactory threadFactory,                          RejectedExecutionHandler handler)</code></pre><ul><li><p>corePoolSize 核心线程数目 (最多保留的线程数)</p></li><li><p>maximumPoolSize 最大线程数目</p></li><li><p>keepAliveTime 生存时间 - 针对救急线程</p></li><li><p>unit 时间单位 - 针对救急线程</p></li><li><p>workQueue 阻塞队列</p></li><li><p>threadFactory 线程工厂 - 可以为线程创建时起个好名字</p></li><li><p>handler 拒绝策略</p></li></ul><h4 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式:"></a>工作方式:</h4><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230102141609805.png" alt="image-20230102141609805"></p><ul><li><p>线程池中刚开始没有线程，当一个任务提交给线程池后，线程池会创建一个新线程来执行任务。</p></li><li><p>当线程数达到 corePoolSize 并没有线程空闲，这时再加入任务，新加的任务会被加入workQueue 队列排</p></li></ul><p>​队，直到有空闲的线程。</p><ul><li>如果队列选择了有界队列，那么任务超过了队列大小时，会创建 maximumPoolSize - corePoolSize 数目的线</li></ul><p>​程来救急。</p><ul><li>如果线程到达 maximumPoolSize 仍然有新任务这时会执行拒绝策略。拒绝策略 jdk 提供了 4 种实现，其它</li></ul><p>​著名框架也提供了实现</p><p>​  1. AbortPolicy 让调用者抛出 RejectedExecutionException 异常，这是默认策略</p><p>​  2. DiscardPolicy 放弃本次任务</p><p>​  3.DiscardOldestPolicy 放弃队列中最早的任务，本任务取而代之</p><p>​  4. Dubbo 的实现，在抛出 RejectedExecutionException 异常之前会记录日志，并 dump 线程栈信息，方</p><p>​便定位问题</p><p>​ 5.Netty 的实现，是创建一个新线程来执行任务</p><pre><code class="java">  6.ActiveMQ 的实现，带超时等待（60s）尝试放入队列，类似我们之前自定义的拒绝策略    7.PinPoint 的实现，它使用了一个拒绝策略链，会逐一尝试策略链中每种拒绝策略</code></pre><ul><li>当高峰过去后，超过corePoolSize 的救急线程如果一段时间没有任务做，需要结束节省资源，这个时间由</li></ul><p>​keepAliveTime 和 unit 来控制。</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230102141915522.png" alt="image-20230102141915522"></p><p>Executors 提供了四种线程池的创建：newCachedThreadPool、newFixedThreadPool、newSingleThreadExecutor、newScheduledThreadPool</p><h3 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h3><pre><code class="java">public static ExecutorService newFixedThreadPool(int nThreads) &#123;    return new ThreadPoolExecutor(nThreads, nThreads,                                  0L, TimeUnit.MILLISECONDS,                                  new LinkedBlockingQueue&lt;Runnable&gt;());&#125;</code></pre><p>特点</p><ul><li><p>核心线程数 &#x3D;&#x3D; 最大线程数（没有救急线程被创建），因此也无需超时时间</p></li><li><p>阻塞队列是无界的，可以放任意数量的任务</p></li></ul><blockquote><p><strong>评价</strong> 适用于任务量已知，相对耗时的任务</p></blockquote><h3 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h3><pre><code class="java">public static ExecutorService newCachedThreadPool() &#123;    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,                                  60L, TimeUnit.SECONDS,                                  new SynchronousQueue&lt;Runnable&gt;());&#125;</code></pre><p>特点</p><ul><li><p>核心线程数是 0， </p></li><li><p>最大线程数是 Integer.MAX_VALUE，救急线程的空闲生存时间是 60s，意味着</p><ul><li>全部都是救急线程（60s 后可以回收）</li><li>救急线程可以无限创建</li></ul></li><li><p>队列采用了 SynchronousQueue 实现特点是，它没有容量，没有线程来取是放不进去的（一手交钱、一手交</p></li></ul><p>​货）</p><pre><code class="java">    SynchronousQueue&lt;Integer&gt;integers=new SynchronousQueue&lt;&gt;();        new Thread(() -&gt; &#123;            try &#123;                log.debug(&quot;putting &#123;&#125; &quot;, 1);                integers.put(1);                log.debug(&quot;&#123;&#125; putted...&quot;, 1);                log.debug(&quot;putting...&#123;&#125; &quot;, 2);                integers.put(2);                log.debug(&quot;&#123;&#125; putted...&quot;, 2);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;,&quot;t1&quot;).start();        Sleeper.sleep(1000);        new Thread(() -&gt; &#123;            try &#123;                log.debug(&quot;taking &#123;&#125;&quot;, 1);                integers.take();            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;,&quot;t2&quot;).start();        Sleeper.sleep(1000);        new Thread(() -&gt; &#123;            try &#123;                log.debug(&quot;taking &#123;&#125;&quot;, 2);                integers.take();            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;,&quot;t3&quot;).start();</code></pre><p>输出:</p><p>14:23:25.562 [t1] DEBUG com.dylan.ThreadPool.testSynchronousQueue - putting 1<br>14:23:26.574 [t2] DEBUG com.dylan.ThreadPool.testSynchronousQueue - taking 1<br>14:23:26.575 [t1] DEBUG com.dylan.ThreadPool.testSynchronousQueue - 1 putted…<br>14:23:26.575 [t1] DEBUG com.dylan.ThreadPool.testSynchronousQueue - putting…2<br>14:23:27.586 [t3] DEBUG com.dylan.ThreadPool.testSynchronousQueue - taking 2<br>14:23:27.587 [t1] DEBUG com.dylan.ThreadPool.testSynchronousQueue - 2 putted…</p><blockquote><p><strong>评价</strong> 整个线程池表现为线程数会根据任务量不断增长，没有上限，当任务执行完毕，空闲 1分钟后释放线</p><p>程。 适合任务数比较密集，但每个任务执行时间较短的情况</p></blockquote><h3 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h3><pre><code class="java">public static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory) &#123;    return new FinalizableDelegatedExecutorService        (new ThreadPoolExecutor(1, 1,                                0L, TimeUnit.MILLISECONDS,                                new LinkedBlockingQueue&lt;Runnable&gt;(),                                threadFactory));&#125;</code></pre><p>使用场景：</p><p>希望多个任务排队执行。线程数固定为 1，任务数多于 1 时，会放入无界队列排队。任务执行完毕，这唯一的线程</p><p>也不会被释放。</p><p>区别：</p><ul><li>自己创建一个单线程串行执行任务，如果任务执行失败而终止那么没有任何补救措施，而线程池还会新建一</li></ul><p>​个线程，保证池的正常工作</p><ul><li>Executors.newSingleThreadExecutor() 线程个数始终为1，不能修改<ul><li>FinalizableDelegatedExecutorService 应用的是装饰器模式，只对外暴露了 ExecutorService 接口，因</li></ul></li></ul><p>​此不能调用 ThreadPoolExecutor 中特有的方法</p><ul><li>Executors.newFixedThreadPool(1) 初始时为1，以后还可以修改<ul><li>对外暴露的是 ThreadPoolExecutor 对象，可以强转后调用 setCorePoolSize 等方法进行修改</li></ul></li></ul><hr><h3 id="开发要求"><a href="#开发要求" class="headerlink" title="开发要求"></a>开发要求</h3><p>阿里巴巴 Java 开发手册要求：</p><ul><li><p><strong>线程资源必须通过线程池提供，不允许在应用中自行显式创建线程</strong></p><ul><li>使用线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源的开销，解决资源不足的问题</li><li>如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者过度切换的问题</li></ul></li><li><p>线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式更加明确线程池的运行规则，规避资源耗尽的风险</p><p>Executors 返回的线程池对象弊端如下：</p><ul><li>FixedThreadPool 和 SingleThreadPool：请求队列长度为 Integer.MAX_VALUE(可看做是无界的)，可能会堆积大量的请求，从而导致 OOM</li><li>CacheThreadPool 和 ScheduledThreadPool：允许创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，导致 OOM</li></ul></li></ul><p>创建多大容量的线程池合适？</p><ul><li><p>一般来说池中<strong>总线程数是核心池线程数量两倍</strong>，确保当核心池有线程停止时，核心池外有线程进入核心池</p></li><li><p>过小会导致程序不能充分地利用系统资源、容易导致饥饿</p></li><li><p>过大会导致更多的线程上下文切换，占用更多内存</p><p>上下文切换：当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态，任务从保存到再加载的过程就是一次上下文切换</p></li></ul><p>核心线程数常用公式：</p><ul><li><p><strong>CPU 密集型任务 (N+1)：</strong> 这种任务消耗的是 CPU 资源，可以将核心线程数设置为 N (CPU 核心数) + 1，比 CPU 核心数多出来的一个线程是为了防止线程发生缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 某个核心就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间</p><p>CPU 密集型简单理解就是利用 CPU 计算能力的任务比如在内存中对大量数据进行分析</p></li><li><p><strong>I&#x2F;O 密集型任务：</strong> 这种系统 CPU 处于阻塞状态，用大部分的时间来处理 I&#x2F;O 交互，而线程在处理 I&#x2F;O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用，因此在 I&#x2F;O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 2N 或 CPU 核数&#x2F; (1-阻塞系数)，阻塞系数在 0.8~0.9 之间</p><p>IO 密集型就是涉及到网络读取，文件读取此类任务 ，特点是 CPU 计算耗费时间相比于等待 IO 操作完成的时间来说很少，大部分时间都花在了等待 IO 操作完成上</p></li></ul><h3 id="提交任务"><a href="#提交任务" class="headerlink" title="提交任务"></a>提交任务</h3><p>ExecutorService 类 API：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>void execute(Runnable command)</td><td>执行任务（Executor 类 API）</td></tr><tr><td>Future&lt;?&gt; submit(Runnable task)</td><td>提交任务 task()</td></tr><tr><td>Future submit(Callable task)</td><td>提交任务 task，用返回值 Future 获得任务执行结果</td></tr><tr><td>List<Future> invokeAll(Collection&lt;? extends Callable&gt; tasks)</td><td>提交 tasks 中所有任务</td></tr><tr><td>List<Future> invokeAll(Collection&lt;? extends Callable&gt; tasks, long timeout, TimeUnit unit)</td><td>提交 tasks 中所有任务，超时时间针对所有task，超时会取消没有执行完的任务，并抛出超时异常</td></tr><tr><td>T invokeAny(Collection&lt;? extends Callable&gt; tasks)</td><td>提交 tasks 中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其它任务取消</td></tr></tbody></table><p>execute 和 submit 都属于线程池的方法，对比：</p><ul><li>execute 只能执行 Runnable 类型的任务，没有返回值； submit 既能提交 Runnable 类型任务也能提交 Callable 类型任务，底层是<strong>封装成 FutureTask，然后调用 execute 执行</strong></li><li>execute 会直接抛出任务执行时的异常，submit 会吞掉异常，可通过 Future 的 get 方法将任务执行时的异常重新抛出</li></ul><pre><code class="java">// 执行任务void execute(Runnable command);// 提交任务 task，用返回值 Future 获得任务执行结果&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);// 提交 tasks 中所有任务&lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks) throws InterruptedException;// 提交 tasks 中所有任务，带超时时间&lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit)throws InterruptedException;// 提交 tasks 中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其它任务取消&lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)throws InterruptedException, ExecutionException;// 提交 tasks 中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其它任务取消，带超时时间&lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit)throws InterruptedException, ExecutionException, TimeoutException;</code></pre><h3 id="关闭线程池"><a href="#关闭线程池" class="headerlink" title="关闭线程池"></a>关闭线程池</h3><p>ExecutorService 类 API：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>void shutdown()</td><td>线程池状态变为 SHUTDOWN，等待任务执行完后关闭线程池，不会接收新任务，但已提交任务会执行完，而且也可以添加线程（不绑定任务）</td></tr><tr><td>List shutdownNow()</td><td>线程池状态变为 STOP，用 interrupt 中断正在执行的任务，直接关闭线程池，不会接收新任务，会将队列中的任务返回</td></tr><tr><td>boolean isShutdown()</td><td>不在 RUNNING 状态的线程池，此执行者已被关闭，方法返回 true</td></tr><tr><td>boolean isTerminated()</td><td>线程池状态是否是 TERMINATED，如果所有任务在关闭后完成，返回 true</td></tr><tr><td>boolean awaitTermination(long timeout, TimeUnit unit)</td><td>调用 shutdown 后，由于调用线程不会等待所有任务运行结束，如果它想在线程池 TERMINATED 后做些事情，可以利用此方法等待</td></tr></tbody></table><h4 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a>shutdown</h4><pre><code class="java">/*线程池状态变为 SHUTDOWN- 不会接收新任务- 但已提交任务会执行完- 此方法不会阻塞调用线程的执行*/void shutdown();</code></pre><pre><code class="java">public void shutdown() &#123;     final ReentrantLock mainLock = this.mainLock;     mainLock.lock();     try &#123;         checkShutdownAccess();         // 修改线程池状态         advanceRunState(SHUTDOWN);         // 仅会打断空闲线程         interruptIdleWorkers();         onShutdown(); // 扩展点 ScheduledThreadPoolExecutor     &#125; finally &#123;         mainLock.unlock();     &#125;     // 尝试终结(没有运行的线程可以立刻终结，如果还有运行的线程也不会等)     tryTerminate();&#125;</code></pre><h4 id="shutdownNow"><a href="#shutdownNow" class="headerlink" title="shutdownNow"></a>shutdownNow</h4><pre><code class="java">/*线程池状态变为 STOP- 不会接收新任务- 会将队列中的任务返回- 并用 interrupt 的方式中断正在执行的任务*/List&lt;Runnable&gt; shutdownNow();</code></pre><pre><code class="java">public List&lt;Runnable&gt; shutdownNow() &#123;    List&lt;Runnable&gt; tasks;     final ReentrantLock mainLock = this.mainLock;     mainLock.lock();     try &#123;         checkShutdownAccess();         // 修改线程池状态         advanceRunState(STOP);         // 打断所有线程         interruptWorkers();         // 获取队列中剩余任务         tasks = drainQueue();     &#125; finally &#123;         mainLock.unlock();     &#125;     // 尝试终结     tryTerminate();     return tasks;&#125;</code></pre><h4 id="其它方法"><a href="#其它方法" class="headerlink" title="其它方法"></a>其它方法</h4><pre><code class="java">// 不在 RUNNING 状态的线程池，此方法就返回 trueboolean isShutdown();// 线程池状态是否是 TERMINATEDboolean isTerminated();// 调用 shutdown 后，由于调用线程并不会等待所有任务运行结束，因此如果它想在线程池 TERMINATED 后做些事情，可以利用此方法等待boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException;</code></pre><h4 id="处理异常"><a href="#处理异常" class="headerlink" title="处理异常"></a>处理异常</h4><p>execute 会直接抛出任务执行时的异常，submit 会吞掉异常，有两种处理方法</p><p>方法 1：主动捉异常</p><pre><code class="java">ExecutorService executorService = Executors.newFixedThreadPool(1);pool.submit(() -&gt; &#123;    try &#123;        System.out.println(&quot;task1&quot;);        int i = 1 / 0;    &#125; catch (Exception e) &#123;        e.printStackTrace();    &#125;&#125;);</code></pre><p>方法 2：使用 Future 对象</p><pre><code class="java">ExecutorService executorService = Executors.newFixedThreadPool(1);Future&lt;?&gt; future = pool.submit(() -&gt; &#123;    System.out.println(&quot;task1&quot;);    int i = 1 / 0;    return true;&#125;);System.out.println(future.get());</code></pre><h3 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h3><h4 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h4><p>Timer 实现定时功能，Timer 的优点在于简单易用，但由于所有任务都是由同一个线程来调度，因此所有任务都是串行执行的，同一时间只能有一个任务在执行，前一个任务的延迟或异常都将会影响到之后的任务</p><pre><code class="java">private static void method1() &#123;    Timer timer = new Timer();    TimerTask task1 = new TimerTask() &#123;        @Override        public void run() &#123;            System.out.println(&quot;task 1&quot;);            //int i = 1 / 0;//任务一的出错会导致任务二无法执行            Thread.sleep(2000);        &#125;    &#125;;    TimerTask task2 = new TimerTask() &#123;        @Override        public void run() &#123;            System.out.println(&quot;task 2&quot;);        &#125;    &#125;;    // 使用 timer 添加两个任务，希望它们都在 1s 后执行    // 但由于 timer 内只有一个线程来顺序执行队列中的任务，因此任务1的延时，影响了任务2的执行    timer.schedule(task1, 1000);//17:45:56 c.ThreadPool [Timer-0] - task 1    timer.schedule(task2, 1000);//17:45:58 c.ThreadPool [Timer-0] - task 2&#125;</code></pre><h4 id="Scheduled"><a href="#Scheduled" class="headerlink" title="Scheduled"></a>Scheduled</h4><p>任务调度线程池 ScheduledThreadPoolExecutor 继承 ThreadPoolExecutor：</p><ul><li>使用内部类 ScheduledFutureTask 封装任务</li><li>使用内部类 DelayedWorkQueue 作为线程池队列</li><li>重写 onShutdown 方法去处理 shutdown 后的任务</li><li>提供 decorateTask 方法作为 ScheduledFutureTask 的修饰方法，以便开发者进行扩展</li></ul><p>构造方法：<code>Executors.newScheduledThreadPool(int corePoolSize)</code></p><pre><code class="java">public ScheduledThreadPoolExecutor(int corePoolSize) &#123;    // 最大线程数固定为 Integer.MAX_VALUE，保活时间 keepAliveTime 固定为 0    super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,          // 阻塞队列是 DelayedWorkQueue          new DelayedWorkQueue());&#125;</code></pre><p>常用 API：</p><ul><li><code>ScheduledFuture&lt;?&gt; schedule(Runnable/Callable&lt;V&gt;, long delay, TimeUnit u)</code>：延迟执行任务</li><li><code>ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable/Callable&lt;V&gt;, long initialDelay, long period, TimeUnit unit)</code>：定时执行周期任务，不考虑执行的耗时，参数为初始延迟时间、间隔时间、单位</li><li><code>ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable/Callable&lt;V&gt;, long initialDelay, long delay, TimeUnit unit)</code>：定时执行周期任务，考虑执行的耗时，参数为初始延迟时间、间隔时间、单位</li></ul><p>基本使用：</p><ul><li><p>延迟任务，但是出现异常并不会在控制台打印，也不会影响其他线程的执行</p><pre><code class="java">public static void main(String[] args)&#123;    // 线程池大小为1时也是串行执行    ScheduledExecutorService executor = Executors.newScheduledThreadPool(2);    // 添加两个任务，都在 1s 后同时执行    executor.schedule(() -&gt; &#123;        System.out.println(&quot;任务1，执行时间：&quot; + new Date());        //int i = 1 / 0;        try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; &#125;    &#125;, 1000, TimeUnit.MILLISECONDS);        executor.schedule(() -&gt; &#123;        System.out.println(&quot;任务2，执行时间：&quot; + new Date());    &#125;, 1000, TimeUnit.MILLISECONDS);&#125;</code></pre></li><li><p>定时任务 scheduleAtFixedRate：<strong>一次任务的启动到下一次任务的启动</strong>之间只要大于等于间隔时间，抢占到 CPU 就会立即执行</p><pre><code class="java">public static void main(String[] args) &#123;    ScheduledExecutorService pool = Executors.newScheduledThreadPool(1);    System.out.println(&quot;start...&quot; + new Date());        pool.scheduleAtFixedRate(() -&gt; &#123;        System.out.println(&quot;running...&quot; + new Date());        Thread.sleep(2000);    &#125;, 1, 1, TimeUnit.SECONDS);&#125;/*start...Sat Apr 24 18:08:12 CST 2021running...Sat Apr 24 18:08:13 CST 2021running...Sat Apr 24 18:08:15 CST 2021running...Sat Apr 24 18:08:17 CST 2021</code></pre></li><li><p>定时任务 scheduleWithFixedDelay：<strong>一次任务的结束到下一次任务的启动之间</strong>等于间隔时间，抢占到 CPU 就会立即执行，这个方法才是真正的设置两个任务之间的间隔</p><pre><code class="java">public static void main(String[] args)&#123;    ScheduledExecutorService pool = Executors.newScheduledThreadPool(3);    System.out.println(&quot;start...&quot; + new Date());        pool.scheduleWithFixedDelay(() -&gt; &#123;        System.out.println(&quot;running...&quot; + new Date());        Thread.sleep(2000);    &#125;, 1, 1, TimeUnit.SECONDS);&#125;/*start...Sat Apr 24 18:11:41 CST 2021running...Sat Apr 24 18:11:42 CST 2021running...Sat Apr 24 18:11:45 CST 2021running...Sat Apr 24 18:11:48 CST 2021</code></pre></li></ul><p>用例: 每周四18点执行定时任务一次:</p><pre><code class="java">@Slf4jpublic class testScheduled &#123;    public static void main(String[] args) &#123;        //获取当前时间        LocalDateTime now=LocalDateTime.now();        //获取本周四时间的18点整        LocalDateTime time = now.withHour(18).withMinute(0).withSecond(0).withNano(0).with(DayOfWeek.THURSDAY);        //如果当前时间大于本周四18点,那么就获取下周四时间        if (now.compareTo(time)&gt;0)&#123;            time=time.plusWeeks(1);        &#125;        //获取两个时间点的时间间隔作为起始时间间隔        Duration between = Duration.between(now, time);        //System.out.println(between.toMillis());        long initialDelay = between.toMillis();        //固定间隔为一周        long period=1000*60*60*24*7;        ScheduledExecutorService pool = Executors.newScheduledThreadPool(1);        pool.scheduleAtFixedRate(()-&gt;&#123;            System.out.println(&quot;running&quot;);        &#125;,initialDelay,period, TimeUnit.MILLISECONDS);    &#125;&#125;</code></pre><h3 id="TomCat线程池"><a href="#TomCat线程池" class="headerlink" title="TomCat线程池"></a>TomCat线程池</h3><p>Tomcat 在哪里用到了线程池呢?</p><ul><li>LimitLatch 用来限流，可以控制最大连接个数，类似 J.U.C 中的 Semaphore</li><li>Acceptor 只负责【接收新的 socket 连接】</li><li>Poller 只负责监听 socket channel 是否有【可读的 I&#x2F;O 事件】</li><li>一旦可读，封装一个任务对象（socketProcessor），提交给 Executor 线程池处理</li><li>Executor 线程池中的工作线程最终负责【处理请求】</li></ul><p>Tomcat 线程池扩展了 ThreadPoolExecutor，行为稍有不同</p><ul><li>如果总线程数达到 maximumPoolSize<ul><li>这时不会立刻抛 RejectedExecutionException 异常</li><li>而是再次尝试将任务放入队列，如果还失败，才抛出 RejectedExecutionException 异常</li></ul></li></ul><p>源码 tomcat-7.0.42</p><pre><code class="java"> public void execute(Runnable command, long timeout, TimeUnit unit) &#123;        submittedCount.incrementAndGet();        try &#123;            super.execute(command);        &#125; catch (RejectedExecutionException rx) &#123;            if (super.getQueue() instanceof TaskQueue) &#123;                final TaskQueue queue = (TaskQueue)super.getQueue();                try &#123;                    if (!queue.force(command, timeout, unit)) &#123;                        submittedCount.decrementAndGet();                        throw new RejectedExecutionException(&quot;Queue capacity is full.&quot;);                    &#125;                &#125; catch (InterruptedException x) &#123;                    submittedCount.decrementAndGet();                    Thread.interrupted();                    throw new RejectedExecutionException(x);                &#125;            &#125; else &#123;                submittedCount.decrementAndGet();                throw rx;            &#125;        &#125;    &#125;</code></pre><p>TaskQueue.java</p><pre><code class="java">public boolean force(Runnable o, long timeout, TimeUnit unit) throws InterruptedException &#123;    if ( parent.isShutdown() )        throw new RejectedExecutionException(                &quot;Executor not running, can&#39;t force a command into the queue&quot;        );    return super.offer(o,timeout,unit); //forces the item onto the queue, to be used if the task     is rejected&#125;</code></pre><p>Connector 配置</p><table><thead><tr><th><strong>配置项</strong></th><th>默认值</th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>acceptorThreadCount</td><td>1</td><td>acceptor 线程数量</td></tr><tr><td>pollerThreadCount</td><td>1</td><td>poller 线程数量</td></tr><tr><td>minSpareThreads</td><td>10</td><td>核心线程数，即 corePoolSize</td></tr><tr><td>maxThreads</td><td>200</td><td>最大线程数，即 maximumPoolSize</td></tr><tr><td>executor</td><td>-</td><td>Executor 名称，用来引用下面的 Executor</td></tr></tbody></table><p>Executor 线程配置</p><table><thead><tr><th><strong>配置项</strong></th><th><strong>默认值</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>threadPriority</td><td>5</td><td>线程优先级</td></tr><tr><td>daemon</td><td>true</td><td>是否守护线程</td></tr><tr><td>minSpareThreads</td><td>25</td><td>核心线程数，即 corePoolSize</td></tr><tr><td>maxThreads</td><td>200</td><td>最大线程数，即 maximumPoolSize</td></tr><tr><td>maxIdleTime</td><td>60000</td><td>线程生存时间，单位是毫秒，默认值即 1 分钟</td></tr><tr><td>maxQueueSize</td><td>Integer.MAX_VALUE</td><td>队列长度</td></tr><tr><td>prestartminSpareThreads</td><td>false</td><td>核心线程是否在服务器启动时启动</td></tr></tbody></table><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230103174939449.png" alt="image-20230103174939449"></p><h3 id="Fork-Join"><a href="#Fork-Join" class="headerlink" title="Fork&#x2F;Join"></a>Fork&#x2F;Join</h3><p>Fork&#x2F;Join：线程池的实现，体现是分治思想，适用于能够进行任务拆分的 CPU 密集型运算，用于<strong>并行计算</strong></p><p>任务拆分：将一个大任务拆分为算法上相同的小任务，直至不能拆分可以直接求解。跟递归相关的一些计算，如归并排序、斐波那契数列都可以用分治思想进行求解</p><ul><li>Fork&#x2F;Join 在<strong>分治的基础上加入了多线程</strong>，把每个任务的分解和合并交给不同的线程来完成，提升了运算效率</li><li>ForkJoin 使用 ForkJoinPool 来启动，是一个特殊的线程池，默认会创建与 CPU 核心数大小相同的线程池</li><li>任务有返回值继承 RecursiveTask，没有返回值继承 RecursiveAction</li></ul><pre><code class="java">public static void main(String[] args) &#123;    ForkJoinPool pool = new ForkJoinPool(4);    System.out.println(pool.invoke(new MyTask(5)));    //拆分  5 + MyTask(4) --&gt; 4 + MyTask(3) --&gt;&#125;// 1~ n 之间整数的和class MyTask extends RecursiveTask&lt;Integer&gt; &#123;    private int n;    public MyTask(int n) &#123;        this.n = n;    &#125;    @Override    public String toString() &#123;        return &quot;MyTask&#123;&quot; + &quot;n=&quot; + n + &#39;&#125;&#39;;    &#125;    @Override    protected Integer compute() &#123;        // 如果 n 已经为 1，可以求得结果了        if (n == 1) &#123;            return n;        &#125;        // 将任务进行拆分(fork)        MyTask t1 = new MyTask(n - 1);        t1.fork();        // 合并(join)结果        int result = n + t1.join();        return result;    &#125;&#125;</code></pre><p>继续拆分优化：</p><pre><code class="java">class AddTask extends RecursiveTask&lt;Integer&gt; &#123;    int begin;    int end;    public AddTask(int begin, int end) &#123;        this.begin = begin;        this.end = end;    &#125;        @Override    public String toString() &#123;        return &quot;&#123;&quot; + begin + &quot;,&quot; + end + &#39;&#125;&#39;;    &#125;        @Override    protected Integer compute() &#123;        // 5, 5        if (begin == end) &#123;            return begin;        &#125;        // 4, 5  防止多余的拆分  提高效率        if (end - begin == 1) &#123;            return end + begin;        &#125;        // 1 5        int mid = (end + begin) / 2; // 3        AddTask t1 = new AddTask(begin, mid); // 1,3        t1.fork();        AddTask t2 = new AddTask(mid + 1, end); // 4,5        t2.fork();        int result = t1.join() + t2.join();        return result;    &#125;&#125;</code></pre><p>ForkJoinPool 实现了<strong>工作窃取算法</strong>来提高 CPU 的利用率：</p><ul><li>每个线程都维护了一个<strong>双端队列</strong>，用来存储需要执行的任务</li><li>工作窃取算法允许空闲的线程从其它线程的双端队列中窃取一个任务来执行</li><li>窃取的必须是<strong>最晚的任务</strong>，避免和队列所属线程发生竞争，但是队列中只有一个任务时还是会发生竞争</li></ul><h2 id="8-2-J-U-C"><a href="#8-2-J-U-C" class="headerlink" title="8.2 J.U.C"></a>8.2 J.U.C</h2><h3 id="1-AQS"><a href="#1-AQS" class="headerlink" title="1.AQS"></a>1.AQS</h3><h4 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h4><p>AQS：AbstractQueuedSynchronizer，是阻塞式锁和相关的同步器工具的框架，许多同步类实现都依赖于该同步器</p><p>AQS 用状态属性来表示资源的状态（分<strong>独占模式和共享模式</strong>），子类需要定义如何维护这个状态，控制如何获取锁和释放锁</p><ul><li>独占模式是只有一个线程能够访问资源，如 ReentrantLock</li><li>共享模式允许多个线程访问资源，如 Semaphore，ReentrantReadWriteLock 是组合式</li></ul><p>AQS 核心思想：</p><ul><li><p>如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并将共享资源设置锁定状态</p></li><li><p>请求的共享资源被占用，AQS 用队列实现线程阻塞等待以及被唤醒时锁分配的机制，将暂时获取不到锁的线程加入到队列中</p><p>CLH 是一种基于单向链表的<strong>高性能、公平的自旋锁</strong>，AQS 是将每条请求共享资源的线程封装成一个 CLH 锁队列的一个结点（Node）来实现锁的分配</p></li></ul><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230103182627999.png" alt="image-20230103182627999"></p><h4 id="设计原理"><a href="#设计原理" class="headerlink" title="设计原理"></a>设计原理</h4><p>设计原理：</p><ul><li><p>获取锁：</p><pre><code class="java">while(state 状态不允许获取) &#123;// tryAcquire(arg)    if(队列中还没有此线程) &#123;        入队并阻塞 park    &#125;&#125;当前线程出队</code></pre></li><li><p>释放锁：</p><pre><code class="java">if(state 状态允许了) &#123;// tryRelease(arg)    恢复阻塞的线程(s) unpark&#125;</code></pre></li></ul><p>AbstractQueuedSynchronizer 中 state 设计：</p><ul><li><p>state 使用了 32bit int 来维护同步状态，独占模式 0 表示未加锁状态，大于 0 表示已经加锁状态</p><pre><code class="java">private volatile int state;</code></pre></li><li><p>state <strong>使用 volatile 修饰配合 cas</strong> 保证其修改时的原子性</p></li><li><p>state 表示<strong>线程重入的次数（独占模式）或者剩余许可数（共享模式）</strong></p></li><li><p>state API：</p><ul><li><code>protected final int getState()</code>：获取 state 状态</li><li><code>protected final void setState(int newState)</code>：设置 state 状态</li><li><code>protected final boolean compareAndSetState(int expect,int update)</code>：<strong>CAS</strong> 安全设置 state</li></ul></li></ul><p>封装线程的 Node 节点中 waitstate 设计：</p><ul><li><p>使用 <strong>volatile 修饰配合 CAS</strong> 保证其修改时的原子性</p></li><li><p>表示 Node 节点的状态，有以下几种状态：</p><pre><code class="java">// 默认为 0volatile int waitStatus;// 由于超时或中断，此节点被取消，不会再改变状态static final int CANCELLED =  1;// 此节点后面的节点已（或即将）被阻止（通过park），【当前节点在释放或取消时必须唤醒后面的节点】static final int SIGNAL    = -1;// 此节点当前在条件队列中static final int CONDITION = -2;// 将releaseShared传播到其他节点static final int PROPAGATE = -3;</code></pre></li></ul><p>阻塞恢复设计：</p><ul><li>使用 park &amp; unpark 来实现线程的暂停和恢复，因为命令的先后顺序不影响结果</li><li>park &amp; unpark 是针对线程的，而不是针对同步器的，因此控制粒度更为精细</li><li>park 线程可以通过 interrupt 打断</li></ul><p>队列设计：</p><ul><li><p>使用了 FIFO 先入先出队列，并不支持优先级队列，<strong>同步队列是双向链表，便于出队入队</strong></p><pre><code class="java">// 头结点，指向哑元节点private transient volatile Node head;// 阻塞队列的尾节点，阻塞队列不包含头结点，从 head.next → tail 认为是阻塞队列private transient volatile Node tail;static final class Node &#123;    // 枚举：共享模式    static final Node SHARED = new Node();    // 枚举：独占模式    static final Node EXCLUSIVE = null;    // node 需要构建成 FIFO 队列，prev 指向前继节点    volatile Node prev;    // next 指向后继节点    volatile Node next;    // 当前 node 封装的线程    volatile Thread thread;    // 条件队列是单向链表，只有后继指针，条件队列使用该属性    Node nextWaiter;&#125;</code></pre></li></ul><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230103183015000.png" alt="image-20230103183015000"></p><ul><li>条件变量来实现等待、唤醒机制，支持多个条件变量，类似于 Monitor 的 WaitSet，<strong>条件队列是单向链表</strong></li></ul><pre><code class="java">public class ConditionObject implements Condition, java.io.Serializable &#123;     // 指向条件队列的第一个 node 节点     private transient Node firstWaiter;     // 指向条件队列的最后一个 node 节点     private transient Node lastWaiter; &#125;</code></pre><h4 id="模板对象"><a href="#模板对象" class="headerlink" title="模板对象"></a>模板对象</h4><p>同步器的设计是基于模板方法模式，该模式是基于继承的，主要是为了在不改变模板结构的前提下在子类中重新定义模板中的内容以实现复用代码</p><ul><li>使用者继承 <code>AbstractQueuedSynchronizer</code> 并重写指定的方法</li><li>将 AQS 组合在自定义同步组件的实现中，并调用其模板方法，这些模板方法会调用使用者重写的方法</li></ul><p>AQS 使用了模板方法模式，自定义同步器时需要重写下面几个 AQS 提供的模板方法：</p><pre><code class="java">isHeldExclusively()//该线程是否正在独占资源。只有用到condition才需要去实现它tryAcquire(int)//独占方式。尝试获取资源，成功则返回true，失败则返回falsetryRelease(int)//独占方式。尝试释放资源，成功则返回true，失败则返回falsetryAcquireShared(int)//共享方式。尝试获取资源。负数表示失败；0表示成功但没有剩余可用资源；正数表示成功且有剩余资源tryReleaseShared(int)//共享方式。尝试释放资源，成功则返回true，失败则返回false</code></pre><ul><li>默认情况下，每个方法都抛出 <code>UnsupportedOperationException</code></li><li>这些方法的实现必须是内部线程安全的</li><li>AQS 类中的其他方法都是 final ，所以无法被其他类使用，只有这几个方法可以被其他类使用</li></ul><h4 id="自定义"><a href="#自定义" class="headerlink" title="自定义"></a>自定义</h4><p>自定义一个不可重入锁：</p><pre><code class="java">@Slf4jpublic class testAqs &#123;    public static void main(String[] args) &#123;        MyLock myLock=new MyLock();        new Thread(()-&gt;&#123;            myLock.lock();            try &#123;                log.debug(&quot;加锁成功&quot;);                Sleeper.sleep(1000);            &#125;finally &#123;                //log.debug(&quot;解锁成功&quot;);               myLock.unlock();            &#125;        &#125;,&quot;t1&quot;).start();        new Thread(()-&gt;&#123;            myLock.unlock();            myLock.lock();            try &#123;                log.debug(&quot;加锁成功&quot;);            &#125;finally &#123;                log.debug(&quot;解锁&quot;);                myLock.unlock();            &#125;        &#125;,&quot;t2&quot;).start();    &#125;&#125;//自定义锁(不可重入)class MyLock implements Lock&#123;    private MySnc mySnc=new MySnc();    //独占锁    class MySnc extends AbstractQueuedLongSynchronizer&#123;        @Override        protected boolean tryAcquire(long arg) &#123;            if(compareAndSetState(0,1))&#123;                //加上了锁,并且设置owner为当前线程                setExclusiveOwnerThread(Thread.currentThread());                return true;            &#125;            return false;        &#125;        @Override        protected boolean tryRelease(long arg) &#123;            if(isHeldExclusively())&#123;                setExclusiveOwnerThread(null);                setState(0);                return true;            &#125;            System.out.println(&quot;当前持有锁的线程是:&quot;+getExclusiveOwnerThread());            System.out.println(&quot;而请求释放锁的线程是:&quot;+Thread.currentThread());            return false;        &#125;        //是否持有独占锁        @Override        protected boolean isHeldExclusively() &#123;            Thread thread = getExclusiveOwnerThread();            return Thread.currentThread()==thread;        &#125;        public Condition newCondition()&#123;            return new ConditionObject();        &#125;    &#125;    //加锁,不成功就会进入等待队列等待    @Override    public void lock() &#123;        mySnc.acquire(1);    &#125;    //可打断的加锁    @Override    public void lockInterruptibly() throws InterruptedException &#123;        mySnc.acquireInterruptibly(1);    &#125;    //尝试加锁(只尝试一次)    @Override    public boolean tryLock() &#123;        return mySnc.tryAcquire(1);    &#125;    //带超时的尝试加锁    @Override    public boolean tryLock(long time, TimeUnit unit) throws InterruptedException &#123;        return mySnc.tryAcquireNanos(1, unit.toNanos(time));    &#125;    //解锁    @Override    public void unlock() &#123;        if (mySnc.release(1)) &#123;            System.out.println(&quot;解锁成功&quot;);        &#125;else &#123;            System.out.println(&quot;解锁失败&quot;);        &#125;    &#125;    //创建条件变量    @Override    public Condition newCondition() &#123;        return mySnc.newCondition();    &#125;   &#125;</code></pre><h3 id="2-ReentrantLock原理"><a href="#2-ReentrantLock原理" class="headerlink" title="2.ReentrantLock原理"></a>2.ReentrantLock原理</h3><h4 id="锁对比"><a href="#锁对比" class="headerlink" title="锁对比"></a>锁对比</h4><p>ReentrantLock 相对于 synchronized 具备如下特点：</p><ol><li>锁的实现：synchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的</li><li>性能：新版本 Java 对 synchronized 进行了很多优化，synchronized 与 ReentrantLock 大致相同</li><li>使用：ReentrantLock 需要手动解锁，synchronized 执行完代码块自动解锁</li><li><strong>可中断</strong>：ReentrantLock 可中断，而 synchronized 不行</li><li>公平锁：公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁<ul><li>ReentrantLock 可以设置公平锁，synchronized 中的锁是非公平的</li><li>不公平锁的含义是阻塞队列内公平，队列外非公平</li></ul></li><li>锁超时：尝试获取锁，超时获取不到直接放弃，不进入阻塞队列<ul><li>ReentrantLock 可以设置超时时间，synchronized 会一直等待</li></ul></li><li>锁绑定多个条件：一个 ReentrantLock 可以同时绑定多个 Condition 对象，更细粒度的唤醒线程</li><li>两者都是可重入锁</li></ol><h4 id="使用锁"><a href="#使用锁" class="headerlink" title="使用锁"></a>使用锁</h4><p>构造方法：<code>ReentrantLock lock = new ReentrantLock();</code></p><p>ReentrantLock 类 API：</p><ul><li><code>public void lock()</code>：获得锁<ul><li>如果锁没有被另一个线程占用，则将锁定计数设置为 1</li><li>如果当前线程已经保持锁定，则保持计数增加 1</li><li>如果锁被另一个线程保持，则当前线程被禁用线程调度，并且在锁定已被获取之前处于休眠状态</li></ul></li><li><code>public void unlock()</code>：尝试释放锁<ul><li>如果当前线程是该锁的持有者，则保持计数递减</li><li>如果保持计数现在为零，则锁定被释放</li><li>如果当前线程不是该锁的持有者，则抛出异常</li></ul></li></ul><p>基本语法：</p><pre><code class="java">// 获取锁reentrantLock.lock();try &#123;    // 临界区&#125; finally &#123;    // 释放锁    reentrantLock.unlock();&#125;</code></pre><h4 id="公平锁-1"><a href="#公平锁-1" class="headerlink" title="公平锁"></a>公平锁</h4><h5 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h5><p>构造方法：<code>ReentrantLock lock = new ReentrantLock(true)</code></p><pre><code class="java">public ReentrantLock(boolean fair) &#123;    sync = fair ? new FairSync() : new NonfairSync();&#125;</code></pre><p>ReentrantLock 默认是不公平的：</p><pre><code class="java">public ReentrantLock() &#123;    sync = new NonfairSync();&#125;</code></pre><p>说明：公平锁一般没有必要，会降低并发度</p><h4 id="非公平锁原理"><a href="#非公平锁原理" class="headerlink" title="非公平锁原理"></a>非公平锁原理</h4><h5 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h5><p>NonfairSync 继承自 AQS</p><pre><code class="java">public void lock() &#123;    sync.lock();&#125;</code></pre><ul><li><p>没有竞争：ExclusiveOwnerThread 属于 Thread-0，state 设置为 1</p><pre><code class="java">// ReentrantLock.NonfairSync#lockfinal void lock() &#123;    // 用 cas 尝试（仅尝试一次）将 state 从 0 改为 1, 如果成功表示【获得了独占锁】    if (compareAndSetState(0, 1))        // 设置当前线程为独占线程        setExclusiveOwnerThread(Thread.currentThread());    else        acquire(1);//失败进入&#125;</code></pre></li><li><p>第一个竞争出现：Thread-1 执行，CAS 尝试将 state 由 0 改为 1，结果失败（第一次），进入 acquire 逻辑</p><pre><code class="java">// AbstractQueuedSynchronizer#acquirepublic final void acquire(int arg) &#123;    // tryAcquire 尝试获取锁失败时, 会调用 addWaiter 将当前线程封装成node入队，acquireQueued 阻塞当前线程，    // acquireQueued 返回 true 表示挂起过程中线程被中断唤醒过，false 表示未被中断过    if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))        // 如果线程被中断了逻辑来到这，完成一次真正的打断效果        selfInterrupt();&#125;</code></pre></li></ul><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230103193946112.png" alt="image-20230103193946112"></p><ul><li><p>进入 tryAcquire 尝试获取锁逻辑，这时 state 已经是1，结果仍然失败（第二次），加锁成功有两种情况：</p><ul><li><p>当前 AQS 处于无锁状态</p></li><li><p>加锁线程就是当前线程，说明发生了锁重入</p></li></ul></li></ul><pre><code class="java">// ReentrantLock.NonfairSync#tryAcquireprotected final boolean tryAcquire(int acquires) &#123;    return nonfairTryAcquire(acquires);&#125;// 抢占成功返回 true，抢占失败返回 falsefinal boolean nonfairTryAcquire(int acquires) &#123;    final Thread current = Thread.currentThread();    // state 值    int c = getState();    // 条件成立说明当前处于【无锁状态】    if (c == 0) &#123;        //如果还没有获得锁，尝试用cas获得，这里体现非公平性: 不去检查 AQS 队列是否有阻塞线程直接获取锁                if (compareAndSetState(0, acquires)) &#123;            // 获取锁成功设置当前线程为独占锁线程。            setExclusiveOwnerThread(current);            return true;         &#125;        &#125;           // 如果已经有线程获得了锁, 独占锁线程还是当前线程, 表示【发生了锁重入】    else if (current == getExclusiveOwnerThread()) &#123;        // 更新锁重入的值        int nextc = c + acquires;        // 越界判断，当重入的深度很深时，会导致 nextc &lt; 0，int值达到最大之后再 + 1 变负数        if (nextc &lt; 0) // overflow            throw new Error(&quot;Maximum lock count exceeded&quot;);        // 更新 state 的值，这里不使用 cas 是因为当前线程正在持有锁，所以这里的操作相当于在一个管程内        setState(nextc);        return true;    &#125;    // 获取失败    return false;&#125;</code></pre><ul><li><p>接下来进入 addWaiter 逻辑，构造 Node 队列，前置条件是当前线程获取锁失败，说明有线程占用了锁</p><ul><li><p>图中黄色三角表示该 Node 的 waitStatus 状态，其中 0 为默认<strong>正常状态</strong></p></li><li><p>Node 的创建是懒惰的，其中第一个 Node 称为 <strong>Dummy（哑元）或哨兵</strong>，用来占位，并不关联线程</p></li></ul></li></ul><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230103194503914.png" alt="image-20230103194503914"></p><pre><code class="java">// AbstractQueuedSynchronizer#addWaiter，返回当前线程的 node 节点private Node addWaiter(Node mode) &#123;    // 将当前线程关联到一个 Node 对象上, 模式为独占模式       Node node = new Node(Thread.currentThread(), mode);    Node pred = tail;    // 快速入队，如果 tail 不为 null，说明存在阻塞队列    if (pred != null) &#123;        // 将当前节点的前驱节点指向 尾节点        node.prev = pred;        // 通过 cas 将 Node 对象加入 AQS 队列，成为尾节点，【尾插法】        if (compareAndSetTail(pred, node)) &#123;            pred.next = node;// 双向链表            return node;        &#125;    &#125;    // 初始时队列为空，或者 CAS 失败进入这里    enq(node);    return node;&#125;</code></pre><pre><code class="java">// AbstractQueuedSynchronizer#enqprivate Node enq(final Node node) &#123;    // 自旋入队，必须入队成功才结束循环    for (;;) &#123;        Node t = tail;        // 说明当前锁被占用，且当前线程可能是【第一个获取锁失败】的线程，【还没有建立队列】        if (t == null) &#123;            // 设置一个【哑元节点】，头尾指针都指向该节点            if (compareAndSetHead(new Node()))                tail = head;        &#125; else &#123;            // 自旋到这，普通入队方式，首先赋值尾节点的前驱节点【尾插法】            node.prev = t;            // 【在设置完尾节点后，才更新的原始尾节点的后继节点，所以此时从前往后遍历会丢失尾节点】            if (compareAndSetTail(t, node)) &#123;                //【此时 t.next  = null，并且这里已经 CAS 结束，线程并不是安全的】                t.next = node;                return t;// 返回当前 node 的前驱节点            &#125;        &#125;    &#125;&#125;</code></pre><ul><li><p>线程节点加入阻塞队列成功，进入 AbstractQueuedSynchronizer#acquireQueued 逻辑阻塞线程</p><ul><li><p>acquireQueued 会在一个自旋中不断尝试获得锁，失败后进入 park 阻塞</p></li><li><p>如果当前线程是在 head 节点后，会再次 tryAcquire 尝试获取锁，state 仍为 1 则失败（第三次）</p></li></ul></li></ul><pre><code class="java">final boolean acquireQueued(final Node node, int arg) &#123;    // true 表示当前线程抢占锁失败，false 表示成功    boolean failed = true;    try &#123;        // 中断标记，表示当前线程是否被中断        boolean interrupted = false;        for (;;) &#123;            // 获得当前线程节点的前驱节点            final Node p = node.predecessor();            // 前驱节点是 head, FIFO 队列的特性表示轮到当前线程可以去获取锁            if (p == head &amp;&amp; tryAcquire(arg)) &#123;                // 获取成功, 设置当前线程自己的 node 为 head                setHead(node);                p.next = null; // help GC                // 表示抢占锁成功                failed = false;                // 返回当前线程是否被中断                return interrupted;            &#125;            // 判断是否应当 park，返回 false 后需要新一轮的循环，返回 true 进入条件二阻塞线程            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())                // 条件二返回结果是当前线程是否被打断，没有被打断返回 false 不进入这里的逻辑                // 【就算被打断了，也会继续循环，并不会返回】                interrupted = true;        &#125;    &#125; finally &#123;        // 【可打断模式下才会进入该逻辑】        if (failed)            cancelAcquire(node);    &#125;&#125;</code></pre><ul><li>进入 shouldParkAfterFailedAcquire 逻辑，<strong>将前驱 node 的 waitStatus 改为 -1</strong>，返回 false；waitStatus 为 -1 的节点用来唤醒下一个节点</li></ul><pre><code class="java">private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123;    int ws = pred.waitStatus;    // 表示前置节点是个可以唤醒当前节点的节点，返回 true    if (ws == Node.SIGNAL)        return true;    // 前置节点的状态处于取消状态，需要【删除前面所有取消的节点】, 返回到外层循环重试    if (ws &gt; 0) &#123;        do &#123;            node.prev = pred = pred.prev;        &#125; while (pred.waitStatus &gt; 0);        // 获取到非取消的节点，连接上当前节点        pred.next = node;    // 默认情况下 node 的 waitStatus 是 0，进入这里的逻辑    &#125; else &#123;        // 【设置上一个节点状态为 Node.SIGNAL】，返回外层循环重试        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);    &#125;    // 返回不应该 park，再次尝试一次    return false;&#125;</code></pre><ul><li>shouldParkAfterFailedAcquire 执行完毕回到 acquireQueued ，再次 tryAcquire 尝试获取锁，这时 state 仍为 1 获取失败（第四次）</li><li>当再次进入 shouldParkAfterFailedAcquire 时，这时其前驱 node 的 waitStatus 已经是 -1 了，返回 true</li><li>进入 parkAndCheckInterrupt， Thread-1 park（灰色表示）</li></ul><pre><code class="java">private final boolean parkAndCheckInterrupt() &#123;    // 阻塞当前线程，如果打断标记已经是 true, 则 park 会失效    LockSupport.park(this);    // 判断当前线程是否被打断，清除打断标记    return Thread.interrupted();&#125;</code></pre><ul><li>再有多个线程经历竞争失败后：</li></ul><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230104152156195.png" alt="image-20230104152156195"></p><h5 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h5><p>ReentrantLock#unlock：释放锁</p><pre><code class="java">public void unlock() &#123;    sync.release(1);&#125;</code></pre><p>Thread-0 释放锁，进入 release 流程</p><ul><li>进入 tryRelease，设置 exclusiveOwnerThread 为 null，state &#x3D; 0</li><li>当前队列不为 null，并且 head 的 waitStatus &#x3D; -1，进入 unparkSuccessor</li></ul><pre><code class="java">// AbstractQueuedSynchronizer#releasepublic final boolean release(int arg) &#123;    // 尝试释放锁，tryRelease 返回 true 表示当前线程已经【完全释放锁，重入的释放了】    if (tryRelease(arg)) &#123;        // 队列头节点        Node h = head;        // 头节点什么时候是空？没有发生锁竞争，没有竞争线程创建哑元节点        // 条件成立说明阻塞队列有等待线程，需要唤醒 head 节点后面的线程        if (h != null &amp;&amp; h.waitStatus != 0)            unparkSuccessor(h);        return true;    &#125;        return false;&#125;</code></pre><pre><code class="java">// ReentrantLock.Sync#tryReleaseprotected final boolean tryRelease(int releases) &#123;    // 减去释放的值，可能重入    int c = getState() - releases;    // 如果当前线程不是持有锁的线程直接报错    if (Thread.currentThread() != getExclusiveOwnerThread())        throw new IllegalMonitorStateException();    // 是否已经完全释放锁    boolean free = false;    // 支持锁重入, 只有 state 减为 0, 才完全释放锁成功    if (c == 0) &#123;        free = true;        setExclusiveOwnerThread(null);    &#125;    // 当前线程就是持有锁线程，所以可以直接更新锁，不需要使用 CAS    setState(c);    return free;&#125;</code></pre><p>进入 AbstractQueuedSynchronizer#unparkSuccessor 方法，唤醒当前节点的后继节点</p><ul><li>找到队列中距离 head 最近的一个没取消的 Node，unpark 恢复其运行，本例中即为 Thread-1</li><li>回到 Thread-1 的 acquireQueued 流程</li></ul><pre><code class="java">private void unparkSuccessor(Node node) &#123;    // 当前节点的状态    int ws = node.waitStatus;        if (ws &lt; 0)                // 【尝试重置状态为 0】，因为当前节点要完成对后续节点的唤醒任务了，不需要 -1 了        compareAndSetWaitStatus(node, ws, 0);        // 找到需要 unpark 的节点，当前节点的下一个        Node s = node.next;        // 已取消的节点不能唤醒，需要找到距离头节点最近的非取消的节点    if (s == null || s.waitStatus &gt; 0) &#123;        s = null;        // AQS 队列【从后至前】找需要 unpark 的节点，直到 t == 当前的 node 为止，找不到就不唤醒了        for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev)            // 说明当前线程状态需要被唤醒            if (t.waitStatus &lt;= 0)                // 置换引用                s = t;    &#125;    // 【找到合适的可以被唤醒的 node，则唤醒线程】    if (s != null)        LockSupport.unpark(s.thread);&#125;</code></pre><p><strong>从后向前的唤醒的原因</strong>：enq 方法中，节点是尾插法，首先赋值的是尾节点的前驱节点，此时前驱节点的 next 并没有指向尾节点，从前遍历会丢失尾节点</p><p>唤醒的线程会从 park 位置开始执行，如果加锁成功（没有竞争），会设置</p><ul><li>exclusiveOwnerThread 为 Thread-1，state &#x3D; 1</li><li>head 指向刚刚 Thread-1 所在的 Node，该 Node 会清空 Thread</li><li>原本的 head 因为从链表断开，而可被垃圾回收（图中有错误，原来的头节点的 waitStatus 被改为 0 了）</li></ul><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230104152316705.png" alt="image-20230104152316705"></p><p>如果这时有其它线程来竞争<strong>（非公平）</strong>，例如这时有 Thread-4 来了并抢占了锁</p><ul><li>Thread-4 被设置为 exclusiveOwnerThread，state &#x3D; 1</li><li>Thread-1 再次进入 acquireQueued 流程，获取锁失败，重新进入 park 阻塞</li></ul><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230104152328943.png" alt="image-20230104152328943"></p><h5 id="公平原理"><a href="#公平原理" class="headerlink" title="公平原理"></a>公平原理</h5><p>与非公平锁主要区别在于 tryAcquire 方法：先检查 AQS 队列中是否有前驱节点，没有才去 CAS 竞争</p><pre><code class="java">static final class FairSync extends Sync &#123;    private static final long serialVersionUID = -3000897897090466540L;    final void lock() &#123;        acquire(1);    &#125;    protected final boolean tryAcquire(int acquires) &#123;        final Thread current = Thread.currentThread();        int c = getState();        if (c == 0) &#123;            // 先检查 AQS 队列中是否有前驱节点, 没有(false)才去竞争            if (!hasQueuedPredecessors() &amp;&amp;                compareAndSetState(0, acquires)) &#123;                setExclusiveOwnerThread(current);                return true;            &#125;        &#125;        // 锁重入        return false;    &#125;&#125;</code></pre><pre><code class="java">public final boolean hasQueuedPredecessors() &#123;        Node t = tail;    Node h = head;    Node s;        // 头尾指向一个节点，链表为空，返回false    return h != t &amp;&amp;        // 头尾之间有节点，判断头节点的下一个是不是空        // 不是空进入最后的判断，第二个节点的线程是否是本线程，不是返回 true，表示当前节点有前驱节点        ((s = h.next) == null || s.thread != Thread.currentThread());&#125;</code></pre><h4 id="可重入-1"><a href="#可重入-1" class="headerlink" title="可重入"></a>可重入</h4><p>可重入是指同一个线程如果首次获得了这把锁，那么它是这把锁的拥有者，因此有权利再次获取这把锁，如果不可重入锁，那么第二次获得锁时，自己也会被锁挡住，直接造成死锁</p><p>源码解析参考：<code>nonfairTryAcquire(int acquires)) </code> 和 <code>tryRelease(int releases)</code></p><pre><code class="java">static ReentrantLock lock = new ReentrantLock();public static void main(String[] args) &#123;    method1();&#125;public static void method1() &#123;    lock.lock();    try &#123;        System.out.println(Thread.currentThread().getName() + &quot; execute method1&quot;);        method2();    &#125; finally &#123;        lock.unlock();    &#125;&#125;public static void method2() &#123;    lock.lock();    try &#123;        System.out.println(Thread.currentThread().getName() + &quot; execute method2&quot;);    &#125; finally &#123;        lock.unlock();    &#125;&#125;</code></pre><p>在 Lock 方法加两把锁会是什么情况呢？</p><ul><li>加锁两次解锁两次：正常执行</li><li>加锁两次解锁一次：程序直接卡死，线程不能出来，也就说明<strong>申请几把锁，最后需要解除几把锁</strong></li><li>加锁一次解锁两次：运行程序会直接报错</li></ul><pre><code class="java">public void getLock() &#123;    lock.lock();    lock.lock();    try &#123;        System.out.println(Thread.currentThread().getName() + &quot;\t get Lock&quot;);    &#125; finally &#123;        lock.unlock();        //lock.unlock();    &#125;&#125;</code></pre><h4 id="可打断-1"><a href="#可打断-1" class="headerlink" title="可打断"></a>可打断</h4><h5 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用"></a>基本使用</h5><p><code>public void lockInterruptibly()</code>：获得可打断的锁</p><ul><li>如果没有竞争此方法就会获取 lock 对象锁</li><li>如果有竞争就进入阻塞队列，可以被其他线程用 interrupt 打断</li></ul><p>注意：如果是不可中断模式，那么即使使用了 interrupt 也不会让等待状态中的线程中断</p><pre><code class="java">public static void main(String[] args) throws InterruptedException &#123;        ReentrantLock lock = new ReentrantLock();        Thread t1 = new Thread(() -&gt; &#123;                try &#123;                        System.out.println(&quot;尝试获取锁&quot;);                        lock.lockInterruptibly();                &#125; catch (InterruptedException e) &#123;                        System.out.println(&quot;没有获取到锁，被打断，直接返回&quot;);                        return;                &#125;                try &#123;                        System.out.println(&quot;获取到锁&quot;);                &#125; finally &#123;                        lock.unlock();                &#125;        &#125;, &quot;t1&quot;);        lock.lock();        t1.start();        Thread.sleep(2000);        System.out.println(&quot;主线程进行打断锁&quot;);        t1.interrupt();&#125;</code></pre><h5 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h5><ul><li>不可打断模式：即使它被打断，仍会驻留在 AQS 阻塞队列中，一直要<strong>等到获得锁后才能得知自己被打断</strong>了</li></ul><pre><code class="java">public final void acquire(int arg) &#123;        if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))//阻塞等待                // 如果acquireQueued返回true，打断状态 interrupted = true                selfInterrupt();&#125;static void selfInterrupt() &#123;    // 知道自己被打断了，需要重新产生一次中断完成中断效果    Thread.currentThread().interrupt();&#125;</code></pre><pre><code class="java">final boolean acquireQueued(final Node node, int arg) &#123;        try &#123;                boolean interrupted = false;                for (;;) &#123;                        final Node p = node.predecessor();                        if (p == head &amp;&amp; tryAcquire(arg)) &#123;                                setHead(node);                                p.next = null; // help GC                                failed = false;                                // 还是需要获得锁后, 才能返回打断状态                return interrupted;                        &#125;                        if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())&#123;                // 条件二中判断当前线程是否被打断，被打断返回true，设置中断标记为 true，【获取锁后返回】                interrupted = true;              &#125;                          &#125;     &#125; finally &#123;        if (failed)            cancelAcquire(node);    &#125;&#125; private final boolean parkAndCheckInterrupt() &#123;         // 阻塞当前线程，如果打断标记已经是 true, 则 park 会失效     LockSupport.park(this);         // 判断当前线程是否被打断，清除打断标记，被打断返回true     return Thread.interrupted(); &#125;</code></pre><p>可打断模式：AbstractQueuedSynchronizer#acquireInterruptibly，<strong>被打断后会直接抛出异常</strong></p><pre><code class="java">public void lockInterruptibly() throws InterruptedException &#123;        sync.acquireInterruptibly(1);&#125;public final void acquireInterruptibly(int arg) &#123;    // 被其他线程打断了直接返回 false    if (Thread.interrupted())        throw new InterruptedException();    if (!tryAcquire(arg))        // 没获取到锁，进入这里        doAcquireInterruptibly(arg);&#125;</code></pre><pre><code class="java">private void doAcquireInterruptibly(int arg) throws InterruptedException &#123;    // 返回封装当前线程的节点    final Node node = addWaiter(Node.EXCLUSIVE);    boolean failed = true;    try &#123;        for (;;) &#123;            //...            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())                // 【在 park 过程中如果被 interrupt 会抛出异常】, 而不会再次进入循环获取锁后才完成打断效果                throw new InterruptedException();        &#125;        &#125; finally &#123;        // 抛出异常前会进入这里        if (failed)            // 取消当前线程的节点            cancelAcquire(node);    &#125;&#125;</code></pre><pre><code class="java">// 取消节点出队的逻辑private void cancelAcquire(Node node) &#123;    // 判空    if (node == null)        return;    // 把当前节点封装的 Thread 置为空    node.thread = null;    // 获取当前取消的 node 的前驱节点    Node pred = node.prev;    // 前驱节点也被取消了，循环找到前面最近的没被取消的节点    while (pred.waitStatus &gt; 0)        node.prev = pred = pred.prev;        // 获取前驱节点的后继节点，可能是当前 node，也可能是 waitStatus &gt; 0 的节点    Node predNext = pred.next;        // 把当前节点的状态设置为 【取消状态 1】    node.waitStatus = Node.CANCELLED;        // 条件成立说明当前节点是尾节点，把当前节点的前驱节点设置为尾节点    if (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;        // 把前驱节点的后继节点置空，这里直接把所有的取消节点出队        compareAndSetNext(pred, predNext, null);    &#125; else &#123;        // 说明当前节点不是 tail 节点        int ws;        // 条件一成立说明当前节点不是 head.next 节点        if (pred != head &amp;&amp;            // 判断前驱节点的状态是不是 -1，不成立说明前驱状态可能是 0 或者刚被其他线程取消排队了            ((ws = pred.waitStatus) == Node.SIGNAL ||             // 如果状态不是 -1，设置前驱节点的状态为 -1             (ws &lt;= 0 &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;            // 前驱节点的线程不为null            pred.thread != null) &#123;                        Node next = node.next;            // 当前节点的后继节点是正常节点            if (next != null &amp;&amp; next.waitStatus &lt;= 0)                // 把 前驱节点的后继节点 设置为 当前节点的后继节点，【从队列中删除了当前节点】                compareAndSetNext(pred, predNext, next);        &#125; else &#123;            // 当前节点是 head.next 节点，唤醒当前节点的后继节点            unparkSuccessor(node);        &#125;        node.next = node; // help GC    &#125;&#125;</code></pre><h4 id="条件变量实现原理"><a href="#条件变量实现原理" class="headerlink" title="条件变量实现原理"></a>条件变量实现原理</h4><h5 id="await"><a href="#await" class="headerlink" title="await"></a>await</h5><p>总体流程是将 await 线程包装成 node 节点放入 ConditionObject 的条件队列，如果被唤醒就将 node 转移到 AQS 的执行阻塞队列，等待获取锁，<strong>每个 Condition 对象都包含一个等待队列</strong></p><ul><li>开始 Thread-0 持有锁，调用 await，线程进入 ConditionObject 等待，直到被唤醒或打断，调用 await 方法的线程都是持锁状态的，所以说逻辑里<strong>不存在并发</strong></li></ul><pre><code class="java">public final void await() throws InterruptedException &#123;     // 判断当前线程是否是中断状态，是就直接给个中断异常    if (Thread.interrupted())        throw new InterruptedException();    // 将调用 await 的线程包装成 Node，添加到条件队列并返回    Node node = addConditionWaiter();    // 完全释放节点持有的锁，因为其他线程唤醒当前线程的前提是【持有锁】    int savedState = fullyRelease(node);        // 设置打断模式为没有被打断，状态码为 0    int interruptMode = 0;        // 如果该节点还没有转移至 AQS 阻塞队列, park 阻塞，等待进入阻塞队列    while (!isOnSyncQueue(node)) &#123;        LockSupport.park(this);        // 如果被打断，退出等待队列，对应的 node 【也会被迁移到阻塞队列】尾部，状态设置为 0        if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)            break;    &#125;    // 逻辑到这说明当前线程退出等待队列，进入【阻塞队列】        // 尝试枪锁，释放了多少锁就【重新获取多少锁】，获取锁成功判断打断模式    if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)        interruptMode = REINTERRUPT;        // node 在条件队列时 如果被外部线程中断唤醒，会加入到阻塞队列，但是并未设 nextWaiter = null    if (node.nextWaiter != null)        // 清理条件队列内所有已取消的 Node        unlinkCancelledWaiters();    // 条件成立说明挂起期间发生过中断    if (interruptMode != 0)        // 应用打断模式        reportInterruptAfterWait(interruptMode);&#125;</code></pre><pre><code class="java">// 打断模式 - 在退出等待时重新设置打断状态private static final int REINTERRUPT = 1;// 打断模式 - 在退出等待时抛出异常private static final int THROW_IE = -1;</code></pre><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230104152638578.png" alt="image-20230104152638578"></p><p><strong>创建新的 Node 状态为 -2（Node.CONDITION）</strong>，关联 Thread-0，加入等待队列尾部</p><pre><code class="java">private Node addConditionWaiter() &#123;    // 获取当前条件队列的尾节点的引用，保存到局部变量 t 中    Node t = lastWaiter;    // 当前队列中不是空，并且节点的状态不是 CONDITION（-2），说明当前节点发生了中断    if (t != null &amp;&amp; t.waitStatus != Node.CONDITION) &#123;        // 清理条件队列内所有已取消的 Node        unlinkCancelledWaiters();        // 清理完成重新获取 尾节点 的引用        t = lastWaiter;    &#125;    // 创建一个关联当前线程的新 node, 设置状态为 CONDITION(-2)，添加至队列尾部    Node node = new Node(Thread.currentThread(), Node.CONDITION);    if (t == null)        firstWaiter = node;// 空队列直接放在队首【不用CAS因为执行线程是持锁线程，并发安全】    else        t.nextWaiter = node;// 非空队列队尾追加    lastWaiter = node;// 更新队尾的引用    return node;&#125;</code></pre><pre><code class="java">// 清理条件队列内所有已取消（不是CONDITION）的 node，【链表删除的逻辑】private void unlinkCancelledWaiters() &#123;    // 从头节点开始遍历【FIFO】    Node t = firstWaiter;    // 指向正常的 CONDITION 节点    Node trail = null;    // 等待队列不空    while (t != null) &#123;        // 获取当前节点的后继节点        Node next = t.nextWaiter;        // 判断 t 节点是不是 CONDITION 节点，条件队列内不是 CONDITION 就不是正常的        if (t.waitStatus != Node.CONDITION) &#123;             // 不是正常节点，需要 t 与下一个节点断开            t.nextWaiter = null;            // 条件成立说明遍历到的节点还未碰到过正常节点            if (trail == null)                // 更新 firstWaiter 指针为下个节点                firstWaiter = next;            else                // 让上一个正常节点指向 当前取消节点的 下一个节点，【删除非正常的节点】                trail.nextWaiter = next;            // t 是尾节点了，更新 lastWaiter 指向最后一个正常节点            if (next == null)                lastWaiter = trail;        &#125; else &#123;            // trail 指向的是正常节点             trail = t;        &#125;        // 把 t.next 赋值给 t，循环遍历        t = next;     &#125;&#125;</code></pre><p>接下来 Thread-0 进入 AQS 的 fullyRelease 流程，释放同步器上的锁</p><pre><code class="java">// 线程可能重入，需要将 state 全部释放final int fullyRelease(Node node) &#123;    // 完全释放锁是否成功，false 代表成功    boolean failed = true;    try &#123;        // 获取当前线程所持有的 state 值总数        int savedState = getState();        // release -&gt; tryRelease 解锁重入锁        if (release(savedState)) &#123;            // 释放成功            failed = false;            // 返回解锁的深度            return savedState;        &#125; else &#123;            // 解锁失败抛出异常            throw new IllegalMonitorStateException();        &#125;    &#125; finally &#123;        // 没有释放成功，将当前 node 设置为取消状态        if (failed)            node.waitStatus = Node.CANCELLED;    &#125;&#125;</code></pre><p>fullyRelease 中会 unpark AQS 队列中的下一个节点竞争锁，假设 Thread-1 竞争成功</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230104152717834.png" alt="image-20230104152717834"></p><p>Thread-0 进入 isOnSyncQueue 逻辑判断节点<strong>是否移动到阻塞队列</strong>，没有就 park 阻塞 Thread-0</p><pre><code class="java">final boolean isOnSyncQueue(Node node) &#123;    // node 的状态是 CONDITION，signal 方法是先修改状态再迁移，所以前驱节点为空证明还【没有完成迁移】    if (node.waitStatus == Node.CONDITION || node.prev == null)        return false;    // 说明当前节点已经成功入队到阻塞队列，且当前节点后面已经有其它 node，因为条件队列的 next 指针为 null    if (node.next != null)        return true;    // 说明【可能在阻塞队列，但是是尾节点】    // 从阻塞队列的尾节点开始向前【遍历查找 node】，如果查找到返回 true，查找不到返回 false    return findNodeFromTail(node);&#125;</code></pre><p>await 线程 park 后如果被 unpark 或者被打断，都会进入 checkInterruptWhileWaiting 判断线程是否被打断：<strong>在条件队列被打断的线程需要抛出异常</strong></p><pre><code class="java">private int checkInterruptWhileWaiting(Node node) &#123;    // Thread.interrupted() 返回当前线程中断标记位，并且重置当前标记位 为 false    // 如果被中断了，根据是否在条件队列被中断的，设置中断状态码    return Thread.interrupted() ?(transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) : 0;&#125;</code></pre><pre><code class="java">// 这个方法只有在线程是被打断唤醒时才会调用final boolean transferAfterCancelledWait(Node node) &#123;    // 条件成立说明当前node一定是在条件队列内，因为 signal 迁移节点到阻塞队列时，会将节点的状态修改为 0    if (compareAndSetWaitStatus(node, Node.CONDITION, 0)) &#123;        // 把【中断唤醒的 node 加入到阻塞队列中】        enq(node);        // 表示是在条件队列内被中断了，设置为 THROW_IE 为 -1        return true;    &#125;    //执行到这里的情况：    //1.当前node已经被外部线程调用 signal 方法将其迁移到 阻塞队列 内了    //2.当前node正在被外部线程调用 signal 方法将其迁移至 阻塞队列 进行中状态        // 如果当前线程还没到阻塞队列，一直释放 CPU    while (!isOnSyncQueue(node))        Thread.yield();    // 表示当前节点被中断唤醒时不在条件队列了，设置为 REINTERRUPT 为 1    return false;&#125;</code></pre><p>最后开始处理中断状态：</p><pre><code class="java">private void reportInterruptAfterWait(int interruptMode) throws InterruptedException &#123;    // 条件成立说明【在条件队列内发生过中断，此时 await 方法抛出中断异常】    if (interruptMode == THROW_IE)        throw new InterruptedException();    // 条件成立说明【在条件队列外发生的中断，此时设置当前线程的中断标记位为 true】    else if (interruptMode == REINTERRUPT)        // 进行一次自己打断，产生中断的效果        selfInterrupt();&#125;</code></pre><h5 id="signal"><a href="#signal" class="headerlink" title="signal"></a>signal</h5><p>假设 Thread-1 要来唤醒 Thread-0，进入 ConditionObject 的 doSignal 流程，<strong>取得等待队列中第一个 Node</strong>，即 Thread-0 所在 Node，必须持有锁才能唤醒, 因此 doSignal 内线程安全</p><pre><code class="java">public final void signal() &#123;    // 判断调用 signal 方法的线程是否是独占锁持有线程    if (!isHeldExclusively())        throw new IllegalMonitorStateException();    // 获取条件队列中第一个 Node    Node first = firstWaiter;    // 不为空就将第该节点【迁移到阻塞队列】    if (first != null)        doSignal(first);&#125;</code></pre><pre><code class="java">// 唤醒 - 【将没取消的第一个节点转移至 AQS 队列尾部】private void doSignal(Node first) &#123;    do &#123;        // 成立说明当前节点的下一个节点是 null，当前节点是尾节点了，队列中只有当前一个节点了        if ((firstWaiter = first.nextWaiter) == null)            lastWaiter = null;        first.nextWaiter = null;    // 将等待队列中的 Node 转移至 AQS 队列，不成功且还有节点则继续循环    &#125; while (!transferForSignal(first) &amp;&amp; (first = firstWaiter) != null);&#125;// signalAll() 会调用这个函数，唤醒所有的节点private void doSignalAll(Node first) &#123;    lastWaiter = firstWaiter = null;    do &#123;        Node next = first.nextWaiter;        first.nextWaiter = null;        transferForSignal(first);        first = next;    // 唤醒所有的节点，都放到阻塞队列中    &#125; while (first != null);&#125;</code></pre><p>执行 transferForSignal，<strong>先将节点的 waitStatus 改为 0，然后加入 AQS 阻塞队列尾部</strong>，将 Thread-3 的 waitStatus 改为 -1</p><pre><code class="java">// 如果节点状态是取消, 返回 false 表示转移失败, 否则转移成功final boolean transferForSignal(Node node) &#123;    // CAS 修改当前节点的状态，修改为 0，因为当前节点马上要迁移到阻塞队列了    // 如果状态已经不是 CONDITION, 说明线程被取消（await 释放全部锁失败）或者被中断（可打断 cancelAcquire）    if (!compareAndSetWaitStatus(node, Node.CONDITION, 0))        // 返回函数调用处继续寻找下一个节点        return false;        // 【先改状态，再进行迁移】    // 将当前 node 入阻塞队列，p 是当前节点在阻塞队列的【前驱节点】    Node p = enq(node);    int ws = p.waitStatus;        // 如果前驱节点被取消或者不能设置状态为 Node.SIGNAL，就 unpark 取消当前节点线程的阻塞状态,     // 让 thread-0 线程竞争锁，重新同步状态    if (ws &gt; 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))        LockSupport.unpark(node.thread);    return true;&#125;</code></pre><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230104152918984.png" alt="image-20230104152918984"></p><ul><li>Thread-1 释放锁，进入 unlock 流程</li></ul><h3 id="3-ReadWrite读写锁"><a href="#3-ReadWrite读写锁" class="headerlink" title="3.ReadWrite读写锁"></a>3.ReadWrite读写锁</h3><h4 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h4><p>独占锁：指该锁一次只能被一个线程所持有，对 ReentrantLock 和 Synchronized 而言都是独占锁</p><p>共享锁：指该锁可以被多个线程锁持有</p><p>ReentrantReadWriteLock 其<strong>读锁是共享锁，写锁是独占锁</strong></p><p>作用：多个线程同时读一个资源类没有任何问题，为了满足并发量，读取共享资源应该同时进行，但是如果一个线程想去写共享资源，就不应该再有其它线程可以对该资源进行读或写</p><p>使用规则：</p><ul><li><p>加锁解锁格式：</p><pre><code class="java">r.lock();try &#123;    // 临界区&#125; finally &#123;    r.unlock();&#125;</code></pre></li><li><p>读-读能共存、读-写不能共存、写-写不能共存</p></li><li><p>读锁不支持条件变量</p></li><li><p><strong>重入时升级不支持</strong>：持有读锁的情况下去获取写锁会导致获取写锁永久等待，需要先释放读，再去获得写</p></li><li><p><strong>重入时降级支持</strong>：持有写锁的情况下去获取读锁，造成只有当前线程会持有读锁，因为写锁会互斥其他的锁</p><pre><code class="java">w.lock();try &#123;    r.lock();// 降级为读锁, 释放写锁, 这样能够让其它线程读取缓存    try &#123;        // ...    &#125; finally&#123;        w.unlock();// 要在写锁释放之前获取读锁    &#125;&#125; finally&#123;    r.unlock();&#125;</code></pre></li></ul><p>构造方法：</p><ul><li><code>public ReentrantReadWriteLock()</code>：默认构造方法，非公平锁</li><li><code>public ReentrantReadWriteLock(boolean fair)</code>：true 为公平锁</li></ul><p>常用API：</p><ul><li><code>public ReentrantReadWriteLock.ReadLock readLock()</code>：返回读锁</li><li><code>public ReentrantReadWriteLock.WriteLock writeLock()</code>：返回写锁</li><li><code>public void lock()</code>：加锁</li><li><code>public void unlock()</code>：解锁</li><li><code>public boolean tryLock()</code>：尝试获取锁</li></ul><p>读读并发：</p><pre><code class="java">public static void main(String[] args) &#123;    ReentrantReadWriteLock rw = new ReentrantReadWriteLock();    ReentrantReadWriteLock.ReadLock r = rw.readLock();    ReentrantReadWriteLock.WriteLock w = rw.writeLock();    new Thread(() -&gt; &#123;        r.lock();        try &#123;            Thread.sleep(2000);            System.out.println(&quot;Thread 1 running &quot; + new Date());        &#125; finally &#123;            r.unlock();        &#125;    &#125;,&quot;t1&quot;).start();    new Thread(() -&gt; &#123;        r.lock();        try &#123;            Thread.sleep(2000);            System.out.println(&quot;Thread 2 running &quot; + new Date());        &#125; finally &#123;            r.unlock();        &#125;    &#125;,&quot;t2&quot;).start();&#125;</code></pre><h4 id="缓存应用"><a href="#缓存应用" class="headerlink" title="缓存应用"></a>缓存应用</h4><p>缓存更新时，是先清缓存还是先更新数据库</p><ul><li>先清缓存：可能造成刚清理缓存还没有更新数据库，线程直接查询了数据库更新过期数据到缓存</li><li>先更新据库：可能造成刚更新数据库，还没清空缓存就有线程从缓存拿到了旧数据</li><li>补充情况：查询线程 A 查询数据时恰好缓存数据由于时间到期失效，或是第一次查询</li></ul><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230104182214710.png" alt="image-20230104182214710"></p><p>可以使用读写锁进行操作</p><h4 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h4><h5 id="成员属性"><a href="#成员属性" class="headerlink" title="成员属性"></a>成员属性</h5><p>读写锁用的是同一个 Sycn 同步器，因此等待队列、state 等也是同一个，原理与 ReentrantLock 加锁相比没有特殊之处，不同是<strong>写锁状态占了 state 的低 16 位，而读锁使用的是 state 的高 16 位</strong></p><ul><li><p>读写锁：</p><pre><code class="java">private final ReentrantReadWriteLock.ReadLock readerLock;private final ReentrantReadWriteLock.WriteLock writerLock;</code></pre></li><li><p>构造方法：默认是非公平锁，可以指定参数创建公平锁</p><pre><code class="java">public ReentrantReadWriteLock(boolean fair) &#123;    // true 为公平锁    sync = fair ? new FairSync() : new NonfairSync();    // 这两个 lock 共享同一个 sync 实例，都是由 ReentrantReadWriteLock 的 sync 提供同步实现    readerLock = new ReadLock(this);    writerLock = new WriteLock(this);&#125;</code></pre></li></ul><p>Sync 类的属性：</p><ul><li>统计变量：</li></ul><pre><code class="java">// 用来移位static final int SHARED_SHIFT   = 16;// 高16位的1static final int SHARED_UNIT    = (1 &lt;&lt; SHARED_SHIFT);// 65535，16个1，代表写锁的最大重入次数static final int MAX_COUNT      = (1 &lt;&lt; SHARED_SHIFT) - 1;// 低16位掩码：0b 1111 1111 1111 1111，用来获取写锁重入的次数static final int EXCLUSIVE_MASK = (1 &lt;&lt; SHARED_SHIFT) - 1;</code></pre><ul><li>获取读写锁的次数</li></ul><pre><code class="java">// 获取读写锁的读锁分配的总次数static int sharedCount(int c)    &#123; return c &gt;&gt;&gt; SHARED_SHIFT; &#125;// 写锁（独占）锁的重入次数static int exclusiveCount(int c) &#123; return c &amp; EXCLUSIVE_MASK; &#125;</code></pre><ul><li>内部类</li></ul><pre><code class="java">// 记录读锁线程自己的持有读锁的数量（重入次数），因为 state 高16位记录的是全局范围内所有的读线程获取读锁的总量static final class HoldCounter &#123;    int count = 0;    // Use id, not reference, to avoid garbage retention    final long tid = getThreadId(Thread.currentThread());&#125;// 线程安全的存放线程各自的 HoldCounter 对象static final class ThreadLocalHoldCounter extends ThreadLocal&lt;HoldCounter&gt; &#123;    public HoldCounter initialValue() &#123;        return new HoldCounter();    &#125;&#125;</code></pre><ul><li>内部类实例：</li></ul><pre><code class="java">// 当前线程持有的可重入读锁的数量，计数为 0 时删除private transient ThreadLocalHoldCounter readHolds;// 记录最后一个获取【读锁】线程的 HoldCounter 对象private transient HoldCounter cachedHoldCounter;</code></pre><ul><li>首次获取锁</li></ul><pre><code class="java">// 第一个获取读锁的线程private transient Thread firstReader = null;// 记录该线程持有的读锁次数（读锁重入次数）private transient int firstReaderHoldCount;</code></pre><ul><li>Sync 构造方法：</li></ul><pre><code class="java">Sync() &#123;    readHolds = new ThreadLocalHoldCounter();    // 确保其他线程的数据可见性，state 是 volatile 修饰的变量，重写该值会将线程本地缓存数据【同步至主存】    setState(getState()); &#125;</code></pre><h5 id="加锁原理"><a href="#加锁原理" class="headerlink" title="加锁原理"></a>加锁原理</h5><p>t1 线程：w.lock（<strong>写锁</strong>），成功上锁 state &#x3D; 0_1</p><pre><code class="java">// lock()  -&gt; sync.acquire(1);public void lock() &#123;    sync.acquire(1);&#125;public final void acquire(int arg) &#123;    // 尝试获得写锁，获得写锁失败，将当前线程关联到一个 Node 对象上, 模式为独占模式     if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))        selfInterrupt();&#125;</code></pre><pre><code class="java">protected final boolean tryAcquire(int acquires) &#123;    Thread current = Thread.currentThread();    int c = getState();    // 获得低 16 位, 代表写锁的 state 计数    int w = exclusiveCount(c);    // 说明有读锁或者写锁    if (c != 0) &#123;        // c != 0 and w == 0 表示有读锁，【读锁不能升级】，直接返回 false        // w != 0 说明有写锁，写锁的拥有者不是自己，获取失败        if (w == 0 || current != getExclusiveOwnerThread())            return false;                // 执行到这里只有一种情况：【写锁重入】，所以下面几行代码不存在并发        if (w + exclusiveCount(acquires) &gt; MAX_COUNT)            throw new Error(&quot;Maximum lock count exceeded&quot;);        // 写锁重入, 获得锁成功，没有并发，所以不使用 CAS        setState(c + acquires);        return true;    &#125;        // c == 0，说明没有任何锁，判断写锁是否该阻塞，是 false 就尝试获取锁，失败返回 false    if (writerShouldBlock() || !compareAndSetState(c, c + acquires))        return false;    // 获得锁成功，设置锁的持有线程为当前线程    setExclusiveOwnerThread(current);    return true;&#125;// 非公平锁 writerShouldBlock 总是返回 false, 无需阻塞final boolean writerShouldBlock() &#123;    return false; &#125;// 公平锁会检查 AQS 队列中是否有前驱节点, 没有(false)才去竞争final boolean writerShouldBlock() &#123;    return hasQueuedPredecessors();&#125;</code></pre><p>t2 r.lock（<strong>读锁</strong>），进入 tryAcquireShared 流程：</p><ul><li>返回 -1 表示失败</li><li>如果返回 0 表示成功</li><li>返回正数表示还有多少后继节点支持共享模式，读写锁返回 1</li></ul><pre><code class="java">public void lock() &#123;    sync.acquireShared(1);&#125;public final void acquireShared(int arg) &#123;    // tryAcquireShared 返回负数, 表示获取读锁失败    if (tryAcquireShared(arg) &lt; 0)        doAcquireShared(arg);&#125;</code></pre><pre><code class="java">public void lock() &#123;    sync.acquireShared(1);&#125;public final void acquireShared(int arg) &#123;    // tryAcquireShared 返回负数, 表示获取读锁失败    if (tryAcquireShared(arg) &lt; 0)        doAcquireShared(arg);&#125;</code></pre><pre><code class="java">// 尝试以共享模式获取protected final int tryAcquireShared(int unused) &#123;    Thread current = Thread.currentThread();    int c = getState();    // exclusiveCount(c) 代表低 16 位, 写锁的 state，成立说明有线程持有写锁    // 写锁的持有者不是当前线程，则获取读锁失败，【写锁允许降级】    if (exclusiveCount(c) != 0 &amp;&amp; getExclusiveOwnerThread() != current)        return -1;        // 高 16 位，代表读锁的 state，共享锁分配出去的总次数    int r = sharedCount(c);    // 读锁是否应该阻塞    if (!readerShouldBlock() &amp;&amp;r &lt; MAX_COUNT &amp;&amp;        compareAndSetState(c, c + SHARED_UNIT)) &#123;// 尝试增加读锁计数        // 加锁成功        // 加锁之前读锁为 0，说明当前线程是第一个读锁线程        if (r == 0) &#123;            firstReader = current;            firstReaderHoldCount = 1;        // 第一个读锁线程是自己就发生了读锁重入        &#125; else if (firstReader == current) &#123;            firstReaderHoldCount++;        &#125; else &#123;            // cachedHoldCounter 设置为当前线程的 holdCounter 对象，即最后一个获取读锁的线程            HoldCounter rh = cachedHoldCounter;            // 说明还没设置 rh            if (rh == null || rh.tid != getThreadId(current))                // 获取当前线程的锁重入的对象，赋值给 cachedHoldCounter                cachedHoldCounter = rh = readHolds.get();            // 还没重入            else if (rh.count == 0)                readHolds.set(rh);            // 重入 + 1            rh.count++;        &#125;        // 读锁加锁成功        return 1;    &#125;    // 逻辑到这 应该阻塞，或者 cas 加锁失败    // 会不断尝试 for (;;) 获取读锁, 执行过程中无阻塞    return fullTryAcquireShared(current);&#125;// 非公平锁 readerShouldBlock 偏向写锁一些，看 AQS 阻塞队列中第一个节点是否是写锁，是则阻塞，反之不阻塞// 防止一直有读锁线程，导致写锁线程饥饿// true 则该阻塞, false 则不阻塞final boolean readerShouldBlock() &#123;    return apparentlyFirstQueuedIsExclusive();&#125;final boolean readerShouldBlock() &#123;    return hasQueuedPredecessors();&#125;</code></pre><pre><code class="java">final int fullTryAcquireShared(Thread current) &#123;    // 当前读锁线程持有的读锁次数对象    HoldCounter rh = null;    for (;;) &#123;        int c = getState();        // 说明有线程持有写锁        if (exclusiveCount(c) != 0) &#123;            // 写锁不是自己则获取锁失败            if (getExclusiveOwnerThread() != current)                return -1;        &#125; else if (readerShouldBlock()) &#123;            // 条件成立说明当前线程是 firstReader，当前锁是读忙碌状态，而且当前线程也是读锁重入            if (firstReader == current) &#123;                // assert firstReaderHoldCount &gt; 0;            &#125; else &#123;                if (rh == null) &#123;                    // 最后一个读锁的 HoldCounter                    rh = cachedHoldCounter;                    // 说明当前线程也不是最后一个读锁                    if (rh == null || rh.tid != getThreadId(current)) &#123;                        // 获取当前线程的 HoldCounter                        rh = readHolds.get();                        // 条件成立说明 HoldCounter 对象是上一步代码新建的                        // 当前线程不是锁重入，在 readerShouldBlock() 返回 true 时需要去排队                        if (rh.count == 0)                            // 防止内存泄漏                            readHolds.remove();                    &#125;                &#125;                if (rh.count == 0)                    return -1;            &#125;        &#125;        // 越界判断        if (sharedCount(c) == MAX_COUNT)            throw new Error(&quot;Maximum lock count exceeded&quot;);        // 读锁加锁，条件内的逻辑与 tryAcquireShared 相同        if (compareAndSetState(c, c + SHARED_UNIT)) &#123;            if (sharedCount(c) == 0) &#123;                firstReader = current;                firstReaderHoldCount = 1;            &#125; else if (firstReader == current) &#123;                firstReaderHoldCount++;            &#125; else &#123;                if (rh == null)                    rh = cachedHoldCounter;                if (rh == null || rh.tid != getThreadId(current))                    rh = readHolds.get();                else if (rh.count == 0)                    readHolds.set(rh);                rh.count++;                cachedHoldCounter = rh; // cache for release            &#125;            return 1;        &#125;    &#125;&#125;</code></pre><p>获取读锁失败，进入 sync.doAcquireShared(1) 流程开始阻塞，首先也是调用 addWaiter 添加节点，不同之处在于节点被设置为 Node.SHARED 模式而非 Node.EXCLUSIVE 模式，注意此时 t2 仍处于活跃状态</p><pre><code class="java">private void doAcquireShared(int arg) &#123;    // 将当前线程关联到一个 Node 对象上, 模式为共享模式    final Node node = addWaiter(Node.SHARED);    boolean failed = true;    try &#123;        boolean interrupted = false;        for (;;) &#123;            // 获取前驱节点            final Node p = node.predecessor();            // 如果前驱节点就头节点就去尝试获取锁            if (p == head) &#123;                // 再一次尝试获取读锁                int r = tryAcquireShared(arg);                // r &gt;= 0 表示获取成功                if (r &gt;= 0) &#123;                    //【这里会设置自己为头节点，唤醒相连的后序的共享节点】                    setHeadAndPropagate(node, r);                    p.next = null; // help GC                    if (interrupted)                        selfInterrupt();                    failed = false;                    return;                &#125;            &#125;            // 是否在获取读锁失败时阻塞       park 当前线程            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())                interrupted = true;        &#125;    &#125; finally &#123;        if (failed)            cancelAcquire(node);    &#125;&#125;</code></pre><p>如果没有成功，在 doAcquireShared 内 for (;;) 循环一次，shouldParkAfterFailedAcquire 内把前驱节点的 waitStatus 改为 -1，再 for (;;) 循环一次尝试 tryAcquireShared，不成功在 parkAndCheckInterrupt() 处 park</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230104183028468.png" alt="image-20230104183028468"></p><p>种状态下，假设又有 t3 r.lock，t4 w.lock，这期间 t1 仍然持有锁，就变成了下面的样子</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230104183041777.png" alt="image-20230104183041777"></p><h5 id="解锁原理"><a href="#解锁原理" class="headerlink" title="解锁原理"></a>解锁原理</h5><p>t1 w.unlock， 写锁解锁</p><pre><code class="java">public void unlock() &#123;    // 释放锁    sync.release(1);&#125;public final boolean release(int arg) &#123;    // 尝试释放锁    if (tryRelease(arg)) &#123;        Node h = head;        // 头节点不为空并且不是等待状态不是 0，唤醒后继的非取消节点        if (h != null &amp;&amp; h.waitStatus != 0)            unparkSuccessor(h);        return true;    &#125;    return false;&#125;protected final boolean tryRelease(int releases) &#123;    if (!isHeldExclusively())        throw new IllegalMonitorStateException();    int nextc = getState() - releases;    // 因为可重入的原因, 写锁计数为 0, 才算释放成功    boolean free = exclusiveCount(nextc) == 0;    if (free)        setExclusiveOwnerThread(null);    setState(nextc);    return free;&#125;</code></pre><ul><li>唤醒流程 sync.unparkSuccessor，这时 t2 在 doAcquireShared 的 parkAndCheckInterrupt() 处恢复运行，继续循环，执行 tryAcquireShared 成功则让读锁计数加一</li></ul><ul><li>接下来 t2 调用 setHeadAndPropagate(node, 1)，它原本所在节点被置为头节点；还会检查下一个节点是否是 shared，如果是则调用 doReleaseShared() 将 head 的状态从 -1 改为 0 并唤醒下一个节点，这时 t3 在 doAcquireShared 内 parkAndCheckInterrupt() 处恢复运行，<strong>唤醒连续的所有的共享节点</strong></li></ul><pre><code class="java">private void setHeadAndPropagate(Node node, int propagate) &#123;    Node h = head;     // 设置自己为 head 节点    setHead(node);    // propagate 表示有共享资源（例如共享读锁或信号量），为 0 就没有资源    if (propagate &gt; 0 || h == null || h.waitStatus &lt; 0 ||        (h = head) == null || h.waitStatus &lt; 0) &#123;        // 获取下一个节点        Node s = node.next;        // 如果当前是最后一个节点，或者下一个节点是【等待共享读锁的节点】        if (s == null || s.isShared())            // 唤醒后继节点            doReleaseShared();    &#125;&#125;</code></pre><pre><code class="java">private void doReleaseShared() &#123;    // 如果 head.waitStatus == Node.SIGNAL ==&gt; 0 成功, 下一个节点 unpark    // 如果 head.waitStatus == 0 ==&gt; Node.PROPAGATE    for (;;) &#123;        Node h = head;        if (h != null &amp;&amp; h != tail) &#123;            int ws = h.waitStatus;            // SIGNAL 唤醒后继            if (ws == Node.SIGNAL) &#123;                // 因为读锁共享，如果其它线程也在释放读锁，那么需要将 waitStatus 先改为 0                // 防止 unparkSuccessor 被多次执行                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))                    continue;                  // 唤醒后继节点                unparkSuccessor(h);            &#125;            // 如果已经是 0 了，改为 -3，用来解决传播性            else if (ws == 0 &amp;&amp; !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))                continue;                        &#125;        // 条件不成立说明被唤醒的节点非常积极，直接将自己设置为了新的 head，        // 此时唤醒它的节点（前驱）执行 h == head 不成立，所以不会跳出循环，会继续唤醒新的 head 节点的后继节点        if (h == head)                               break;    &#125;&#125;</code></pre><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230104183139918.png" alt="image-20230104183139918"></p><ul><li>下一个节点不是 shared 了，因此不会继续唤醒 t4 所在节点</li><li>t2 读锁解锁，进入 sync.releaseShared(1) 中，调用 tryReleaseShared(1) 让计数减一，但计数还不为零，t3 同样让计数减一，计数为零，进入doReleaseShared() 将头节点从 -1 改为 0 并唤醒下一个节点</li></ul><pre><code class="java">public void unlock() &#123;    sync.releaseShared(1);&#125;public final boolean releaseShared(int arg) &#123;    if (tryReleaseShared(arg)) &#123;        doReleaseShared();        return true;    &#125;    return false;&#125;</code></pre><pre><code class="java">protected final boolean tryReleaseShared(int unused) &#123;    for (;;) &#123;        int c = getState();        int nextc = c - SHARED_UNIT;        // 读锁的计数不会影响其它获取读锁线程, 但会影响其它获取写锁线程，计数为 0 才是真正释放        if (compareAndSetState(c, nextc))            // 返回是否已经完全释放了             return nextc == 0;    &#125;&#125;</code></pre><ul><li>t4 在 acquireQueued 中 parkAndCheckInterrupt 处恢复运行，再次 for (;;) 这次自己是头节点的临节点，并且没有其他节点竞争，tryAcquire(1) 成功，修改头结点，流程结束</li></ul><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230104183257411.png" alt="image-20230104183257411"></p><h3 id="4-StampedLock"><a href="#4-StampedLock" class="headerlink" title="4.StampedLock"></a>4.StampedLock</h3><p>该类自 JDK 8 加入，是为了进一步优化读性能，它的特点是在使用读锁、写锁时都必须配合【戳】使用</p><p>加解读锁</p><pre><code class="java">long stamp = lock.readLock();lock.unlockRead(stamp);</code></pre><p>加解写锁</p><pre><code class="java">long stamp = lock.writeLock();lock.unlockWrite(stamp);</code></pre><p>乐观读，StampedLock 支持 <code>tryOptimisticRead()</code> 方法，读取完毕后做一次<strong>戳校验</strong>，如果校验通过，表示这期间没有其他线程的写操作，数据可以安全使用，如果校验没通过，需要重新获取读锁，保证数据一致性</p><pre><code class="java">long stamp = lock.tryOptimisticRead();// 验戳if(!lock.validate(stamp))&#123;    // 锁升级&#125;</code></pre><p>提供一个数据容器类内部分别使用读锁保护数据的 read() 方法，写锁保护数据的 write() 方法：</p><ul><li>读-读可以优化</li><li>读-写优化读，补加读锁</li></ul><pre><code class="java">public static void main(String[] args) throws InterruptedException &#123;    DataContainerStamped dataContainer = new DataContainerStamped(1);    new Thread(() -&gt; &#123;        dataContainer.read(1000);    &#125;,&quot;t1&quot;).start();    Thread.sleep(500);        new Thread(() -&gt; &#123;        dataContainer.write(1000);    &#125;,&quot;t2&quot;).start();&#125;class DataContainerStamped &#123;    private int data;    private final StampedLock lock = new StampedLock();    public int read(int readTime) throws InterruptedException &#123;        long stamp = lock.tryOptimisticRead();        System.out.println(new Date() + &quot; optimistic read locking&quot; + stamp);        Thread.sleep(readTime);        // 戳有效，直接返回数据        if (lock.validate(stamp)) &#123;            Sout(new Date() + &quot; optimistic read finish...&quot; + stamp);            return data;        &#125;        // 说明其他线程更改了戳，需要锁升级了，从乐观读升级到读锁        System.out.println(new Date() + &quot; updating to read lock&quot; + stamp);        try &#123;            stamp = lock.readLock();            System.out.println(new Date() + &quot; read lock&quot; + stamp);            Thread.sleep(readTime);            System.out.println(new Date() + &quot; read finish...&quot; + stamp);            return data;        &#125; finally &#123;            System.out.println(new Date() + &quot; read unlock &quot; +  stamp);            lock.unlockRead(stamp);        &#125;    &#125;    public void write(int newData) &#123;        long stamp = lock.writeLock();        System.out.println(new Date() + &quot; write lock &quot; + stamp);        try &#123;            Thread.sleep(2000);            this.data = newData;        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125; finally &#123;            System.out.println(new Date() + &quot; write unlock &quot; + stamp);            lock.unlockWrite(stamp);        &#125;    &#125;&#125;</code></pre><h3 id="5-Semaphore"><a href="#5-Semaphore" class="headerlink" title="5.Semaphore"></a>5.Semaphore</h3><h4 id="基本使用-2"><a href="#基本使用-2" class="headerlink" title="基本使用"></a>基本使用</h4><p>synchronized 可以起到锁的作用，但某个时间段内，只能有一个线程允许执行</p><p>Semaphore（信号量）用来限制能同时访问共享资源的线程上限，非重入锁</p><p>构造方法：</p><ul><li><code>public Semaphore(int permits)</code>：permits 表示许可线程的数量（state）</li><li><code>public Semaphore(int permits, boolean fair)</code>：fair 表示公平性，如果设为 true，下次执行的线程会是等待最久的线程</li></ul><p>常用API：</p><ul><li><code>public void acquire()</code>：表示获取许可</li><li><code>public void release()</code>：表示释放许可，acquire() 和 release() 方法之间的代码为同步代码</li></ul><pre><code class="java">public static void main(String[] args) &#123;    // 1.创建Semaphore对象    Semaphore semaphore = new Semaphore(3);    // 2. 10个线程同时运行    for (int i = 0; i &lt; 10; i++) &#123;        new Thread(() -&gt; &#123;            try &#123;                // 3. 获取许可                semaphore.acquire();                sout(Thread.currentThread().getName() + &quot; running...&quot;);                Thread.sleep(1000);                sout(Thread.currentThread().getName() + &quot; end...&quot;);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125; finally &#123;                // 4. 释放许可                semaphore.release();            &#125;        &#125;).start();    &#125;&#125;</code></pre><h4 id="实现原理-2"><a href="#实现原理-2" class="headerlink" title="实现原理"></a>实现原理</h4><p>加锁流程：</p><ul><li><p>Semaphore 的 permits（state）为 3，这时 5 个线程来获取资源</p><pre><code class="java">Sync(int permits) &#123;    setState(permits);&#125;</code></pre><p>假设其中 Thread-1，Thread-2，Thread-4 CAS 竞争成功，permits 变为 0，而 Thread-0 和 Thread-3 竞争失败，进入 AQS 队列park 阻塞</p><pre><code class="java">// acquire() -&gt; sync.acquireSharedInterruptibly(1)，可中断public final void acquireSharedInterruptibly(int arg) &#123;    if (Thread.interrupted())        throw new InterruptedException();    // 尝试获取通行证，获取成功返回 &gt;= 0的值    if (tryAcquireShared(arg) &lt; 0)        // 获取许可证失败，进入阻塞        doAcquireSharedInterruptibly(arg);&#125;// tryAcquireShared() -&gt; nonfairTryAcquireShared()// 非公平，公平锁会在循环内 hasQueuedPredecessors()方法判断阻塞队列是否有临头节点(第二个节点)final int nonfairTryAcquireShared(int acquires) &#123;    for (;;) &#123;        // 获取 state ，state 这里【表示通行证】        int available = getState();        // 计算当前线程获取通行证完成之后，通行证还剩余数量        int remaining = available - acquires;        // 如果许可已经用完, 返回负数, 表示获取失败,        if (remaining &lt; 0 ||            // 许可证足够分配的，如果 cas 重试成功, 返回正数, 表示获取成功            compareAndSetState(available, remaining))            return remaining;    &#125;&#125;</code></pre><pre><code class="java">private void doAcquireSharedInterruptibly(int arg) &#123;    // 将调用 Semaphore.aquire 方法的线程，包装成 node 加入到 AQS 的阻塞队列中    final Node node = addWaiter(Node.SHARED);    // 获取标记    boolean failed = true;    try &#123;        for (;;) &#123;            final Node p = node.predecessor();            // 前驱节点是头节点可以再次获取许可            if (p == head) &#123;                // 再次尝试获取许可，【返回剩余的许可证数量】                int r = tryAcquireShared(arg);                if (r &gt;= 0) &#123;                    // 成功后本线程出队（AQS）, 所在 Node设置为 head                    // r 表示【可用资源数】, 为 0 则不会继续传播                    setHeadAndPropagate(node, r);                     p.next = null; // help GC                    failed = false;                    return;                &#125;            &#125;            // 不成功, 设置上一个节点 waitStatus = Node.SIGNAL, 下轮进入 park 阻塞            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())                throw new InterruptedException();        &#125;    &#125; finally &#123;        // 被打断后进入该逻辑        if (failed)            cancelAcquire(node);    &#125;&#125;</code></pre><pre><code class="java">private void setHeadAndPropagate(Node node, int propagate) &#123;        Node h = head;    // 设置自己为 head 节点    setHead(node);    // propagate 表示有【共享资源】（例如共享读锁或信号量）    // head waitStatus == Node.SIGNAL 或 Node.PROPAGATE，doReleaseShared 函数中设置的    if (propagate &gt; 0 || h == null || h.waitStatus &lt; 0 ||        (h = head) == null || h.waitStatus &lt; 0) &#123;        Node s = node.next;        // 如果是最后一个节点或者是等待共享读锁的节点，做一次唤醒        if (s == null || s.isShared())            doReleaseShared();    &#125;&#125;</code></pre><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230110155608382.png" alt="image-20230110155608382"></p></li></ul><p>这时 Thread-4 释放了 permits，状态如下</p><pre><code class="java">// release() -&gt; releaseShared()public final boolean releaseShared(int arg) &#123;    // 尝试释放锁    if (tryReleaseShared(arg)) &#123;        doReleaseShared();        return true;    &#125;        return false;&#125;protected final boolean tryReleaseShared(int releases) &#123;        for (;;) &#123;        // 获取当前锁资源的可用许可证数量        int current = getState();        int next = current + releases;        // 索引越界判断        if (next &lt; current)                        throw new Error(&quot;Maximum permit count exceeded&quot;);                // 释放锁        if (compareAndSetState(current, next))                        return true;        &#125;&#125;private void doReleaseShared() &#123;        // PROPAGATE 详解        // 如果 head.waitStatus == Node.SIGNAL ==&gt; 0 成功, 下一个节点 unpark    // 如果 head.waitStatus == 0 ==&gt; Node.PROPAGATE&#125;</code></pre><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230110155916768.png" alt="image-20230110155916768"></p><ul><li>接下来 Thread-0 竞争成功，permits 再次设置为 0，设置自己为 head 节点，并且 unpark 接下来的共享状态的 Thread-3 节点，但由于 permits 是 0，因此 Thread-3 在尝试不成功后再次进入 park 状态</li></ul><h3 id="6-CountDownLatch"><a href="#6-CountDownLatch" class="headerlink" title="6.CountDownLatch"></a>6.CountDownLatch</h3><h4 id="基本使用-3"><a href="#基本使用-3" class="headerlink" title="基本使用"></a>基本使用</h4><p>CountDownLatch：计数器，用来进行线程同步协作，<strong>等待所有线程完成</strong></p><p>构造器：</p><ul><li><code>public CountDownLatch(int count)</code>：初始化唤醒需要的 down 几步</li></ul><p>常用API：</p><ul><li><code>public void await() </code>：让当前线程等待，必须 down 完初始化的数字才可以被唤醒，否则进入无限等待</li><li><code>public void countDown()</code>：计数器进行减 1（down 1）</li></ul><p>应用：同步等待多个 Rest 远程调用结束</p><pre><code class="java">// LOL 10人进入游戏倒计时public static void main(String[] args) throws InterruptedException &#123;    CountDownLatch latch = new CountDownLatch(10);    ExecutorService service = Executors.newFixedThreadPool(10);    String[] all = new String[10];    Random random = new Random();    for (int j = 0; j &lt; 10; j++) &#123;        int finalJ = j;//常量        service.submit(() -&gt; &#123;            for (int i = 0; i &lt;= 100; i++) &#123;                Thread.sleep(random.nextInt(100));//随机休眠                all[finalJ] = i + &quot;%&quot;;                System.out.print(&quot;\r&quot; + Arrays.toString(all));// \r代表覆盖            &#125;            latch.countDown();        &#125;);    &#125;    latch.await();    System.out.println(&quot;\n游戏开始&quot;);    service.shutdown();&#125;/*[100%, 100%, 100%, 100%, 100%, 100%, 100%, 100%, 100%, 100%]游戏开始</code></pre><h4 id="实现原理-3"><a href="#实现原理-3" class="headerlink" title="实现原理"></a>实现原理</h4><p>阻塞等待：</p><ul><li><p>线程调用 await() 等待其他线程完成任务：支持打断</p><pre><code class="java">public void await() throws InterruptedException &#123;    sync.acquireSharedInterruptibly(1);&#125;// AbstractQueuedSynchronizer#acquireSharedInterruptiblypublic final void acquireSharedInterruptibly(int arg) throws InterruptedException &#123;    // 判断线程是否被打断，抛出打断异常    if (Thread.interrupted())        throw new InterruptedException();    // 尝试获取共享锁，条件成立说明 state &gt; 0，此时线程入队阻塞等待，等待其他线程获取共享资源    // 条件不成立说明 state = 0，此时不需要阻塞线程，直接结束函数调用    if (tryAcquireShared(arg) &lt; 0)        doAcquireSharedInterruptibly(arg);&#125;// CountDownLatch.Sync#tryAcquireSharedprotected int tryAcquireShared(int acquires) &#123;    return (getState() == 0) ? 1 : -1;&#125;</code></pre></li><li><p>线程进入 AbstractQueuedSynchronizer#doAcquireSharedInterruptibly 函数阻塞挂起，等待 latch 变为 0：</p><pre><code class="java">private void doAcquireSharedInterruptibly(int arg) throws InterruptedException &#123;    // 将调用latch.await()方法的线程 包装成 SHARED 类型的 node 加入到 AQS 的阻塞队列中    final Node node = addWaiter(Node.SHARED);    boolean failed = true;    try &#123;        for (;;) &#123;            // 获取当前节点的前驱节点            final Node p = node.predecessor();            // 前驱节点时头节点就可以尝试获取锁            if (p == head) &#123;                // 再次尝试获取锁，获取成功返回 1                int r = tryAcquireShared(arg);                if (r &gt;= 0) &#123;                    // 获取锁成功，设置当前节点为 head 节点，并且向后传播                    setHeadAndPropagate(node, r);                    p.next = null; // help GC                    failed = false;                    return;                &#125;            &#125;            // 阻塞在这里            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())                throw new InterruptedException();        &#125;    &#125; finally &#123;        // 阻塞线程被中断后抛出异常，进入取消节点的逻辑        if (failed)            cancelAcquire(node);    &#125;&#125;</code></pre></li><li><p>获取共享锁成功，进入唤醒阻塞队列中与头节点相连的 SHARED 模式的节点：</p><pre><code class="java">private void setHeadAndPropagate(Node node, int propagate) &#123;    Node h = head;    // 将当前节点设置为新的 head 节点，前驱节点和持有线程置为 null    setHead(node);    // propagate = 1，条件一成立    if (propagate &gt; 0 || h == null || h.waitStatus &lt; 0 || (h = head) == null || h.waitStatus &lt; 0) &#123;        // 获取当前节点的后继节点        Node s = node.next;        // 当前节点是尾节点时 next 为 null，或者后继节点是 SHARED 共享模式        if (s == null || s.isShared())            // 唤醒所有的等待共享锁的节点            doReleaseShared();    &#125;&#125;</code></pre></li></ul><p>计数减一：</p><ul><li><p>线程进入 countDown() 完成计数器减一（释放锁）的操作</p><pre><code class="java">public void countDown() &#123;    sync.releaseShared(1);&#125;public final boolean releaseShared(int arg) &#123;    // 尝试释放共享锁    if (tryReleaseShared(arg)) &#123;        // 释放锁成功开始唤醒阻塞节点        doReleaseShared();        return true;    &#125;    return false;&#125;</code></pre></li><li><p>更新 state 值，每调用一次，state 值减一，当 state -1 正好为 0 时，返回 true</p><pre><code class="java">protected boolean tryReleaseShared(int releases) &#123;    for (;;) &#123;        int c = getState();        // 条件成立说明前面【已经有线程触发唤醒操作】了，这里返回 false        if (c == 0)            return false;        // 计数器减一        int nextc = c-1;        if (compareAndSetState(c, nextc))            // 计数器为 0 时返回 true            return nextc == 0;    &#125;&#125;</code></pre></li><li><p>state &#x3D; 0 时，当前线程需要执行<strong>唤醒阻塞节点的任务</strong></p><pre><code class="java">private void doReleaseShared() &#123;    for (;;) &#123;        Node h = head;        // 判断队列是否是空队列        if (h != null &amp;&amp; h != tail) &#123;            int ws = h.waitStatus;            // 头节点的状态为 signal，说明后继节点没有被唤醒过            if (ws == Node.SIGNAL) &#123;                // cas 设置头节点的状态为 0，设置失败继续自旋                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))                    continue;                // 唤醒后继节点                unparkSuccessor(h);            &#125;            // 如果有其他线程已经设置了头节点的状态，重新设置为 PROPAGATE 传播属性            else if (ws == 0 &amp;&amp; !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))                continue;        &#125;        // 条件不成立说明被唤醒的节点非常积极，直接将自己设置为了新的head，        // 此时唤醒它的节点（前驱）执行 h == head 不成立，所以不会跳出循环，会继续唤醒新的 head 节点的后继节点        if (h == head)            break;    &#125;&#125;</code></pre></li></ul><h3 id="7-CyclicBarrier"><a href="#7-CyclicBarrier" class="headerlink" title="7.CyclicBarrier"></a>7.CyclicBarrier</h3><h4 id="基本使用-4"><a href="#基本使用-4" class="headerlink" title="基本使用"></a>基本使用</h4><p>CyclicBarrier：循环屏障，用来进行线程协作，等待线程满足某个计数，才能触发自己执行</p><p>常用方法:</p><ul><li><pre><code>public CyclicBarrier(int parties, Runnable barrierAction)</code></pre><p>：用于在线程到达屏障 parties 时，执行 barrierAction</p><ul><li>parties：代表多少个线程到达屏障开始触发线程任务</li><li>barrierAction：线程任务</li></ul></li><li><p><code>public int await()</code>：线程调用 await 方法通知 CyclicBarrier 本线程已经到达屏障</p></li></ul><p>与 CountDownLatch 的区别：CyclicBarrier 0是可以重用的</p><p>应用：可以实现多线程中，某个任务在等待其他线程执行完毕以后触发</p><pre><code class="java">public static void main(String[] args) &#123;    ExecutorService service = Executors.newFixedThreadPool(2);    CyclicBarrier barrier = new CyclicBarrier(2, () -&gt; &#123;//所有任务结束后执行下面的语句        System.out.println(&quot;task1 task2 finish...&quot;);    &#125;);    for (int i = 0; i &lt; 3; i++) &#123; // 循环重用        service.submit(() -&gt; &#123;            System.out.println(&quot;task1 begin...&quot;);            try &#123;                Thread.sleep(1000);                barrier.await();    // 2 - 1 = 1            &#125; catch (InterruptedException | BrokenBarrierException e) &#123;                e.printStackTrace();            &#125;        &#125;);        service.submit(() -&gt; &#123;            System.out.println(&quot;task2 begin...&quot;);            try &#123;                Thread.sleep(2000);                barrier.await();    // 1 - 1 = 0            &#125; catch (InterruptedException | BrokenBarrierException e) &#123;                e.printStackTrace();            &#125;        &#125;);    &#125;    service.shutdown();&#125;</code></pre><h4 id="实现原理-4"><a href="#实现原理-4" class="headerlink" title="实现原理"></a>实现原理</h4><h5 id="成员属性-1"><a href="#成员属性-1" class="headerlink" title="成员属性"></a>成员属性</h5><ul><li><p>全局锁：利用可重入锁实现的工具类</p><pre><code class="java">// barrier 实现是依赖于Condition条件队列，condition 条件队列必须依赖lock才能使用private final ReentrantLock lock = new ReentrantLock();// 线程挂起实现使用的 condition 队列，当前代所有线程到位，这个条件队列内的线程才会被唤醒private final Condition trip = lock.newCondition();</code></pre></li><li><p>线程数量：</p><pre><code class="java">private final int parties;// 代表多少个线程到达屏障开始触发线程任务private int count;// 表示当前“代”还有多少个线程未到位，初始值为 parties</code></pre></li><li><p>当前代中最后一个线程到位后要执行的事件：</p><pre><code class="java">private final Runnable barrierCommand;</code></pre></li><li><p>代：</p><pre><code class="java">// 表示 barrier 对象当前 代private Generation generation = new Generation();private static class Generation &#123;    // 表示当前“代”是否被打破，如果被打破再来到这一代的线程 就会直接抛出 BrokenException 异常    // 且在这一代挂起的线程都会被唤醒，然后抛出 BrokerException 异常。    boolean broken = false;&#125;</code></pre></li><li><p>构造方法：</p><pre><code class="java">public CyclicBarrie(int parties, Runnable barrierAction) &#123;    // 因为小于等于 0 的 barrier 没有任何意义    if (parties &lt;= 0) throw new IllegalArgumentException();    this.parties = parties;    this.count = parties;    // 可以为 null    this.barrierCommand = barrierAction;&#125;</code></pre></li></ul><h5 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h5><ul><li><p>await()：阻塞等待所有线程到位</p><pre><code class="java">public int await() throws InterruptedException, BrokenBarrierException &#123;    try &#123;        return dowait(false, 0L);    &#125; catch (TimeoutException toe) &#123;        throw new Error(toe); // cannot happen    &#125;&#125;</code></pre><pre><code class="java">// timed：表示当前调用await方法的线程是否指定了超时时长，如果 true 表示线程是响应超时的// nanos：线程等待超时时长，单位是纳秒private int dowait(boolean timed, long nanos) &#123;    final ReentrantLock lock = this.lock;    // 加锁    lock.lock();    try &#123;        // 获取当前代        final Generation g = generation;        // 【如果当前代是已经被打破状态，则当前调用await方法的线程，直接抛出Broken异常】        if (g.broken)            throw new BrokenBarrierException();        // 如果当前线程被中断了，则打破当前代，然后当前线程抛出中断异常        if (Thread.interrupted()) &#123;            // 设置当前代的状态为 broken 状态，唤醒在 trip 条件队列内的线程            breakBarrier();            throw new InterruptedException();        &#125;        // 逻辑到这说明，当前线程中断状态是 false， 当前代的 broken 为 false（未打破状态）                // 假设 parties 给的是 5，那么index对应的值为 4,3,2,1,0        int index = --count;        // 条件成立说明当前线程是最后一个到达 barrier 的线程，【需要开启新代，唤醒阻塞线程】        if (index == 0) &#123;            // 栅栏任务启动标记            boolean ranAction = false;            try &#123;                final Runnable command = barrierCommand;                if (command != null)                    // 启动触发的任务                    command.run();                // run()未抛出异常的话，启动标记设置为 true                ranAction = true;                // 开启新的一代，这里会【唤醒所有的阻塞队列】                nextGeneration();                // 返回 0 因为当前线程是此代最后一个到达的线程，index == 0                return 0;            &#125; finally &#123;                // 如果 command.run() 执行抛出异常的话，会进入到这里                if (!ranAction)                    breakBarrier();            &#125;        &#125;        // 自旋，一直到条件满足、当前代被打破、线程被中断，等待超时        for (;;) &#123;            try &#123;                // 根据是否需要超时等待选择阻塞方法                if (!timed)                    // 当前线程释放掉 lock，【进入到 trip 条件队列的尾部挂起自己】，等待被唤醒                    trip.await();                else if (nanos &gt; 0L)                    nanos = trip.awaitNanos(nanos);            &#125; catch (InterruptedException ie) &#123;                // 被中断后来到这里的逻辑                                // 当前代没有变化并且没有被打破                if (g == generation &amp;&amp; !g.broken) &#123;                    // 打破屏障                    breakBarrier();                    // node 节点在【条件队列】内收到中断信号时 会抛出中断异常                    throw ie;                &#125; else &#123;                    // 等待过程中代变化了，完成一次自我打断                    Thread.currentThread().interrupt();                &#125;            &#125;            // 唤醒后的线程，【判断当前代已经被打破，线程唤醒后依次抛出 BrokenBarrier 异常】            if (g.broken)                throw new BrokenBarrierException();            // 当前线程挂起期间，最后一个线程到位了，然后触发了开启新的一代的逻辑            if (g != generation)                return index;            // 当前线程 trip 中等待超时，然后主动转移到阻塞队列            if (timed &amp;&amp; nanos &lt;= 0L) &#123;                breakBarrier();                // 抛出超时异常                throw new TimeoutException();            &#125;        &#125;    &#125; finally &#123;        // 解锁        lock.unlock();    &#125;&#125;</code></pre></li><li><p>breakBarrier()：打破 Barrier 屏障</p><pre><code class="java">private void breakBarrier() &#123;    // 将代中的 broken 设置为 true，表示这一代是被打破了，再来到这一代的线程，直接抛出异常    generation.broken = true;    // 重置 count 为 parties    count = parties;    // 将在trip条件队列内挂起的线程全部唤醒，唤醒后的线程会检查当前是否是打破的，然后抛出异常    trip.signalAll();&#125;</code></pre></li><li><p>nextGeneration()：开启新的下一代java</p></li><li><pre><code class="java">private void nextGeneration() &#123;    // 将在 trip 条件队列内挂起的线程全部唤醒    trip.signalAll();    // 重置 count 为 parties    count = parties;    // 开启新的一代，使用一个新的generation对象，表示新的一代，新的一代和上一代【没有任何关系】    generation = new Generation();&#125;</code></pre></li></ul><h3 id="8-ConcurrentHashMap"><a href="#8-ConcurrentHashMap" class="headerlink" title="8.ConcurrentHashMap"></a>8.ConcurrentHashMap</h3><h4 id="并发集合"><a href="#并发集合" class="headerlink" title="并发集合"></a>并发集合</h4><h5 id="集合对比"><a href="#集合对比" class="headerlink" title="集合对比"></a>集合对比</h5><p>三种集合：</p><ul><li>HashMap 是线程不安全的，性能好</li><li>Hashtable 线程安全基于 synchronized，综合性能差，已经被淘汰</li><li>ConcurrentHashMap 保证了线程安全，综合性能较好，不止线程安全，而且效率高，性能好</li></ul><p>集合对比：</p><ol><li>Hashtable 继承 Dictionary 类，HashMap、ConcurrentHashMap 继承 AbstractMap，均实现 Map 接口</li><li>Hashtable 底层是数组 + 链表，JDK8 以后 HashMap 和 ConcurrentHashMap 底层是数组 + 链表 + 红黑树</li><li>HashMap 线程非安全，Hashtable 线程安全，Hashtable 的方法都加了 synchronized 关来确保线程同步</li><li>ConcurrentHashMap、Hashtable <strong>不允许 null 值</strong>，HashMap 允许 null 值</li><li>ConcurrentHashMap、HashMap 的初始容量为 16，Hashtable 初始容量为11，填充因子默认都是 0.75，两种 Map 扩容是当前容量翻倍：capacity * 2，Hashtable 扩容时是容量翻倍 + 1：capacity*2 + 1</li></ol><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20230217153735934.png" alt="image-20230217153735934"></p><h4 id="工作步骤："><a href="#工作步骤：" class="headerlink" title="工作步骤："></a>工作步骤：</h4><ol><li><p>初始化，使用 cas 来保证并发安全，懒惰初始化 table</p></li><li><p>树化，当 table.length &lt; 64 时，先尝试扩容，超过 64 时，并且 bin.length &gt; 8 时，会将<strong>链表树化</strong>，树化过程会用 synchronized 锁住链表头</p><p>说明：锁住某个槽位的对象头，是一种很好的<strong>细粒度的加锁</strong>方式，类似 MySQL 中的行锁</p></li><li><p>put，如果该 bin 尚未创建，只需要使用 cas 创建 bin；如果已经有了，锁住链表头进行后续 put 操作，元素添加至 bin 的尾部</p></li><li><p>get，无锁操作仅需要保证可见性，扩容过程中 get 操作拿到的是 ForwardingNode 会让 get 操作在新 table 进行搜索</p></li><li><p>扩容，扩容时以 bin 为单位进行，需要对 bin 进行 synchronized，但这时其它竞争线程也不是无事可做，它们会帮助把其它 bin 进行扩容</p></li><li><p>size，元素个数保存在 baseCount 中，并发时的个数变动保存在 CounterCell[] 当中，最后统计数量时累加</p></li></ol><pre><code class="java">//需求：多个线程同时往HashMap容器中存入数据会出现安全问题public class ConcurrentHashMapDemo&#123;    public static Map&lt;String,String&gt; map = new ConcurrentHashMap();        public static void main(String[] args)&#123;        new AddMapDataThread().start();        new AddMapDataThread().start();                Thread.sleep(1000 * 5);//休息5秒，确保两个线程执行完毕        System.out.println(&quot;Map大小：&quot; + map.size());//20万    &#125;&#125;public class AddMapDataThread extends Thread&#123;    @Override    public void run() &#123;        for(int i = 0 ; i &lt; 1000000 ; i++ )&#123;            ConcurrentHashMapDemo.map.put(&quot;键：&quot;+i , &quot;值&quot;+i);        &#125;    &#125;&#125;</code></pre><h5 id="并发死链"><a href="#并发死链" class="headerlink" title="并发死链"></a>并发死链</h5><p>JDK1.7 的 HashMap 采用的头插法（拉链法）进行节点的添加，HashMap 的扩容长度为原来的 2 倍</p><p>resize() 中节点（Entry）转移的源代码：</p><pre><code class="java">void transfer(Entry[] newTable, boolean rehash) &#123;    int newCapacity = newTable.length;//得到新数组的长度       // 遍历整个数组对应下标下的链表，e代表一个节点    for (Entry&lt;K,V&gt; e : table) &#123;           // 当e == null时，则该链表遍历完了，继续遍历下一数组下标的链表         while(null != e) &#123;             // 先把e节点的下一节点存起来            Entry&lt;K,V&gt; next = e.next;             if (rehash) &#123;              //得到新的hash值                e.hash = null == e.key ? 0 : hash(e.key);              &#125;            // 在新数组下得到新的数组下标            int i = indexFor(e.hash, newCapacity);               // 将e的next指针指向新数组下标的位置            e.next = newTable[i];               // 将该数组下标的节点变为e节点            newTable[i] = e;             // 遍历链表的下一节点            e = next;                                           &#125;    &#125;&#125;</code></pre><p>JDK 8 虽然将扩容算法做了调整，改用了尾插法，但仍不意味着能够在多线程环境下能够安全扩容，还会出现其它问题（如扩容丢数据）</p><h4 id="成员属性-2"><a href="#成员属性-2" class="headerlink" title="成员属性"></a>成员属性</h4><h5 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h5><ul><li><p>存储数组：</p><pre><code class="java">transient volatile Node&lt;K,V&gt;[] table;</code></pre></li><li><p>散列表的长度：</p><pre><code class="java">private static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;// 最大长度private static final int DEFAULT_CAPACITY = 16;// 默认长度</code></pre></li><li><p>并发级别，JDK7 遗留下来，1.8 中不代表并发级别：</p><pre><code class="java">private static final int DEFAULT_CONCURRENCY_LEVEL = 16;</code></pre></li><li><p>负载因子，JDK1.8 的 ConcurrentHashMap 中是固定值：</p><pre><code class="java">private static final float LOAD_FACTOR = 0.75f;</code></pre></li><li><p>阈值：</p><pre><code class="java">static final int TREEIFY_THRESHOLD = 8;// 链表树化的阈值static final int UNTREEIFY_THRESHOLD = 6;// 红黑树转化为链表的阈值static final int MIN_TREEIFY_CAPACITY = 64;// 当数组长度达到64且某个桶位中的链表长度超过8，才会真正树化</code></pre></li><li><p>扩容相关：</p><pre><code class="java">private static final int MIN_TRANSFER_STRIDE = 16;// 线程迁移数据【最小步长】，控制线程迁移任务的最小区间private static int RESIZE_STAMP_BITS = 16;// 用来计算扩容时生成的【标识戳】private static final int MAX_RESIZERS = (1 &lt;&lt; (32 - RESIZE_STAMP_BITS)) - 1;// 65535-1并发扩容最多线程数private static final int RESIZE_STAMP_SHIFT = 32 - RESIZE_STAMP_BITS;// 扩容时使用</code></pre></li><li><p>节点哈希值：</p><pre><code class="java">static final int MOVED     = -1; // 表示当前节点是 FWD 节点static final int TREEBIN   = -2; // 表示当前节点已经树化，且当前节点为 TreeBin 对象static final int RESERVED  = -3; // 表示节点时临时节点static final int HASH_BITS = 0x7fffffff; // 正常节点的哈希值的可用的位数</code></pre></li><li><p>扩容过程：volatile 修饰保证多线程的可见性</p><pre><code class="java">// 扩容过程中，会将扩容中的新 table 赋值给 nextTable 保持引用，扩容结束之后，这里会被设置为 nullprivate transient volatile Node&lt;K,V&gt;[] nextTable;// 记录扩容进度，所有线程都要从 0 - transferIndex 中分配区间任务，简单说就是老表转移到哪了，索引从高到低转移private transient volatile int transferIndex;</code></pre></li><li><p>累加统计：</p><pre><code class="java">// LongAdder 中的 baseCount 未发生竞争时或者当前LongAdder处于加锁状态时，增量累到到 baseCount 中private transient volatile long baseCount;// LongAdder 中的 cellsBuzy，0 表示当前 LongAdder 对象无锁状态，1 表示当前 LongAdder 对象加锁状态private transient volatile int cellsBusy;// LongAdder 中的 cells 数组，private transient volatile CounterCell[] counterCells;</code></pre></li><li><p>控制变量：</p><p><strong>sizeCtl</strong> &lt; 0：</p><ul><li>-1 表示当前 table 正在初始化（有线程在创建 table 数组），当前线程需要自旋等待</li><li>其他负数表示当前 map 的 table 数组正在进行扩容，高 16 位表示扩容的标识戳；低 16 位表示 (1 + nThread) 当前参与并发扩容的线程数量 + 1</li></ul><p>sizeCtl &#x3D; 0，表示创建 table 数组时使用 DEFAULT_CAPACITY 为数组大小</p><p>sizeCtl &gt; 0：</p><ul><li>如果 table 未初始化，表示初始化大小</li><li>如果 table 已经初始化，表示下次扩容时的触发条件（阈值，元素个数，不是数组的长度）</li></ul><pre><code class="java">private transient volatile int sizeCtl;// volatile 保持可见性</code></pre></li></ul><h5 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h5><ul><li><p>Node 节点：</p><pre><code class="java">static class Node&lt;K,V&gt; implements Entry&lt;K,V&gt; &#123;    // 节点哈希值    final int hash;    final K key;    volatile V val;    // 单向链表    volatile Node&lt;K,V&gt; next;&#125;</code></pre></li><li><p>TreeBin 节点：</p><pre><code class="java"> static final class TreeBin&lt;K,V&gt; extends Node&lt;K,V&gt; &#123;     // 红黑树根节点     TreeNode&lt;K,V&gt; root;     // 链表的头节点     volatile TreeNode&lt;K,V&gt; first;     // 等待者线程     volatile Thread waiter;     volatile int lockState;     // 写锁状态 写锁是独占状态，以散列表来看，真正进入到 TreeBin 中的写线程同一时刻只有一个线程     static final int WRITER = 1;     // 等待者状态（写线程在等待），当 TreeBin 中有读线程目前正在读取数据时，写线程无法修改数据     static final int WAITER = 2;     // 读锁状态是共享，同一时刻可以有多个线程 同时进入到 TreeBi 对象中获取数据，每一个线程都给 lockState + 4     static final int READER = 4; &#125;</code></pre></li><li><p>TreeNode 节点：</p><pre><code class="java">static final class TreeNode&lt;K,V&gt; extends Node&lt;K,V&gt; &#123;    TreeNode&lt;K,V&gt; parent;  // red-black tree links    TreeNode&lt;K,V&gt; left;    TreeNode&lt;K,V&gt; right;    TreeNode&lt;K,V&gt; prev;   //双向链表    boolean red;&#125;</code></pre></li><li><p>ForwardingNode 节点：转移节点</p><pre><code class="java"> static final class ForwardingNode&lt;K,V&gt; extends Node&lt;K,V&gt; &#123;     // 持有扩容后新的哈希表的引用     final Node&lt;K,V&gt;[] nextTable;     ForwardingNode(Node&lt;K,V&gt;[] tab) &#123;         // ForwardingNode 节点的 hash 值设为 -1         super(MOVED, null, null, null);         this.nextTable = tab;     &#125; &#125;</code></pre></li></ul><h5 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h5><ul><li><p>变量：</p><pre><code class="java">// 表示sizeCtl属性在 ConcurrentHashMap 中内存偏移地址private static final long SIZECTL;// 表示transferIndex属性在 ConcurrentHashMap 中内存偏移地址private static final long TRANSFERINDEX;// 表示baseCount属性在 ConcurrentHashMap 中内存偏移地址private static final long BASECOUNT;// 表示cellsBusy属性在 ConcurrentHashMap 中内存偏移地址private static final long CELLSBUSY;// 表示cellValue属性在 CounterCell 中内存偏移地址private static final long CELLVALUE;// 表示数组第一个元素的偏移地址private static final long ABASE;// 用位移运算替代乘法private static final int ASHIFT;</code></pre></li><li><p>赋值方法：</p><pre><code class="java">// 表示数组单元所占用空间大小，scale 表示 Node[] 数组中每一个单元所占用空间大小，int 是 4 字节int scale = U.arrayIndexScale(ak);// 判断一个数是不是 2 的 n 次幂，比如 8：1000 &amp; 0111 = 0000if ((scale &amp; (scale - 1)) != 0)    throw new Error(&quot;data type scale not a power of two&quot;);// numberOfLeadingZeros(n)：返回当前数值转换为二进制后，从高位到低位开始统计，看有多少个0连续在一起// 8 → 1000 numberOfLeadingZeros(8) = 28// 4 → 100 numberOfLeadingZeros(4) = 29   int 值就是占4个字节ASHIFT = 31 - Integer.numberOfLeadingZeros(scale);// ASHIFT = 31 - 29 = 2 ，int 的大小就是 2 的 2 次方，获取次方数// ABASE + （5 &lt;&lt; ASHIFT） 用位移运算替代了乘法，获取 arr[5] 的值</code></pre></li></ul><hr><h4 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h4><ul><li><p>无参构造， 散列表结构延迟初始化，默认的数组大小是 16：</p><pre><code class="java">public ConcurrentHashMap() &#123;&#125;</code></pre></li><li><p>有参构造：</p><pre><code class="java">public ConcurrentHashMap(int initialCapacity) &#123;    // 指定容量初始化    if (initialCapacity &lt; 0) throw new IllegalArgumentException();    int cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; 1)) ?               MAXIMUM_CAPACITY :               // 假如传入的参数是 16，16 + 8 + 1 ，最后得到 32               // 传入 12， 12 + 6 + 1 = 19，最后得到 32，尽可能的大，与 HashMap不一样               tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; 1) + 1));    // sizeCtl &gt; 0，当目前 table 未初始化时，sizeCtl 表示初始化容量    this.sizeCtl = cap;&#125;</code></pre><pre><code class="java">private static final int tableSizeFor(int c) &#123;    int n = c - 1;    n |= n &gt;&gt;&gt; 1;    n |= n &gt;&gt;&gt; 2;    n |= n &gt;&gt;&gt; 4;    n |= n &gt;&gt;&gt; 8;    n |= n &gt;&gt;&gt; 16;    return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;&#125;</code></pre><p>HashMap 部分详解了该函数，核心思想就是<strong>把最高位是 1 的位以及右边的位全部置 1</strong>，结果加 1 后就是 2 的 n 次幂</p></li><li><p>多个参数构造方法：</p><pre><code class="java">public ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel) &#123;    if (!(loadFactor &gt; 0.0f) || initialCapacity &lt; 0 || concurrencyLevel &lt;= 0)        throw new IllegalArgumentException();    // 初始容量小于并发级别    if (initialCapacity &lt; concurrencyLevel)          // 把并发级别赋值给初始容量        initialCapacity = concurrencyLevel;     // loadFactor 默认是 0.75    long size = (long)(1.0 + (long)initialCapacity / loadFactor);    int cap = (size &gt;= (long)MAXIMUM_CAPACITY) ?        MAXIMUM_CAPACITY : tableSizeFor((int)size);    // sizeCtl &gt; 0，当目前 table 未初始化时，sizeCtl 表示初始化容量    this.sizeCtl = cap;&#125;</code></pre></li><li><p>集合构造方法：</p><pre><code class="java">public ConcurrentHashMap(Map&lt;? extends K, ? extends V&gt; m) &#123;    this.sizeCtl = DEFAULT_CAPACITY;// 默认16    putAll(m);&#125;public void putAll(Map&lt;? extends K, ? extends V&gt; m) &#123;    // 尝试触发扩容    tryPresize(m.size());    for (Entry&lt;? extends K, ? extends V&gt; e : m.entrySet())        putVal(e.getKey(), e.getValue(), false);&#125;</code></pre><pre><code class="java">private final void tryPresize(int size) &#123;    // 扩容为大于 2 倍的最小的 2 的 n 次幂    int c = (size &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; 1)) ? MAXIMUM_CAPACITY :        tableSizeFor(size + (size &gt;&gt;&gt; 1) + 1);    int sc;    while ((sc = sizeCtl) &gt;= 0) &#123;        Node&lt;K,V&gt;[] tab = table; int n;        // 数组还未初始化，【一般是调用集合构造方法才会成立，put 后调用该方法都是不成立的】        if (tab == null || (n = tab.length) == 0) &#123;            n = (sc &gt; c) ? sc : c;            if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) &#123;                try &#123;                    if (table == tab) &#123;                        Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n];                        table = nt;                        sc = n - (n &gt;&gt;&gt; 2);// 扩容阈值：n - 1/4 n                    &#125;                &#125; finally &#123;                    sizeCtl = sc;// 扩容阈值赋值给sizeCtl                &#125;            &#125;        &#125;        // 未达到扩容阈值或者数组长度已经大于最大长度        else if (c &lt;= sc || n &gt;= MAXIMUM_CAPACITY)            break;        // 与 addCount 逻辑相同        else if (tab == table) &#123;                   &#125;    &#125;&#125;</code></pre></li></ul><hr><h4 id="成员方法-1"><a href="#成员方法-1" class="headerlink" title="成员方法"></a>成员方法</h4><h5 id="数据访存"><a href="#数据访存" class="headerlink" title="数据访存"></a>数据访存</h5><ul><li><p>tabAt()：获取数组某个槽位的<strong>头节点</strong>，类似于数组中的直接寻址 arr[i]</p><pre><code class="java">// i 是数组索引static final &lt;K,V&gt; Node&lt;K,V&gt; tabAt(Node&lt;K,V&gt;[] tab, int i) &#123;    // (i &lt;&lt; ASHIFT) + ABASE == ABASE + i * 4 （一个 int 占 4 个字节），这就相当于寻址，替代了乘法    return (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((long)i &lt;&lt; ASHIFT) + ABASE);&#125;</code></pre></li><li><p>casTabAt()：指定数组索引位置修改原值为指定的值</p><pre><code class="java">static final &lt;K,V&gt; boolean casTabAt(Node&lt;K,V&gt;[] tab, int i, Node&lt;K,V&gt; c, Node&lt;K,V&gt; v) &#123;    return U.compareAndSwapObject(tab, ((long)i &lt;&lt; ASHIFT) + ABASE, c, v);&#125;</code></pre></li><li><p>setTabAt()：指定数组索引位置设置值</p><pre><code class="java">static final &lt;K,V&gt; void setTabAt(Node&lt;K,V&gt;[] tab, int i, Node&lt;K,V&gt; v) &#123;    U.putObjectVolatile(tab, ((long)i &lt;&lt; ASHIFT) + ABASE, v);&#125;</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> java并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git常用命令与github</title>
      <link href="/2022/01/01/git/"/>
      <url>/2022/01/01/git/</url>
      
        <content type="html"><![CDATA[<h2 id="git常用命令"><a href="#git常用命令" class="headerlink" title="git常用命令"></a>git常用命令</h2><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20220518102346259.png"></p><h2 id="初始化本地库"><a href="#初始化本地库" class="headerlink" title="初始化本地库"></a>初始化本地库</h2><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20220518102546885.png"></p><h3 id="查看本地库状态"><a href="#查看本地库状态" class="headerlink" title="查看本地库状态"></a>查看本地库状态</h3><p>git status</p><h3 id="新增文件"><a href="#新增文件" class="headerlink" title="新增文件"></a>新增文件</h3><p>vim  +文件名.xx</p><h3 id="添加暂存区"><a href="#添加暂存区" class="headerlink" title="添加暂存区"></a>添加暂存区</h3><p>git add 文件名</p><h3 id="提交本地库"><a href="#提交本地库" class="headerlink" title="提交本地库"></a>提交本地库</h3><p>git commit -m “日志信息” 文件名</p><h3 id="修改文件"><a href="#修改文件" class="headerlink" title="修改文件"></a>修改文件</h3><p>使用的是vim+linux命令,vim + 文件名进入该目录下的文件,</p><p>命令 i 为进入编辑状态</p><p>esc退出编辑状态</p><p>shift + : 输入wq,为退出并保存</p><p>cat +文件名:查看文件内容</p><h2 id="历史版本"><a href="#历史版本" class="headerlink" title="历史版本"></a>历史版本</h2><h3 id="查看版本信息"><a href="#查看版本信息" class="headerlink" title="查看版本信息:"></a>查看版本信息:</h3><p>git reflog 查看简单版本信息</p><p>git log 查看详细版本信息</p><h3 id="版本穿梭"><a href="#版本穿梭" class="headerlink" title="版本穿梭:"></a>版本穿梭:</h3><p>git reset –hard +版本号      将当前指针指向的版本转换为指向该版本号代表的版本,可以向前也可以向后</p><h2 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h2><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20220518112628596.png" alt="image-20220518112628596"></p><h3 id="什么是分支"><a href="#什么是分支" class="headerlink" title="什么是分支:"></a>什么是分支:</h3><p>​在版本控制过程中，同时推进多个任务，为每个任务，我们就可以创建每个任务的单独</p><p>分支。使用分支意味着程序员可以把自己的工作从开发主线上分离开来，开发自己分支的时</p><p>候，不会影响主线分支的运行。对于初学者而言，分支可以简单理解为副本，一个分支就是</p><p>一个单独的副本。（分支底层其实也是指针的引用）</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20220518114305584.png" alt="image-20220518114305584"></p><h3 id="分支的好处"><a href="#分支的好处" class="headerlink" title="分支的好处"></a>分支的好处</h3><p>同时并行推进多个功能开发，提高开发效率。</p><p>各个分支在开发过程中，如果某一个分支开发失败，不会对其他分支有任何影响。失败</p><p>的分支删除重新开始即可.</p><h3 id="分支的操作"><a href="#分支的操作" class="headerlink" title="分支的操作"></a>分支的操作</h3><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20220518114501485.png" alt="image-20220518114501485"></p><h3 id="分支合并"><a href="#分支合并" class="headerlink" title="分支合并"></a>分支合并</h3><p>git merge 分支名     将该分支名代表的分支合并到当前分支</p><h3 id="产生冲突"><a href="#产生冲突" class="headerlink" title="产生冲突"></a>产生冲突</h3><p>冲突产生的原因：</p><p>合并分支时，两个分支在<strong>同一个文件的同一个位置</strong>有两套完全不同的修改。Git 无法替</p><p>我们决定使用哪一个。必须<strong>人为决定</strong>新代码内容。</p><p>冲突产生的表现：后面状态为 MERGING.</p><h3 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h3><p>需要手动到vim下选择需要保存的内容,保存后需要添加到暂存区,再进行提交,注意提交的时候不能到文件名,不然会失败</p><h2 id="Git-Github"><a href="#Git-Github" class="headerlink" title="Git_Github"></a>Git_Github</h2><h3 id="创建远程库别名-首先要创建远程库github或gitee"><a href="#创建远程库别名-首先要创建远程库github或gitee" class="headerlink" title="创建远程库别名(首先要创建远程库github或gitee)"></a>创建远程库别名(首先要创建远程库github或gitee)</h3><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20220518181623725.png" alt="image-20220518181623725"></p><h3 id="推送本地库到远程库"><a href="#推送本地库到远程库" class="headerlink" title="推送本地库到远程库"></a>推送本地库到远程库</h3><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20220518182642662.png" alt="image-20220518182642662"></p><h3 id="克隆远程仓库到本地-非仓库主人"><a href="#克隆远程仓库到本地-非仓库主人" class="headerlink" title="克隆远程仓库到本地(非仓库主人)"></a>克隆远程仓库到本地(非仓库主人)</h3><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20220518184246687.png" alt="image-20220518184246687"></p><p>可以直接克隆不需要账号.并且clone能再拉取代码的同时,初始化本地库与创建别名,但是自动取的别名叫origin</p><h3 id="邀请加入团队"><a href="#邀请加入团队" class="headerlink" title="邀请加入团队"></a>邀请加入团队</h3><p>从远程库settings中设置即可</p><p>拉取远程库内容:</p><p>基本语法</p><p>git pull 远程库地址别名 远程分支名</p><h3 id="跨团队协作"><a href="#跨团队协作" class="headerlink" title="跨团队协作"></a>跨团队协作</h3><p>1.发送地址</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20220519115503515.png" alt="image-20220519115503515"></p><p>2.另外一个团队点击链接,fork到本地库,编辑,提交</p><p>3.编辑完毕后,填写描述信息,并提交</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20220519115632527.png" alt="image-20220519115632527"></p><p>4.点击pull request</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20220519115730194.png" alt="image-20220519115730194"></p><p>create pull request</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20220519115814839.png" alt="image-20220519115814839"></p><p>5.原代码团队收到pull request</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20220519115856747.png" alt="image-20220519115856747"></p><p>6.若代码没有问题,则合并代码</p><h3 id="ssh免密登录"><a href="#ssh免密登录" class="headerlink" title="ssh免密登录"></a>ssh免密登录</h3><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20220519121647304.png" alt="image-20220519121647304"></p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20220519121713435.png" alt="image-20220519121713435"></p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20220519121746263.png" alt="image-20220519121746263"></p><p>复制 id_rsa.pub 文件内容，登录 GitHub，点击用户头像→Settings→SSH and GPG keys</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20220519121848526.png" alt="image-20220519121848526"></p><h2 id="idea集成git"><a href="#idea集成git" class="headerlink" title="idea集成git"></a>idea集成git</h2><h3 id="初始化本地库-1"><a href="#初始化本地库-1" class="headerlink" title="初始化本地库"></a>初始化本地库</h3><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20220519125002193.png" alt="image-20220519125002193"></p><h3 id="添加到暂存区"><a href="#添加到暂存区" class="headerlink" title="添加到暂存区"></a>添加到暂存区</h3><p>项目目录或模块-&gt;git-&gt;add</p><h3 id="提交到本地库"><a href="#提交到本地库" class="headerlink" title="提交到本地库"></a>提交到本地库</h3><p>项目目录或模块-&gt;git-&gt;Commit Directory</p>]]></content>
      
      
      <categories>
          
          <category> 版本控制工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 版本控制工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java容器</title>
      <link href="/2021/12/16/java-di-ceng-rong-qi-de-shi-xian-yuan-li/"/>
      <url>/2021/12/16/java-di-ceng-rong-qi-de-shi-xian-yuan-li/</url>
      
        <content type="html"><![CDATA[<h1 id="JDK中栈的底层实现"><a href="#JDK中栈的底层实现" class="headerlink" title="JDK中栈的底层实现:"></a>JDK中栈的底层实现:</h1><p>java底层Stack是继承Vector的,也就是说是直接实现Collection的(满足先进后出)<br><img src="https://gitee.com/DylanToT99/images/raw/master/images/1667285842751-ae9a32b8-eceb-454e-a90d-7d47d0d19299.png" alt="image.png"><br>创建一个空栈，这里我们不禁有一个疑问，既然它继承了Vector，它的父类是有一个默认容量的，为10，那么Stack的构造方法只有一个，且没有默认大小，那么它是怎么进行扩容的呢，这时候我们去查看它的push()方法，Stack直接调用了Vector类的addElement(E item)方法</p><pre><code class="java">public E push(E item) &#123;        addElement(item);         return item;    &#125;</code></pre><pre><code class="java"> private void add(E e, Object[] elementData, int s) &#123;        if (s == elementData.length)            elementData = grow();        elementData[s] = e;        elementCount = s + 1;    &#125;</code></pre><pre><code class="java"> private Object[] grow(int minCapacity) &#123;        int oldCapacity = elementData.length;        int newCapacity = ArraysSupport.newLength(oldCapacity,                minCapacity - oldCapacity, /* minimum growth */                capacityIncrement &gt; 0 ? capacityIncrement : oldCapacity                                           /* preferred growth */);        return elementData = Arrays.copyOf(elementData, newCapacity);    &#125;</code></pre><h1 id="JAVA队列（-Queue-及实现类（双端队列）"><a href="#JAVA队列（-Queue-及实现类（双端队列）" class="headerlink" title="JAVA队列（ Queue )及实现类（双端队列）"></a>JAVA队列（ Queue )及实现类（双端队列）</h1><h2 id="队列的定义"><a href="#队列的定义" class="headerlink" title="队列的定义:"></a>队列的定义:</h2><pre><code> 队列是一种特殊的[线性](https://so.csdn.net/so/search?q=%E7%BA%BF%E6%80%A7&amp;spm=1001.2101.3001.7020)表，**遵循先入先出、后入后出的基本原则**，一般来说，它只允许在表的前端进行删除操作，而在表的后端进行插入操作，但是java的某些队列运行在任何地方插入删除；比如我们常用的 LinkedList 集合，它实现了Queue 接口，因此，我们可以理解为 LinkedList 就是一个队列；</code></pre><h2 id="java队列特性"><a href="#java队列特性" class="headerlink" title="java队列特性:"></a>java队列特性:</h2><p>队列主要分为阻塞和非阻塞，有界和无界、单向链表和双向链表之分；</p><h3 id="阻塞和非阻塞"><a href="#阻塞和非阻塞" class="headerlink" title="阻塞和非阻塞"></a><strong>阻塞和非阻塞</strong></h3><h4 id="1-阻塞队列"><a href="#1-阻塞队列" class="headerlink" title="1.阻塞队列:"></a>1.阻塞队列:</h4><p>入列(添加元素)时，如果元素数量超过队列总数，会进行等待（阻塞），待队列的中的元素出列后，元素数量未超过队列总数时，就会解除阻塞状态，进而可以继续入列；<br>          出列(删除元素)时，如果队列为空的情况下，也会进行等待（阻塞），待队列有值的时候即会解除阻塞状态，进而继续出列；<br>          阻塞队列的好处是可以防止队列容器溢出；只要满了就会进行阻塞等待；也就不存在溢出的情况；<br>          只要是阻塞队列，都是<strong>线程安全</strong>的；</p><h4 id="2-非阻塞队列"><a href="#2-非阻塞队列" class="headerlink" title="2.非阻塞队列"></a>2.非阻塞队列</h4><p>不管出列还是入列，都不会进行阻塞，<br>    入列时，如果元素数量超过队列总数，则会抛出异常，<br>    出列时，如果队列为空，则取出空值；<br>一般情况下，非阻塞式队列使用的比较少，一般都用阻塞式的对象比较多；阻塞和非阻塞队列在使用上的最大区别就是阻塞队列提供了以下2个方法：</p><ul><li><pre><code>出队阻塞方法 ：** take()**</code></pre></li><li><pre><code>入队阻塞方法 ：** put()**</code></pre></li></ul><h3 id="有界和无界"><a href="#有界和无界" class="headerlink" title="有界和无界"></a>有界和无界</h3><p>  <strong>有界</strong>：有界限，大小长度受限制<br> ** 无界**：无限大小，其实说是无限大小，其实是有界限的，只不过超过界限时就会进行扩容，就像ArrayList 一样，在内部动态扩容</p><h3 id="单向链表和双向链表"><a href="#单向链表和双向链表" class="headerlink" title="单向链表和双向链表"></a><strong>单向链表和双向链表</strong></h3><p>**单向链表 ： **每个元素中除了元素本身之外，还存储一个指针，这个指针指向下一个元素；<br><img src="https://gitee.com/DylanToT99/images/raw/master/images/1667288035831-d2d967c7-1d62-46d6-86cb-b12d83c4480f.jpeg" alt="队列.jpg"><br><strong>双向链表 ：</strong>除了元素本身之外，还有两个指针，一个指针指向前一个元素的地址，另一个指针指向后一个元素的地址；<br><img src="https://gitee.com/DylanToT99/images/raw/master/images/1667288091715-d3af9a22-9b97-4d51-bf27-03b3a32d144d.png" alt="image.png"></p><h1 id="Java-队列接口继承图"><a href="#Java-队列接口继承图" class="headerlink" title="Java 队列接口继承图"></a><strong>Java 队列接口继承图</strong></h1><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/1667288223948-6cf00d2c-a195-43f7-a99b-f8ca6c594304.png" alt="image.png"></p><h2 id="队列的常用方法"><a href="#队列的常用方法" class="headerlink" title="队列的常用方法"></a>队列的常用方法</h2><ul><li><strong>add</strong>        增加一个元索                     如果队列已满，则抛出一个IIIegaISlabEepeplian异常</li><li><strong>remove</strong>   移除并返回队列头部的元素    如果队列为空，则抛出一个NoSuchElementException异常</li><li>** element  **返回队列头部的元素             如果队列为空，则抛出一个NoSuchElementException异常</li><li>** offer**       添加一个元素并返回true       如果队列已满，则返回false</li><li>** poll**         移除并返问队列头部的元素    如果队列为空，则返回null</li><li>** peek**       返回队列头部的元素             如果队列为空，则返回null</li><li>** put**         添加一个元素                      如果队列满，则阻塞</li><li>** take**        移除并返回队列头部的元素     如果队列为空，则阻塞</li><li>**drainTo(list)   **一次性取出队列所有元素</li></ul><p>**知识点： remove、element、offer 、poll、peek 其实是属于Queue接口。 **</p><h1 id="双端队列："><a href="#双端队列：" class="headerlink" title="双端队列："></a><strong>双端队列：</strong></h1><p><strong>双端队列既可以当作队列也可以当作栈！方法中可以先入先出也可以先入后出，因为是双端的，所以栈我们不推荐使用Vector的实现类Stack，推荐使用双端队列ArrayDeque来做栈。</strong></p><h3 id="Deque———ArrayDeque类详解"><a href="#Deque———ArrayDeque类详解" class="headerlink" title="Deque———ArrayDeque类详解"></a>Deque———ArrayDeque类详解</h3><table><thead><tr><th><strong>类型</strong></th><th><strong>方法</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td><strong>添加元素</strong></td><td>public void addFirst(E e)</td><td>在数组前面添加元素</td></tr><tr><td></td><td>public void addLast(E e)</td><td>在数组后面添加元素</td></tr><tr><td></td><td>public boolean offerFirst(E e)</td><td>在数组前面添加元素，并返回是否添加成功</td></tr><tr><td></td><td>public boolean offerLast</td><td>在数组后面添加元素，并返回是否添加成功</td></tr><tr><td><strong>删除元素</strong></td><td>public E pollFirst()</td><td>删除第一个元素，并返回删除元素的值，如果元素为null，将返回null</td></tr><tr><td></td><td>public E removeFirst()</td><td>删除第一个元素，并返回删除元素的值,如果元素为null，将抛出异常</td></tr><tr><td></td><td>public E pollLast()</td><td>删除最后一个元素，并返回删除元素的值，如果为null，将返回null</td></tr><tr><td></td><td>public E removeLast()</td><td>删除最后一个元素，并返回删除元素的值，如果为null，将抛出异常</td></tr><tr><td></td><td>public boolean removeFirstOccurrence(Object o)</td><td>删除第一次出现的指定元素</td></tr><tr><td></td><td>public boolean removeLastOccurrence(Object o)</td><td>删除最后一次出现的指定元素</td></tr><tr><td><strong>获取元素</strong></td><td>public E getFirst()</td><td>获取第一个元素,如果没有将抛出异常</td></tr><tr><td></td><td>public E getLast()</td><td>获取最后一个元素，如果没有将抛出异常</td></tr><tr><td><strong>队列操作</strong></td><td>public boolean add(E e)</td><td>在队列尾部添加一个元素</td></tr><tr><td></td><td>public boolean offer(E e)</td><td>在队列尾部添加一个元素，并返回是否成功</td></tr><tr><td></td><td>public E remove()</td><td>删除队列中第一个元素，并返回该元素的值，如果元素为null，将抛出异常(其实底层调用的是removeFirst())</td></tr><tr><td></td><td>public E poll()</td><td>删除队列中第一个元素，并返回该元素的值,如果元素为null，将返回null(其实调用的是pollFirst())</td></tr><tr><td></td><td>public E element()</td><td>获取第一个元素，如果没有将抛出异常</td></tr><tr><td></td><td>public E peek()</td><td>获取第一个元素，如果返回null</td></tr><tr><td><strong>栈操作</strong></td><td>public void push(E e)</td><td>栈顶添加一个元素</td></tr><tr><td></td><td>public E pop()</td><td>移除栈顶元素,如果栈顶没有元素将抛出异常</td></tr><tr><td><strong>其他</strong></td><td>public int size()</td><td>获取队列中元素个数</td></tr><tr><td></td><td>public boolean isEmpty()</td><td>判断队列是否为空</td></tr><tr><td></td><td>public Iterator iterator()</td><td>迭代器，从前向后迭代</td></tr><tr><td></td><td>public Iterator descendingIterator()</td><td>迭代器，从后向前迭代</td></tr><tr><td></td><td>public boolean contains(Object o)</td><td>判断队列中是否存在该元素</td></tr><tr><td></td><td>public Object[] toArray()</td><td>转成数组</td></tr><tr><td></td><td>public T[] toArray(T[] a)</td><td>转成a数组常</td></tr><tr><td></td><td>public void clear()</td><td>清空队列</td></tr><tr><td></td><td>public ArrayDeque clone()</td><td>克隆(复制)一个新的队列</td></tr></tbody></table><h3 id="ArrayDeque类是-双端队列的线性实现类。"><a href="#ArrayDeque类是-双端队列的线性实现类。" class="headerlink" title="ArrayDeque类是 双端队列的线性实现类。"></a>ArrayDeque类是 双端队列的线性实现类。</h3><p><strong>具有以下特征</strong>：<br>☞ ArrayDeque是采用数组方式实现的双端队列。<br>☞ ArrayDeque的出队入队是通过头尾指针循环，利用数组实现的。<br>☞ ArrayDeque容量不足时是会扩容的，每次扩容容量增加一倍。<br>☞ ArrayDeque可以直接作为栈使用。当用作栈时，性能优于Stack，当用于队列时，性能优于LinkedList。<br>☞ 无容量大小限制，容量按需增长。<br>☞ 非线程安全队列，无同步策略，不支持多线程安全访问。<br>☞ 具有fail-fast特性，不能存储null值，支持双向迭代器遍历。<br>ArrayDeque的实现结构图如下所示:<br><img src="https://gitee.com/DylanToT99/images/raw/master/images/1667288612982-6f770e81-0cd2-4537-bc93-57ab1c6e629a.png" alt="image.png"></p><h1 id="优先级队列-PriorityQueue"><a href="#优先级队列-PriorityQueue" class="headerlink" title="优先级队列(PriorityQueue)"></a><strong>优先级队列(PriorityQueue)</strong></h1><p>Java的优先级队列: 一个基于优先级堆的无界优先级队列.</p><p>继承关系:</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221108140434039.png" alt="image-20221108140434039"></p><p>优先级队列的元素进行排序，根据他们的自然排序，或通过设置在队列 Comparator 排序规则，这取决于使用哪个构造函数。</p><p>构造方法如下表:</p><table><thead><tr><th><strong>方法</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>PriorityQueue()</strong></td><td>创建一个默认的初始容量 <code>PriorityQueue</code>（11），命令其元素按其自然排序（<strong>从小到大，默认出来就是小根堆</strong>）</td></tr><tr><td><strong>PriorityQueue(Collection&lt;? extends E&gt; c)</strong></td><td>创建一个 <code>PriorityQueue</code>包含在指定集合的元素（c的元素都被放置到优先级队列集合）。</td></tr><tr><td><strong>PriorityQueue(Comparator&lt;? super E&gt; comparator)</strong></td><td>创建一个默认的初始容量和它的元素是按指定的比较器 <code>PriorityQueue</code>。</td></tr><tr><td><strong>PriorityQueue(int initialCapacity)</strong></td><td>创建一个具有指定的初始容量，命令其元素按其自然排序<code>PriorityQueue</code>。</td></tr><tr><td><strong>PriorityQueue(int initialCapacity, Comparator&lt;? super E&gt; comparator)</strong></td><td>创建一个具有指定的初始容量，命令其元素根据指定的比较器 <code>PriorityQueue</code>。</td></tr><tr><td><strong>PriorityQueue(PriorityQueue&lt;? extends E&gt; c)</strong></td><td>创建一个 <code>PriorityQueue</code>包含指定的优先级队列中的元素。</td></tr><tr><td><strong>PriorityQueue(SortedSet&lt;? extends E&gt; c)</strong></td><td>创建一个 <code>PriorityQueue</code>含有指定排序的集合中的元素。</td></tr></tbody></table><h2 id="基本规则"><a href="#基本规则" class="headerlink" title="基本规则:"></a>基本规则:</h2><p>一个优先级队列不允许有null元素,且依靠自然排序的优先级队列也不允许插入不可比较对象(若插入则会抛出ClassCastException)</p><p><strong>此队列的头相对于指定的排序是最小的元素</strong>(若未指定排序规则,则默认是小顶堆).如果多个元素被绑定为最小值，头部是这些元素的一个，关系被任意地打破。队列检索操作poll，remove，peek，和element可以访问在队列的头元素。</p><p><strong>优先队列是无界的</strong>，但有一个内部容量管理用于存储在队列中的元素的数组的大小。它总是至少和队列大小一样大。当元素被添加到优先级队列中时，它的容量会自动增长。</p><p><strong>这个类和它的迭代器实现所有的可选方法的Collection和Iterator接口。</strong>方法iterator()提供的迭代器不能保证遍历优先级队列的元素在任何特定的顺序。如果你需要有序遍历，考虑使用Arrays.sort(pq.toArray())。</p><p>注意：此实现不同步。多线程不能访问PriorityQueue实例同时如果线程修改队列。相反，使用<strong>线程安全类PriorityBlockingQueue。</strong></p><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a><strong>时间复杂度</strong></h2><ul><li>该类实现了<code>O（log(n)）</code>的方法（如：offer、poll、remove()和add方法）；</li><li>对于remove(Object)和contains(Object)方法是线性时间<code>O（n）</code>；</li><li>对检索方法的时间为常数<code>O（1）</code>（如：peek，element，和size）</li></ul><h2 id="方法api"><a href="#方法api" class="headerlink" title="方法api"></a>方法api</h2><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221108145750162.png" alt="image-20221108145750162"></p><p>优先级队列本质还是队列, 是java实现堆排序的api接口, 我们可以直接调用.</p><p>如上图PriorityQueue的继承关系，实现的也是Queue接口，那么他也可以使用队列的方法.除此之外其还有额外的方法:</p><p><img src="E:/After2022/Blog/myblog/source/_posts/Java%E5%BA%95%E5%B1%82%E5%AE%B9%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.assets/image-20230323104639181.png" alt="image-20230323104639181"></p><h2 id="排序规则"><a href="#排序规则" class="headerlink" title="排序规则:"></a>排序规则:</h2><p>若想自定义排序或者实现大顶堆, 则需要重写比较器:</p><p>第一种：Comparator<br>重写compare方法:</p><pre><code class="java">PriorityQueue&lt;Integer&gt; bigHeap=new PriorityQueue&lt;&gt;(new Comparator&lt;Integer&gt;() &#123;    @Override    public int compare(Integer o1, Integer o2) &#123;        return o2-o1;    &#125;&#125;);</code></pre><p>第二种：lambda表达式<br>借助lambda表达式实现：</p><pre><code class="java">Queue&lt;Integer&gt; bigHeap = new PriorityQueue&lt;&gt;((o1, o2) -&gt; o2 - o1);</code></pre><p>若需要自定义排序规则:只需要改变构造器的Comparator对象即可</p><blockquote><h3 id="compare返回值"><a href="#compare返回值" class="headerlink" title="compare返回值:"></a>compare返回值:</h3><ul><li>如果返回值为负数，传入的第一个参数排在前,第二个参数排在后</li><li>如果返回值为0，表示当前存入的元素跟集合中元素重复了，不存</li><li>如果返回值为正数，传入的第一个参数排在后,第二个参数排在前</li><li>总结: 第一个参数减第二个代表升序, 第二个减第一个就是降序</li></ul></blockquote><h2 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理:"></a>底层原理:</h2><p>通过jdk17源码:可以看到</p><p>若我们传入了自定义的Comparator对象, 程序会调用该构造函数:</p><pre><code class="java">public PriorityQueue(Comparator&lt;? super E&gt; comparator) &#123;        this(DEFAULT_INITIAL_CAPACITY, comparator);    &#125;</code></pre><p>传入默认的容器大小(11),与自定义的comparator,接下来调用:</p><pre><code class="java">public PriorityQueue(int initialCapacity,                         Comparator&lt;? super E&gt; comparator) &#123;        // Note: This restriction of at least one is not actually needed,        // but continues for 1.5 compatibility        if (initialCapacity &lt; 1)            throw new IllegalArgumentException();        this.queue = new Object[initialCapacity];        this.comparator = comparator;    &#125;</code></pre><p>将队列初始化为默认大小为11的Object数组, 为比较器赋值. 若此时执行了add()方法会调用offer:</p><pre><code class="java">public boolean add(E e) &#123;        return offer(e);    &#125;</code></pre><p>offer(E e):</p><pre><code class="java">public boolean offer(E e) &#123;        if (e == null)            throw new NullPointerException();        modCount++;        int i = size;        if (i &gt;= queue.length)            grow(i + 1);        siftUp(i, e);        size = i + 1;        return true; &#125;</code></pre><p>默认的大小+1, 若此时队列的大小大于队列的容量, 则执行grow()函数,自动提升容量:</p><p>grow()方法的原理:</p><pre><code class="java"> private void grow(int minCapacity) &#123;        int oldCapacity = queue.length;        // Double size if small; else grow by 50%        int newCapacity = ArraysSupport.newLength(oldCapacity,                minCapacity - oldCapacity, /* minimum growth */                oldCapacity &lt; 64 ? oldCapacity + 2 : oldCapacity &gt;&gt; 1                                           /* preferred growth */);        queue = Arrays.copyOf(queue, newCapacity);    &#125;</code></pre><p>若原容量小于64, 则直接将容量提升为2*oldCapacity+2(该容量要小于Integer.MAX_VALUE-8,细节在ArraysSupport类中),否则将容量扩大百分之50.</p><p>容量处理完之后执行siftUp方法:</p><pre><code class="java">private void siftUp(int k, E x) &#123;    if (comparator != null)        siftUpUsingComparator(k, x, queue, comparator);//判断是否传入自定义的comparator    else        siftUpComparable(k, x, queue);&#125;</code></pre><p>调用siftUpUsingComparator()方法:</p><pre><code class="java">private static &lt;T&gt; void siftUpUsingComparator(        int k, T x, Object[] es, Comparator&lt;? super T&gt; cmp) &#123;        while (k &gt; 0) &#123;            int parent = (k - 1) &gt;&gt;&gt; 1;            Object e = es[parent];            if (cmp.compare(x, (T) e) &gt;= 0)                break;            es[k] = e;            k = parent;        &#125;        es[k] = x;    &#125;</code></pre><p>根据自定义的比较器,向上提升需要插入的元素X,以大顶堆(完全二叉树)为例: </p><p>首先该方法获取最底层子树的父节点所在的位置(  int parent &#x3D; (k - 1) &gt;&gt;&gt; 1;),根据比较器判断x与父节点的权重大小,若x比e大,则compare返回负值, 将插入位置k的值赋值为e, 再将父节点位置的下标赋给k,循环, 直到找到父节点的值大于x的值的位置, 再将x插到k位置.</p><blockquote><p>持续更新…………..</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mybatis功能实战</title>
      <link href="/2021/11/15/mybatis-bi-ji/"/>
      <url>/2021/11/15/mybatis-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="Mybatis简介"><a href="#Mybatis简介" class="headerlink" title="Mybatis简介"></a>Mybatis简介</h1><h2 id="MyBatis历史"><a href="#MyBatis历史" class="headerlink" title="MyBatis历史"></a>MyBatis历史</h2><ul><li>MyBatis最初是Apache的一个开源项目iBatis, 2010年6月这个项目由Apache Software Foundation迁移到了Google Code。随着开发团队转投Google Code旗下，iBatis3.x正式更名为MyBatis。代码于2013年11月迁移到Github</li><li>iBatis一词来源于“internet”和“abatis”的组合，是一个基于Java的持久层框架。iBatis提供的持久层框架包括SQL Maps和Data Access Objects（DAO）</li></ul><h2 id="MyBatis特性"><a href="#MyBatis特性" class="headerlink" title="MyBatis特性"></a>MyBatis特性</h2><ol><li>MyBatis 是支持定制化 SQL、存储过程以及高级映射的优秀的持久层框架</li><li>MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集</li><li>MyBatis可以使用简单的XML或注解用于配置和原始映射，将接口和Java的POJO（Plain Old Java Objects，普通的Java对象）映射成数据库中的记录</li><li>MyBatis 是一个 半自动的ORM（Object Relation Mapping）框架</li></ol><h2 id="MyBatis下载"><a href="#MyBatis下载" class="headerlink" title="MyBatis下载"></a>MyBatis下载</h2><ul><li><a href="https://github.com/mybatis/mybatis-3">MyBatis下载地址</a></li><li><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221107230550134.png" alt="image-20221107230550134"></li></ul><h2 id="和其它持久化层技术对比"><a href="#和其它持久化层技术对比" class="headerlink" title="和其它持久化层技术对比"></a>和其它持久化层技术对比</h2><ul><li>JDBC  <ul><li>SQL 夹杂在Java代码中耦合度高，导致硬编码内伤  </li><li>维护不易且实际开发需求中 SQL 有变化，频繁修改的情况多见  </li><li>代码冗长，开发效率低</li></ul></li><li>Hibernate 和 JPA<ul><li>操作简便，开发效率高  </li><li>程序中的长难复杂 SQL 需要绕过框架  </li><li>内部自动生产的 SQL，不容易做特殊优化  </li><li>基于全映射的全自动框架，大量字段的 POJO 进行部分映射时比较困难。  </li><li>反射操作太多，导致数据库性能下降</li></ul></li><li>MyBatis<ul><li>轻量级，性能出色  </li><li>SQL 和 Java 编码分开，功能边界清晰。Java代码专注业务、SQL语句专注数据  </li><li>开发效率稍逊于HIbernate，但是完全能够接受</li></ul></li></ul><h1 id="搭建MyBatis"><a href="#搭建MyBatis" class="headerlink" title="搭建MyBatis"></a>搭建MyBatis</h1><h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><ul><li>IDE：idea 2019.2  </li><li>构建工具：maven 3.5.4  </li><li>MySQL版本：MySQL 5.7  </li><li>MyBatis版本：MyBatis 3.5.7</li></ul><h2 id="创建maven工程"><a href="#创建maven工程" class="headerlink" title="创建maven工程"></a>创建maven工程</h2><ul><li>打包方式：jar</li><li>引入依赖</li></ul><pre><code class="xml">```xml&lt;dependencies&gt;    &lt;!-- Mybatis核心 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.mybatis&lt;/groupId&gt;        &lt;artifactId&gt;mybatis&lt;/artifactId&gt;        &lt;version&gt;3.5.7&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- junit测试 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;junit&lt;/groupId&gt;        &lt;artifactId&gt;junit&lt;/artifactId&gt;        &lt;version&gt;4.12&lt;/version&gt;        &lt;scope&gt;test&lt;/scope&gt;    &lt;/dependency&gt;    &lt;!-- MySQL驱动 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;mysql&lt;/groupId&gt;        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;        &lt;version&gt;5.1.3&lt;/version&gt;        &lt;/dependency&gt;&lt;/dependencies&gt;```</code></pre><h2 id="创建MyBatis的核心配置文件"><a href="#创建MyBatis的核心配置文件" class="headerlink" title="创建MyBatis的核心配置文件"></a>创建MyBatis的核心配置文件</h2><blockquote><p>习惯上命名为<code>mybatis-config.xml</code>，这个文件名仅仅只是建议，并非强制要求。将来整合Spring之后，这个配置文件可以省略，所以大家操作时可以直接复制、粘贴。<br>核心配置文件主要用于配置连接数据库的环境以及MyBatis的全局配置信息<br>核心配置文件存放的位置是src&#x2F;main&#x2F;resources目录下</p></blockquote><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;  &lt;!DOCTYPE configuration  PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;  &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;  &lt;configuration&gt;         &lt;!--设置连接数据库的环境--&gt;      &lt;environments default=&quot;development&quot;&gt;          &lt;environment id=&quot;development&quot;&gt;              &lt;transactionManager type=&quot;JDBC&quot;/&gt;              &lt;dataSource type=&quot;POOLED&quot;&gt;                  &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;                  &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/MyBatis&quot;/&gt;                  &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;                  &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt;              &lt;/dataSource&gt;          &lt;/environment&gt;      &lt;/environments&gt;      &lt;!--引入映射文件--&gt;      &lt;mappers&gt;          &lt;mapper resource=&quot;mappers/UserMapper.xml&quot;/&gt;      &lt;/mappers&gt;  &lt;/configuration&gt;</code></pre><h2 id="创建mapper接口"><a href="#创建mapper接口" class="headerlink" title="创建mapper接口"></a>创建mapper接口</h2><blockquote><p>MyBatis中的mapper接口相当于以前的dao。但是区别在于，mapper仅仅是接口，我们不需要提供实现类</p></blockquote><pre><code class="java">package com.atguigu.mybatis.mapper;    public interface UserMapper &#123;      /**      * 添加用户信息      */      int insertUser();  &#125;</code></pre><h2 id="创建MyBatis的映射文件"><a href="#创建MyBatis的映射文件" class="headerlink" title="创建MyBatis的映射文件"></a>创建MyBatis的映射文件</h2><ul><li>相关概念：ORM（Object Relationship Mapping）对象关系映射。  <ul><li>对象：Java的实体类对象  </li><li>关系：关系型数据库  </li><li>映射：二者之间的对应关系</li></ul></li></ul><table><thead><tr><th>Java概念</th><th>数据库概念</th></tr></thead><tbody><tr><td>类</td><td>表</td></tr><tr><td>属性</td><td>字段&#x2F;列</td></tr><tr><td>对象</td><td>记录&#x2F;行</td></tr></tbody></table><ul><li>映射文件的命名规则<ul><li>表所对应的实体类的类名+Mapper.xml</li><li>例如：表t_user，映射的实体类为User，所对应的映射文件为UserMapper.xml </li><li>因此一个映射文件对应一个实体类，对应一张表的操作</li><li>MyBatis映射文件用于编写SQL，访问以及操作表中的数据</li><li>MyBatis映射文件存放的位置是src&#x2F;main&#x2F;resources&#x2F;mappers目录下</li></ul></li><li>MyBatis中可以面向接口操作数据，要保证两个一致<ul><li>mapper接口的全类名和映射文件的命名空间（namespace）保持一致</li><li>mapper接口中方法的方法名和映射文件中编写SQL的标签的id属性保持一致</li></ul></li></ul><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;  &lt;!DOCTYPE mapper  PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;  &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;  &lt;mapper namespace=&quot;com.atguigu.mybatis.mapper.UserMapper&quot;&gt;      &lt;!--int insertUser();--&gt;      &lt;insert id=&quot;insertUser&quot;&gt;          insert into t_user values(null,&#39;张三&#39;,&#39;123&#39;,23,&#39;女&#39;)      &lt;/insert&gt;  &lt;/mapper&gt;</code></pre><h2 id="通过junit测试功能"><a href="#通过junit测试功能" class="headerlink" title="通过junit测试功能"></a>通过junit测试功能</h2><ul><li>SqlSession：代表Java程序和数据库之间的会话。（HttpSession是Java程序和浏览器之间的会话）</li><li>SqlSessionFactory：是“生产”SqlSession的“工厂”</li><li>工厂模式：如果创建某一个对象，使用的过程基本固定，那么我们就可以把创建这个对象的相关代码封装到一个“工厂类”中，以后都使用这个工厂类来“生产”我们需要的对象</li></ul><pre><code class="java">public class UserMapperTest &#123;    @Test    public void testInsertUser() throws IOException &#123;        //读取MyBatis的核心配置文件        InputStream is = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;);        //获取SqlSessionFactoryBuilder对象        SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder();        //通过核心配置文件所对应的字节输入流创建工厂类SqlSessionFactory，生产SqlSession对象        SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(is);        //获取sqlSession，此时通过SqlSession对象所操作的sql都必须手动提交或回滚事务        //SqlSession sqlSession = sqlSessionFactory.openSession();        //创建SqlSession对象，此时通过SqlSession对象所操作的sql都会自动提交          SqlSession sqlSession = sqlSessionFactory.openSession(true);        //通过代理模式创建UserMapper接口的代理实现类对象        UserMapper userMapper = sqlSession.getMapper(UserMapper.class);        //调用UserMapper接口中的方法，就可以根据UserMapper的全类名匹配元素文件，通过调用的方法名匹配映射文件中的SQL标签，并执行标签中的SQL语句        int result = userMapper.insertUser();        //提交事务        //sqlSession.commit();        System.out.println(&quot;result:&quot; + result);    &#125;&#125;</code></pre><ul><li>此时需要手动提交事务，如果要自动提交事务，则在获取sqlSession对象时，使用<code>SqlSession sqlSession = sqlSessionFactory.openSession(true);</code>，传入一个Boolean类型的参数，值为true，这样就可以自动提交</li></ul><h2 id="加入log4j日志功能"><a href="#加入log4j日志功能" class="headerlink" title="加入log4j日志功能"></a>加入log4j日志功能</h2><ol><li>加入依赖<pre><code class="xml">&lt;!-- log4j日志 --&gt;&lt;dependency&gt;&lt;groupId&gt;log4j&lt;/groupId&gt;&lt;artifactId&gt;log4j&lt;/artifactId&gt;&lt;version&gt;1.2.17&lt;/version&gt;&lt;/dependency&gt;</code></pre></li><li>加入log4j的配置文件<ul><li>log4j的配置文件名为log4j.xml，存放的位置是src&#x2F;main&#x2F;resources目录下</li><li>日志的级别：FATAL(致命)&gt;ERROR(错误)&gt;WARN(警告)&gt;INFO(信息)&gt;DEBUG(调试) 从左到右打印的内容越来越详细</li></ul><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE log4j:configuration SYSTEM &quot;log4j.dtd&quot;&gt;&lt;log4j:configuration xmlns:log4j=&quot;http://jakarta.apache.org/log4j/&quot;&gt;    &lt;appender name=&quot;STDOUT&quot; class=&quot;org.apache.log4j.ConsoleAppender&quot;&gt;        &lt;param name=&quot;Encoding&quot; value=&quot;UTF-8&quot; /&gt;        &lt;layout class=&quot;org.apache.log4j.PatternLayout&quot;&gt;            &lt;param name=&quot;ConversionPattern&quot; value=&quot;%-5p %d&#123;MM-dd HH:mm:ss,SSS&#125; %m (%F:%L) \n&quot; /&gt;        &lt;/layout&gt;    &lt;/appender&gt;    &lt;logger name=&quot;java.sql&quot;&gt;        &lt;level value=&quot;debug&quot; /&gt;    &lt;/logger&gt;    &lt;logger name=&quot;org.apache.ibatis&quot;&gt;        &lt;level value=&quot;info&quot; /&gt;    &lt;/logger&gt;    &lt;root&gt;        &lt;level value=&quot;debug&quot; /&gt;        &lt;appender-ref ref=&quot;STDOUT&quot; /&gt;    &lt;/root&gt;&lt;/log4j:configuration&gt;</code></pre></li></ol><h1 id="核心配置文件详解"><a href="#核心配置文件详解" class="headerlink" title="核心配置文件详解"></a>核心配置文件详解</h1><blockquote><p>核心配置文件中的标签必须按照固定的顺序(有的标签可以不写，但顺序一定不能乱)：<br>properties、settings、typeAliases、typeHandlers、objectFactory、objectWrapperFactory、reflectorFactory、plugins、environments、databaseIdProvider、mappers</p></blockquote><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration        PUBLIC &quot;-//MyBatis.org//DTD Config 3.0//EN&quot;        &quot;http://MyBatis.org/dtd/MyBatis-3-config.dtd&quot;&gt;&lt;configuration&gt;    &lt;!--引入properties文件，此时就可以$&#123;属性名&#125;的方式访问属性值--&gt;    &lt;properties resource=&quot;jdbc.properties&quot;&gt;&lt;/properties&gt;    &lt;settings&gt;        &lt;!--将表中字段的下划线自动转换为驼峰--&gt;        &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;        &lt;!--开启延迟加载--&gt;        &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt;    &lt;/settings&gt;    &lt;typeAliases&gt;        &lt;!--        typeAlias：设置某个具体的类型的别名        属性：        type：需要设置别名的类型的全类名        alias：设置此类型的别名，且别名不区分大小写。若不设置此属性，该类型拥有默认的别名，即类名        --&gt;        &lt;!--&lt;typeAlias type=&quot;com.atguigu.mybatis.bean.User&quot;&gt;&lt;/typeAlias&gt;--&gt;        &lt;!--&lt;typeAlias type=&quot;com.atguigu.mybatis.bean.User&quot; alias=&quot;user&quot;&gt;        &lt;/typeAlias&gt;--&gt;        &lt;!--以包为单位，设置改包下所有的类型都拥有默认的别名，即类名且不区分大小写--&gt;        &lt;package name=&quot;com.atguigu.mybatis.bean&quot;/&gt;    &lt;/typeAliases&gt;    &lt;!--    environments：设置多个连接数据库的环境    属性：        default：设置默认使用的环境的id    --&gt;    &lt;environments default=&quot;mysql_test&quot;&gt;        &lt;!--        environment：设置具体的连接数据库的环境信息        属性：            id：设置环境的唯一标识，可通过environments标签中的default设置某一个环境的id，表示默认使用的环境        --&gt;        &lt;environment id=&quot;mysql_test&quot;&gt;            &lt;!--            transactionManager：设置事务管理方式            属性：                type：设置事务管理方式，type=&quot;JDBC|MANAGED&quot;                type=&quot;JDBC&quot;：设置当前环境的事务管理都必须手动处理                type=&quot;MANAGED&quot;：设置事务被管理，例如spring中的AOP            --&gt;            &lt;transactionManager type=&quot;JDBC&quot;/&gt;            &lt;!--            dataSource：设置数据源            属性：                type：设置数据源的类型，type=&quot;POOLED|UNPOOLED|JNDI&quot;                type=&quot;POOLED&quot;：使用数据库连接池，即会将创建的连接进行缓存，下次使用可以从缓存中直接获取，不需要重新创建                type=&quot;UNPOOLED&quot;：不使用数据库连接池，即每次使用连接都需要重新创建                type=&quot;JNDI&quot;：调用上下文中的数据源            --&gt;            &lt;dataSource type=&quot;POOLED&quot;&gt;                &lt;!--设置驱动类的全类名--&gt;                &lt;property name=&quot;driver&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt;                &lt;!--设置连接数据库的连接地址--&gt;                &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt;                &lt;!--设置连接数据库的用户名--&gt;                &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt;                &lt;!--设置连接数据库的密码--&gt;                &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt;            &lt;/dataSource&gt;        &lt;/environment&gt;    &lt;/environments&gt;    &lt;!--引入映射文件--&gt;    &lt;mappers&gt;        &lt;!-- &lt;mapper resource=&quot;UserMapper.xml&quot;/&gt; --&gt;        &lt;!--        以包为单位，将包下所有的映射文件引入核心配置文件        注意：            1. 此方式必须保证mapper接口和mapper映射文件必须在相同的包下            2. mapper接口要和mapper映射文件的名字一致        --&gt;        &lt;package name=&quot;com.atguigu.mybatis.mapper&quot;/&gt;    &lt;/mappers&gt;&lt;/configuration&gt;</code></pre><h1 id="默认的类型别名"><a href="#默认的类型别名" class="headerlink" title="默认的类型别名"></a>默认的类型别名</h1><h1 id="MyBatis的增删改查"><a href="#MyBatis的增删改查" class="headerlink" title="MyBatis的增删改查"></a>MyBatis的增删改查</h1><ol><li>添加<pre><code class="xml">&lt;!--int insertUser();--&gt;&lt;insert id=&quot;insertUser&quot;&gt;    insert into t_user values(null,&#39;admin&#39;,&#39;123456&#39;,23,&#39;男&#39;,&#39;12345@qq.com&#39;)&lt;/insert&gt;</code></pre></li><li>删除<pre><code class="xml">&lt;!--int deleteUser();--&gt;&lt;delete id=&quot;deleteUser&quot;&gt;    delete from t_user where id = 6&lt;/delete&gt;</code></pre></li><li>修改<pre><code class="xml">&lt;!--int updateUser();--&gt;&lt;update id=&quot;updateUser&quot;&gt;    update t_user set username = &#39;张三&#39; where id = 5&lt;/update&gt;</code></pre></li><li>查询一个实体类对象<pre><code class="xml">&lt;!--User getUserById();--&gt;  &lt;select id=&quot;getUserById&quot; resultType=&quot;com.atguigu.mybatis.bean.User&quot;&gt;      select * from t_user where id = 2  &lt;/select&gt;</code></pre></li><li>查询集合<pre><code class="xml">&lt;!--List&lt;User&gt; getUserList();--&gt;&lt;select id=&quot;getUserList&quot; resultType=&quot;com.atguigu.mybatis.bean.User&quot;&gt;    select * from t_user&lt;/select&gt;</code></pre></li></ol><ul><li><p>注意：</p><ol><li>查询的标签select必须设置属性resultType或resultMap，用于设置实体类和数据库表的映射关系  <ul><li>resultType：自动映射，用于属性名和表中字段名一致的情况  </li><li>resultMap：自定义映射，用于一对多或多对一或字段名和属性名不一致的情况</li></ul></li><li>当查询的数据为多条时，不能使用实体类作为返回值，只能使用集合，否则会抛出异常TooManyResultsException；但是若查询的数据只有一条，可以使用实体类或集合作为返回值</li></ol></li></ul><h1 id="MyBatis获取参数值的两种方式（重点）"><a href="#MyBatis获取参数值的两种方式（重点）" class="headerlink" title="MyBatis获取参数值的两种方式（重点）"></a>MyBatis获取参数值的两种方式（重点）</h1><ul><li>MyBatis获取参数值的两种方式：${}和#{}  </li><li>${}的本质就是字符串拼接，#{}的本质就是占位符赋值  </li><li>${}使用字符串拼接的方式拼接sql，若为字符串类型或日期类型的字段进行赋值时，需要手动加单引号；但是#{}使用占位符赋值的方式拼接sql，此时为字符串类型或日期类型的字段进行赋值时，可以自动添加单引号</li></ul><h2 id="单个字面量类型的参数"><a href="#单个字面量类型的参数" class="headerlink" title="单个字面量类型的参数"></a>单个字面量类型的参数</h2><ul><li>若mapper接口中的方法参数为单个的字面量类型，此时可以使用${}和#{}以任意的名称（最好见名识意）获取参数的值，注意${}需要手动加单引号</li></ul><pre><code class="xml">&lt;!--User getUserByUsername(String username);--&gt;&lt;select id=&quot;getUserByUsername&quot; resultType=&quot;User&quot;&gt;    select * from t_user where username = #&#123;username&#125;&lt;/select&gt;</code></pre><pre><code class="xml">&lt;!--User getUserByUsername(String username);--&gt;&lt;select id=&quot;getUserByUsername&quot; resultType=&quot;User&quot;&gt;      select * from t_user where username = &#39;$&#123;username&#125;&#39;  &lt;/select&gt;</code></pre><h2 id="多个字面量类型的参数"><a href="#多个字面量类型的参数" class="headerlink" title="多个字面量类型的参数"></a>多个字面量类型的参数</h2><ul><li><p>若mapper接口中的方法参数为多个时，此时MyBatis会自动将这些参数放在一个map集合中</p><ol><li>以arg0,arg1…为键，以参数为值；</li><li>以param1,param2…为键，以参数为值；</li></ol></li><li><p>因此只需要通过${}和#{}访问map集合的键就可以获取相对应的值，注意${}需要手动加单引号。</p></li><li><p>使用arg或者param都行，要注意的是，arg是从arg0开始的，param是从param1开始的</p></li></ul><pre><code class="xml">&lt;!--User checkLogin(String username,String password);--&gt;&lt;select id=&quot;checkLogin&quot; resultType=&quot;User&quot;&gt;      select * from t_user where username = #&#123;arg0&#125; and password = #&#123;arg1&#125;  &lt;/select&gt;</code></pre><pre><code class="xml">&lt;!--User checkLogin(String username,String password);--&gt;&lt;select id=&quot;checkLogin&quot; resultType=&quot;User&quot;&gt;    select * from t_user where username = &#39;$&#123;param1&#125;&#39; and password = &#39;$&#123;param2&#125;&#39;&lt;/select&gt;</code></pre><h2 id="map集合类型的参数"><a href="#map集合类型的参数" class="headerlink" title="map集合类型的参数"></a>map集合类型的参数</h2><ul><li>若mapper接口中的方法需要的参数为多个时，此时可以手动创建map集合，将这些数据放在map中只需要通过${}和#{}访问map集合的键就可以获取相对应的值，注意${}需要手动加单引号</li></ul><pre><code class="xml">&lt;!--User checkLoginByMap(Map&lt;String,Object&gt; map);--&gt;&lt;select id=&quot;checkLoginByMap&quot; resultType=&quot;User&quot;&gt;    select * from t_user where username = #&#123;username&#125; and password = #&#123;password&#125;&lt;/select&gt;</code></pre><pre><code class="java">@Testpublic void checkLoginByMap() &#123;    SqlSession sqlSession = SqlSessionUtils.getSqlSession();    ParameterMapper mapper = sqlSession.getMapper(ParameterMapper.class);    Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();    map.put(&quot;usermane&quot;,&quot;admin&quot;);    map.put(&quot;password&quot;,&quot;123456&quot;);    User user = mapper.checkLoginByMap(map);    System.out.println(user);&#125;</code></pre><h2 id="实体类类型的参数"><a href="#实体类类型的参数" class="headerlink" title="实体类类型的参数"></a>实体类类型的参数</h2><ul><li>若mapper接口中的方法参数为实体类对象时此时可以使用${}和#{}，通过访问实体类对象中的属性名获取属性值，注意${}需要手动加单引号</li></ul><pre><code class="xml">&lt;!--int insertUser(User user);--&gt;&lt;insert id=&quot;insertUser&quot;&gt;    insert into t_user values(null,#&#123;username&#125;,#&#123;password&#125;,#&#123;age&#125;,#&#123;sex&#125;,#&#123;email&#125;)&lt;/insert&gt;</code></pre><pre><code class="java">@Testpublic void insertUser() &#123;    SqlSession sqlSession = SqlSessionUtils.getSqlSession();    ParameterMapper mapper = sqlSession.getMapper(ParameterMapper.class);    User user = new User(null,&quot;Tom&quot;,&quot;123456&quot;,12,&quot;男&quot;,&quot;123@321.com&quot;);    mapper.insertUser(user);&#125;</code></pre><h2 id="使用-Param标识参数"><a href="#使用-Param标识参数" class="headerlink" title="使用@Param标识参数"></a>使用@Param标识参数</h2><ul><li><p>可以通过@Param注解标识mapper接口中的方法参数，此时，会将这些参数放在map集合中 </p><ol><li>以@Param注解的value属性值为键，以参数为值；</li><li>以param1,param2…为键，以参数为值；</li></ol></li><li><p>只需要通过${}和#{}访问map集合的键就可以获取相对应的值，注意${}需要手动加单引号</p></li></ul><pre><code class="xml">&lt;!--User CheckLoginByParam(@Param(&quot;username&quot;) String username, @Param(&quot;password&quot;) String password);--&gt;    &lt;select id=&quot;CheckLoginByParam&quot; resultType=&quot;User&quot;&gt;        select * from t_user where username = #&#123;username&#125; and password = #&#123;password&#125;    &lt;/select&gt;</code></pre><pre><code class="java">@Testpublic void checkLoginByParam() &#123;    SqlSession sqlSession = SqlSessionUtils.getSqlSession();    ParameterMapper mapper = sqlSession.getMapper(ParameterMapper.class);    mapper.CheckLoginByParam(&quot;admin&quot;,&quot;123456&quot;);&#125;</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>建议分成两种情况进行处理</p><ol><li>实体类类型的参数</li><li>使用@Param标识参数</li></ol></li></ul><h1 id="MyBatis的各种查询功能"><a href="#MyBatis的各种查询功能" class="headerlink" title="MyBatis的各种查询功能"></a>MyBatis的各种查询功能</h1><ol><li>如果查询出的数据只有一条，可以通过<ol><li>实体类对象接收</li><li>List集合接收</li><li>Map集合接收，结果<code>&#123;password=123456, sex=男, id=1, age=23, username=admin&#125;</code></li></ol></li><li>如果查询出的数据有多条，一定不能用实体类对象接收，会抛异常TooManyResultsException，可以通过<ol><li>实体类类型的LIst集合接收</li><li>Map类型的LIst集合接收</li><li>在mapper接口的方法上添加@MapKey注解</li></ol></li></ol><h2 id="查询一个实体类对象"><a href="#查询一个实体类对象" class="headerlink" title="查询一个实体类对象"></a>查询一个实体类对象</h2><pre><code class="java">/** * 根据用户id查询用户信息 * @param id * @return */User getUserById(@Param(&quot;id&quot;) int id);</code></pre><pre><code class="xml">&lt;!--User getUserById(@Param(&quot;id&quot;) int id);--&gt;&lt;select id=&quot;getUserById&quot; resultType=&quot;User&quot;&gt;    select * from t_user where id = #&#123;id&#125;&lt;/select&gt;</code></pre><h2 id="查询一个List集合"><a href="#查询一个List集合" class="headerlink" title="查询一个List集合"></a>查询一个List集合</h2><pre><code class="java">/** * 查询所有用户信息 * @return */List&lt;User&gt; getUserList();</code></pre><pre><code class="xml">&lt;!--List&lt;User&gt; getUserList();--&gt;&lt;select id=&quot;getUserList&quot; resultType=&quot;User&quot;&gt;    select * from t_user&lt;/select&gt;</code></pre><h2 id="查询单个数据"><a href="#查询单个数据" class="headerlink" title="查询单个数据"></a>查询单个数据</h2><pre><code class="java">/**   * 查询用户的总记录数   * @return   * 在MyBatis中，对于Java中常用的类型都设置了类型别名   * 例如：java.lang.Integer--&gt;int|integer   * 例如：int--&gt;_int|_integer   * 例如：Map--&gt;map,List--&gt;list   */  int getCount();</code></pre><pre><code class="xml">&lt;!--int getCount();--&gt;&lt;select id=&quot;getCount&quot; resultType=&quot;_integer&quot;&gt;    select count(id) from t_user&lt;/select&gt;</code></pre><h2 id="查询一条数据为map集合"><a href="#查询一条数据为map集合" class="headerlink" title="查询一条数据为map集合"></a>查询一条数据为map集合</h2><pre><code class="java">/**   * 根据用户id查询用户信息为map集合   * @param id   * @return   */  Map&lt;String, Object&gt; getUserToMap(@Param(&quot;id&quot;) int id);</code></pre><pre><code class="xml">&lt;!--Map&lt;String, Object&gt; getUserToMap(@Param(&quot;id&quot;) int id);--&gt;&lt;select id=&quot;getUserToMap&quot; resultType=&quot;map&quot;&gt;    select * from t_user where id = #&#123;id&#125;&lt;/select&gt;&lt;!--结果：&#123;password=123456, sex=男, id=1, age=23, username=admin&#125;--&gt;</code></pre><h2 id="查询多条数据为map集合"><a href="#查询多条数据为map集合" class="headerlink" title="查询多条数据为map集合"></a>查询多条数据为map集合</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><pre><code class="java">/**   * 查询所有用户信息为map集合   * @return   * 将表中的数据以map集合的方式查询，一条数据对应一个map；若有多条数据，就会产生多个map集合，此时可以将这些map放在一个list集合中获取   */  List&lt;Map&lt;String, Object&gt;&gt; getAllUserToMap();</code></pre><pre><code class="xml">&lt;!--Map&lt;String, Object&gt; getAllUserToMap();--&gt;  &lt;select id=&quot;getAllUserToMap&quot; resultType=&quot;map&quot;&gt;      select * from t_user  &lt;/select&gt;&lt;!--    结果：    [&#123;password=123456, sex=男, id=1, age=23, username=admin&#125;,    &#123;password=123456, sex=男, id=2, age=23, username=张三&#125;,    &#123;password=123456, sex=男, id=3, age=23, username=张三&#125;]--&gt;</code></pre><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><pre><code class="java">/** * 查询所有用户信息为map集合 * @return * 将表中的数据以map集合的方式查询，一条数据对应一个map；若有多条数据，就会产生多个map集合，并且最终要以一个map的方式返回数据，此时需要通过@MapKey注解设置map集合的键，值是每条数据所对应的map集合 */@MapKey(&quot;id&quot;)Map&lt;String, Object&gt; getAllUserToMap();</code></pre><pre><code class="xml">&lt;!--Map&lt;String, Object&gt; getAllUserToMap();--&gt;&lt;select id=&quot;getAllUserToMap&quot; resultType=&quot;map&quot;&gt;    select * from t_user&lt;/select&gt;&lt;!--    结果：    &#123;    1=&#123;password=123456, sex=男, id=1, age=23, username=admin&#125;,    2=&#123;password=123456, sex=男, id=2, age=23, username=张三&#125;,    3=&#123;password=123456, sex=男, id=3, age=23, username=张三&#125;    &#125;--&gt;</code></pre><h1 id="特殊SQL的执行"><a href="#特殊SQL的执行" class="headerlink" title="特殊SQL的执行"></a>特殊SQL的执行</h1><h2 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h2><pre><code class="java">/** * 根据用户名进行模糊查询 * @param username  * @return java.util.List&lt;com.atguigu.mybatis.pojo.User&gt; * @date 2022/2/26 21:56 */List&lt;User&gt; getUserByLike(@Param(&quot;username&quot;) String username);</code></pre><pre><code class="xml">&lt;!--List&lt;User&gt; getUserByLike(@Param(&quot;username&quot;) String username);--&gt;&lt;select id=&quot;getUserByLike&quot; resultType=&quot;User&quot;&gt;    &lt;!--select * from t_user where username like &#39;%$&#123;mohu&#125;%&#39;--&gt;      &lt;!--select * from t_user where username like concat(&#39;%&#39;,#&#123;mohu&#125;,&#39;%&#39;)--&gt;      select * from t_user where username like &quot;%&quot;#&#123;mohu&#125;&quot;%&quot;&lt;/select&gt;</code></pre><ul><li>其中<code>select * from t_user where username like &quot;%&quot;#&#123;mohu&#125;&quot;%&quot;</code>是最常用的</li></ul><h2 id="批量删除"><a href="#批量删除" class="headerlink" title="批量删除"></a>批量删除</h2><ul><li>只能使用${}，如果使用#{}，则解析后的sql语句为<code>delete from t_user where id in (&#39;1,2,3&#39;)</code>，这样是将<code>1,2,3</code>看做是一个整体，只有id为<code>1,2,3</code>的数据会被删除。正确的语句应该是<code>delete from t_user where id in (1,2,3)</code>，或者<code>delete from t_user where id in (&#39;1&#39;,&#39;2&#39;,&#39;3&#39;)</code></li></ul><pre><code class="java">/** * 根据id批量删除 * @param ids  * @return int * @date 2022/2/26 22:06 */int deleteMore(@Param(&quot;ids&quot;) String ids);</code></pre><pre><code class="xml">&lt;delete id=&quot;deleteMore&quot;&gt;    delete from t_user where id in ($&#123;ids&#125;)&lt;/delete&gt;</code></pre><pre><code class="java">//测试类@Testpublic void deleteMore() &#123;    SqlSession sqlSession = SqlSessionUtils.getSqlSession();    SQLMapper mapper = sqlSession.getMapper(SQLMapper.class);    int result = mapper.deleteMore(&quot;1,2,3,8&quot;);    System.out.println(result);&#125;</code></pre><h2 id="动态设置表名"><a href="#动态设置表名" class="headerlink" title="动态设置表名"></a>动态设置表名</h2><ul><li>只能使用${}，因为表名不能加单引号</li></ul><pre><code class="java">/** * 查询指定表中的数据 * @param tableName  * @return java.util.List&lt;com.atguigu.mybatis.pojo.User&gt; * @date 2022/2/27 14:41 */List&lt;User&gt; getUserByTable(@Param(&quot;tableName&quot;) String tableName);</code></pre><pre><code class="xml">&lt;!--List&lt;User&gt; getUserByTable(@Param(&quot;tableName&quot;) String tableName);--&gt;&lt;select id=&quot;getUserByTable&quot; resultType=&quot;User&quot;&gt;    select * from $&#123;tableName&#125;&lt;/select&gt;</code></pre><h2 id="添加功能获取自增的主键"><a href="#添加功能获取自增的主键" class="headerlink" title="添加功能获取自增的主键"></a>添加功能获取自增的主键</h2><ul><li>使用场景<ul><li>t_clazz(clazz_id,clazz_name)  </li><li>t_student(student_id,student_name,clazz_id)</li></ul><ol><li>添加班级信息  </li><li>获取新添加的班级的id  </li><li>为班级分配学生，即将某学的班级id修改为新添加的班级的id</li></ol></li><li>在mapper.xml中设置两个属性<ul><li>useGeneratedKeys：设置使用自增的主键</li></ul><ul><li>keyProperty：因为增删改有统一的返回值是受影响的行数，因此只能将获取的自增的主键放在传输的参数user对象的某个属性中</li></ul></li></ul><pre><code class="java">/** * 添加用户信息 * @param user  * @date 2022/2/27 15:04 */void insertUser(User user);</code></pre><pre><code class="xml">&lt;!--void insertUser(User user);--&gt;&lt;insert id=&quot;insertUser&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt;    insert into t_user values (null,#&#123;username&#125;,#&#123;password&#125;,#&#123;age&#125;,#&#123;sex&#125;,#&#123;email&#125;)&lt;/insert&gt;</code></pre><pre><code class="java">//测试类@Testpublic void insertUser() &#123;    SqlSession sqlSession = SqlSessionUtils.getSqlSession();    SQLMapper mapper = sqlSession.getMapper(SQLMapper.class);    User user = new User(null, &quot;ton&quot;, &quot;123&quot;, 23, &quot;男&quot;, &quot;123@321.com&quot;);    mapper.insertUser(user);    System.out.println(user);    //输出：user&#123;id=10, username=&#39;ton&#39;, password=&#39;123&#39;, age=23, sex=&#39;男&#39;, email=&#39;123@321.com&#39;&#125;，自增主键存放到了user的id属性中&#125;</code></pre><h1 id="自定义映射resultMap"><a href="#自定义映射resultMap" class="headerlink" title="自定义映射resultMap"></a>自定义映射resultMap</h1><h2 id="resultMap处理字段和属性的映射关系"><a href="#resultMap处理字段和属性的映射关系" class="headerlink" title="resultMap处理字段和属性的映射关系"></a>resultMap处理字段和属性的映射关系</h2><ul><li>resultMap：设置自定义映射  <ul><li>属性：  <ul><li>id：表示自定义映射的唯一标识，不能重复</li><li>type：查询的数据要映射的实体类的类型</li></ul></li><li>子标签：  <ul><li>id：设置主键的映射关系  </li><li>result：设置普通字段的映射关系  </li><li>子标签属性：  <ul><li>property：设置映射关系中实体类中的属性名  </li><li>column：设置映射关系中表中的字段名</li></ul></li></ul></li></ul></li><li>若字段名和实体类中的属性名不一致，则可以通过resultMap设置自定义映射，即使字段名和属性名一致的属性也要映射，也就是全部属性都要列出来</li></ul><pre><code class="xml">&lt;resultMap id=&quot;empResultMap&quot; type=&quot;Emp&quot;&gt;    &lt;id property=&quot;eid&quot; column=&quot;eid&quot;&gt;&lt;/id&gt;    &lt;result property=&quot;empName&quot; column=&quot;emp_name&quot;&gt;&lt;/result&gt;    &lt;result property=&quot;age&quot; column=&quot;age&quot;&gt;&lt;/result&gt;    &lt;result property=&quot;sex&quot; column=&quot;sex&quot;&gt;&lt;/result&gt;    &lt;result property=&quot;email&quot; column=&quot;email&quot;&gt;&lt;/result&gt;&lt;/resultMap&gt;&lt;!--List&lt;Emp&gt; getAllEmp();--&gt;&lt;select id=&quot;getAllEmp&quot; resultMap=&quot;empResultMap&quot;&gt;    select * from t_emp&lt;/select&gt;</code></pre><ul><li><p>若字段名和实体类中的属性名不一致，但是字段名符合数据库的规则（使用_），实体类中的属性名符合Java的规则（使用驼峰）。此时也可通过以下两种方式处理字段名和实体类中的属性的映射关系  </p><ol><li>可以通过为字段起别名的方式，保证和实体类中的属性名保持一致  <pre><code class="xml">&lt;!--List&lt;Emp&gt; getAllEmp();--&gt;&lt;select id=&quot;getAllEmp&quot; resultType=&quot;Emp&quot;&gt;    select eid,emp_name empName,age,sex,email from t_emp&lt;/select&gt;</code></pre></li><li>可以在MyBatis的核心配置文件中的<code>setting</code>标签中，设置一个全局配置信息mapUnderscoreToCamelCase，可以在查询表中数据时，自动将_类型的字段名转换为驼峰，例如：字段名user_name，设置了mapUnderscoreToCamelCase，此时字段名就会转换为userName。<a href="#%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3">核心配置文件详解</a><pre><code class="xml"></code></pre></li></ol>  <settings>      <setting name="mapUnderscoreToCamelCase" value="true"/>  </settings>      ```</li></ul><h2 id="多对一映射处理"><a href="#多对一映射处理" class="headerlink" title="多对一映射处理"></a>多对一映射处理</h2><blockquote><p>查询员工信息以及员工所对应的部门信息</p></blockquote><pre><code class="java">public class Emp &#123;      private Integer eid;      private String empName;      private Integer age;      private String sex;      private String email;      private Dept dept;    //...构造器、get、set方法等&#125;</code></pre><h3 id="级联方式处理映射关系"><a href="#级联方式处理映射关系" class="headerlink" title="级联方式处理映射关系"></a>级联方式处理映射关系</h3><pre><code class="xml">&lt;resultMap id=&quot;empAndDeptResultMapOne&quot; type=&quot;Emp&quot;&gt;    &lt;id property=&quot;eid&quot; column=&quot;eid&quot;&gt;&lt;/id&gt;    &lt;result property=&quot;empName&quot; column=&quot;emp_name&quot;&gt;&lt;/result&gt;    &lt;result property=&quot;age&quot; column=&quot;age&quot;&gt;&lt;/result&gt;    &lt;result property=&quot;sex&quot; column=&quot;sex&quot;&gt;&lt;/result&gt;    &lt;result property=&quot;email&quot; column=&quot;email&quot;&gt;&lt;/result&gt;    &lt;result property=&quot;dept.did&quot; column=&quot;did&quot;&gt;&lt;/result&gt;    &lt;result property=&quot;dept.deptName&quot; column=&quot;dept_name&quot;&gt;&lt;/result&gt;&lt;/resultMap&gt;&lt;!--Emp getEmpAndDept(@Param(&quot;eid&quot;)Integer eid);--&gt;&lt;select id=&quot;getEmpAndDept&quot; resultMap=&quot;empAndDeptResultMapOne&quot;&gt;    select * from t_emp left join t_dept on t_emp.eid = t_dept.did where t_emp.eid = #&#123;eid&#125;&lt;/select&gt;</code></pre><h3 id="使用association处理映射关系"><a href="#使用association处理映射关系" class="headerlink" title="使用association处理映射关系"></a>使用association处理映射关系</h3><ul><li>association：处理多对一的映射关系</li><li>property：需要处理多对的映射关系的属性名</li><li>javaType：该属性的类型</li></ul><pre><code class="xml">&lt;resultMap id=&quot;empAndDeptResultMapTwo&quot; type=&quot;Emp&quot;&gt;    &lt;id property=&quot;eid&quot; column=&quot;eid&quot;&gt;&lt;/id&gt;    &lt;result property=&quot;empName&quot; column=&quot;emp_name&quot;&gt;&lt;/result&gt;    &lt;result property=&quot;age&quot; column=&quot;age&quot;&gt;&lt;/result&gt;    &lt;result property=&quot;sex&quot; column=&quot;sex&quot;&gt;&lt;/result&gt;    &lt;result property=&quot;email&quot; column=&quot;email&quot;&gt;&lt;/result&gt;    &lt;association property=&quot;dept&quot; javaType=&quot;Dept&quot;&gt;        &lt;id property=&quot;did&quot; column=&quot;did&quot;&gt;&lt;/id&gt;        &lt;result property=&quot;deptName&quot; column=&quot;dept_name&quot;&gt;&lt;/result&gt;    &lt;/association&gt;&lt;/resultMap&gt;&lt;!--Emp getEmpAndDept(@Param(&quot;eid&quot;)Integer eid);--&gt;&lt;select id=&quot;getEmpAndDept&quot; resultMap=&quot;empAndDeptResultMapTwo&quot;&gt;    select * from t_emp left join t_dept on t_emp.eid = t_dept.did where t_emp.eid = #&#123;eid&#125;&lt;/select&gt;</code></pre><h3 id="分步查询"><a href="#分步查询" class="headerlink" title="分步查询"></a>分步查询</h3><h4 id="1-查询员工信息"><a href="#1-查询员工信息" class="headerlink" title="1. 查询员工信息"></a>1. 查询员工信息</h4><ul><li>select：设置分布查询的sql的唯一标识（namespace.SQLId或mapper接口的全类名.方法名）</li><li>column：设置分步查询的条件</li></ul><pre><code class="java">//EmpMapper里的方法/** * 通过分步查询，员工及所对应的部门信息 * 分步查询第一步：查询员工信息 * @param   * @return com.atguigu.mybatis.pojo.Emp * @date 2022/2/27 20:17 */Emp getEmpAndDeptByStepOne(@Param(&quot;eid&quot;) Integer eid);</code></pre><pre><code class="xml">&lt;resultMap id=&quot;empAndDeptByStepResultMap&quot; type=&quot;Emp&quot;&gt;    &lt;id property=&quot;eid&quot; column=&quot;eid&quot;&gt;&lt;/id&gt;    &lt;result property=&quot;empName&quot; column=&quot;emp_name&quot;&gt;&lt;/result&gt;    &lt;result property=&quot;age&quot; column=&quot;age&quot;&gt;&lt;/result&gt;    &lt;result property=&quot;sex&quot; column=&quot;sex&quot;&gt;&lt;/result&gt;    &lt;result property=&quot;email&quot; column=&quot;email&quot;&gt;&lt;/result&gt;    &lt;association property=&quot;dept&quot;                 select=&quot;com.atguigu.mybatis.mapper.DeptMapper.getEmpAndDeptByStepTwo&quot;                 column=&quot;did&quot;&gt;&lt;/association&gt;&lt;/resultMap&gt;&lt;!--Emp getEmpAndDeptByStepOne(@Param(&quot;eid&quot;) Integer eid);--&gt;&lt;select id=&quot;getEmpAndDeptByStepOne&quot; resultMap=&quot;empAndDeptByStepResultMap&quot;&gt;    select * from t_emp where eid = #&#123;eid&#125;&lt;/select&gt;</code></pre><h4 id="2-查询部门信息"><a href="#2-查询部门信息" class="headerlink" title="2. 查询部门信息"></a>2. 查询部门信息</h4><pre><code class="java">//DeptMapper里的方法/** * 通过分步查询，员工及所对应的部门信息 * 分步查询第二步：通过did查询员工对应的部门信息 * @param * @return com.atguigu.mybatis.pojo.Emp * @date 2022/2/27 20:23 */Dept getEmpAndDeptByStepTwo(@Param(&quot;did&quot;) Integer did);</code></pre><pre><code class="xml">&lt;!--此处的resultMap仅是处理字段和属性的映射关系--&gt;&lt;resultMap id=&quot;EmpAndDeptByStepTwoResultMap&quot; type=&quot;Dept&quot;&gt;    &lt;id property=&quot;did&quot; column=&quot;did&quot;&gt;&lt;/id&gt;    &lt;result property=&quot;deptName&quot; column=&quot;dept_name&quot;&gt;&lt;/result&gt;&lt;/resultMap&gt;&lt;!--Dept getEmpAndDeptByStepTwo(@Param(&quot;did&quot;) Integer did);--&gt;&lt;select id=&quot;getEmpAndDeptByStepTwo&quot; resultMap=&quot;EmpAndDeptByStepTwoResultMap&quot;&gt;    select * from t_dept where did = #&#123;did&#125;&lt;/select&gt;</code></pre><h2 id="一对多映射处理"><a href="#一对多映射处理" class="headerlink" title="一对多映射处理"></a>一对多映射处理</h2><pre><code class="java">public class Dept &#123;    private Integer did;    private String deptName;    private List&lt;Emp&gt; emps;    //...构造器、get、set方法等&#125;</code></pre><h3 id="collection"><a href="#collection" class="headerlink" title="collection"></a>collection</h3><ul><li>collection：用来处理一对多的映射关系</li><li>ofType：表示该属性对饮的集合中存储的数据的类型</li></ul><pre><code class="xml">&lt;resultMap id=&quot;DeptAndEmpResultMap&quot; type=&quot;Dept&quot;&gt;    &lt;id property=&quot;did&quot; column=&quot;did&quot;&gt;&lt;/id&gt;    &lt;result property=&quot;deptName&quot; column=&quot;dept_name&quot;&gt;&lt;/result&gt;    &lt;collection property=&quot;emps&quot; ofType=&quot;Emp&quot;&gt;        &lt;id property=&quot;eid&quot; column=&quot;eid&quot;&gt;&lt;/id&gt;        &lt;result property=&quot;empName&quot; column=&quot;emp_name&quot;&gt;&lt;/result&gt;        &lt;result property=&quot;age&quot; column=&quot;age&quot;&gt;&lt;/result&gt;        &lt;result property=&quot;sex&quot; column=&quot;sex&quot;&gt;&lt;/result&gt;        &lt;result property=&quot;email&quot; column=&quot;email&quot;&gt;&lt;/result&gt;    &lt;/collection&gt;&lt;/resultMap&gt;&lt;!--Dept getDeptAndEmp(@Param(&quot;did&quot;) Integer did);--&gt;&lt;select id=&quot;getDeptAndEmp&quot; resultMap=&quot;DeptAndEmpResultMap&quot;&gt;    select * from t_dept left join t_emp on t_dept.did = t_emp.did where t_dept.did = #&#123;did&#125;&lt;/select&gt;</code></pre><h3 id="分步查询-1"><a href="#分步查询-1" class="headerlink" title="分步查询"></a>分步查询</h3><h4 id="1-查询部门信息"><a href="#1-查询部门信息" class="headerlink" title="1. 查询部门信息"></a>1. 查询部门信息</h4><pre><code class="java">/** * 通过分步查询，查询部门及对应的所有员工信息 * 分步查询第一步：查询部门信息 * @param did  * @return com.atguigu.mybatis.pojo.Dept * @date 2022/2/27 22:04 */Dept getDeptAndEmpByStepOne(@Param(&quot;did&quot;) Integer did);</code></pre><pre><code class="xml">&lt;resultMap id=&quot;DeptAndEmpByStepOneResultMap&quot; type=&quot;Dept&quot;&gt;    &lt;id property=&quot;did&quot; column=&quot;did&quot;&gt;&lt;/id&gt;    &lt;result property=&quot;deptName&quot; column=&quot;dept_name&quot;&gt;&lt;/result&gt;    &lt;collection property=&quot;emps&quot;                select=&quot;com.atguigu.mybatis.mapper.EmpMapper.getDeptAndEmpByStepTwo&quot;                column=&quot;did&quot;&gt;&lt;/collection&gt;&lt;/resultMap&gt;&lt;!--Dept getDeptAndEmpByStepOne(@Param(&quot;did&quot;) Integer did);--&gt;&lt;select id=&quot;getDeptAndEmpByStepOne&quot; resultMap=&quot;DeptAndEmpByStepOneResultMap&quot;&gt;    select * from t_dept where did = #&#123;did&#125;&lt;/select&gt;</code></pre><h4 id="2-根据部门id查询部门中的所有员工"><a href="#2-根据部门id查询部门中的所有员工" class="headerlink" title="2. 根据部门id查询部门中的所有员工"></a>2. 根据部门id查询部门中的所有员工</h4><pre><code class="java">/** * 通过分步查询，查询部门及对应的所有员工信息 * 分步查询第二步：根据部门id查询部门中的所有员工 * @param did * @return java.util.List&lt;com.atguigu.mybatis.pojo.Emp&gt; * @date 2022/2/27 22:10 */List&lt;Emp&gt; getDeptAndEmpByStepTwo(@Param(&quot;did&quot;) Integer did);</code></pre><pre><code class="xml">&lt;!--List&lt;Emp&gt; getDeptAndEmpByStepTwo(@Param(&quot;did&quot;) Integer did);--&gt;&lt;select id=&quot;getDeptAndEmpByStepTwo&quot; resultType=&quot;Emp&quot;&gt;    select * from t_emp where did = #&#123;did&#125;&lt;/select&gt;</code></pre><h2 id="延迟加载"><a href="#延迟加载" class="headerlink" title="延迟加载"></a>延迟加载</h2><ul><li>分步查询的优点：可以实现延迟加载，但是必须在核心配置文件中设置全局配置信息：<ul><li>lazyLoadingEnabled：延迟加载的全局开关。当开启时，所有关联对象都会延迟加载  </li><li>aggressiveLazyLoading：当开启时，任何方法的调用都会加载该对象的所有属性。 否则，每个属性会按需加载</li></ul></li><li>此时就可以实现按需加载，获取的数据是什么，就只会执行相应的sql。此时可通过association和collection中的fetchType属性设置当前的分步查询是否使用延迟加载，fetchType&#x3D;”lazy(延迟加载)|eager(立即加载)”</li></ul><pre><code class="xml">&lt;settings&gt;    &lt;!--开启延迟加载--&gt;    &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt;&lt;/settings&gt;</code></pre><pre><code class="java">@Testpublic void getEmpAndDeptByStepOne() &#123;    SqlSession sqlSession = SqlSessionUtils.getSqlSession();    EmpMapper mapper = sqlSession.getMapper(EmpMapper.class);    Emp emp = mapper.getEmpAndDeptByStepOne(1);    System.out.println(emp.getEmpName());&#125;</code></pre><ul><li>关闭延迟加载，两条SQL语句都运行了</li><li>开启延迟加载，只运行获取emp的SQL语句</li></ul><pre><code class="java">@Testpublic void getEmpAndDeptByStepOne() &#123;    SqlSession sqlSession = SqlSessionUtils.getSqlSession();    EmpMapper mapper = sqlSession.getMapper(EmpMapper.class);    Emp emp = mapper.getEmpAndDeptByStepOne(1);    System.out.println(emp.getEmpName());    System.out.println(&quot;----------------&quot;);    System.out.println(emp.getDept());&#125;</code></pre><ul><li><p>开启后，需要用到查询dept的时候才会调用相应的SQL语句</p></li><li><p>fetchType：当开启了全局的延迟加载之后，可以通过该属性手动控制延迟加载的效果，fetchType&#x3D;”lazy(延迟加载)|eager(立即加载)”</p><pre><code class="xml">&lt;resultMap id=&quot;empAndDeptByStepResultMap&quot; type=&quot;Emp&quot;&gt;    &lt;id property=&quot;eid&quot; column=&quot;eid&quot;&gt;&lt;/id&gt;    &lt;result property=&quot;empName&quot; column=&quot;emp_name&quot;&gt;&lt;/result&gt;    &lt;result property=&quot;age&quot; column=&quot;age&quot;&gt;&lt;/result&gt;    &lt;result property=&quot;sex&quot; column=&quot;sex&quot;&gt;&lt;/result&gt;    &lt;result property=&quot;email&quot; column=&quot;email&quot;&gt;&lt;/result&gt;    &lt;association property=&quot;dept&quot;                 select=&quot;com.atguigu.mybatis.mapper.DeptMapper.getEmpAndDeptByStepTwo&quot;                 column=&quot;did&quot;                 fetchType=&quot;lazy&quot;&gt;&lt;/association&gt;&lt;/resultMap&gt;</code></pre></li></ul><h1 id="动态SQL"><a href="#动态SQL" class="headerlink" title="动态SQL"></a>动态SQL</h1><ul><li>Mybatis框架的动态SQL技术是一种根据特定条件动态拼装SQL语句的功能，它存在的意义是为了解决拼接SQL语句字符串时的痛点问题</li></ul><h2 id="if"><a href="#if" class="headerlink" title="if"></a>if</h2><ul><li>if标签可通过test属性（即传递过来的数据）的表达式进行判断，若表达式的结果为true，则标签中的内容会执行；反之标签中的内容不会执行</li><li>在where后面添加一个恒成立条件<code>1=1</code><ul><li>这个恒成立条件并不会影响查询的结果</li><li>这个<code>1=1</code>可以用来拼接<code>and</code>语句，例如：当empName为null时<ul><li>如果不加上恒成立条件，则SQL语句为<code>select * from t_emp where and age = ? and sex = ? and email = ?</code>，此时<code>where</code>会与<code>and</code>连用，SQL语句会报错</li><li>如果加上一个恒成立条件，则SQL语句为<code>select * from t_emp where 1= 1 and age = ? and sex = ? and email = ?</code>，此时不报错</li></ul></li></ul></li></ul><pre><code class="xml">&lt;!--List&lt;Emp&gt; getEmpByCondition(Emp emp);--&gt;&lt;select id=&quot;getEmpByCondition&quot; resultType=&quot;Emp&quot;&gt;    select * from t_emp where 1=1    &lt;if test=&quot;empName != null and empName !=&#39;&#39;&quot;&gt;        and emp_name = #&#123;empName&#125;    &lt;/if&gt;    &lt;if test=&quot;age != null and age !=&#39;&#39;&quot;&gt;        and age = #&#123;age&#125;    &lt;/if&gt;    &lt;if test=&quot;sex != null and sex !=&#39;&#39;&quot;&gt;        and sex = #&#123;sex&#125;    &lt;/if&gt;    &lt;if test=&quot;email != null and email !=&#39;&#39;&quot;&gt;        and email = #&#123;email&#125;    &lt;/if&gt;&lt;/select&gt;</code></pre><h2 id="where"><a href="#where" class="headerlink" title="where"></a>where</h2><ul><li>where和if一般结合使用：<ul><li>若where标签中的if条件都不满足，则where标签没有任何功能，即不会添加where关键字  </li><li>若where标签中的if条件满足，则where标签会自动添加where关键字，并将条件最前方多余的and&#x2F;or去掉</li></ul></li></ul><pre><code class="xml">&lt;!--List&lt;Emp&gt; getEmpByCondition(Emp emp);--&gt;&lt;select id=&quot;getEmpByCondition&quot; resultType=&quot;Emp&quot;&gt;    select * from t_emp    &lt;where&gt;        &lt;if test=&quot;empName != null and empName !=&#39;&#39;&quot;&gt;            emp_name = #&#123;empName&#125;        &lt;/if&gt;        &lt;if test=&quot;age != null and age !=&#39;&#39;&quot;&gt;            and age = #&#123;age&#125;        &lt;/if&gt;        &lt;if test=&quot;sex != null and sex !=&#39;&#39;&quot;&gt;            and sex = #&#123;sex&#125;        &lt;/if&gt;        &lt;if test=&quot;email != null and email !=&#39;&#39;&quot;&gt;            and email = #&#123;email&#125;        &lt;/if&gt;    &lt;/where&gt;&lt;/select&gt;</code></pre><ul><li><p>注意：where标签不能去掉条件后多余的and&#x2F;or</p><pre><code class="xml">&lt;!--这种用法是错误的，只能去掉条件前面的and/or，条件后面的不行--&gt;&lt;if test=&quot;empName != null and empName !=&#39;&#39;&quot;&gt;emp_name = #&#123;empName&#125; and&lt;/if&gt;&lt;if test=&quot;age != null and age !=&#39;&#39;&quot;&gt;    age = #&#123;age&#125;&lt;/if&gt;</code></pre></li></ul><h2 id="trim"><a href="#trim" class="headerlink" title="trim"></a>trim</h2><ul><li>trim用于去掉或添加标签中的内容  </li><li>常用属性<ul><li>prefix：在trim标签中的内容的前面添加某些内容  </li><li>suffix：在trim标签中的内容的后面添加某些内容 </li><li>prefixOverrides：在trim标签中的内容的前面去掉某些内容  </li><li>suffixOverrides：在trim标签中的内容的后面去掉某些内容</li></ul></li><li>若trim中的标签都不满足条件，则trim标签没有任何效果，也就是只剩下<code>select * from t_emp</code></li></ul><pre><code class="xml">&lt;!--List&lt;Emp&gt; getEmpByCondition(Emp emp);--&gt;&lt;select id=&quot;getEmpByCondition&quot; resultType=&quot;Emp&quot;&gt;    select * from t_emp    &lt;trim prefix=&quot;where&quot; suffixOverrides=&quot;and|or&quot;&gt;        &lt;if test=&quot;empName != null and empName !=&#39;&#39;&quot;&gt;            emp_name = #&#123;empName&#125; and        &lt;/if&gt;        &lt;if test=&quot;age != null and age !=&#39;&#39;&quot;&gt;            age = #&#123;age&#125; and        &lt;/if&gt;        &lt;if test=&quot;sex != null and sex !=&#39;&#39;&quot;&gt;            sex = #&#123;sex&#125; or        &lt;/if&gt;        &lt;if test=&quot;email != null and email !=&#39;&#39;&quot;&gt;            email = #&#123;email&#125;        &lt;/if&gt;    &lt;/trim&gt;&lt;/select&gt;</code></pre><pre><code class="java">//测试类@Testpublic void getEmpByCondition() &#123;    SqlSession sqlSession = SqlSessionUtils.getSqlSession();    DynamicSQLMapper mapper = sqlSession.getMapper(DynamicSQLMapper.class);    List&lt;Emp&gt; emps= mapper.getEmpByCondition(new Emp(null, &quot;张三&quot;, null, null, null, null));    System.out.println(emps);&#125;</code></pre><h2 id="choose、when、otherwise"><a href="#choose、when、otherwise" class="headerlink" title="choose、when、otherwise"></a>choose、when、otherwise</h2><ul><li><code>choose、when、otherwise</code>相当于<code>if...else if..else</code></li><li>when至少要有一个，otherwise至多只有一个</li></ul><pre><code class="xml">&lt;select id=&quot;getEmpByChoose&quot; resultType=&quot;Emp&quot;&gt;    select * from t_emp    &lt;where&gt;        &lt;choose&gt;            &lt;when test=&quot;empName != null and empName != &#39;&#39;&quot;&gt;                emp_name = #&#123;empName&#125;            &lt;/when&gt;            &lt;when test=&quot;age != null and age != &#39;&#39;&quot;&gt;                age = #&#123;age&#125;            &lt;/when&gt;            &lt;when test=&quot;sex != null and sex != &#39;&#39;&quot;&gt;                sex = #&#123;sex&#125;            &lt;/when&gt;            &lt;when test=&quot;email != null and email != &#39;&#39;&quot;&gt;                email = #&#123;email&#125;            &lt;/when&gt;            &lt;otherwise&gt;                did = 1            &lt;/otherwise&gt;        &lt;/choose&gt;    &lt;/where&gt;&lt;/select&gt;</code></pre><pre><code class="java">@Testpublic void getEmpByChoose() &#123;    SqlSession sqlSession = SqlSessionUtils.getSqlSession();    DynamicSQLMapper mapper = sqlSession.getMapper(DynamicSQLMapper.class);    List&lt;Emp&gt; emps = mapper.getEmpByChoose(new Emp(null, &quot;张三&quot;, 23, &quot;男&quot;, &quot;123@qq.com&quot;, null));    System.out.println(emps);&#125;</code></pre><ul><li>相当于<code>if a else if b else if c else d</code>，只会执行其中一个</li></ul><h2 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h2><ul><li><p>属性：  </p><ul><li>collection：设置要循环的数组或集合  </li><li>item：表示集合或数组中的每一个数据  </li><li>separator：设置循环体之间的分隔符，分隔符前后默认有一个空格，如<code>,</code></li><li>open：设置foreach标签中的内容的开始符  </li><li>close：设置foreach标签中的内容的结束符</li></ul></li><li><p>批量删除</p><pre><code class="xml">&lt;!--int deleteMoreByArray(Integer[] eids);--&gt;&lt;delete id=&quot;deleteMoreByArray&quot;&gt;    delete from t_emp where eid in    &lt;foreach collection=&quot;eids&quot; item=&quot;eid&quot; separator=&quot;,&quot; open=&quot;(&quot; close=&quot;)&quot;&gt;        #&#123;eid&#125;    &lt;/foreach&gt;&lt;/delete&gt;</code></pre><pre><code class="java">@Testpublic void deleteMoreByArray() &#123;    SqlSession sqlSession = SqlSessionUtils.getSqlSession();    DynamicSQLMapper mapper = sqlSession.getMapper(DynamicSQLMapper.class);    int result = mapper.deleteMoreByArray(new Integer[]&#123;6, 7, 8, 9&#125;);    System.out.println(result);&#125;</code></pre></li><li><p>批量添加</p><pre><code class="xml">&lt;!--int insertMoreByList(@Param(&quot;emps&quot;) List&lt;Emp&gt; emps);--&gt;&lt;insert id=&quot;insertMoreByList&quot;&gt;    insert into t_emp values    &lt;foreach collection=&quot;emps&quot; item=&quot;emp&quot; separator=&quot;,&quot;&gt;        (null,#&#123;emp.empName&#125;,#&#123;emp.age&#125;,#&#123;emp.sex&#125;,#&#123;emp.email&#125;,null)    &lt;/foreach&gt;&lt;/insert&gt;</code></pre><pre><code class="java">@Testpublic void insertMoreByList() &#123;    SqlSession sqlSession = SqlSessionUtils.getSqlSession();    DynamicSQLMapper mapper = sqlSession.getMapper(DynamicSQLMapper.class);    Emp emp1 = new Emp(null,&quot;a&quot;,1,&quot;男&quot;,&quot;123@321.com&quot;,null);    Emp emp2 = new Emp(null,&quot;b&quot;,1,&quot;男&quot;,&quot;123@321.com&quot;,null);    Emp emp3 = new Emp(null,&quot;c&quot;,1,&quot;男&quot;,&quot;123@321.com&quot;,null);    List&lt;Emp&gt; emps = Arrays.asList(emp1, emp2, emp3);    int result = mapper.insertMoreByList(emps);    System.out.println(result);&#125;</code></pre></li></ul><h2 id="SQL片段"><a href="#SQL片段" class="headerlink" title="SQL片段"></a>SQL片段</h2><ul><li>sql片段，可以记录一段公共sql片段，在使用的地方通过include标签进行引入</li><li>声明sql片段：<code>&lt;sql&gt;</code>标签</li></ul><pre><code class="xml">&lt;sql id=&quot;empColumns&quot;&gt;eid,emp_name,age,sex,email&lt;/sql&gt;</code></pre><ul><li>引用sql片段：<code>&lt;include&gt;</code>标签</li></ul><pre><code class="xml">&lt;!--List&lt;Emp&gt; getEmpByCondition(Emp emp);--&gt;&lt;select id=&quot;getEmpByCondition&quot; resultType=&quot;Emp&quot;&gt;    select &lt;include refid=&quot;empColumns&quot;&gt;&lt;/include&gt; from t_emp&lt;/select&gt;</code></pre><h1 id="MyBatis的缓存"><a href="#MyBatis的缓存" class="headerlink" title="MyBatis的缓存"></a>MyBatis的缓存</h1><h2 id="MyBatis的一级缓存"><a href="#MyBatis的一级缓存" class="headerlink" title="MyBatis的一级缓存"></a>MyBatis的一级缓存</h2><ul><li><p>一级缓存是SqlSession级别的，通过同一个SqlSession查询的数据会被缓存，下次查询相同的数据，就会从缓存中直接获取，不会从数据库重新访问  </p></li><li><p>使一级缓存失效的四种情况：  </p><ol><li>不同的SqlSession对应不同的一级缓存  </li><li>同一个SqlSession但是查询条件不同</li><li>同一个SqlSession两次查询期间执行了任何一次增删改操作</li><li>同一个SqlSession两次查询期间手动清空了缓存</li></ol></li></ul><h2 id="MyBatis的二级缓存"><a href="#MyBatis的二级缓存" class="headerlink" title="MyBatis的二级缓存"></a>MyBatis的二级缓存</h2><ul><li><p>二级缓存是SqlSessionFactory级别，通过同一个SqlSessionFactory创建的SqlSession查询的结果会被缓存；此后若再次执行相同的查询语句，结果就会从缓存中获取  </p></li><li><p>二级缓存开启的条件</p><ol><li>在核心配置文件中，设置全局配置属性cacheEnabled&#x3D;”true”，默认为true，不需要设置</li><li>在映射文件中设置标签<cache /></li><li>二级缓存必须在SqlSession关闭或提交之后有效</li><li>查询的数据所转换的实体类类型必须实现序列化的接口</li></ol></li><li><p>使二级缓存失效的情况：两次查询之间执行了任意的增删改，会使一级和二级缓存同时失效</p></li></ul><h2 id="二级缓存的相关配置"><a href="#二级缓存的相关配置" class="headerlink" title="二级缓存的相关配置"></a>二级缓存的相关配置</h2><ul><li>在mapper配置文件中添加的cache标签可以设置一些属性</li><li>eviction属性：缓存回收策略  <ul><li>LRU（Least Recently Used） – 最近最少使用的：移除最长时间不被使用的对象。  </li><li>FIFO（First in First out） – 先进先出：按对象进入缓存的顺序来移除它们。  </li><li>SOFT – 软引用：移除基于垃圾回收器状态和软引用规则的对象。  </li><li>WEAK – 弱引用：更积极地移除基于垃圾收集器状态和弱引用规则的对象。</li><li>默认的是 LRU</li></ul></li><li>flushInterval属性：刷新间隔，单位毫秒<ul><li>默认情况是不设置，也就是没有刷新间隔，缓存仅仅调用语句（增删改）时刷新</li></ul></li><li>size属性：引用数目，正整数<ul><li>代表缓存最多可以存储多少个对象，太大容易导致内存溢出</li></ul></li><li>readOnly属性：只读，true&#x2F;false<ul><li>true：只读缓存；会给所有调用者返回缓存对象的相同实例。因此这些对象不能被修改。这提供了很重要的性能优势。  </li><li>false：读写缓存；会返回缓存对象的拷贝（通过序列化）。这会慢一些，但是安全，因此默认是false</li></ul></li></ul><h2 id="MyBatis缓存查询的顺序"><a href="#MyBatis缓存查询的顺序" class="headerlink" title="MyBatis缓存查询的顺序"></a>MyBatis缓存查询的顺序</h2><ul><li>先查询二级缓存，因为二级缓存中可能会有其他程序已经查出来的数据，可以拿来直接使用  </li><li>如果二级缓存没有命中，再查询一级缓存  </li><li>如果一级缓存也没有命中，则查询数据库  </li><li>SqlSession关闭之后，一级缓存中的数据会写入二级缓存</li></ul><h2 id="整合第三方缓存EHCache（了解）"><a href="#整合第三方缓存EHCache（了解）" class="headerlink" title="整合第三方缓存EHCache（了解）"></a>整合第三方缓存EHCache（了解）</h2><h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><pre><code class="xml">&lt;!-- Mybatis EHCache整合包 --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.mybatis.caches&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-ehcache&lt;/artifactId&gt;    &lt;version&gt;1.2.1&lt;/version&gt;&lt;/dependency&gt;&lt;!-- slf4j日志门面的一个具体实现 --&gt;&lt;dependency&gt;    &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;    &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;    &lt;version&gt;1.2.3&lt;/version&gt;&lt;/dependency&gt;</code></pre><h3 id="各个jar包的功能"><a href="#各个jar包的功能" class="headerlink" title="各个jar包的功能"></a>各个jar包的功能</h3><table><thead><tr><th>jar包名称</th><th>作用</th></tr></thead><tbody><tr><td>mybatis-ehcache</td><td>Mybatis和EHCache的整合包</td></tr><tr><td>ehcache</td><td>EHCache核心包</td></tr><tr><td>slf4j-api</td><td>SLF4J日志门面包</td></tr><tr><td>logback-classic</td><td>支持SLF4J门面接口的一个具体实现</td></tr></tbody></table><h3 id="创建EHCache的配置文件ehcache-xml"><a href="#创建EHCache的配置文件ehcache-xml" class="headerlink" title="创建EHCache的配置文件ehcache.xml"></a>创建EHCache的配置文件ehcache.xml</h3><ul><li>名字必须叫<code>ehcache.xml</code></li></ul><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;&lt;ehcache xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:noNamespaceSchemaLocation=&quot;../config/ehcache.xsd&quot;&gt;    &lt;!-- 磁盘保存路径 --&gt;    &lt;diskStore path=&quot;D:\atguigu\ehcache&quot;/&gt;    &lt;defaultCache            maxElementsInMemory=&quot;1000&quot;            maxElementsOnDisk=&quot;10000000&quot;            eternal=&quot;false&quot;            overflowToDisk=&quot;true&quot;            timeToIdleSeconds=&quot;120&quot;            timeToLiveSeconds=&quot;120&quot;            diskExpiryThreadIntervalSeconds=&quot;120&quot;            memoryStoreEvictionPolicy=&quot;LRU&quot;&gt;    &lt;/defaultCache&gt;&lt;/ehcache&gt;</code></pre><h3 id="设置二级缓存的类型"><a href="#设置二级缓存的类型" class="headerlink" title="设置二级缓存的类型"></a>设置二级缓存的类型</h3><ul><li>在xxxMapper.xml文件中设置二级缓存类型</li></ul><pre><code class="xml">&lt;cache type=&quot;org.mybatis.caches.ehcache.EhcacheCache&quot;/&gt;</code></pre><h3 id="加入logback日志"><a href="#加入logback日志" class="headerlink" title="加入logback日志"></a>加入logback日志</h3><ul><li>存在SLF4J时，作为简易日志的log4j将失效，此时我们需要借助SLF4J的具体实现logback来打印日志。创建logback的配置文件<code>logback.xml</code>，名字固定，不可改变</li></ul><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;configuration debug=&quot;true&quot;&gt;    &lt;!-- 指定日志输出的位置 --&gt;    &lt;appender name=&quot;STDOUT&quot;              class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;        &lt;encoder&gt;            &lt;!-- 日志输出的格式 --&gt;            &lt;!-- 按照顺序分别是：时间、日志级别、线程名称、打印日志的类、日志主体内容、换行 --&gt;            &lt;pattern&gt;[%d&#123;HH:mm:ss.SSS&#125;] [%-5level] [%thread] [%logger] [%msg]%n&lt;/pattern&gt;        &lt;/encoder&gt;    &lt;/appender&gt;    &lt;!-- 设置全局日志级别。日志级别按顺序分别是：DEBUG、INFO、WARN、ERROR --&gt;    &lt;!-- 指定任何一个日志级别都只打印当前级别和后面级别的日志。 --&gt;    &lt;root level=&quot;DEBUG&quot;&gt;        &lt;!-- 指定打印日志的appender，这里通过“STDOUT”引用了前面配置的appender --&gt;        &lt;appender-ref ref=&quot;STDOUT&quot; /&gt;    &lt;/root&gt;    &lt;!-- 根据特殊需求指定局部日志级别 --&gt;    &lt;logger name=&quot;com.atguigu.crowd.mapper&quot; level=&quot;DEBUG&quot;/&gt;&lt;/configuration&gt;</code></pre><h3 id="EHCache配置文件说明"><a href="#EHCache配置文件说明" class="headerlink" title="EHCache配置文件说明"></a>EHCache配置文件说明</h3><table><thead><tr><th>属性名</th><th>是否必须</th><th>作用</th></tr></thead><tbody><tr><td>maxElementsInMemory</td><td>是</td><td>在内存中缓存的element的最大数目</td></tr><tr><td>maxElementsOnDisk</td><td>是</td><td>在磁盘上缓存的element的最大数目，若是0表示无穷大</td></tr><tr><td>eternal</td><td>是</td><td>设定缓存的elements是否永远不过期。 如果为true，则缓存的数据始终有效， 如果为false那么还要根据timeToIdleSeconds、timeToLiveSeconds判断</td></tr><tr><td>overflowToDisk</td><td>是</td><td>设定当内存缓存溢出的时候是否将过期的element缓存到磁盘上</td></tr><tr><td>timeToIdleSeconds</td><td>否</td><td>当缓存在EhCache中的数据前后两次访问的时间超过timeToIdleSeconds的属性取值时， 这些数据便会删除，默认值是0,也就是可闲置时间无穷大</td></tr><tr><td>timeToLiveSeconds</td><td>否</td><td>缓存element的有效生命期，默认是0.,也就是element存活时间无穷大</td></tr><tr><td>diskSpoolBufferSizeMB</td><td>否</td><td>DiskStore(磁盘缓存)的缓存区大小。默认是30MB。每个Cache都应该有自己的一个缓冲区</td></tr><tr><td>diskPersistent</td><td>否</td><td>在VM重启的时候是否启用磁盘保存EhCache中的数据，默认是false</td></tr><tr><td>diskExpiryThreadIntervalSeconds</td><td>否</td><td>磁盘缓存的清理线程运行间隔，默认是120秒。每个120s， 相应的线程会进行一次EhCache中数据的清理工作</td></tr><tr><td>memoryStoreEvictionPolicy</td><td>否</td><td>当内存缓存达到最大，有新的element加入的时候， 移除缓存中element的策略。 默认是LRU（最近最少使用），可选的有LFU（最不常使用）和FIFO（先进先出</td></tr></tbody></table><h1 id="MyBatis的逆向工程"><a href="#MyBatis的逆向工程" class="headerlink" title="MyBatis的逆向工程"></a>MyBatis的逆向工程</h1><ul><li>正向工程：先创建Java实体类，由框架负责根据实体类生成数据库表。Hibernate是支持正向工程的</li><li>逆向工程：先创建数据库表，由框架负责根据数据库表，反向生成如下资源：  <ul><li>Java实体类  </li><li>Mapper接口  </li><li>Mapper映射文件</li></ul></li></ul><h2 id="创建逆向工程的步骤"><a href="#创建逆向工程的步骤" class="headerlink" title="创建逆向工程的步骤"></a>创建逆向工程的步骤</h2><h3 id="添加依赖和插件"><a href="#添加依赖和插件" class="headerlink" title="添加依赖和插件"></a>添加依赖和插件</h3><pre><code class="xml">&lt;dependencies&gt;    &lt;!-- MyBatis核心依赖包 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.mybatis&lt;/groupId&gt;        &lt;artifactId&gt;mybatis&lt;/artifactId&gt;        &lt;version&gt;3.5.9&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- junit测试 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;junit&lt;/groupId&gt;        &lt;artifactId&gt;junit&lt;/artifactId&gt;        &lt;version&gt;4.13.2&lt;/version&gt;        &lt;scope&gt;test&lt;/scope&gt;    &lt;/dependency&gt;    &lt;!-- MySQL驱动 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;mysql&lt;/groupId&gt;        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;        &lt;version&gt;8.0.27&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- log4j日志 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;log4j&lt;/groupId&gt;        &lt;artifactId&gt;log4j&lt;/artifactId&gt;        &lt;version&gt;1.2.17&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;&lt;!-- 控制Maven在构建过程中相关配置 --&gt;&lt;build&gt;    &lt;!-- 构建过程中用到的插件 --&gt;    &lt;plugins&gt;        &lt;!-- 具体插件，逆向工程的操作是以构建过程中插件形式出现的 --&gt;        &lt;plugin&gt;            &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;            &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt;            &lt;version&gt;1.3.0&lt;/version&gt;            &lt;!-- 插件的依赖 --&gt;            &lt;dependencies&gt;                &lt;!-- 逆向工程的核心依赖 --&gt;                &lt;dependency&gt;                    &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;                    &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt;                    &lt;version&gt;1.3.2&lt;/version&gt;                &lt;/dependency&gt;                &lt;!-- 数据库连接池 --&gt;                &lt;dependency&gt;                    &lt;groupId&gt;com.mchange&lt;/groupId&gt;                    &lt;artifactId&gt;c3p0&lt;/artifactId&gt;                    &lt;version&gt;0.9.2&lt;/version&gt;                &lt;/dependency&gt;                &lt;!-- MySQL驱动 --&gt;                &lt;dependency&gt;                    &lt;groupId&gt;mysql&lt;/groupId&gt;                    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;                    &lt;version&gt;8.0.27&lt;/version&gt;                &lt;/dependency&gt;            &lt;/dependencies&gt;        &lt;/plugin&gt;    &lt;/plugins&gt;&lt;/build&gt;</code></pre><h3 id="创建MyBatis的核心配置文件-1"><a href="#创建MyBatis的核心配置文件-1" class="headerlink" title="创建MyBatis的核心配置文件"></a>创建MyBatis的核心配置文件</h3><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;    &lt;properties resource=&quot;jdbc.properties&quot;/&gt;    &lt;typeAliases&gt;        &lt;package name=&quot;&quot;/&gt;    &lt;/typeAliases&gt;    &lt;environments default=&quot;development&quot;&gt;        &lt;environment id=&quot;development&quot;&gt;            &lt;transactionManager type=&quot;JDBC&quot;/&gt;            &lt;dataSource type=&quot;POOLED&quot;&gt;                &lt;property name=&quot;driver&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt;                &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt;                &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt;                &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt;            &lt;/dataSource&gt;        &lt;/environment&gt;    &lt;/environments&gt;    &lt;mappers&gt;        &lt;package name=&quot;&quot;/&gt;    &lt;/mappers&gt;&lt;/configuration&gt;</code></pre><h3 id="创建逆向工程的配置文件"><a href="#创建逆向工程的配置文件" class="headerlink" title="创建逆向工程的配置文件"></a>创建逆向工程的配置文件</h3><ul><li>文件名必须是：<code>generatorConfig.xml</code></li></ul><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE generatorConfiguration        PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;&lt;generatorConfiguration&gt;    &lt;!--    targetRuntime: 执行生成的逆向工程的版本    MyBatis3Simple: 生成基本的CRUD（清新简洁版）    MyBatis3: 生成带条件的CRUD（奢华尊享版）    --&gt;    &lt;context id=&quot;DB2Tables&quot; targetRuntime=&quot;MyBatis3Simple&quot;&gt;        &lt;!-- 数据库的连接信息 --&gt;        &lt;jdbcConnection driverClass=&quot;com.mysql.cj.jdbc.Driver&quot;                        connectionURL=&quot;jdbc:mysql://localhost:3306/mybatis&quot;                        userId=&quot;root&quot;                        password=&quot;123456&quot;&gt;        &lt;/jdbcConnection&gt;        &lt;!-- javaBean的生成策略--&gt;        &lt;javaModelGenerator targetPackage=&quot;com.atguigu.mybatis.pojo&quot; targetProject=&quot;.\src\main\java&quot;&gt;            &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot; /&gt;            &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot; /&gt;        &lt;/javaModelGenerator&gt;        &lt;!-- SQL映射文件的生成策略 --&gt;        &lt;sqlMapGenerator targetPackage=&quot;com.atguigu.mybatis.mapper&quot;                         targetProject=&quot;.\src\main\resources&quot;&gt;            &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot; /&gt;        &lt;/sqlMapGenerator&gt;        &lt;!-- Mapper接口的生成策略 --&gt;        &lt;javaClientGenerator type=&quot;XMLMAPPER&quot;                             targetPackage=&quot;com.atguigu.mybatis.mapper&quot; targetProject=&quot;.\src\main\java&quot;&gt;            &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot; /&gt;        &lt;/javaClientGenerator&gt;        &lt;!-- 逆向分析的表 --&gt;        &lt;!-- tableName设置为*号，可以对应所有表，此时不写domainObjectName --&gt;        &lt;!-- domainObjectName属性指定生成出来的实体类的类名 --&gt;        &lt;table tableName=&quot;t_emp&quot; domainObjectName=&quot;Emp&quot;/&gt;        &lt;table tableName=&quot;t_dept&quot; domainObjectName=&quot;Dept&quot;/&gt;    &lt;/context&gt;&lt;/generatorConfiguration&gt;</code></pre><h3 id="执行MBG插件的generate目标"><a href="#执行MBG插件的generate目标" class="headerlink" title="执行MBG插件的generate目标"></a>执行MBG插件的generate目标</h3><ul><li><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221107231950968.png" alt="image-20221107231950968"></p></li><li><p>如果出现报错：<code>Exception getting JDBC Driver</code>，可能是pom.xml中，数据库驱动配置错误</p><ul><li>dependency中的驱动</li><li>mybatis-generator-maven-plugin插件中的驱动</li><li>两者的驱动版本应该相同</li></ul></li><li><p>执行结果</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/image-20221107232112040.png" alt="image-20221107232112040"></p></li></ul><h2 id="QBC"><a href="#QBC" class="headerlink" title="QBC"></a>QBC</h2><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><ul><li><code>selectByExample</code>：按条件查询，需要传入一个example对象或者null；如果传入一个null，则表示没有条件，也就是查询所有数据</li><li><code>example.createCriteria().xxx</code>：创建条件对象，通过andXXX方法为SQL添加查询添加，每个条件之间是and关系</li><li><code>example.or().xxx</code>：将之前添加的条件通过or拼接其他条件</li></ul><pre><code class="java">@Test public void testMBG() throws IOException &#123;    InputStream is = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;);    SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder();    SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(is);    SqlSession sqlSession = sqlSessionFactory.openSession(true);    EmpMapper mapper = sqlSession.getMapper(EmpMapper.class);    EmpExample example = new EmpExample();    //名字为张三，且年龄大于等于20    example.createCriteria().andEmpNameEqualTo(&quot;张三&quot;).andAgeGreaterThanOrEqualTo(20);    //或者did不为空    example.or().andDidIsNotNull();    List&lt;Emp&gt; emps = mapper.selectByExample(example);    emps.forEach(System.out::println);&#125;</code></pre><h3 id="增改"><a href="#增改" class="headerlink" title="增改"></a>增改</h3><ul><li><code>updateByPrimaryKey</code>：通过主键进行数据修改，如果某一个值为null，也会将对应的字段改为null</li><li><code>mapper.updateByPrimaryKey(new Emp(1,&quot;admin&quot;,22,null,&quot;456@qq.com&quot;,3));</code></li><li><code>updateByPrimaryKeySelective()</code>：通过主键进行选择性数据修改，如果某个值为null，则不修改这个字段</li><li><code>mapper.updateByPrimaryKeySelective(new Emp(2,&quot;admin2&quot;,22,null,&quot;456@qq.com&quot;,3));</code></li></ul><h1 id="分页插件"><a href="#分页插件" class="headerlink" title="分页插件"></a>分页插件</h1><h2 id="分页插件使用步骤"><a href="#分页插件使用步骤" class="headerlink" title="分页插件使用步骤"></a>分页插件使用步骤</h2><h3 id="添加依赖-1"><a href="#添加依赖-1" class="headerlink" title="添加依赖"></a>添加依赖</h3><pre><code class="xml">&lt;!-- https://mvnrepository.com/artifact/com.github.pagehelper/pagehelper --&gt;&lt;dependency&gt;    &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;    &lt;artifactId&gt;pagehelper&lt;/artifactId&gt;    &lt;version&gt;5.2.0&lt;/version&gt;&lt;/dependency&gt;</code></pre><h3 id="配置分页插件"><a href="#配置分页插件" class="headerlink" title="配置分页插件"></a>配置分页插件</h3><ul><li>在MyBatis的核心配置文件（mybatis-config.xml）中配置插件</li></ul><pre><code class="xml">&lt;plugins&gt;    &lt;!--设置分页插件--&gt;    &lt;plugin interceptor=&quot;com.github.pagehelper.PageInterceptor&quot;&gt;&lt;/plugin&gt;&lt;/plugins&gt;</code></pre><h2 id="分页插件的使用"><a href="#分页插件的使用" class="headerlink" title="分页插件的使用"></a>分页插件的使用</h2><h3 id="开启分页功能"><a href="#开启分页功能" class="headerlink" title="开启分页功能"></a>开启分页功能</h3><ul><li>在查询功能之前使用<code>PageHelper.startPage(int pageNum, int pageSize)</code>开启分页功能<ul><li>pageNum：当前页的页码  </li><li>pageSize：每页显示的条数</li></ul></li></ul><pre><code class="java">@Testpublic void testPageHelper() throws IOException &#123;    InputStream is = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;);    SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder();    SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(is);    SqlSession sqlSession = sqlSessionFactory.openSession(true);    EmpMapper mapper = sqlSession.getMapper(EmpMapper.class);    //访问第一页，每页四条数据    PageHelper.startPage(1,4);    List&lt;Emp&gt; emps = mapper.selectByExample(null);    emps.forEach(System.out::println);&#125;</code></pre><h3 id="分页相关数据"><a href="#分页相关数据" class="headerlink" title="分页相关数据"></a>分页相关数据</h3><h4 id="方法一：直接输出"><a href="#方法一：直接输出" class="headerlink" title="方法一：直接输出"></a>方法一：直接输出</h4><pre><code class="java">@Testpublic void testPageHelper() throws IOException &#123;    InputStream is = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;);    SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder();    SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(is);    SqlSession sqlSession = sqlSessionFactory.openSession(true);    EmpMapper mapper = sqlSession.getMapper(EmpMapper.class);    //访问第一页，每页四条数据    Page&lt;Object&gt; page = PageHelper.startPage(1, 4);    List&lt;Emp&gt; emps = mapper.selectByExample(null);    //在查询到List集合后，打印分页数据    System.out.println(page);&#125;</code></pre><ul><li><p>分页相关数据：</p><pre><code>Page&#123;count=true, pageNum=1, pageSize=4, startRow=0, endRow=4, total=8, pages=2, reasonable=false, pageSizeZero=false&#125;[Emp&#123;eid=1, empName=&#39;admin&#39;, age=22, sex=&#39;男&#39;, email=&#39;456@qq.com&#39;, did=3&#125;, Emp&#123;eid=2, empName=&#39;admin2&#39;, age=22, sex=&#39;男&#39;, email=&#39;456@qq.com&#39;, did=3&#125;, Emp&#123;eid=3, empName=&#39;王五&#39;, age=12, sex=&#39;女&#39;, email=&#39;123@qq.com&#39;, did=3&#125;, Emp&#123;eid=4, empName=&#39;赵六&#39;, age=32, sex=&#39;男&#39;, email=&#39;123@qq.com&#39;, did=1&#125;]</code></pre></li></ul><h4 id="方法二使用PageInfo"><a href="#方法二使用PageInfo" class="headerlink" title="方法二使用PageInfo"></a>方法二使用PageInfo</h4><ul><li>在查询获取list集合之后，使用<code>PageInfo&lt;T&gt; pageInfo = new PageInfo&lt;&gt;(List&lt;T&gt; list, intnavigatePages)</code>获取分页相关数据<ul><li>list：分页之后的数据  </li><li>navigatePages：导航分页的页码数</li></ul></li></ul><pre><code class="java">@Testpublic void testPageHelper() throws IOException &#123;    InputStream is = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;);    SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder();    SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(is);    SqlSession sqlSession = sqlSessionFactory.openSession(true);    EmpMapper mapper = sqlSession.getMapper(EmpMapper.class);    PageHelper.startPage(1, 4);    List&lt;Emp&gt; emps = mapper.selectByExample(null);    PageInfo&lt;Emp&gt; page = new PageInfo&lt;&gt;(emps,5);    System.out.println(page);&#125;</code></pre><ul><li><p>分页相关数据：</p><pre><code>PageInfo&#123;pageNum=1, pageSize=4, size=4, startRow=1, endRow=4, total=8, pages=2, list=Page&#123;count=true, pageNum=1, pageSize=4, startRow=0, endRow=4, total=8, pages=2, reasonable=false, pageSizeZero=false&#125;[Emp&#123;eid=1, empName=&#39;admin&#39;, age=22, sex=&#39;男&#39;, email=&#39;456@qq.com&#39;, did=3&#125;, Emp&#123;eid=2, empName=&#39;admin2&#39;, age=22, sex=&#39;男&#39;, email=&#39;456@qq.com&#39;, did=3&#125;, Emp&#123;eid=3, empName=&#39;王五&#39;, age=12, sex=&#39;女&#39;, email=&#39;123@qq.com&#39;, did=3&#125;, Emp&#123;eid=4, empName=&#39;赵六&#39;, age=32, sex=&#39;男&#39;, email=&#39;123@qq.com&#39;, did=1&#125;], prePage=0, nextPage=2, isFirstPage=true, isLastPage=false, hasPreviousPage=false, hasNextPage=true, navigatePages=5, navigateFirstPage=1, navigateLastPage=2, navigatepageNums=[1, 2]&#125;</code></pre></li><li><p>其中list中的数据等同于方法一中直接输出的page数据</p></li></ul><h4 id="常用数据："><a href="#常用数据：" class="headerlink" title="常用数据："></a>常用数据：</h4><ul><li>pageNum：当前页的页码  </li><li>pageSize：每页显示的条数  </li><li>size：当前页显示的真实条数  </li><li>total：总记录数  </li><li>pages：总页数  </li><li>prePage：上一页的页码  </li><li>nextPage：下一页的页码</li><li>isFirstPage&#x2F;isLastPage：是否为第一页&#x2F;最后一页  </li><li>hasPreviousPage&#x2F;hasNextPage：是否存在上一页&#x2F;下一页  </li><li>navigatePages：导航分页的页码数  </li><li>navigatepageNums：导航分页的页码，[1,2,3,4,5]</li></ul>]]></content>
      
      
      <categories>
          
          <category> Mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring基础-Spring的整体认知</title>
      <link href="/2021/07/08/spring-ji-chu-spring-de-zheng-ti-ren-zhi/"/>
      <url>/2021/07/08/spring-ji-chu-spring-de-zheng-ti-ren-zhi/</url>
      
        <content type="html"><![CDATA[<h1 id="对Spring有个整体认知"><a href="#对Spring有个整体认知" class="headerlink" title="对Spring有个整体认知:"></a>对Spring有个整体认知:</h1><p>首先看看spring框架的架构图:</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/spring-framework-introduce-8.png" alt="img"></p><blockquote><p>Spring是什么?它是怎么诞生的?它的核心和与核心功能是什么</p></blockquote><h2 id="Spring的起源"><a href="#Spring的起源" class="headerlink" title="Spring的起源:"></a>Spring的起源:</h2><p>百度对于spring的历史介绍如下:</p><p>要谈Spring的历史，就要先谈J2EE。J2EE应用程序的广泛实现是在1999年和2000年开始的，它的出现带来了诸如事务管理之类的<strong>核心中间层概念的标准化</strong>，但是在实践中并没有获得绝对的成功，因为<strong>开发效率</strong>，开发难度和实际的<strong>性能</strong>都令人失望。</p><p>曾经使用过EJB开发JAVA EE应用的人，一定知道，在EJB开始的学习和应用非常的艰苦，很多东西都不能一下子就很容易的理解。EJB要严格地实现各种不同类型的接口，类似的或者重复的代码大量存在。而配置也是复杂和单调，同样使用JNDI进行对象查找的代码也是单调而枯燥。虽然有一些开发工作随着xdoclet的出现，而有所缓解，但是学习EJB的高昂代价，和极低的开发效率，极高的资源消耗，都造成了EJB的使用困难。而Spring出现的初衷就是为了解决类似的这些问题。</p><p><strong>Spring的一个最大的目的就是使JAVA EE开发更加容易</strong>。同时，Spring之所以与Struts、Hibernate等单层框架不同，是因为Spring致力于提供一个以统一的、高效的方式构造整个应用，并且可以将单层框架以最佳的组合揉和在一起建立一个连贯的体系。可以说Spring是一个提供了更完善开发环境的一个框架，可以为POJO(Plain Ordinary Java Object)对象提供企业级的服务。</p><p>Spring的形成，最初来自Rod Jahnson所著的一本很有影响力的书籍《<a href="https://item.jd.com/68619611892.html">Expert One-on-One J2EE Design and Development在新窗口打开</a>》，就是在这本书中第一次出现了Spring的一些核心思想，该书出版于2002年。</p><hr><h2 id="Spring的特性和优势"><a href="#Spring的特性和优势" class="headerlink" title="Spring的特性和优势"></a>Spring的特性和优势</h2><blockquote><p>Spring Framework有哪些特性?</p></blockquote><h3 id="从Spring框架的特性来看"><a href="#从Spring框架的特性来看" class="headerlink" title="从Spring框架的特性来看:"></a>从Spring框架的特性来看:</h3><ul><li><p>非侵入式: 基于Spring开发的应用中的对象可以不依赖Spring的API</p></li><li><p><strong>控制反转: IOC</strong>——Inversion of Control，指的是将对象的创建权交给 Spring 去创建。使用 Spring 之前，对象的创建都是由我们自己在代码中new创建。而使用 Spring 之后。对象的创建都是给了 Spring 框架。</p></li><li><p><strong>依赖注入: DI</strong>——Dependency Injection，是指依赖的对象不需要手动调用 setXX 方法去设置，而是通过配置赋值。</p></li><li><p>面向切面编程：Aspect Oriented Programming——AOP</p></li><li><p>容器：Spring 是一个容器，因为它包含并且管理应用对象的生命周期</p></li><li><p><strong>组件化</strong>：Spring 实现了使用简单的组件配置组合成一个复杂的应用。在 Spring 中可以使用XML和Java注解组合这些对象</p></li><li><p>一站式：在 IOC 和 AOP 的基础上可以整合各种企业应用的开源框架和优秀的第三方类库（实际上 Spring 自身也提供了表现层的 SpringMVC 和持久层的 Spring JDBC</p></li></ul><h3 id="从使用Spring-框架的好处看："><a href="#从使用Spring-框架的好处看：" class="headerlink" title="从使用Spring 框架的好处看："></a>从使用Spring 框架的好处看：</h3><ul><li>Spring 可以使开发人员使用 POJOs 开发企业级的应用程序。只使用 POJOs 的好处是你不需要一个 EJB 容器产品，比如一个应用程序服务器，但是你可以选择使用一个健壮的 servlet 容器，比如 Tomcat 或者一些商业产品。</li><li>Spring 在一个单元模式中是有组织的。即使包和类的数量非常大，你只要担心你需要的，而其它的就可以忽略了。</li><li>Spring 不会让你白费力气做重复工作，它真正的利用了一些现有的技术，像 ORM 框架、日志框架、JEE、Quartz 和 JDK 计时器，其他视图技术。</li><li>测试一个用 Spring 编写的应用程序很容易，因为环境相关的代码被移动到这个框架中。此外，通过使用 JavaBean-style POJOs，它在使用依赖注入注入测试数据时变得更容易。</li><li>Spring 的 web 框架是一个设计良好的 web MVC 框架，它为比如 Structs 或者其他工程上的或者不怎么受欢迎的 web 框架提供了一个很好的供替代的选择。MVC 模式导致应用程序的不同方面(输入逻辑，业务逻辑和UI逻辑)分离，同时提供这些元素之间的松散耦合。模型(Model)封装了应用程序数据，通常它们将由 POJO 类组成。视图(View)负责渲染模型数据，一般来说它生成客户端浏览器可以解释 HTML 输出。控制器(Controller)负责处理用户请求并构建适当的模型，并将其传递给视图进行渲染。</li><li>Spring 对 JavaEE 开发中非常难用的一些 API（JDBC、JavaMail、远程调用等），都提供了封装，使这些API应用难度大大降低。</li><li>轻量级的 IOC 容器往往是轻量级的，例如，特别是当与 EJB 容器相比的时候。这有利于在内存和 CPU 资源有限的计算机上开发和部署应用程序。</li><li>Spring 提供了<strong>一致的事务管理接口</strong>，可向下扩展到（使用一个单一的数据库，例如）本地事务并扩展到全局事务（例如，使用 JTA）</li></ul><hr><h2 id="Spring有哪些组件"><a href="#Spring有哪些组件" class="headerlink" title="Spring有哪些组件"></a>Spring有哪些组件</h2><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/spring-framework-introduce-8.png" alt="img"></p><p>上图中包含了 Spring 框架的所有模块，这些模块可以满足一切企业级应用开发的需求，在开发过程中可以根据需求有选择性地使用所需要的模块。下面分别对这些模块的作用进行简单介绍（并且结合SpringFramework5.x源码模块帮助你对应好各模块关系）。</p><h3 id="Core-Container（Spring的核心容器）"><a href="#Core-Container（Spring的核心容器）" class="headerlink" title="Core Container（Spring的核心容器）"></a>Core Container（Spring的核心容器）</h3><p>Spring 的核心容器是其他模块建立的基础，由 Beans 模块、Core 核心模块、Context 上下文模块和 SpEL 表达式语言模块组成，没有这些核心容器，也不可能有 AOP、Web 等上层的功能。具体介绍如下。</p><ul><li><strong>Beans 模块</strong>：提供了框架的基础部分，包括控制反转和依赖注入。</li><li><strong>Core 核心模块</strong>：封装了 Spring 框架的底层部分，包括资源访问、类型转换及一些常用工具类。</li><li><strong>Context 上下文模块</strong>：建立在 Core 和 Beans 模块的基础之上，集成 Beans 模块功能并添加资源绑定、数据验证、国际化、Java EE 支持、容器生命周期、事件传播等。ApplicationContext 接口是上下文模块的焦点。</li><li><strong>SpEL 模块</strong>：提供了强大的表达式语言支持，支持访问和修改属性值，方法调用，支持访问及修改数组、容器和索引器，命名变量，支持算数和逻辑运算，支持从 Spring 容器获取 Bean，它也支持列表投影、选择和一般的列表聚合等。</li></ul><p>对应的源码模块如下：</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/spring-framework-introduce-9.png" alt="img"></p><h3 id="Data-Access-Integration（数据访问／集成）"><a href="#Data-Access-Integration（数据访问／集成）" class="headerlink" title="Data Access&#x2F;Integration（数据访问／集成）"></a>Data Access&#x2F;Integration（数据访问／集成）</h3><p>数据访问／集成层包括 JDBC、ORM、OXM、JMS 和 Transactions 模块，具体介绍如下。</p><ul><li><strong>JDBC 模块</strong>：提供了一个 JDBC 的样例模板，使用这些模板能消除传统冗长的 JDBC 编码还有必须的事务控制，而且能享受到 Spring 管理事务的好处。</li><li><strong>ORM 模块</strong>：提供与流行的“对象-关系”映射框架无缝集成的 API，包括 JPA、JDO、Hibernate 和 MyBatis 等。而且还可以使用 Spring 事务管理，无需额外控制事务。</li><li><strong>OXM 模块</strong>：提供了一个支持 Object &#x2F;XML 映射的抽象层实现，如 JAXB、Castor、XMLBeans、JiBX 和 XStream。将 Java 对象映射成 XML 数据，或者将XML 数据映射成 Java 对象。</li><li><strong>JMS 模块</strong>：指 Java 消息服务，提供一套 “消息生产者、消息消费者”模板用于更加简单的使用 JMS，JMS 用于用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。</li><li><strong>Transactions 事务模块</strong>：支持编程和声明式事务管理。</li></ul><p>对应的源码模块如下：</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/spring-framework-introduce-10.png" alt="img"></p><h3 id="Web模块"><a href="#Web模块" class="headerlink" title="Web模块"></a>Web模块</h3><p>Spring 的 Web 层包括 Web、Servlet、WebSocket 和 Webflux 组件，具体介绍如下。</p><ul><li><strong>Web 模块</strong>：提供了基本的 Web 开发集成特性，例如多文件上传功能、使用的 Servlet 监听器的 IOC 容器初始化以及 Web 应用上下文。</li><li><strong>Servlet 模块</strong>：提供了一个 Spring MVC Web 框架实现。Spring MVC 框架提供了基于注解的请求资源注入、更简单的数据绑定、数据验证等及一套非常易用的 JSP 标签，完全无缝与 Spring 其他技术协作。</li><li><strong>WebSocket 模块</strong>：提供了简单的接口，用户只要实现响应的接口就可以快速的搭建 WebSocket Server，从而实现双向通讯。</li><li><strong>Webflux 模块</strong>： Spring WebFlux 是 Spring Framework 5.x中引入的新的响应式web框架。与Spring MVC不同，它不需要Servlet API，是完全异步且非阻塞的，并且通过Reactor项目实现了Reactive Streams规范。Spring WebFlux 用于创建基于事件循环执行模型的完全异步且非阻塞的应用程序。</li></ul><p>此外Spring4.x中还有Portlet 模块，在Spring 5.x中已经移除</p><ul><li><strong>Portlet 模块</strong>：提供了在 Portlet 环境中使用 MVC 实现，类似 Web-Servlet 模块的功能。</li></ul><p>对应的源码模块如下：</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/spring-framework-introduce-11.png" alt="img"></p><h3 id="AOP、Aspects、Instrumentation和Messaging"><a href="#AOP、Aspects、Instrumentation和Messaging" class="headerlink" title="AOP、Aspects、Instrumentation和Messaging"></a>AOP、Aspects、Instrumentation和Messaging</h3><p>在 Core Container 之上是 AOP、Aspects 等模块，具体介绍如下：</p><ul><li><strong>AOP 模块</strong>：提供了面向切面编程实现，提供比如日志记录、权限控制、性能统计等通用功能和业务逻辑分离的技术，并且能动态的把这些功能添加到需要的代码中，这样各司其职，降低业务逻辑和通用功能的耦合。</li><li><strong>Aspects 模块</strong>：提供与 AspectJ 的集成，是一个功能强大且成熟的面向切面编程（AOP）框架。</li><li><strong>Instrumentation 模块</strong>：提供了类工具的支持和类加载器的实现，可以在特定的应用服务器中使用。</li><li><strong>messaging 模块</strong>：Spring 4.0 以后新增了消息（Spring-messaging）模块，该模块提供了对消息传递体系结构和协议的支持。</li><li><strong>jcl 模块</strong>： Spring 5.x中新增了日志框架集成的模块。</li></ul><p>对应的源码模块如下：</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/spring-framework-introduce-12.png" alt="img"></p><h3 id="Test模块"><a href="#Test模块" class="headerlink" title="Test模块"></a>Test模块</h3><p>Test 模块：Spring 支持 Junit 和 TestNG 测试框架，而且还额外提供了一些基于 Spring 的测试功能，比如在测试 Web 框架时，模拟 Http 请求的功能。</p><p>包含Mock Objects, TestContext Framework, Spring MVC Test, WebTestClient。</p><p>对应的源码模块如下：</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/spring-framework-introduce-13.png" alt="img"></p><h3 id="Spring-的官方Github"><a href="#Spring-的官方Github" class="headerlink" title="Spring 的官方Github"></a>Spring 的官方Github</h3><p>Spring官方的GitHub在<a href="https://github.com/spring-projects/spring-framework">这里在新窗口打开</a>，它包含着Spring-framework的源码，如果你感兴趣，可以从这里clone代码进行阅读。</p><h3 id="Spring-的归档文档"><a href="#Spring-的归档文档" class="headerlink" title="Spring 的归档文档"></a>Spring 的归档文档</h3><p>官方提供了系统性的文档的FTP，你可以在<a href="https://docs.spring.io/spring-framework/docs/">这里在新窗口打开</a>找到所有历史版本的PDF&#x2F;HTML版本。</p><h3 id="Spring-的官方项目和教程"><a href="#Spring-的官方项目和教程" class="headerlink" title="Spring 的官方项目和教程"></a>Spring 的官方项目和教程</h3><p>官方的项目和教程，地址在<a href="https://spring.io/projects/spring-framework">这里在新窗口打开</a></p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/spring-framework-introduce-4.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> Spring基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring整体认知 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring的简单案例</title>
      <link href="/2021/05/08/spring-de-jian-dan-an-li/"/>
      <url>/2021/05/08/spring-de-jian-dan-an-li/</url>
      
        <content type="html"><![CDATA[<p>下图是Spring官方解释Spring框架常用的场景图:</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/spring-framework-helloworld-2.png" alt="img"></p><h1 id="设计一个Spring的Hello-World"><a href="#设计一个Spring的Hello-World" class="headerlink" title="设计一个Spring的Hello World"></a>设计一个Spring的Hello World</h1><blockquote><p>结合上面的使用场景，<strong>设计一个查询用户的案例的两个需求</strong>，来看Spring框架帮我们简化了什么开发工作:</p><ol><li><strong>查询用户数据</strong> - 来看DAO+POJO-&gt; Service 的初始化和装载。</li><li><strong>给所有Service的查询方法记录日志</strong></li></ol><hr></blockquote><h2 id="创建Maven工程"><a href="#创建Maven工程" class="headerlink" title="创建Maven工程"></a><strong>创建Maven工程</strong></h2><p><img src="https://gitee.com/DylanToT99/images/raw/57179e6b9bba6f6ee0170027f49ac8b02f3559b4/images/spring-framework-helloworld-3.png" alt="images/spring-framework-helloworld-3.png  0 → 100644"></p><h2 id="引入Spring框架的POM依赖，以及查看这些依赖之间的关系"><a href="#引入Spring框架的POM依赖，以及查看这些依赖之间的关系" class="headerlink" title="引入Spring框架的POM依赖，以及查看这些依赖之间的关系"></a><strong>引入Spring框架的POM依赖，以及查看这些依赖之间的关系</strong></h2><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;tech.pdai&lt;/groupId&gt;    &lt;artifactId&gt;001-spring-framework-demo-helloworld-xml&lt;/artifactId&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;properties&gt;        &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt;        &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt;        &lt;spring.version&gt;5.3.9&lt;/spring.version&gt;        &lt;aspectjweaver.version&gt;1.9.6&lt;/aspectjweaver.version&gt;    &lt;/properties&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;            &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-core&lt;/artifactId&gt;            &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-beans&lt;/artifactId&gt;            &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.aspectj&lt;/groupId&gt;            &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;            &lt;version&gt;$&#123;aspectjweaver.version&#125;&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/project&gt;</code></pre><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/spring-framework-helloworld-4.png" alt="img"></p><h2 id="POJO-User"><a href="#POJO-User" class="headerlink" title="POJO - User"></a><strong>POJO - User</strong></h2><pre><code class="java">package tech.pdai.springframework.entity;/** * @author pdai */public class User &#123;    /**     * user&#39;s name.     */    private String name;    /**     * user&#39;s age.     */    private int age;    /**     * init.     *     * @param name name     * @param age  age     */    public User(String name, int age) &#123;        this.name = name;        this.age = age;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public int getAge() &#123;        return age;    &#125;    public void setAge(int age) &#123;        this.age = age;    &#125;&#125;</code></pre><h2 id="DAO-获取-POJO，-UserDaoServiceImpl-mock-数据"><a href="#DAO-获取-POJO，-UserDaoServiceImpl-mock-数据" class="headerlink" title="DAO 获取 POJO， UserDaoServiceImpl (mock 数据)"></a><strong>DAO 获取 POJO， UserDaoServiceImpl (mock 数据)</strong></h2><pre><code class="java">package tech.pdai.springframework.dao;import java.util.Collections;import java.util.List;import tech.pdai.springframework.entity.User;/** * @author pdai */public class UserDaoImpl &#123;    /**     * init.     */    public UserDaoImpl() &#123;    &#125;    /**     * mocked to find user list.     *     * @return user list     */    public List&lt;User&gt; findUserList() &#123;        return Collections.singletonList(new User(&quot;pdai&quot;, 18));    &#125;&#125;</code></pre><p>并增加daos.xml</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;bean id=&quot;userDao&quot; class=&quot;tech.pdai.springframework.dao.UserDaoImpl&quot;&gt;        &lt;!-- additional collaborators and configuration for this bean go here --&gt;    &lt;/bean&gt;    &lt;!-- more bean definitions for data access objects go here --&gt;&lt;/beans&gt;</code></pre><h2 id="业务层-UserServiceImpl（调用DAO层）"><a href="#业务层-UserServiceImpl（调用DAO层）" class="headerlink" title="业务层 UserServiceImpl（调用DAO层）"></a><strong>业务层 UserServiceImpl（调用DAO层）</strong></h2><pre><code class="java">package tech.pdai.springframework.service;import java.util.List;import tech.pdai.springframework.dao.UserDaoImpl;import tech.pdai.springframework.entity.User;/** * @author pdai */public class UserServiceImpl &#123;    /**     * user dao impl.     */    private UserDaoImpl userDao;    /**     * init.     */    public UserServiceImpl() &#123;    &#125;    /**     * find user list.     *     * @return user list     */    public List&lt;User&gt; findUserList() &#123;        return this.userDao.findUserList();    &#125;    /**     * set dao.     *     * @param userDao user dao     */    public void setUserDao(UserDaoImpl userDao) &#123;        this.userDao = userDao;    &#125;&#125;</code></pre><p>并增加services.xml</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;!-- services --&gt;    &lt;bean id=&quot;userService&quot; class=&quot;tech.pdai.springframework.service.UserServiceImpl&quot;&gt;        &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt;        &lt;!-- additional collaborators and configuration for this bean go here --&gt;    &lt;/bean&gt;    &lt;!-- more bean definitions for services go here --&gt;&lt;/beans&gt;</code></pre><h2 id="拦截所有service中的方法，并输出记录"><a href="#拦截所有service中的方法，并输出记录" class="headerlink" title="拦截所有service中的方法，并输出记录"></a><strong>拦截所有service中的方法，并输出记录</strong></h2><pre><code class="java">package tech.pdai.springframework.aspect;import java.lang.reflect.Method;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.Around;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.reflect.MethodSignature;import org.springframework.context.annotation.EnableAspectJAutoProxy;/** * @author pdai */@Aspectpublic class LogAspect &#123;    /**     * aspect for every methods under service package.     */    @Around(&quot;execution(* tech.pdai.springframework.service.*.*(..))&quot;)    public Object businessService(ProceedingJoinPoint pjp) throws Throwable &#123;        // get attribute through annotation        Method method = ((MethodSignature) pjp.getSignature()).getMethod();        System.out.println(&quot;execute method: &quot; + method.getName());        // continue to process        return pjp.proceed();    &#125;&#125;</code></pre><p>并增加aspects.xml</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;    &lt;context:component-scan base-package=&quot;tech.pdai.springframework&quot; /&gt;    &lt;aop:aspectj-autoproxy/&gt;    &lt;bean id=&quot;logAspect&quot; class=&quot;tech.pdai.springframework.aspect.LogAspect&quot;&gt;        &lt;!-- configure properties of aspect here as normal --&gt;    &lt;/bean&gt;    &lt;!-- more bean definitions for data access objects go here --&gt;&lt;/beans&gt;</code></pre><h2 id="组装App"><a href="#组装App" class="headerlink" title="组装App"></a><strong>组装App</strong></h2><pre><code class="java">package tech.pdai.springframework;import java.util.List;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import tech.pdai.springframework.entity.User;import tech.pdai.springframework.service.UserServiceImpl;/** * @author pdai */public class App &#123;    /**     * main interfaces.     *     * @param args args     */    public static void main(String[] args) &#123;        // create and configure beans        ApplicationContext context =                new ClassPathXmlApplicationContext(&quot;aspects.xml&quot;, &quot;daos.xml&quot;, &quot;services.xml&quot;);        // retrieve configured instance        UserServiceImpl service = context.getBean(&quot;userService&quot;, UserServiceImpl.class);        // use configured instance        List&lt;User&gt; userList = service.findUserList();        // print info from beans        userList.forEach(a -&gt; System.out.println(a.getName() + &quot;,&quot; + a.getAge()));    &#125;&#125;</code></pre><h2 id="整体结构和运行app"><a href="#整体结构和运行app" class="headerlink" title="整体结构和运行app"></a><strong>整体结构和运行app</strong></h2><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/spring-framework-helloworld-5.png" alt="img"></p><h1 id="这个例子体现了Spring的哪些核心功能"><a href="#这个例子体现了Spring的哪些核心功能" class="headerlink" title="这个例子体现了Spring的哪些核心功能"></a>这个例子体现了Spring的哪些核心功能</h1><h2 id="控制反转-IOC"><a href="#控制反转-IOC" class="headerlink" title="控制反转 - IOC"></a>控制反转 - IOC</h2><ul><li><strong>如果没有Spring框架，我们需要自己创建User&#x2F;Dao&#x2F;Service等</strong>，比如：</li></ul><pre><code class="java">UserDaoImpl userDao = new UserDaoImpl();UserSericeImpl userService = new UserServiceImpl();userService.setUserDao(userDao);List&lt;User&gt; userList = userService.findUserList();</code></pre><hr><ul><li><strong>有了Spring框架，可以将原有Bean的创建工作转给框架, 需要用时从Bean的容器中获取即可，这样便简化了开发工作</strong></li></ul><p>Bean的创建和使用分离了。</p><pre><code class="java">// create and configure beansApplicationContext context =        new ClassPathXmlApplicationContext(&quot;aspects.xml&quot;, &quot;daos.xml&quot;, &quot;services.xml&quot;);// retrieve configured instanceUserServiceImpl service = context.getBean(&quot;userService&quot;, UserServiceImpl.class);// use configured instanceList&lt;User&gt; userList = service.findUserList();</code></pre><hr><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/spring-framework-helloworld-6.png" alt="img"></p><p>更进一步，<strong>你便能理解为何会有如下的知识点了</strong>：</p><ol><li>Spring框架管理这些Bean的创建工作，即由用户管理Bean转变为框架管理Bean，这个就叫<strong>控制反转 - Inversion of Control (IoC)</strong></li><li>Spring 框架托管创建的Bean放在哪里呢？ 这便是<strong>IoC Container</strong>;</li><li>Spring 框架为了更好让用户配置Bean，必然会引入<strong>不同方式来配置Bean？ 这便是xml配置，Java配置，注解配置</strong>等支持</li><li>Spring 框架既然接管了Bean的生成，必然需要<strong>管理整个Bean的生命周期</strong>等；</li><li>应用程序代码从Ioc Container中获取依赖的Bean，注入到应用程序中，这个过程叫 <strong>依赖注入(Dependency Injection，DI)</strong> ； 所以说控制反转是通过依赖注入实现的，其实它们是同一个概念的不同角度描述。通俗来说就是<strong>IoC是设计思想，DI是实现方式</strong></li><li>在依赖注入时，有哪些方式呢？这就是构造器方式，@Autowired, @Resource, @Qualifier… 同时Bean之间存在依赖（可能存在先后顺序问题，以及<strong>循环依赖问题</strong>等）</li></ol><hr><h2 id="面向切面-AOP"><a href="#面向切面-AOP" class="headerlink" title="面向切面 - AOP"></a>面向切面 - AOP</h2><ul><li><strong>如果没有Spring框架，我们需要在每个service的方法中都添加记录日志的方法</strong>，比如：</li></ul><pre><code class="java">/*** find user list.** @return user list*/public List&lt;User&gt; findUserList() &#123;    System.out.println(&quot;execute method findUserList&quot;);    return this.userDao.findUserList();&#125;</code></pre><ul><li><strong>有了Spring框架，通过@Aspect注解 定义了切面，这个切面中定义了拦截所有service中的方法，并记录日志； 可以明显看到，框架将日志记录和业务需求的代码解耦了，不再是侵入式的了</strong></li></ul><pre><code class="java">/*** aspect for every methods under service package.*/@Around(&quot;execution(* tech.pdai.springframework.service.*.*(..))&quot;)public Object businessService(ProceedingJoinPoint pjp) throws Throwable &#123;    // get attribute through annotation    Method method = ((MethodSignature) pjp.getSignature()).getMethod();    System.out.println(&quot;execute method: &quot; + method.getName());    // continue to process    return pjp.proceed();&#125;</code></pre><hr><p>更进一步，<strong>你便能理解为何会有如下的知识点了</strong>：</p><ol><li>Spring 框架通过定义切面, 通过拦截切点实现了不同业务模块的解耦，这个就叫<strong>面向切面编程 - Aspect Oriented Programming (AOP)</strong></li><li>为什么@Aspect注解使用的是aspectj的jar包呢？这就引出了<strong>Aspect4J和Spring AOP的历史渊源</strong>，只有理解了Aspect4J和Spring的渊源才能理解有些注解上的兼容设计</li><li>如何支持<strong>更多拦截方式</strong>来实现解耦， 以满足更多场景需求呢？ 这就是@Around, @Pointcut… 等的设计</li><li>那么Spring框架又是如何实现AOP的呢？ 这就引入<strong>代理技术，分静态代理和动态代理</strong>，动态代理又包含JDK代理和CGLIB代理等</li></ol><hr><h1 id="Spring框架设计如何逐步简化开发的"><a href="#Spring框架设计如何逐步简化开发的" class="headerlink" title="Spring框架设计如何逐步简化开发的"></a>Spring框架设计如何逐步简化开发的</h1><h2 id="Java-配置方式改造"><a href="#Java-配置方式改造" class="headerlink" title="Java 配置方式改造"></a>Java 配置方式改造</h2><p>在前文的例子中， 通过xml配置方式实现的，这种方式实际上比较麻烦； 我通过Java配置进行改造：</p><ul><li>User，UserDaoImpl, UserServiceImpl，LogAspect不用改</li><li>将原通过.xml配置转换为Java配置</li></ul><pre><code class="java">package tech.pdai.springframework.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.EnableAspectJAutoProxy;import tech.pdai.springframework.aspect.LogAspect;import tech.pdai.springframework.dao.UserDaoImpl;import tech.pdai.springframework.service.UserServiceImpl;/** * @author pdai */@EnableAspectJAutoProxy@Configurationpublic class BeansConfig &#123;    /**     * @return user dao     */    @Bean(&quot;userDao&quot;)    public UserDaoImpl userDao() &#123;        return new UserDaoImpl();    &#125;    /**     * @return user service     */    @Bean(&quot;userService&quot;)    public UserServiceImpl userService() &#123;        UserServiceImpl userService = new UserServiceImpl();        userService.setUserDao(userDao());        return userService;    &#125;    /**     * @return log aspect     */    @Bean(&quot;logAspect&quot;)    public LogAspect logAspect() &#123;        return new LogAspect();    &#125;&#125;</code></pre><ul><li><strong>在App中加载BeansConfig的配置</strong></li></ul><pre><code class="java">package tech.pdai.springframework;import java.util.List;import org.springframework.context.annotation.AnnotationConfigApplicationContext;import tech.pdai.springframework.config.BeansConfig;import tech.pdai.springframework.entity.User;import tech.pdai.springframework.service.UserServiceImpl;/** * @author pdai */public class App &#123;    /**     * main interfaces.     *     * @param args args     */    public static void main(String[] args) &#123;        // create and configure beans        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(BeansConfig.class);        // retrieve configured instance        UserServiceImpl service = context.getBean(&quot;userService&quot;, UserServiceImpl.class);        // use configured instance        List&lt;User&gt; userList = service.findUserList();        // print info from beans        userList.forEach(a -&gt; System.out.println(a.getName() + &quot;,&quot; + a.getAge()));    &#125;&#125;</code></pre><hr><ul><li><strong>整体结构和运行app</strong></li></ul><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/spring-framework-helloworld-7.png" alt="img"></p><h2 id="注解配置方式改造"><a href="#注解配置方式改造" class="headerlink" title="注解配置方式改造"></a>注解配置方式改造</h2><p>更进一步，Java 5开始提供注解支持，Spring 2.5 开始完全支持基于注解的配置并且也支持JSR250 注解。在Spring后续的版本发展倾向于通过注解和Java配置结合使用</p><ul><li><strong>BeanConfig 不再需要Java配置</strong></li></ul><pre><code class="java">package tech.pdai.springframework.config;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.ComponentScans;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.EnableAspectJAutoProxy;/** * @author pdai */@Configuration@EnableAspectJAutoProxypublic class BeansConfig &#123;&#125;</code></pre><ul><li><strong>UserDaoImpl 增加了 @Repository注解</strong></li></ul><pre><code class="java">/** * @author pdai */@Repositorypublic class UserDaoImpl &#123;    /**     * mocked to find user list.     *     * @return user list     */    public List&lt;User&gt; findUserList() &#123;        return Collections.singletonList(new User(&quot;pdai&quot;, 18));    &#125;&#125;</code></pre><ul><li><strong>UserServiceImpl 增加了@Service 注解，并通过@Autowired注入userDao</strong>.</li></ul><pre><code class="java">/** * @author pdai */@Servicepublic class UserServiceImpl &#123;    /**     * user dao impl.     */    @Autowired    private UserDaoImpl userDao;    /**     * find user list.     *     * @return user list     */    public List&lt;User&gt; findUserList() &#123;        return userDao.findUserList();    &#125;&#125;</code></pre><ul><li><strong>在App中扫描tech.pdai.springframework包</strong></li></ul><pre><code class="java">package tech.pdai.springframework;import java.util.List;import org.springframework.context.annotation.AnnotationConfigApplicationContext;import tech.pdai.springframework.entity.User;import tech.pdai.springframework.service.UserServiceImpl;/** * @author pdai */public class App &#123;    /**     * main interfaces.     *     * @param args args     */    public static void main(String[] args) &#123;        // create and configure beans        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(                &quot;tech.pdai.springframework&quot;);        // retrieve configured instance        UserServiceImpl service = context.getBean(UserServiceImpl.class);        // use configured instance        List&lt;User&gt; userList = service.findUserList();        // print info from beans        userList.forEach(a -&gt; System.out.println(a.getName() + &quot;,&quot; + a.getAge()));    &#125;&#125;</code></pre><hr><ul><li><strong>整体结构和运行app</strong></li></ul><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/spring-framework-helloworld-9.png" alt="img"></p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/spring-framework-helloworld-8.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> Spring基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring基础 </tag>
            
            <tag> 简单案例 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring基础-Spring核心之IOC</title>
      <link href="/2021/05/08/spring-ji-chu-ioc-kong-zhi-fan-zhuan/"/>
      <url>/2021/05/08/spring-ji-chu-ioc-kong-zhi-fan-zhuan/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Spring框架管理这些Bean的创建工作，即由用户管理Bean转变为框架管理Bean，这个就叫<strong>控制反转 - Inversion of Control (IoC)</strong></p><p>Spring 框架托管创建的Bean放在哪里呢？ 这便是<strong>IoC Container</strong>;</p><p>Spring 框架为了更好让用户配置Bean，必然会引入<strong>不同方式来配置Bean？ 这便是xml配置，Java配置，注解配置</strong>等支持</p><p>Spring 框架既然接管了Bean的生成，必然需要<strong>管理整个Bean的生命周期</strong>等；</p><p>应用程序代码从Ioc Container中获取依赖的Bean，注入到应用程序中，这个过程叫 <strong>依赖注入(Dependency Injection，DI)</strong> ； 所以说控制反转是通过依赖注入实现的，其实它们是同一个概念的不同角度描述。通俗来说就是<strong>IoC是设计思想，DI是实现方式</strong></p><p>在依赖注入时，有哪些方式呢？这就是构造器方式，@Autowired, @Resource, @Qualifier… 同时Bean之间存在依赖（可能存在先后顺序问题，以及<strong>循环依赖问题</strong>等）</p></blockquote><h1 id="如何理解IoC"><a href="#如何理解IoC" class="headerlink" title="如何理解IoC"></a>如何理解IoC</h1><p>如果你有精力看英文，首推 Martin Fowler大师的 <a href="https://www.martinfowler.com/articles/injection.html">Inversion of Control Containers and the Dependency Injection pattern</a>；其次IoC作为一种设计思想，不要过度解读，而是应该简化理解，所以我这里也整合了 张开涛早前的博客<a href="https://www.iteye.com/blog/jinnianshilongnian-1413846">IoC基础在新窗口打开</a>并加入了自己的理解。</p><h2 id="Spring-Bean的定义"><a href="#Spring-Bean的定义" class="headerlink" title="Spring Bean的定义:"></a>Spring Bean的定义:</h2><p>IoC Container管理的是Spring Bean， 那么Spring Bean是什么呢？</p><p>Spring里面的bean就类似是定义的一个组件，而这个组件的作用就是实现某个功能的，这里所定义的bean就相当于给了你一个更为简便的方法来调用这个组件去实现你要完成的功能。</p><h2 id="IoC是什么"><a href="#IoC是什么" class="headerlink" title="IoC是什么"></a>IoC是什么</h2><blockquote><p>Ioc—Inversion of Control，即“控制反转”，<strong>不是什么技术，而是一种设计思想</strong>。在Java开发中，Ioc意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。</p></blockquote><ul><li><strong>谁控制谁，控制什么</strong>？</li></ul><p>传统Java SE程序设计，我们直接在对象内部通过new进行创建对象，<strong>是程序主动去创建依赖对象</strong>；而IoC是有专门一个容器来创建这些对象，即由<strong>Ioc容器来控制对象的创建</strong>；谁控制谁？当然是IoC容器控制了对象；控制什么？那就是主要控制了外部资源获取（不只是对象包括比如文件等）。</p><ul><li><strong>为何是反转，哪些方面反转了</strong>?</li></ul><p>有反转就有正转，传统应用程序是由我们自己在对象中主动控制去直接获取依赖对象，也就是正转；而反转则是由容器来帮忙创建及注入依赖对象；为何是反转？因为由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象，所以是反转；哪些方面反转了？依赖对象的获取被反转了。</p><ul><li><strong>用图例说明一下</strong>?</li></ul><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/spring-framework-ioc-1.png" alt="img"></p><p>当有了IoC&#x2F;DI的容器后，在客户端类中不再主动去创建这些对象了，如图</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/spring-framework-ioc-2.png" alt="img"></p><h2 id="IoC能做什么"><a href="#IoC能做什么" class="headerlink" title="IoC能做什么"></a>IoC能做什么</h2><blockquote><p>IoC <strong>不是一种技术，只是一种思想</strong>，一个重要的面向对象编程的法则，它能指导我们如何设计出松耦合、更优良的程序。</p></blockquote><p>传统应用程序都是由我们在类内部主动创建依赖对象，从而导致类与类之间高耦合，难于测试；有了IoC容器后，<strong>把创建和查找依赖对象的控制权交给了容器，由容器进行注入组合对象，所以对象与对象之间是 松散耦合，这样也方便测试，利于功能复用，更重要的是使得程序的整个体系结构变得非常灵活</strong>。</p><p>其实IoC对编程带来的最大改变不是从代码上，而是从思想上，发生了“主从换位”的变化。应用程序原本是老大，要获取什么资源都是主动出击，但是在IoC&#x2F;DI思想中，应用程序就变成被动的了，被动的等待IoC容器来创建并注入它所需要的资源了。</p><p>IoC很好的体现了面向对象设计法则之一—— <strong>好莱坞法则：“别找我们，我们找你”</strong>；即由IoC容器帮对象找相应的依赖对象并注入，而不是由对象主动去找。</p><hr><h2 id="IoC和DI是什么关系"><a href="#IoC和DI是什么关系" class="headerlink" title="IoC和DI是什么关系"></a>IoC和DI是什么关系</h2><blockquote><p>控制反转是通过依赖注入实现的，其实它们是同一个概念的不同角度描述。通俗来说就是<strong>IoC是设计思想，DI是实现方式</strong>。</p></blockquote><p><strong>DI—Dependency Injection，即依赖注入</strong>：组件之间依赖关系由容器在运行期决定，形象的说，即由容器动态的将某个依赖关系注入到组件之中。依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。</p><p>我们来深入分析一下：</p><ul><li><strong>谁依赖于谁</strong>？</li></ul><p>当然是应用程序依赖于IoC容器；</p><ul><li><strong>为什么需要依赖</strong>？</li></ul><p>应用程序需要IoC容器来提供对象需要的外部资源；</p><ul><li><strong>谁注入谁</strong>？</li></ul><p>很明显是IoC容器注入应用程序某个对象，应用程序依赖的对象；</p><ul><li><strong>注入了什么</strong>？</li></ul><p>就是注入某个对象所需要的外部资源（包括对象、资源、常量数据）。</p><ul><li><strong>IoC和DI有什么关系呢</strong>？</li></ul><p>其实它们是同一个概念的不同角度描述，由于控制反转概念比较含糊（可能只是理解为容器控制对象这一个层面，很难让人想到谁来维护对象关系），所以2004年大师级人物Martin Fowler又给出了一个新的名字：“依赖注入”，相对IoC 而言，“依赖注入”明确描述了“被注入对象依赖IoC容器配置依赖对象”。通俗来说就是<strong>IoC是设计思想，DI是实现方式</strong>。</p><h2 id="Ioc-配置的三种方式"><a href="#Ioc-配置的三种方式" class="headerlink" title="Ioc 配置的三种方式"></a>Ioc 配置的三种方式</h2><h3 id="xml-配置"><a href="#xml-配置" class="headerlink" title="xml 配置"></a>xml 配置</h3><p>顾名思义，就是将bean的信息配置.xml文件里，通过Spring加载文件为我们创建bean。这种方式出现很多早前的SSM项目中，将第三方类库或者一些配置工具类都以这种方式进行配置，主要原因是由于第三方类不支持Spring注解。</p><ul><li><strong>优点</strong>： 可以使用于任何场景，结构清晰，通俗易懂</li><li><strong>缺点</strong>： 配置繁琐，不易维护，枯燥无味，扩展性差</li></ul><p><strong>举例</strong>：</p><ol><li>配置xx.xml文件</li><li>声明命名空间和配置bean</li></ol><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;!-- services --&gt;    &lt;bean id=&quot;userService&quot; class=&quot;tech.pdai.springframework.service.UserServiceImpl&quot;&gt;        &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt;        &lt;!-- additional collaborators and configuration for this bean go here --&gt;    &lt;/bean&gt;    &lt;!-- more bean definitions for services go here --&gt;&lt;/beans&gt;</code></pre><hr><h3 id="Java-配置"><a href="#Java-配置" class="headerlink" title="Java 配置"></a>Java 配置</h3><p>将类的创建交给我们配置的JavcConfig类来完成，Spring只负责维护和管理，采用纯Java创建方式。其本质上就是把在XML上的配置声明转移到Java配置类中</p><ul><li><strong>优点</strong>：适用于任何场景，配置方便，因为是纯Java代码，扩展性高，十分灵活</li><li><strong>缺点</strong>：由于是采用Java类的方式，声明不明显，如果大量配置，可读性比较差</li></ul><p><strong>举例</strong>：</p><ol><li>创建一个配置类， 添加@Configuration注解声明为配置类</li><li>创建方法，方法上加上@bean，该方法用于创建实例并返回，该实例创建后会交给spring管理，方法名建议与实例名相同（首字母小写）。注：实例类不需要加任何注解</li></ol><pre><code class="java">/** * @author pdai */@Configurationpublic class BeansConfig &#123;    /**     * @return user dao     */    @Bean(&quot;userDao&quot;)    public UserDaoImpl userDao() &#123;        return new UserDaoImpl();    &#125;    /**     * @return user service     */    @Bean(&quot;userService&quot;)    public UserServiceImpl userService() &#123;        UserServiceImpl userService = new UserServiceImpl();        userService.setUserDao(userDao());        return userService;    &#125;&#125;</code></pre><hr><h3 id="注解配置"><a href="#注解配置" class="headerlink" title="注解配置"></a>注解配置</h3><p>通过在类上加注解的方式，来声明一个类交给Spring管理，Spring会自动扫描带有**@Component，@Controller，@Service，@Repository**这四个注解的类，然后帮我们创建并管理，前提是需要先配置Spring的注解扫描器。</p><ul><li><strong>优点</strong>：开发便捷，通俗易懂，方便维护。</li><li><strong>缺点</strong>：具有局限性，对于一些第三方资源，无法添加注解。只能采用XML或JavaConfig的方式配置</li></ul><p><strong>举例</strong>：</p><ol><li>对类添加@Component相关的注解，比如@Controller，@Service，@Repository</li><li>设置ComponentScan的basePackage, 比如<code>&lt;context:component-scan base-package=&#39;tech.pdai.springframework&#39;&gt;</code>, 或者<code>@ComponentScan(&quot;tech.pdai.springframework&quot;)</code>注解，或者 <code>new AnnotationConfigApplicationContext(&quot;tech.pdai.springframework&quot;)</code>指定扫描的basePackage.</li></ol><pre><code class="java">/** * @author pdai */@Servicepublic class UserServiceImpl &#123;    /**     * user dao impl.     */    @Autowired    private UserDaoImpl userDao;    /**     * find user list.     *     * @return user list     */    public List&lt;User&gt; findUserList() &#123;        return userDao.findUserList();    &#125;&#125;</code></pre><hr><h2 id="依赖注入的三种方式"><a href="#依赖注入的三种方式" class="headerlink" title="依赖注入的三种方式"></a>依赖注入的三种方式</h2><blockquote><p>常用的注入方式主要有三种：构造方法注入（Construct注入），setter注入，基于注解的注入（接口注入）</p></blockquote><h3 id="setter方式"><a href="#setter方式" class="headerlink" title="setter方式"></a>setter方式</h3><ul><li><strong>在XML配置方式中</strong>，property都是setter方式注入，比如下面的xml:</li></ul><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;!-- services --&gt;    &lt;bean id=&quot;userService&quot; class=&quot;tech.pdai.springframework.service.UserServiceImpl&quot;&gt;        &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt;        &lt;!-- additional collaborators and configuration for this bean go here --&gt;    &lt;/bean&gt;    &lt;!-- more bean definitions for services go here --&gt;&lt;/beans&gt;</code></pre><p>本质上包含两步：</p><ol><li>第一步，需要new UserServiceImpl()创建对象, 所以需要默认构造函数</li><li>第二步，调用setUserDao()函数注入userDao的值, 所以需要setUserDao()函数</li></ol><p>所以对应的service类是这样的：</p><pre><code class="java">/** * @author pdai */public class UserServiceImpl &#123;    /**     * user dao impl.     */    private UserDaoImpl userDao;    /**     * init.     */    public UserServiceImpl() &#123;    &#125;    /**     * find user list.     *     * @return user list     */    public List&lt;User&gt; findUserList() &#123;        return this.userDao.findUserList();    &#125;    /**     * set dao.     *     * @param userDao user dao     */    public void setUserDao(UserDaoImpl userDao) &#123;        this.userDao = userDao;    &#125;&#125;</code></pre><ul><li><strong>在注解和Java配置方式下</strong></li></ul><pre><code class="java">/** * @author pdai */public class UserServiceImpl &#123;    /**     * user dao impl.     */    private UserDaoImpl userDao;    /**     * find user list.     *     * @return user list     */    public List&lt;User&gt; findUserList() &#123;        return this.userDao.findUserList();    &#125;    /**     * set dao.     *     * @param userDao user dao     */    @Autowired    public void setUserDao(UserDaoImpl userDao) &#123;        this.userDao = userDao;    &#125;&#125;</code></pre><p>在Spring3.x刚推出的时候，推荐使用注入的就是这种, 但是这种方式比较麻烦，所以在Spring4.x版本中推荐构造函数注入。</p><hr><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><ul><li><strong>在XML配置方式中</strong>，<code>&lt;constructor-arg&gt;</code>是通过构造函数参数注入，比如下面的xml:</li></ul><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;!-- services --&gt;    &lt;bean id=&quot;userService&quot; class=&quot;tech.pdai.springframework.service.UserServiceImpl&quot;&gt;        &lt;constructor-arg name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt;        &lt;!-- additional collaborators and configuration for this bean go here --&gt;    &lt;/bean&gt;    &lt;!-- more bean definitions for services go here --&gt;&lt;/beans&gt;</code></pre><p>本质上是new UserServiceImpl(userDao)创建对象, 所以对应的service类是这样的：</p><pre><code class="java">/** * @author pdai */public class UserServiceImpl &#123;    /**     * user dao impl.     */    private final UserDaoImpl userDao;    /**     * init.     * @param userDaoImpl user dao impl     */    public UserServiceImpl(UserDaoImpl userDaoImpl) &#123;        this.userDao = userDaoImpl;    &#125;    /**     * find user list.     *     * @return user list     */    public List&lt;User&gt; findUserList() &#123;        return this.userDao.findUserList();    &#125;&#125;</code></pre><ul><li><strong>在注解和Java配置方式下</strong></li></ul><pre><code class="java">/** * @author pdai */ @Servicepublic class UserServiceImpl &#123;    /**     * user dao impl.     */    private final UserDaoImpl userDao;    /**     * init.     * @param userDaoImpl user dao impl     */    @Autowired // 这里@Autowired也可以省略    public UserServiceImpl(final UserDaoImpl userDaoImpl) &#123;        this.userDao = userDaoImpl;    &#125;    /**     * find user list.     *     * @return user list     */    public List&lt;User&gt; findUserList() &#123;        return this.userDao.findUserList();    &#125;&#125;</code></pre><p>在Spring4.x版本中推荐的注入方式就是这种， 具体原因看后续章节。</p><hr><h3 id="注解注入"><a href="#注解注入" class="headerlink" title="注解注入"></a>注解注入</h3><p>以@Autowired（自动注入）注解注入为例，修饰符有三个属性：Constructor，byType，byName。默认按照byType注入。</p><ul><li><strong>constructor</strong>：通过构造方法进行自动注入，spring会匹配与构造方法参数类型一致的bean进行注入，如果有一个多参数的构造方法，一个只有一个参数的构造方法，在容器中查找到多个匹配多参数构造方法的bean，那么spring会优先将bean注入到多参数的构造方法中。</li><li><strong>byName</strong>：被注入bean的id名必须与set方法后半截匹配，并且id名称的第一个单词首字母必须小写，这一点与手动set注入有点不同。</li><li><strong>byType</strong>：查找所有的set方法，将符合符合参数类型的bean注入。</li></ul><p>比如：</p><pre><code class="java">/** * @author pdai */@Servicepublic class UserServiceImpl &#123;    /**     * user dao impl.     */    @Autowired    private UserDaoImpl userDao;    /**     * find user list.     *     * @return user list     */    public List&lt;User&gt; findUserList() &#123;        return userDao.findUserList();    &#125;&#125;</code></pre><hr><h2 id="IoC和DI使用问题小结"><a href="#IoC和DI使用问题小结" class="headerlink" title="IoC和DI使用问题小结"></a>IoC和DI使用问题小结</h2><h3 id="为什么推荐构造器注入方式？"><a href="#为什么推荐构造器注入方式？" class="headerlink" title="为什么推荐构造器注入方式？"></a>为什么推荐构造器注入方式？</h3><p>先来看看Spring在文档里怎么说：</p><blockquote><p>The Spring team generally advocates constructor injection as it enables one to implement application components as immutable objects and to ensure that required dependencies are not null. Furthermore constructor-injected components are always returned to client (calling) code in a fully initialized state.</p></blockquote><p>简单的翻译一下：这个构造器注入的方式<strong>能够保证注入的组件不可变，并且确保需要的依赖不为空</strong>。此外，构造器注入的依赖总是能够在返回客户端（组件）代码的时候保证完全初始化的状态。</p><p>下面来简单的解释一下：</p><ul><li><strong>依赖不可变</strong>：其实说的就是final关键字。</li><li><strong>依赖不为空</strong>（省去了我们对其检查）：当要实例化UserServiceImpl的时候，由于自己实现了有参数的构造函数，所以不会调用默认构造函数，那么就需要Spring容器传入所需要的参数，所以就两种情况：1、有该类型的参数-&gt;传入，OK 。2：无该类型的参数-&gt;报错。</li><li><strong>完全初始化的状态</strong>：这个可以跟上面的依赖不为空结合起来，向构造器传参之前，要确保注入的内容不为空，那么肯定要调用依赖组件的构造方法完成实例化。而在Java类加载实例化的过程中，构造方法是最后一步（之前如果有父类先初始化父类，然后自己的成员变量，最后才是构造方法），所以返回来的都是初始化之后的状态。</li></ul><p>所以通常是这样的</p><pre><code class="java">/** * @author pdai */ @Servicepublic class UserServiceImpl &#123;    /**     * user dao impl.     */    private final UserDaoImpl userDao;    /**     * init.     * @param userDaoImpl user dao impl     */    public UserServiceImpl(final UserDaoImpl userDaoImpl) &#123;        this.userDao = userDaoImpl;    &#125;&#125;</code></pre><p>如果使用setter注入，缺点显而易见，对于IOC容器以外的环境，除了使用反射来提供它需要的依赖之外，<strong>无法复用该实现类</strong>。而且将一直是个潜在的隐患，因为你不调用将一直无法发现NPE的存在。</p><pre><code class="java">// 这里只是模拟一下，正常来说我们只会暴露接口给客户端，不会暴露实现。UserServiceImpl userService = new UserServiceImpl();userService.findUserList(); // -&gt; NullPointerException, 潜在的隐患</code></pre><hr><p><strong>循环依赖的问题</strong>：使用field注入可能会导致循环依赖，即A里面注入B，B里面又注入A：</p><pre><code class="java">public class A &#123;    @Autowired    private B b;&#125;public class B &#123;    @Autowired    private A a;&#125;</code></pre><p>如果使用构造器注入，在spring项目启动的时候，就会抛出：BeanCurrentlyInCreationException：Requested bean is currently in creation: Is there an unresolvable circular reference？从而提醒你避免循环依赖，如果是field注入的话，启动的时候不会报错，在使用那个bean的时候才会报错。</p><h3 id="我在使用构造器注入方式时注入了太多的类导致Bad-Smell怎么办？"><a href="#我在使用构造器注入方式时注入了太多的类导致Bad-Smell怎么办？" class="headerlink" title="我在使用构造器注入方式时注入了太多的类导致Bad Smell怎么办？"></a>我在使用构造器注入方式时注入了太多的类导致Bad Smell怎么办？</h3><p>比如当你一个Controller中注入了太多的Service类，Sonar会给你提示相关告警</p><p><img src="https://gitee.com/DylanToT99/images/raw/master/images/spring-framework-ioc-3.png" alt="img"></p><p>对于这个问题，说明你的类当中有太多的责任，那么你要好好想一想是不是自己违反了类的<a href="">单一性职责原则</a>，从而导致有这么多的依赖要注入</p><h3 id="Autowired和-Resource以及-Inject等注解注入有何区别？"><a href="#Autowired和-Resource以及-Inject等注解注入有何区别？" class="headerlink" title="@Autowired和@Resource以及@Inject等注解注入有何区别？"></a>@Autowired和@Resource以及@Inject等注解注入有何区别？</h3><blockquote><p>@Autowired和@Resource以及@Inject等注解注入有何区别？ 这时平时在开发中，或者常见的面试题。</p></blockquote><h4 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h4><ul><li><strong>Autowired注解源码</strong></li></ul><p>在Spring 2.5 引入了 @Autowired 注解</p><pre><code class="java">@Target(&#123;ElementType.CONSTRUCTOR, ElementType.METHOD, ElementType.PARAMETER, ElementType.FIELD, ElementType.ANNOTATION_TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface Autowired &#123;  boolean required() default true;&#125;</code></pre><p>从Autowired注解源码上看，可以使用在下面这些地方：</p><pre><code class="java">@Target(ElementType.CONSTRUCTOR) #构造函数@Target(ElementType.METHOD) #方法@Target(ElementType.PARAMETER) #方法参数@Target(ElementType.FIELD) #字段、枚举的常量@Target(ElementType.ANNOTATION_TYPE) #注解</code></pre><p>还有一个value属性，默认是true。</p><ul><li><strong>简单总结</strong>：</li></ul><p>1、@Autowired是Spring自带的注解，通过AutowiredAnnotationBeanPostProcessor 类实现的依赖注入</p><p>2、@Autowired可以作用在CONSTRUCTOR、METHOD、PARAMETER、FIELD、ANNOTATION_TYPE</p><p><strong>3、@Autowired默认是根据类型（byType ）进行自动装配的</strong></p><p>4、如果有多个类型一样的Bean候选者，需要指定按照名称（byName ）进行装配，则需要配合**@Qualifier。**</p><p>指定名称后，如果Spring IOC容器中没有对应的组件bean抛出NoSuchBeanDefinitionException。也可以将@Autowired中required配置为false，如果配置为false之后，当没有找到相应bean的时候，系统不会抛异常</p><ul><li><strong>简单使用代码</strong>：</li></ul><p>在字段属性上。</p><pre><code class="java">@Autowiredprivate HelloDao helloDao;</code></pre><p>或者</p><pre><code class="java">private HelloDao helloDao;public HelloDao getHelloDao() &#123; return helloDao;&#125;@Autowiredpublic void setHelloDao(HelloDao helloDao) &#123; this.helloDao = helloDao;&#125;</code></pre><p>或者</p><pre><code class="java">private HelloDao helloDao;//@Autowiredpublic HelloServiceImpl(@Autowired HelloDao helloDao) &#123; this.helloDao = helloDao;&#125;// 构造器注入也可不写@Autowired，也可以注入成功。</code></pre><p>将@Autowired写在被注入的成员变量上，setter或者构造器上，就不用再xml文件中配置了。</p><p>如果有多个类型一样的Bean候选者，则默认根据设定的属性名称进行获取。如 HelloDao 在Spring中有 helloWorldDao 和 helloDao 两个Bean候选者。</p><pre><code class="java">@Autowiredprivate HelloDao helloDao;</code></pre><p>首先根据类型获取，发现多个HelloDao，然后根据helloDao进行获取，如果要获取限定的其中一个候选者，结合@Qualifier进行注入。</p><pre><code class="java">@Autowired@Qualifier(&quot;helloWorldDao&quot;)private HelloDao helloDao;</code></pre><p>注入名称为helloWorldDao 的Bean组件。@Qualifier(“XXX”) 中的 XX是 Bean 的名称，所以 @<strong>Autowired 和 @Qualifier 结合使用时，自动注入的策略就从 byType 转变成 byName 了。</strong></p><p>多个类型一样的Bean候选者，也可以@Primary进行使用，设置首选的组件，也就是默认优先使用哪一个。</p><p>注意：使用@Qualifier 时候，如何设置的指定名称的Bean不存在，则会抛出异常，如果防止抛出异常，可以使用：</p><pre><code class="java">@Qualifier(&quot;xxxxyyyy&quot;)@Autowired(required = false)private HelloDao helloDao;</code></pre><p>在SpringBoot中也可以使用@Bean+@Autowired进行组件注入，将@Autowired加到参数上，其实也可以省略。</p><pre><code class="java">@Beanpublic Person getPerson(@Autowired Car car)&#123; return new Person();&#125;// @Autowired 其实也可以省略</code></pre><h4 id="Resource"><a href="#Resource" class="headerlink" title="# @Resource"></a><a href="#resource">#</a> @Resource</h4><ul><li><strong>Resource注解源码</strong></li></ul><pre><code class="java">@Target(&#123;TYPE, FIELD, METHOD&#125;)@Retention(RUNTIME)public @interface Resource &#123;    String name() default &quot;&quot;;    // 其他省略&#125;</code></pre><p>从Resource注解源码上看，可以使用在下面这些地方：</p><pre><code class="java">@Target(ElementType.TYPE) #接口、类、枚举、注解@Target(ElementType.FIELD) #字段、枚举的常量@Target(ElementType.METHOD) #方法</code></pre><p>name 指定注入指定名称的组件。</p><ul><li><strong>简单总结</strong>：</li></ul><p>1、@Resource是JSR250规范的实现，在javax.annotation包下</p><p>2、@Resource可以作用TYPE、FIELD、METHOD上</p><p>3、**@Resource是默认根据属性名称进行自动装配的，**如果有多个类型一样的Bean候选者，则可以通过name进行指定进行注入</p><ul><li><strong>简单使用代码</strong>：</li></ul><pre><code class="java">@Componentpublic class SuperMan &#123;    @Resource    private Car car;&#125;</code></pre><p>按照属性名称 car 注入容器中的组件。如果容器中BMW还有BYD两种类型组件。指定加入BMW。如下代码：</p><pre><code class="java">@Componentpublic class SuperMan &#123;    @Resource(name = &quot;BMW&quot;)    private Car car;&#125;</code></pre><p>name 的作用类似 @Qualifier</p><h4 id="Inject"><a href="#Inject" class="headerlink" title="# @Inject"></a><a href="#inject">#</a> @Inject</h4><ul><li><strong>Inject注解源码</strong></li></ul><pre><code class="java">@Target(&#123; METHOD, CONSTRUCTOR, FIELD &#125;)@Retention(RUNTIME)@Documentedpublic @interface Inject &#123;&#125;</code></pre><p>从Inject注解源码上看，可以使用在下面这些地方：</p><pre><code class="java">@Target(ElementType.CONSTRUCTOR) #构造函数@Target(ElementType.METHOD) #方法@Target(ElementType.FIELD) #字段、枚举的常量</code></pre><ul><li><strong>简单总结</strong>：</li></ul><p>1、@Inject是JSR330 (Dependency Injection for Java)中的规范，需要导入javax.inject.Inject jar包 ，才能实现注入</p><p>2、@Inject可以作用CONSTRUCTOR、METHOD、FIELD上</p><p>3、**@Inject是根据类型进行自动装配的，如果需要按名称进行装配，则需要配合@Named；**</p><ul><li><strong>简单使用代码</strong>：</li></ul><pre><code class="java">@Injectprivate Car car;</code></pre><p>指定加入BMW组件。</p><pre><code class="java">@Inject@Named(&quot;BMW&quot;)private Car car;</code></pre><p>@Named 的作用类似 @Qualifier！</p><h4 id="总结"><a href="#总结" class="headerlink" title="# 总结"></a><a href="#%E6%80%BB%E7%BB%93">#</a> 总结</h4><p>1、@Autowired是Spring自带的，@Resource是JSR250规范实现的，@Inject是JSR330规范实现的</p><p>2、@Autowired、@Inject用法基本一样，不同的是@Inject没有required属性</p><p>3、**@Autowired、@Inject是默认按照类型匹配的，@Resource是按照名称匹配的**</p><p>4、@Autowired如果需要按照名称匹配需要和@Qualifier一起使用，@Inject和@Named一起使用，@Resource则通过name进行指定</p><p>源码级别文章<a href="https://blog.csdn.net/qq_35634181/article/details/104802906">Spring源码分析@Autowired、@Resource注解的区别</a></p>]]></content>
      
      
      <categories>
          
          <category> Spring基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring基础 </tag>
            
            <tag> java框架 </tag>
            
            <tag> IOC </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
